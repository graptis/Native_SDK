<!-- HTML header for doxygen 1.8.4-->
<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="generator" content="Doxygen 1.8.6"/>
<title>PVRAssets: pvr::assets::Mesh Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="IMGdoxygen.css" rel="stylesheet" type="text/css"/>
<link rel="shortcut icon" href="http://www.imgtec.com/images/img.ico">
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
  <div class="headercontent">
    <div class="PVRlogo">
      <a href="http://www.powervrinsider.com" target="_blank"><img src="PVRlogo.png" width="40%" height="40%"  border="none" /></a>
    </div>
    <a class="SiteTitle"><span id="projectname">PVRAssets</span> Documentation</a>
   <tbody>
  </div>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="inherits.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacepvr.html">pvr</a></li><li class="navelem"><a class="el" href="namespacepvr_1_1assets.html">assets</a></li><li class="navelem"><a class="el" href="classpvr_1_1assets_1_1_mesh.html">Mesh</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classpvr_1_1assets_1_1_mesh-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">pvr::assets::Mesh Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><a class="el" href="classpvr_1_1assets_1_1_mesh.html" title="Mesh class. Represent a Mesh, a collection of primitives (usually, but not necessarily, triangles) together with their per-vertex information. A mesh&#39;s is a grouping where all vertices/primitives will have the same basic transformation (but can then be skinned) and material applied.">Mesh</a> class. Represent a <a class="el" href="classpvr_1_1assets_1_1_mesh.html" title="Mesh class. Represent a Mesh, a collection of primitives (usually, but not necessarily, triangles) together with their per-vertex information. A mesh&#39;s is a grouping where all vertices/primitives will have the same basic transformation (but can then be skinned) and material applied.">Mesh</a>, a collection of primitives (usually, but not necessarily, triangles) together with their per-vertex information. A mesh's is a grouping where all vertices/primitives will have the same basic transformation (but can then be skinned) and material applied. 
 <a href="classpvr_1_1assets_1_1_mesh.html#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpvr_1_1assets_1_1_mesh_1_1_bone_batches.html">BoneBatches</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class is used to break meshes into different batches in order to avoid overflowing the number of uniforms that would otherwise be required to load all the bones into. <a href="structpvr_1_1assets_1_1_mesh_1_1_bone_batches.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1assets_1_1_mesh_1_1_face_data.html">FaceData</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="classpvr_1_1assets_1_1_mesh_1_1_face_data.html" title="The FaceData class contains the information of the Indices that defines the Faces of a Mesh...">FaceData</a> class contains the information of the Indices that defines the Faces of a <a class="el" href="classpvr_1_1assets_1_1_mesh.html" title="Mesh class. Represent a Mesh, a collection of primitives (usually, but not necessarily, triangles) together with their per-vertex information. A mesh&#39;s is a grouping where all vertices/primitives will have the same basic transformation (but can then be skinned) and material applied.">Mesh</a>.  <a href="classpvr_1_1assets_1_1_mesh_1_1_face_data.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpvr_1_1assets_1_1_mesh_1_1_internal_data.html">InternalData</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Raw internal structure of the <a class="el" href="classpvr_1_1assets_1_1_mesh.html" title="Mesh class. Represent a Mesh, a collection of primitives (usually, but not necessarily, triangles) together with their per-vertex information. A mesh&#39;s is a grouping where all vertices/primitives will have the same basic transformation (but can then be skinned) and material applied.">Mesh</a>. <a href="structpvr_1_1assets_1_1_mesh_1_1_internal_data.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpvr_1_1assets_1_1_mesh_1_1_mesh_info.html">MeshInfo</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Contains mesh information. <a href="structpvr_1_1assets_1_1_mesh_1_1_mesh_info.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1assets_1_1_mesh_1_1_vertex_attribute_data.html">VertexAttributeData</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Definition of a single VertexAttribute. <a href="classpvr_1_1assets_1_1_mesh_1_1_vertex_attribute_data.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a4722749d8d5bfa2c811074f83a109169"><td class="memItemLeft" align="right" valign="top">typedef IndexedArray<br class="typebreak"/>
&lt; <a class="el" href="classpvr_1_1assets_1_1_mesh_1_1_vertex_attribute_data.html">VertexAttributeData</a>, <br class="typebreak"/>
StringHash &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1assets_1_1_mesh.html#a4722749d8d5bfa2c811074f83a109169">VertexAttributeContainer</a></td></tr>
<tr class="memdesc:a4722749d8d5bfa2c811074f83a109169"><td class="mdescLeft">&#160;</td><td class="mdescRight">This container is automatically kept sorted. <a href="#a4722749d8d5bfa2c811074f83a109169">More...</a><br/></td></tr>
<tr class="separator:a4722749d8d5bfa2c811074f83a109169"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ad86f903670f1604c60460197a75bb9ef"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1assets_1_1_mesh.html#ad86f903670f1604c60460197a75bb9ef">addData</a> (const uint8_t *data, uint32_t size, uint32_t stride)</td></tr>
<tr class="memdesc:ad86f903670f1604c60460197a75bb9ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implicitly append a block of vertex data to the mesh and (optionally) populate it with data. <a href="#ad86f903670f1604c60460197a75bb9ef">More...</a><br/></td></tr>
<tr class="separator:ad86f903670f1604c60460197a75bb9ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70a29004239651b6c879a912bd347c2f"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1assets_1_1_mesh.html#a70a29004239651b6c879a912bd347c2f">addData</a> (const uint8_t *data, uint32_t size, uint32_t stride, uint32_t index)</td></tr>
<tr class="memdesc:a70a29004239651b6c879a912bd347c2f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a block of vertex data to the mesh at the specified index and (optionally) populate it with data.  <a href="#a70a29004239651b6c879a912bd347c2f">More...</a><br/></td></tr>
<tr class="separator:a70a29004239651b6c879a912bd347c2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeba19b4f7de6dc15ef164950b7f9b893"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1assets_1_1_mesh.html#aeba19b4f7de6dc15ef164950b7f9b893">addFaces</a> (const uint8_t *data, uint32_t size, const IndexType indexType)</td></tr>
<tr class="memdesc:aeba19b4f7de6dc15ef164950b7f9b893"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add face information to the mesh. <a href="#aeba19b4f7de6dc15ef164950b7f9b893">More...</a><br/></td></tr>
<tr class="separator:aeba19b4f7de6dc15ef164950b7f9b893"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe1c6afb7857d5a2a55ad1df8a94fac4"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1assets_1_1_mesh.html#abe1c6afb7857d5a2a55ad1df8a94fac4">addVertexAttribute</a> (const <a class="el" href="classpvr_1_1assets_1_1_mesh_1_1_vertex_attribute_data.html">VertexAttributeData</a> &amp;element, bool forceReplace=false)</td></tr>
<tr class="memdesc:abe1c6afb7857d5a2a55ad1df8a94fac4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a vertex attribute to the mesh. <a href="#abe1c6afb7857d5a2a55ad1df8a94fac4">More...</a><br/></td></tr>
<tr class="separator:abe1c6afb7857d5a2a55ad1df8a94fac4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22dd8fec1aacd0e21644e68b3da5eece"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1assets_1_1_mesh.html#a22dd8fec1aacd0e21644e68b3da5eece">addVertexAttribute</a> (const StringHash &amp;semanticName, const DataType &amp;type, uint32_t width, uint32_t offset, uint32_t dataIndex, bool forceReplace=false)</td></tr>
<tr class="memdesc:a22dd8fec1aacd0e21644e68b3da5eece"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a vertex attribute to the mesh. <a href="#a22dd8fec1aacd0e21644e68b3da5eece">More...</a><br/></td></tr>
<tr class="separator:a22dd8fec1aacd0e21644e68b3da5eece"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae320f2a19d317b96675e82d626482cfc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1assets_1_1_mesh.html#ae320f2a19d317b96675e82d626482cfc">clearAllData</a> ()</td></tr>
<tr class="memdesc:ae320f2a19d317b96675e82d626482cfc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove all data blocks. <a href="#ae320f2a19d317b96675e82d626482cfc">More...</a><br/></td></tr>
<tr class="separator:ae320f2a19d317b96675e82d626482cfc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed6ea457b436fc57266d14d8fddf407c"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1assets_1_1_mesh.html#aed6ea457b436fc57266d14d8fddf407c">getBatchBone</a> (uint32_t batch, uint32_t bone) const </td></tr>
<tr class="memdesc:aed6ea457b436fc57266d14d8fddf407c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the global index of a bone from its batch and index in the batch. <a href="#aed6ea457b436fc57266d14d8fddf407c">More...</a><br/></td></tr>
<tr class="separator:aed6ea457b436fc57266d14d8fddf407c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad547fc0fe2790736db4839bd70052962"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1assets_1_1_mesh.html#ad547fc0fe2790736db4839bd70052962">getBatchFaceOffset</a> (uint32_t batch) const </td></tr>
<tr class="memdesc:ad547fc0fe2790736db4839bd70052962"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the offset in the Faces data that the specified batch begins at. <a href="#ad547fc0fe2790736db4839bd70052962">More...</a><br/></td></tr>
<tr class="separator:ad547fc0fe2790736db4839bd70052962"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7719d5ec94e1a6deca30103f0234c52f"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1assets_1_1_mesh.html#a7719d5ec94e1a6deca30103f0234c52f">getBatchFaceOffsetBytes</a> (uint32_t batch) const </td></tr>
<tr class="memdesc:a7719d5ec94e1a6deca30103f0234c52f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the offset in the Faces data that the specified batch begins at. <a href="#a7719d5ec94e1a6deca30103f0234c52f">More...</a><br/></td></tr>
<tr class="separator:a7719d5ec94e1a6deca30103f0234c52f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6f9fe4b4705e6dfead28b9b87e27116"><td class="memItemLeft" align="right" valign="top">const void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1assets_1_1_mesh.html#ab6f9fe4b4705e6dfead28b9b87e27116">getData</a> (uint32_t index) const </td></tr>
<tr class="memdesc:ab6f9fe4b4705e6dfead28b9b87e27116"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a pointer to the data of a specified Data block. Read only overload. <a href="#ab6f9fe4b4705e6dfead28b9b87e27116">More...</a><br/></td></tr>
<tr class="separator:ab6f9fe4b4705e6dfead28b9b87e27116"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add38ffc4f6966aa5a7d9ba73b6aa12bc"><td class="memItemLeft" align="right" valign="top">uint8_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1assets_1_1_mesh.html#add38ffc4f6966aa5a7d9ba73b6aa12bc">getData</a> (uint32_t index)</td></tr>
<tr class="memdesc:add38ffc4f6966aa5a7d9ba73b6aa12bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a pointer to the data of a specified Data block. Read/write overload. <a href="#add38ffc4f6966aa5a7d9ba73b6aa12bc">More...</a><br/></td></tr>
<tr class="separator:add38ffc4f6966aa5a7d9ba73b6aa12bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6e6b2798652d73515aa84d2fe630bd7"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1assets_1_1_mesh.html#ad6e6b2798652d73515aa84d2fe630bd7">getDataSize</a> (uint32_t index) const </td></tr>
<tr class="memdesc:ad6e6b2798652d73515aa84d2fe630bd7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the size of the specified Data block. <a href="#ad6e6b2798652d73515aa84d2fe630bd7">More...</a><br/></td></tr>
<tr class="separator:ad6e6b2798652d73515aa84d2fe630bd7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5e14d52dd4f491e9fdc743c8fb68fba"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classpvr_1_1assets_1_1_mesh_1_1_face_data.html">FaceData</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1assets_1_1_mesh.html#af5e14d52dd4f491e9fdc743c8fb68fba">getFaces</a> () const </td></tr>
<tr class="memdesc:af5e14d52dd4f491e9fdc743c8fb68fba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get all face data of this mesh. <a href="#af5e14d52dd4f491e9fdc743c8fb68fba">More...</a><br/></td></tr>
<tr class="separator:af5e14d52dd4f491e9fdc743c8fb68fba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25853ea014e345aaf8437f4f4e59ad26"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpvr_1_1assets_1_1_mesh_1_1_face_data.html">FaceData</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1assets_1_1_mesh.html#a25853ea014e345aaf8437f4f4e59ad26">getFaces</a> ()</td></tr>
<tr class="memdesc:a25853ea014e345aaf8437f4f4e59ad26"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get all face data of this mesh. <a href="#a25853ea014e345aaf8437f4f4e59ad26">More...</a><br/></td></tr>
<tr class="separator:a25853ea014e345aaf8437f4f4e59ad26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d2c88d289cccdee673a91beaffd62df"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structpvr_1_1assets_1_1_mesh_1_1_internal_data.html">InternalData</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1assets_1_1_mesh.html#a9d2c88d289cccdee673a91beaffd62df">getInternalData</a> ()</td></tr>
<tr class="memdesc:a9d2c88d289cccdee673a91beaffd62df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a reference to the internal representation and data of this <a class="el" href="classpvr_1_1assets_1_1_mesh.html" title="Mesh class. Represent a Mesh, a collection of primitives (usually, but not necessarily, triangles) together with their per-vertex information. A mesh&#39;s is a grouping where all vertices/primitives will have the same basic transformation (but can then be skinned) and material applied.">Mesh</a>. Handle with care. <a href="#a9d2c88d289cccdee673a91beaffd62df">More...</a><br/></td></tr>
<tr class="separator:a9d2c88d289cccdee673a91beaffd62df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0bd59376ff32b82b6eebba0c8c135ace"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structpvr_1_1assets_1_1_mesh_1_1_mesh_info.html">MeshInfo</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1assets_1_1_mesh.html#a0bd59376ff32b82b6eebba0c8c135ace">getMeshInfo</a> () const </td></tr>
<tr class="memdesc:a0bd59376ff32b82b6eebba0c8c135ace"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get information on this <a class="el" href="classpvr_1_1assets_1_1_mesh.html" title="Mesh class. Represent a Mesh, a collection of primitives (usually, but not necessarily, triangles) together with their per-vertex information. A mesh&#39;s is a grouping where all vertices/primitives will have the same basic transformation (but can then be skinned) and material applied.">Mesh</a>. <a href="#a0bd59376ff32b82b6eebba0c8c135ace">More...</a><br/></td></tr>
<tr class="separator:a0bd59376ff32b82b6eebba0c8c135ace"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e178e1f82eef52d6c4ee5e91ca2990a"><td class="memItemLeft" align="right" valign="top">const FreeValue *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1assets_1_1_mesh.html#a6e178e1f82eef52d6c4ee5e91ca2990a">getMeshSemantic</a> (const StringHash &amp;semantic) const </td></tr>
<tr class="memdesc:a6e178e1f82eef52d6c4ee5e91ca2990a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the value of a Per-Mesh semantic as a FreeValue, null if it does not exist. <a href="#a6e178e1f82eef52d6c4ee5e91ca2990a">More...</a><br/></td></tr>
<tr class="separator:a6e178e1f82eef52d6c4ee5e91ca2990a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4631a8b4fb8bfa0888efd0da743f1150"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1assets_1_1_mesh.html#a4631a8b4fb8bfa0888efd0da743f1150">getNumBatchBones</a> (uint32_t batch) const </td></tr>
<tr class="memdesc:a4631a8b4fb8bfa0888efd0da743f1150"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get how many bones the specified bone batch has. <a href="#a4631a8b4fb8bfa0888efd0da743f1150">More...</a><br/></td></tr>
<tr class="separator:a4631a8b4fb8bfa0888efd0da743f1150"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaed956628770c5a5d268ad6575d97cba"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1assets_1_1_mesh.html#aaed956628770c5a5d268ad6575d97cba">getNumBoneBatches</a> () const </td></tr>
<tr class="memdesc:aaed956628770c5a5d268ad6575d97cba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of <a class="el" href="structpvr_1_1assets_1_1_mesh_1_1_bone_batches.html" title="This class is used to break meshes into different batches in order to avoid overflowing the number of...">BoneBatches</a> the bones of this mesh are organised into. <a href="#aaed956628770c5a5d268ad6575d97cba">More...</a><br/></td></tr>
<tr class="separator:aaed956628770c5a5d268ad6575d97cba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2b00633fc96e0ca805715c91f670abb"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1assets_1_1_mesh.html#af2b00633fc96e0ca805715c91f670abb">getNumBones</a> () const </td></tr>
<tr class="memdesc:af2b00633fc96e0ca805715c91f670abb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the information of a VertexAttribute by its SemanticName. <a href="#af2b00633fc96e0ca805715c91f670abb">More...</a><br/></td></tr>
<tr class="separator:af2b00633fc96e0ca805715c91f670abb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a343b45c267531da7378f4372a55caff8"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1assets_1_1_mesh.html#a343b45c267531da7378f4372a55caff8">getNumDataElements</a> () const </td></tr>
<tr class="memdesc:a343b45c267531da7378f4372a55caff8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of vertex data blocks that this mesh has. <a href="#a343b45c267531da7378f4372a55caff8">More...</a><br/></td></tr>
<tr class="separator:a343b45c267531da7378f4372a55caff8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3dd3ad8c738c550d282f627ce7814884"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1assets_1_1_mesh.html#a3dd3ad8c738c550d282f627ce7814884">getNumElements</a> () const </td></tr>
<tr class="memdesc:a3dd3ad8c738c550d282f627ce7814884"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of different vertex attributes that this mesh has. <a href="#a3dd3ad8c738c550d282f627ce7814884">More...</a><br/></td></tr>
<tr class="separator:a3dd3ad8c738c550d282f627ce7814884"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f92999bddcef4351a470309b287af91"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1assets_1_1_mesh.html#a1f92999bddcef4351a470309b287af91">getNumFaces</a> () const </td></tr>
<tr class="memdesc:a1f92999bddcef4351a470309b287af91"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of faces that comprise this mesh. <a href="#a1f92999bddcef4351a470309b287af91">More...</a><br/></td></tr>
<tr class="separator:a1f92999bddcef4351a470309b287af91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a104eceb0cca8c21cc7b1f437af60781d"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1assets_1_1_mesh.html#a104eceb0cca8c21cc7b1f437af60781d">getNumFaces</a> (uint32_t boneBatch) const </td></tr>
<tr class="memdesc:a104eceb0cca8c21cc7b1f437af60781d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of faces that comprise the designated bonebatch. <a href="#a104eceb0cca8c21cc7b1f437af60781d">More...</a><br/></td></tr>
<tr class="separator:a104eceb0cca8c21cc7b1f437af60781d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a563f695e4cd8d361859ae1d6529e29f7"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1assets_1_1_mesh.html#a563f695e4cd8d361859ae1d6529e29f7">getNumIndices</a> () const </td></tr>
<tr class="memdesc:a563f695e4cd8d361859ae1d6529e29f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of indices that comprise this mesh. Takes TriangleStrips into consideration.  <a href="#a563f695e4cd8d361859ae1d6529e29f7">More...</a><br/></td></tr>
<tr class="separator:a563f695e4cd8d361859ae1d6529e29f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5345259d234d0ec6a86cddda321b76d0"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1assets_1_1_mesh.html#a5345259d234d0ec6a86cddda321b76d0">getNumStrips</a> () const </td></tr>
<tr class="memdesc:a5345259d234d0ec6a86cddda321b76d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of Triangle Strips (if any) that comprise this <a class="el" href="classpvr_1_1assets_1_1_mesh.html" title="Mesh class. Represent a Mesh, a collection of primitives (usually, but not necessarily, triangles) together with their per-vertex information. A mesh&#39;s is a grouping where all vertices/primitives will have the same basic transformation (but can then be skinned) and material applied.">Mesh</a>. <a href="#a5345259d234d0ec6a86cddda321b76d0">More...</a><br/></td></tr>
<tr class="separator:a5345259d234d0ec6a86cddda321b76d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ad5165623e8cf72138ee941b6fa96fe"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1assets_1_1_mesh.html#a9ad5165623e8cf72138ee941b6fa96fe">getNumVertices</a> () const </td></tr>
<tr class="memdesc:a9ad5165623e8cf72138ee941b6fa96fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of vertices that comprise this mesh. <a href="#a9ad5165623e8cf72138ee941b6fa96fe">More...</a><br/></td></tr>
<tr class="separator:a9ad5165623e8cf72138ee941b6fa96fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad44274c2f282635815af77085e05ae0"><td class="memItemLeft" align="right" valign="top">PrimitiveTopology&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1assets_1_1_mesh.html#aad44274c2f282635815af77085e05ae0">getPrimitiveType</a> () const </td></tr>
<tr class="memdesc:aad44274c2f282635815af77085e05ae0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the primitive topology that the data in this <a class="el" href="classpvr_1_1assets_1_1_mesh.html" title="Mesh class. Represent a Mesh, a collection of primitives (usually, but not necessarily, triangles) together with their per-vertex information. A mesh&#39;s is a grouping where all vertices/primitives will have the same basic transformation (but can then be skinned) and material applied.">Mesh</a> represent. <a href="#aad44274c2f282635815af77085e05ae0">More...</a><br/></td></tr>
<tr class="separator:aad44274c2f282635815af77085e05ae0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b8b165ab2fb7b8e3c0d76c1b243a7e4"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1assets_1_1_mesh.html#a0b8b165ab2fb7b8e3c0d76c1b243a7e4">getStride</a> (uint32_t index) const </td></tr>
<tr class="memdesc:a0b8b165ab2fb7b8e3c0d76c1b243a7e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get distance in bytes from vertex in an array to the next. <a href="#a0b8b165ab2fb7b8e3c0d76c1b243a7e4">More...</a><br/></td></tr>
<tr class="separator:a0b8b165ab2fb7b8e3c0d76c1b243a7e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a722fd34a8c4d3f576902cb60af47b709"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1assets_1_1_mesh.html#a722fd34a8c4d3f576902cb60af47b709">getStripLength</a> (uint32_t strip) const </td></tr>
<tr class="memdesc:a722fd34a8c4d3f576902cb60af47b709"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the length of the specified triangle strip. <a href="#a722fd34a8c4d3f576902cb60af47b709">More...</a><br/></td></tr>
<tr class="separator:a722fd34a8c4d3f576902cb60af47b709"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96068e0b13badc70fe76b632838caa5a"><td class="memItemLeft" align="right" valign="top">const uint32_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1assets_1_1_mesh.html#a96068e0b13badc70fe76b632838caa5a">getStripLengths</a> () const </td></tr>
<tr class="memdesc:a96068e0b13badc70fe76b632838caa5a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get an array containing the Triangle Strip lengths. <a href="#a96068e0b13badc70fe76b632838caa5a">More...</a><br/></td></tr>
<tr class="separator:a96068e0b13badc70fe76b632838caa5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc0eda8a17f910099b4580b4c5fde0da"><td class="memItemLeft" align="right" valign="top">const glm::mat4x4 &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1assets_1_1_mesh.html#acc0eda8a17f910099b4580b4c5fde0da">getUnpackMatrix</a> () const </td></tr>
<tr class="memdesc:acc0eda8a17f910099b4580b4c5fde0da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the Unpack Matrix of this <a class="el" href="classpvr_1_1assets_1_1_mesh.html" title="Mesh class. Represent a Mesh, a collection of primitives (usually, but not necessarily, triangles) together with their per-vertex information. A mesh&#39;s is a grouping where all vertices/primitives will have the same basic transformation (but can then be skinned) and material applied.">Mesh</a>. The unpack matrix is used for some exotic types of vertex position compression. <a href="#acc0eda8a17f910099b4580b4c5fde0da">More...</a><br/></td></tr>
<tr class="separator:acc0eda8a17f910099b4580b4c5fde0da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf477d4772b1d169050032d3ed8af003"><td class="memItemLeft" align="right" valign="top">const RefCountedResource&lt; void &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1assets_1_1_mesh.html#abf477d4772b1d169050032d3ed8af003">getUserDataPtr</a> () const </td></tr>
<tr class="memdesc:abf477d4772b1d169050032d3ed8af003"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the UserData of this mesh, if such user data exist. <a href="#abf477d4772b1d169050032d3ed8af003">More...</a><br/></td></tr>
<tr class="separator:abf477d4772b1d169050032d3ed8af003"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2031f8467bf23a6167dd5c89db41224"><td class="memItemLeft" align="right" valign="top">RefCountedResource&lt; void &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1assets_1_1_mesh.html#ac2031f8467bf23a6167dd5c89db41224">getUserDataPtr</a> ()</td></tr>
<tr class="memdesc:ac2031f8467bf23a6167dd5c89db41224"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the UserData of this mesh, if such user data exist. <a href="#ac2031f8467bf23a6167dd5c89db41224">More...</a><br/></td></tr>
<tr class="separator:ac2031f8467bf23a6167dd5c89db41224"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afcc66af649bcb8770241fc30ca34a1b8"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classpvr_1_1assets_1_1_mesh_1_1_vertex_attribute_data.html">VertexAttributeData</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1assets_1_1_mesh.html#afcc66af649bcb8770241fc30ca34a1b8">getVertexAttribute</a> (int32_t idx) const </td></tr>
<tr class="memdesc:afcc66af649bcb8770241fc30ca34a1b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the information of a VertexAttribute by its SemanticName. <a href="#afcc66af649bcb8770241fc30ca34a1b8">More...</a><br/></td></tr>
<tr class="separator:afcc66af649bcb8770241fc30ca34a1b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d7592cc303be36e0648a6197923f450"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classpvr_1_1assets_1_1_mesh_1_1_vertex_attribute_data.html">VertexAttributeData</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1assets_1_1_mesh.html#a7d7592cc303be36e0648a6197923f450">getVertexAttributeByName</a> (const StringHash &amp;semanticName) const </td></tr>
<tr class="memdesc:a7d7592cc303be36e0648a6197923f450"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the information of a VertexAttribute by its SemanticName (return NULL if not exist) <a href="#a7d7592cc303be36e0648a6197923f450">More...</a><br/></td></tr>
<tr class="separator:a7d7592cc303be36e0648a6197923f450"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a514add6ba80930e469334ca641ad3f17"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1assets_1_1_mesh.html#a514add6ba80930e469334ca641ad3f17">getVertexAttributeIndex</a> (const char *semanticName) const </td></tr>
<tr class="memdesc:a514add6ba80930e469334ca641ad3f17"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the Index of a VertexAttribute by its SemanticName. <a href="#a514add6ba80930e469334ca641ad3f17">More...</a><br/></td></tr>
<tr class="separator:a514add6ba80930e469334ca641ad3f17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40407ad5da4c5bf49064b979f3efe7d9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpvr_1_1assets_1_1_mesh.html#a4722749d8d5bfa2c811074f83a109169">VertexAttributeContainer</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1assets_1_1_mesh.html#a40407ad5da4c5bf49064b979f3efe7d9">getVertexAttributes</a> ()</td></tr>
<tr class="memdesc:a40407ad5da4c5bf49064b979f3efe7d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get all the vertex attributes. <a href="#a40407ad5da4c5bf49064b979f3efe7d9">More...</a><br/></td></tr>
<tr class="separator:a40407ad5da4c5bf49064b979f3efe7d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1728791103eaec595819ca93b7918fff"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classpvr_1_1assets_1_1_mesh.html#a4722749d8d5bfa2c811074f83a109169">VertexAttributeContainer</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1assets_1_1_mesh.html#a1728791103eaec595819ca93b7918fff">getVertexAttributes</a> () const </td></tr>
<tr class="memdesc:a1728791103eaec595819ca93b7918fff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get all the vertex attributes. <a href="#a1728791103eaec595819ca93b7918fff">More...</a><br/></td></tr>
<tr class="separator:a1728791103eaec595819ca93b7918fff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6ffee1763b8400c47ca017425d47953"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1assets_1_1_mesh.html#ae6ffee1763b8400c47ca017425d47953">getVertexAttributesSize</a> () const </td></tr>
<tr class="memdesc:ae6ffee1763b8400c47ca017425d47953"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get number of vertex attributes. <a href="#ae6ffee1763b8400c47ca017425d47953">More...</a><br/></td></tr>
<tr class="separator:ae6ffee1763b8400c47ca017425d47953"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a489d5d9e5a2a54127623b756e78c4315"><td class="memItemLeft" align="right" valign="top">const std::vector<br class="typebreak"/>
&lt; StridedBuffer &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1assets_1_1_mesh.html#a489d5d9e5a2a54127623b756e78c4315">getVertexData</a> () const </td></tr>
<tr class="memdesc:a489d5d9e5a2a54127623b756e78c4315"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get all DataBlocks of this <a class="el" href="classpvr_1_1assets_1_1_mesh.html" title="Mesh class. Represent a Mesh, a collection of primitives (usually, but not necessarily, triangles) together with their per-vertex information. A mesh&#39;s is a grouping where all vertices/primitives will have the same basic transformation (but can then be skinned) and material applied.">Mesh</a>. <a href="#a489d5d9e5a2a54127623b756e78c4315">More...</a><br/></td></tr>
<tr class="separator:a489d5d9e5a2a54127623b756e78c4315"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12bcecb68bbf030852edd91a31498160"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1assets_1_1_mesh.html#a12bcecb68bbf030852edd91a31498160">mergeBoneBatches</a> (uint32_t boneIndexAttributeId)</td></tr>
<tr class="memdesc:a12bcecb68bbf030852edd91a31498160"><td class="mdescLeft">&#160;</td><td class="mdescRight">Merge all bone batches into one, effectively re-merging the mesh into one draw call <a href="#a12bcecb68bbf030852edd91a31498160">More...</a><br/></td></tr>
<tr class="separator:a12bcecb68bbf030852edd91a31498160"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e2ba13eaed9b97ac1975af18dcfd421"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1assets_1_1_mesh.html#a1e2ba13eaed9b97ac1975af18dcfd421">removeAllVertexAttributes</a> ()</td></tr>
<tr class="memdesc:a1e2ba13eaed9b97ac1975af18dcfd421"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove all vertex attribute to the mesh. <a href="#a1e2ba13eaed9b97ac1975af18dcfd421">More...</a><br/></td></tr>
<tr class="separator:a1e2ba13eaed9b97ac1975af18dcfd421"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf2f385432d65c533b61618aa0b01bb5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1assets_1_1_mesh.html#adf2f385432d65c533b61618aa0b01bb5">removeData</a> (uint32_t index)</td></tr>
<tr class="memdesc:adf2f385432d65c533b61618aa0b01bb5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delete a block of data. <a href="#adf2f385432d65c533b61618aa0b01bb5">More...</a><br/></td></tr>
<tr class="separator:adf2f385432d65c533b61618aa0b01bb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aede8af714093e8affa635c468a791730"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1assets_1_1_mesh.html#aede8af714093e8affa635c468a791730">removeVertexAttribute</a> (const StringHash &amp;semanticName)</td></tr>
<tr class="memdesc:aede8af714093e8affa635c468a791730"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove a vertex attribute to the mesh. <a href="#aede8af714093e8affa635c468a791730">More...</a><br/></td></tr>
<tr class="separator:aede8af714093e8affa635c468a791730"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1dd580700ba77baa5451ab23cad67f7d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1assets_1_1_mesh.html#a1dd580700ba77baa5451ab23cad67f7d">setNumFaces</a> (uint32_t numFaces)</td></tr>
<tr class="memdesc:a1dd580700ba77baa5451ab23cad67f7d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the total number of faces. Will not change the actual Face Data. <a href="#a1dd580700ba77baa5451ab23cad67f7d">More...</a><br/></td></tr>
<tr class="separator:a1dd580700ba77baa5451ab23cad67f7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6f35f211c34039ffee592af24b7d1c7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1assets_1_1_mesh.html#ad6f35f211c34039ffee592af24b7d1c7">setNumVertices</a> (uint32_t numVertices)</td></tr>
<tr class="memdesc:ad6f35f211c34039ffee592af24b7d1c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the total number of vertices. Will not change the actual Vertex Data. <a href="#ad6f35f211c34039ffee592af24b7d1c7">More...</a><br/></td></tr>
<tr class="separator:ad6f35f211c34039ffee592af24b7d1c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a511cf5eb1381ebb0b46c188dfc19b76d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1assets_1_1_mesh.html#a511cf5eb1381ebb0b46c188dfc19b76d">setPrimitiveType</a> (const PrimitiveTopology &amp;type)</td></tr>
<tr class="memdesc:a511cf5eb1381ebb0b46c188dfc19b76d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the primitive topology that the data in this <a class="el" href="classpvr_1_1assets_1_1_mesh.html" title="Mesh class. Represent a Mesh, a collection of primitives (usually, but not necessarily, triangles) together with their per-vertex information. A mesh&#39;s is a grouping where all vertices/primitives will have the same basic transformation (but can then be skinned) and material applied.">Mesh</a> represent. <a href="#a511cf5eb1381ebb0b46c188dfc19b76d">More...</a><br/></td></tr>
<tr class="separator:a511cf5eb1381ebb0b46c188dfc19b76d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc3ae0aff3ae49e0bb969b076415bc3a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1assets_1_1_mesh.html#adc3ae0aff3ae49e0bb969b076415bc3a">setStride</a> (uint32_t index, uint32_t stride)</td></tr>
<tr class="memdesc:adc3ae0aff3ae49e0bb969b076415bc3a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the stride of a Data block. <a href="#adc3ae0aff3ae49e0bb969b076415bc3a">More...</a><br/></td></tr>
<tr class="separator:adc3ae0aff3ae49e0bb969b076415bc3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a3b53368879dea40e0afe52cd207258"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1assets_1_1_mesh.html#a2a3b53368879dea40e0afe52cd207258">setStripData</a> (uint32_t numStrips, const uint32_t *lengths)</td></tr>
<tr class="memdesc:a2a3b53368879dea40e0afe52cd207258"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the TriangleStrip number and lengths. <a href="#a2a3b53368879dea40e0afe52cd207258">More...</a><br/></td></tr>
<tr class="separator:a2a3b53368879dea40e0afe52cd207258"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6511bf2b294ecaf38ebf6f6668b9a4e4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1assets_1_1_mesh.html#a6511bf2b294ecaf38ebf6f6668b9a4e4">setUnpackMatrix</a> (const glm::mat4x4 &amp;unpackMatrix)</td></tr>
<tr class="memdesc:a6511bf2b294ecaf38ebf6f6668b9a4e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the Unpack Matrix of this <a class="el" href="classpvr_1_1assets_1_1_mesh.html" title="Mesh class. Represent a Mesh, a collection of primitives (usually, but not necessarily, triangles) together with their per-vertex information. A mesh&#39;s is a grouping where all vertices/primitives will have the same basic transformation (but can then be skinned) and material applied.">Mesh</a>. The unpack matrix is used for some exotic types of vertex position compression. <a href="#a6511bf2b294ecaf38ebf6f6668b9a4e4">More...</a><br/></td></tr>
<tr class="separator:a6511bf2b294ecaf38ebf6f6668b9a4e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c901debed7dab92c980c1a5961de874"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1assets_1_1_mesh.html#a8c901debed7dab92c980c1a5961de874">setUserDataPtr</a> (const RefCountedResource&lt; void &gt; &amp;ptr)</td></tr>
<tr class="memdesc:a8c901debed7dab92c980c1a5961de874"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the UserData of this mesh (wrap the data into a RefCountedResource and cast to Ref Counted void pointer. <a href="#a8c901debed7dab92c980c1a5961de874">More...</a><br/></td></tr>
<tr class="separator:a8c901debed7dab92c980c1a5961de874"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae96a1c1ff722b758f6c8940b61289d4b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1assets_1_1_mesh.html#ae96a1c1ff722b758f6c8940b61289d4b">setVertexAttributeIndex</a> (const char *attributeName, size_t userIndex)</td></tr>
<tr class="memdesc:ae96a1c1ff722b758f6c8940b61289d4b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Locate the specified Attribute in a specific position in the vertex attribute array. Can be used to sort the vertex attributes according to a specific order. <a href="#ae96a1c1ff722b758f6c8940b61289d4b">More...</a><br/></td></tr>
<tr class="separator:ae96a1c1ff722b758f6c8940b61289d4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p><a class="el" href="classpvr_1_1assets_1_1_mesh.html" title="Mesh class. Represent a Mesh, a collection of primitives (usually, but not necessarily, triangles) together with their per-vertex information. A mesh&#39;s is a grouping where all vertices/primitives will have the same basic transformation (but can then be skinned) and material applied.">Mesh</a> class. Represent a <a class="el" href="classpvr_1_1assets_1_1_mesh.html" title="Mesh class. Represent a Mesh, a collection of primitives (usually, but not necessarily, triangles) together with their per-vertex information. A mesh&#39;s is a grouping where all vertices/primitives will have the same basic transformation (but can then be skinned) and material applied.">Mesh</a>, a collection of primitives (usually, but not necessarily, triangles) together with their per-vertex information. A mesh's is a grouping where all vertices/primitives will have the same basic transformation (but can then be skinned) and material applied.</p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a class="anchor" id="a4722749d8d5bfa2c811074f83a109169"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef IndexedArray&lt;<a class="el" href="classpvr_1_1assets_1_1_mesh_1_1_vertex_attribute_data.html">VertexAttributeData</a>, StringHash&gt; <a class="el" href="classpvr_1_1assets_1_1_mesh.html#a4722749d8d5bfa2c811074f83a109169">pvr::assets::Mesh::VertexAttributeContainer</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This container is automatically kept sorted.</p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="ad86f903670f1604c60460197a75bb9ef"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t pvr::assets::Mesh::addData </td>
          <td>(</td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>stride</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Implicitly append a block of vertex data to the mesh and (optionally) populate it with data.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>A pointer to data that will be copied to the new block. If <em>data</em> is NULL, the block remains uninitialized.</td></tr>
    <tr><td class="paramname">size</td><td>The ordinal of the data block. If no block exists, it will be created along with all the ones before it, as</td></tr>
    <tr><td class="paramname">stride</td><td>The stride that the block index will be set to.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><p class="startdd">The index of the block that was just created.</p>
<p class="enddd">The index of the block that was just created.</p>
</dd></dl>
<p>With this call, a new data block will be appended to the end of the mesh, and will be populated with (size) bytes of data copied from the (data) pointer. (stride) will be saved as metadata with the data of the block and will be queriable with the (getStride) call with the same index as the data.</p>

</div>
</div>
<a class="anchor" id="a70a29004239651b6c879a912bd347c2f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t pvr::assets::Mesh::addData </td>
          <td>(</td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>stride</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add a block of vertex data to the mesh at the specified index and (optionally) populate it with data. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>A pointer to data that will be copied to the new block. If <em>data</em> is NULL, the block remains uninitialized.</td></tr>
    <tr><td class="paramname">size</td><td>The ordinal of the data block. If no block exists, it will be created along with all the ones before it, as</td></tr>
    <tr><td class="paramname">stride</td><td>The stride that the block index will be set to.</td></tr>
    <tr><td class="paramname">index</td><td>The index where this block will be created on.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The index of the block that was just created.</dd></dl>
<p>With this call, a new data block will be added to the specified index of the mesh, and will be populated with (size) bytes of data copied from the (data) pointer. (stride) will be saved as metadata with the data of the block and will be queriable with the (getStride) call with the same index as the data. </p>

</div>
</div>
<a class="anchor" id="aeba19b4f7de6dc15ef164950b7f9b893"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pvr::assets::Mesh::addFaces </td>
          <td>(</td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const IndexType&#160;</td>
          <td class="paramname"><em>indexType</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add face information to the mesh.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>A pointer to the face data</td></tr>
    <tr><td class="paramname">size</td><td>The size, in bytes, of the face data</td></tr>
    <tr><td class="paramname">indexType</td><td>The actual datatype contained in (data). (16 or 32 bit)</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="abe1c6afb7857d5a2a55ad1df8a94fac4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t pvr::assets::Mesh::addVertexAttribute </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpvr_1_1assets_1_1_mesh_1_1_vertex_attribute_data.html">VertexAttributeData</a> &amp;&#160;</td>
          <td class="paramname"><em>element</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>forceReplace</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add a vertex attribute to the mesh.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">element</td><td>The vertex attribute to add</td></tr>
    <tr><td class="paramname">forceReplace</td><td>If set to true, the element will be replaced if it already exists. Otherwise, the insertion will fail.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The index where the element was added (or where the already existing item was)</dd></dl>

</div>
</div>
<a class="anchor" id="a22dd8fec1aacd0e21644e68b3da5eece"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t pvr::assets::Mesh::addVertexAttribute </td>
          <td>(</td>
          <td class="paramtype">const StringHash &amp;&#160;</td>
          <td class="paramname"><em>semanticName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DataType &amp;&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>dataIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>forceReplace</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add a vertex attribute to the mesh.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">semanticName</td><td>The semantic that the vertex attribute to add represents</td></tr>
    <tr><td class="paramname">type</td><td>The DataType of the Vertex Attribute</td></tr>
    <tr><td class="paramname">width</td><td>The number of (type) values per Vertex Attribute</td></tr>
    <tr><td class="paramname">offset</td><td>The Offset of this Vertex Attribute from the start of its DataBlock</td></tr>
    <tr><td class="paramname">dataIndex</td><td>The DataBlock this Vertex Attribute belongs to</td></tr>
    <tr><td class="paramname">forceReplace</td><td>force replace the attribute</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The index where the element was added (or where the already existing item was)</dd></dl>

</div>
</div>
<a class="anchor" id="ae320f2a19d317b96675e82d626482cfc"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pvr::assets::Mesh::clearAllData </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Remove all data blocks.</p>

</div>
</div>
<a class="anchor" id="aed6ea457b436fc57266d14d8fddf407c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t pvr::assets::Mesh::getBatchBone </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>batch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>bone</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the global index of a bone from its batch and index in the batch.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">batch</td><td>The index of a BoneBatch</td></tr>
    <tr><td class="paramname">bone</td><td>The index in the of a bone in the batch</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The index of the bone</dd></dl>

</div>
</div>
<a class="anchor" id="ad547fc0fe2790736db4839bd70052962"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t pvr::assets::Mesh::getBatchFaceOffset </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>batch</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the offset in the Faces data that the specified batch begins at.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">batch</td><td>The index of a BoneBatch</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The offset, in bytes, in the Faces data that the specified batch begins at.</dd></dl>

</div>
</div>
<a class="anchor" id="a7719d5ec94e1a6deca30103f0234c52f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t pvr::assets::Mesh::getBatchFaceOffsetBytes </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>batch</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the offset in the Faces data that the specified batch begins at.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">batch</td><td>The index of a BoneBatch</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The offset, in bytes, in the Faces data that the specified batch begins at.</dd></dl>

</div>
</div>
<a class="anchor" id="ab6f9fe4b4705e6dfead28b9b87e27116"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const void* pvr::assets::Mesh::getData </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a pointer to the data of a specified Data block. Read only overload.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>The index of the data block</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A const pointer to the specified data block.</dd></dl>

</div>
</div>
<a class="anchor" id="add38ffc4f6966aa5a7d9ba73b6aa12bc"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t* pvr::assets::Mesh::getData </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a pointer to the data of a specified Data block. Read/write overload.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>The index of the data block</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the specified data block.</dd></dl>

</div>
</div>
<a class="anchor" id="ad6e6b2798652d73515aa84d2fe630bd7"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t pvr::assets::Mesh::getDataSize </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the size of the specified Data block.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>The index of the data block</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The size in bytes of the specified Data block.</dd></dl>

</div>
</div>
<a class="anchor" id="af5e14d52dd4f491e9fdc743c8fb68fba"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classpvr_1_1assets_1_1_mesh_1_1_face_data.html">FaceData</a>&amp; pvr::assets::Mesh::getFaces </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get all face data of this mesh.</p>
<dl class="section return"><dt>Returns</dt><dd>A reference to the face data object of this mesh</dd></dl>

</div>
</div>
<a class="anchor" id="a25853ea014e345aaf8437f4f4e59ad26"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpvr_1_1assets_1_1_mesh_1_1_face_data.html">FaceData</a>&amp; pvr::assets::Mesh::getFaces </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get all face data of this mesh.</p>
<dl class="section return"><dt>Returns</dt><dd>A reference to the face data object of this mesh</dd></dl>

</div>
</div>
<a class="anchor" id="a9d2c88d289cccdee673a91beaffd62df"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structpvr_1_1assets_1_1_mesh_1_1_internal_data.html">InternalData</a>&amp; pvr::assets::Mesh::getInternalData </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a reference to the internal representation and data of this <a class="el" href="classpvr_1_1assets_1_1_mesh.html" title="Mesh class. Represent a Mesh, a collection of primitives (usually, but not necessarily, triangles) together with their per-vertex information. A mesh&#39;s is a grouping where all vertices/primitives will have the same basic transformation (but can then be skinned) and material applied.">Mesh</a>. Handle with care.</p>
<dl class="section return"><dt>Returns</dt><dd>The internal representation of this object.</dd></dl>

</div>
</div>
<a class="anchor" id="a0bd59376ff32b82b6eebba0c8c135ace"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structpvr_1_1assets_1_1_mesh_1_1_mesh_info.html">MeshInfo</a>&amp; pvr::assets::Mesh::getMeshInfo </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get information on this <a class="el" href="classpvr_1_1assets_1_1_mesh.html" title="Mesh class. Represent a Mesh, a collection of primitives (usually, but not necessarily, triangles) together with their per-vertex information. A mesh&#39;s is a grouping where all vertices/primitives will have the same basic transformation (but can then be skinned) and material applied.">Mesh</a>.</p>
<dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="structpvr_1_1assets_1_1_mesh_1_1_mesh_info.html" title="Contains mesh information.">Mesh::MeshInfo</a> object containing information on this <a class="el" href="classpvr_1_1assets_1_1_mesh.html" title="Mesh class. Represent a Mesh, a collection of primitives (usually, but not necessarily, triangles) together with their per-vertex information. A mesh&#39;s is a grouping where all vertices/primitives will have the same basic transformation (but can then be skinned) and material applied.">Mesh</a></dd></dl>

</div>
</div>
<a class="anchor" id="a6e178e1f82eef52d6c4ee5e91ca2990a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const FreeValue* pvr::assets::Mesh::getMeshSemantic </td>
          <td>(</td>
          <td class="paramtype">const StringHash &amp;&#160;</td>
          <td class="paramname"><em>semantic</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the value of a Per-Mesh semantic as a FreeValue, null if it does not exist.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">semantic</td><td>The semantic name to retrieve</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to a FreeValue containing the value of the semantic. If the semantic does not exist, return NULL</dd></dl>

</div>
</div>
<a class="anchor" id="a4631a8b4fb8bfa0888efd0da743f1150"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t pvr::assets::Mesh::getNumBatchBones </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>batch</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get how many bones the specified bone batch has.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">batch</td><td>The index of a BoneBatch</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of bones in the batch with index (batch)</dd></dl>

</div>
</div>
<a class="anchor" id="aaed956628770c5a5d268ad6575d97cba"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t pvr::assets::Mesh::getNumBoneBatches </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the number of <a class="el" href="structpvr_1_1assets_1_1_mesh_1_1_bone_batches.html" title="This class is used to break meshes into different batches in order to avoid overflowing the number of...">BoneBatches</a> the bones of this mesh are organised into.</p>
<dl class="section return"><dt>Returns</dt><dd>The number of bone batches</dd></dl>

</div>
</div>
<a class="anchor" id="af2b00633fc96e0ca805715c91f670abb"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t pvr::assets::Mesh::getNumBones </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the information of a VertexAttribute by its SemanticName.</p>
<dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="classpvr_1_1assets_1_1_mesh_1_1_vertex_attribute_data.html" title="Definition of a single VertexAttribute.">VertexAttributeData</a> object with information on this attribute. (layout, index etc.) Null if failed</dd></dl>
<p>This method does lookup in O(logN) time. Prefer to call the getVertexAttributeID and then use the constant-time O(1) getVertexAttribute(int32_t) method</p>

</div>
</div>
<a class="anchor" id="a343b45c267531da7378f4372a55caff8"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t pvr::assets::Mesh::getNumDataElements </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the number of vertex data blocks that this mesh has.</p>
<dl class="section return"><dt>Returns</dt><dd>The number of data blocks</dd></dl>

</div>
</div>
<a class="anchor" id="a3dd3ad8c738c550d282f627ce7814884"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t pvr::assets::Mesh::getNumElements </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the number of different vertex attributes that this mesh has.</p>
<dl class="section return"><dt>Returns</dt><dd>The number of vertex attributes</dd></dl>

</div>
</div>
<a class="anchor" id="a1f92999bddcef4351a470309b287af91"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t pvr::assets::Mesh::getNumFaces </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the number of faces that comprise this mesh.</p>
<dl class="section return"><dt>Returns</dt><dd>The number of faces</dd></dl>

</div>
</div>
<a class="anchor" id="a104eceb0cca8c21cc7b1f437af60781d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t pvr::assets::Mesh::getNumFaces </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>boneBatch</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the number of faces that comprise the designated bonebatch.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">boneBatch</td><td>The bone batch id</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of faces</dd></dl>

</div>
</div>
<a class="anchor" id="a563f695e4cd8d361859ae1d6529e29f7"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t pvr::assets::Mesh::getNumIndices </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the number of indices that comprise this mesh. Takes TriangleStrips into consideration. </p>
<dl class="section return"><dt>Returns</dt><dd>The number of indexes</dd></dl>

</div>
</div>
<a class="anchor" id="a5345259d234d0ec6a86cddda321b76d0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t pvr::assets::Mesh::getNumStrips </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the number of Triangle Strips (if any) that comprise this <a class="el" href="classpvr_1_1assets_1_1_mesh.html" title="Mesh class. Represent a Mesh, a collection of primitives (usually, but not necessarily, triangles) together with their per-vertex information. A mesh&#39;s is a grouping where all vertices/primitives will have the same basic transformation (but can then be skinned) and material applied.">Mesh</a>.</p>
<dl class="section return"><dt>Returns</dt><dd>The number of Triangle Strips (if any) that comprise this <a class="el" href="classpvr_1_1assets_1_1_mesh.html" title="Mesh class. Represent a Mesh, a collection of primitives (usually, but not necessarily, triangles) together with their per-vertex information. A mesh&#39;s is a grouping where all vertices/primitives will have the same basic transformation (but can then be skinned) and material applied.">Mesh</a>. 0 if the <a class="el" href="classpvr_1_1assets_1_1_mesh.html" title="Mesh class. Represent a Mesh, a collection of primitives (usually, but not necessarily, triangles) together with their per-vertex information. A mesh&#39;s is a grouping where all vertices/primitives will have the same basic transformation (but can then be skinned) and material applied.">Mesh</a> is not made of strips </dd></dl>

</div>
</div>
<a class="anchor" id="a9ad5165623e8cf72138ee941b6fa96fe"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t pvr::assets::Mesh::getNumVertices </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the number of vertices that comprise this mesh.</p>
<dl class="section return"><dt>Returns</dt><dd>The number of vertices</dd></dl>

</div>
</div>
<a class="anchor" id="aad44274c2f282635815af77085e05ae0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">PrimitiveTopology pvr::assets::Mesh::getPrimitiveType </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the primitive topology that the data in this <a class="el" href="classpvr_1_1assets_1_1_mesh.html" title="Mesh class. Represent a Mesh, a collection of primitives (usually, but not necessarily, triangles) together with their per-vertex information. A mesh&#39;s is a grouping where all vertices/primitives will have the same basic transformation (but can then be skinned) and material applied.">Mesh</a> represent.</p>
<dl class="section return"><dt>Returns</dt><dd>The primitive topology that the data in this <a class="el" href="classpvr_1_1assets_1_1_mesh.html" title="Mesh class. Represent a Mesh, a collection of primitives (usually, but not necessarily, triangles) together with their per-vertex information. A mesh&#39;s is a grouping where all vertices/primitives will have the same basic transformation (but can then be skinned) and material applied.">Mesh</a> represent (Triangles, TriangleStrips, TriangleFans, Patch etc.)</dd></dl>

</div>
</div>
<a class="anchor" id="a0b8b165ab2fb7b8e3c0d76c1b243a7e4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t pvr::assets::Mesh::getStride </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get distance in bytes from vertex in an array to the next.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>The index of the data block whose stride to get</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The distance in bytes from one array entry to the next.</dd></dl>

</div>
</div>
<a class="anchor" id="a722fd34a8c4d3f576902cb60af47b709"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t pvr::assets::Mesh::getStripLength </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>strip</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the length of the specified triangle strip.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">strip</td><td>The index of the strip of which to return the length</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The length of the TriangleStrip with index (strip)</dd></dl>

</div>
</div>
<a class="anchor" id="a96068e0b13badc70fe76b632838caa5a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const uint32_t* pvr::assets::Mesh::getStripLengths </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get an array containing the Triangle Strip lengths.</p>
<dl class="section return"><dt>Returns</dt><dd>An array of 32 bit values representing the Triangle Strip lengths. Use getNumStrips for the length of the array.</dd></dl>

</div>
</div>
<a class="anchor" id="acc0eda8a17f910099b4580b4c5fde0da"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const glm::mat4x4&amp; pvr::assets::Mesh::getUnpackMatrix </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the Unpack Matrix of this <a class="el" href="classpvr_1_1assets_1_1_mesh.html" title="Mesh class. Represent a Mesh, a collection of primitives (usually, but not necessarily, triangles) together with their per-vertex information. A mesh&#39;s is a grouping where all vertices/primitives will have the same basic transformation (but can then be skinned) and material applied.">Mesh</a>. The unpack matrix is used for some exotic types of vertex position compression.</p>
<dl class="section return"><dt>Returns</dt><dd>The unpack matrix</dd></dl>

</div>
</div>
<a class="anchor" id="abf477d4772b1d169050032d3ed8af003"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const RefCountedResource&lt;void&gt;&amp; pvr::assets::Mesh::getUserDataPtr </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the UserData of this mesh, if such user data exist.</p>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the UserData, as a Reference Counted Void pointer. Cast to appropriate (ref counted)type</dd></dl>

</div>
</div>
<a class="anchor" id="ac2031f8467bf23a6167dd5c89db41224"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">RefCountedResource&lt;void&gt; pvr::assets::Mesh::getUserDataPtr </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the UserData of this mesh, if such user data exist.</p>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the UserData, as a Reference Counted Void pointer. Cast to appropriate (ref counted)type</dd></dl>

</div>
</div>
<a class="anchor" id="afcc66af649bcb8770241fc30ca34a1b8"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classpvr_1_1assets_1_1_mesh_1_1_vertex_attribute_data.html">VertexAttributeData</a>* pvr::assets::Mesh::getVertexAttribute </td>
          <td>(</td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>idx</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the information of a VertexAttribute by its SemanticName.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">idx</td><td>A semantic id with which to retrieve a vertex attribute.<dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="classpvr_1_1assets_1_1_mesh_1_1_vertex_attribute_data.html" title="Definition of a single VertexAttribute.">VertexAttributeData</a> object with information on this attribute. (layout, data index etc.) Null if failed</dd></dl>
</td></tr>
  </table>
  </dd>
</dl>
<p>This method does lookup in constant O(1) time. Use the getVertexAttributeID to get the index to use this method</p>

</div>
</div>
<a class="anchor" id="a7d7592cc303be36e0648a6197923f450"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classpvr_1_1assets_1_1_mesh_1_1_vertex_attribute_data.html">VertexAttributeData</a>* pvr::assets::Mesh::getVertexAttributeByName </td>
          <td>(</td>
          <td class="paramtype">const StringHash &amp;&#160;</td>
          <td class="paramname"><em>semanticName</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the information of a VertexAttribute by its SemanticName (return NULL if not exist)</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">semanticName</td><td>A semantic name with which to look for a vertex attribute.<dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="classpvr_1_1assets_1_1_mesh_1_1_vertex_attribute_data.html" title="Definition of a single VertexAttribute.">VertexAttributeData</a> object with information on this attribute. (layout, index etc.) Null if failed</dd></dl>
</td></tr>
  </table>
  </dd>
</dl>
<p>This method does lookup in O(logN) time. Prefer to call the getVertexAttributeID and then use the constant-time O(1) getVertexAttribute(int32_t) method</p>

</div>
</div>
<a class="anchor" id="a514add6ba80930e469334ca641ad3f17"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int32_t pvr::assets::Mesh::getVertexAttributeIndex </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>semanticName</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the Index of a VertexAttribute by its SemanticName.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">semanticName</td><td>A semantic name with which to look for a vertex attribute.<dl class="section return"><dt>Returns</dt><dd>The Index of the vertexAttribute.</dd></dl>
</td></tr>
  </table>
  </dd>
</dl>
<p>Use this method to get the Index of a vertex attribute in O(logN) time and then be able to retrieve it by index with getVertexAttribute in constant time</p>

</div>
</div>
<a class="anchor" id="a40407ad5da4c5bf49064b979f3efe7d9"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpvr_1_1assets_1_1_mesh.html#a4722749d8d5bfa2c811074f83a109169">VertexAttributeContainer</a>&amp; pvr::assets::Mesh::getVertexAttributes </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get all the vertex attributes.</p>
<dl class="section return"><dt>Returns</dt><dd>A reference to the actual container the Vertex Attributes are stored in.</dd></dl>

</div>
</div>
<a class="anchor" id="a1728791103eaec595819ca93b7918fff"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classpvr_1_1assets_1_1_mesh.html#a4722749d8d5bfa2c811074f83a109169">VertexAttributeContainer</a>&amp; pvr::assets::Mesh::getVertexAttributes </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get all the vertex attributes.</p>
<dl class="section return"><dt>Returns</dt><dd>A const reference to the actual container the Vertex Attributes are stored in.</dd></dl>

</div>
</div>
<a class="anchor" id="ae6ffee1763b8400c47ca017425d47953"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t pvr::assets::Mesh::getVertexAttributesSize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get number of vertex attributes.</p>
<dl class="section return"><dt>Returns</dt><dd>The number of vertex attributes</dd></dl>

</div>
</div>
<a class="anchor" id="a489d5d9e5a2a54127623b756e78c4315"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt;StridedBuffer&gt;&amp; pvr::assets::Mesh::getVertexData </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get all DataBlocks of this <a class="el" href="classpvr_1_1assets_1_1_mesh.html" title="Mesh class. Represent a Mesh, a collection of primitives (usually, but not necessarily, triangles) together with their per-vertex information. A mesh&#39;s is a grouping where all vertices/primitives will have the same basic transformation (but can then be skinned) and material applied.">Mesh</a>.</p>
<dl class="section return"><dt>Returns</dt><dd>The datablocks, as an std::vector of StridedBuffers that additionally have a stride member. </dd></dl>
<p>Use as char arrays and additionally use the <a class="el" href="classpvr_1_1assets_1_1_mesh.html#a0b8b165ab2fb7b8e3c0d76c1b243a7e4" title="Get distance in bytes from vertex in an array to the next.">getStride()</a> method to get the element stride</p>

</div>
</div>
<a class="anchor" id="a12bcecb68bbf030852edd91a31498160"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pvr::assets::Mesh::mergeBoneBatches </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>boneIndexAttributeId</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Merge all bone batches into one, effectively re-merging the mesh into one draw call</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">boneIndexAttributeId</td><td>The Attribute ID of the Bone Index attribute of this mesh</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a1e2ba13eaed9b97ac1975af18dcfd421"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pvr::assets::Mesh::removeAllVertexAttributes </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove all vertex attribute to the mesh.</p>

</div>
</div>
<a class="anchor" id="adf2f385432d65c533b61618aa0b01bb5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pvr::assets::Mesh::removeData </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Delete a block of data.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>The index of the block to delete</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aede8af714093e8affa635c468a791730"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pvr::assets::Mesh::removeVertexAttribute </td>
          <td>(</td>
          <td class="paramtype">const StringHash &amp;&#160;</td>
          <td class="paramname"><em>semanticName</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove a vertex attribute to the mesh.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">semanticName</td><td>The semantic that the vertex attribute to remove has</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a1dd580700ba77baa5451ab23cad67f7d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pvr::assets::Mesh::setNumFaces </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>numFaces</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the total number of faces. Will not change the actual Face Data.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">numFaces</td><td>Set the number of faces</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ad6f35f211c34039ffee592af24b7d1c7"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pvr::assets::Mesh::setNumVertices </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>numVertices</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the total number of vertices. Will not change the actual Vertex Data.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">numVertices</td><td>Set the number of vertices</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a511cf5eb1381ebb0b46c188dfc19b76d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pvr::assets::Mesh::setPrimitiveType </td>
          <td>(</td>
          <td class="paramtype">const PrimitiveTopology &amp;&#160;</td>
          <td class="paramname"><em>type</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the primitive topology that the data in this <a class="el" href="classpvr_1_1assets_1_1_mesh.html" title="Mesh class. Represent a Mesh, a collection of primitives (usually, but not necessarily, triangles) together with their per-vertex information. A mesh&#39;s is a grouping where all vertices/primitives will have the same basic transformation (but can then be skinned) and material applied.">Mesh</a> represent.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">type</td><td>The primitive topology that the data in this <a class="el" href="classpvr_1_1assets_1_1_mesh.html" title="Mesh class. Represent a Mesh, a collection of primitives (usually, but not necessarily, triangles) together with their per-vertex information. A mesh&#39;s is a grouping where all vertices/primitives will have the same basic transformation (but can then be skinned) and material applied.">Mesh</a> will represent (Triangles, TriangleStrips, TriangleFans, Patch etc.)</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="adc3ae0aff3ae49e0bb969b076415bc3a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pvr::assets::Mesh::setStride </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>stride</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the stride of a Data block.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>The ordinal of the data block (as it was defined by the addData call). If no block exists, it will be created along with all the ones before it, as blocks are always assumed to be continuous</td></tr>
    <tr><td class="paramname">stride</td><td>The stride that the block (index) will be set to.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a2a3b53368879dea40e0afe52cd207258"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pvr::assets::Mesh::setStripData </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>numStrips</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t *&#160;</td>
          <td class="paramname"><em>lengths</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the TriangleStrip number and lengths.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">numStrips</td><td>The number of TriangleStrips</td></tr>
    <tr><td class="paramname">lengths</td><td>An array of size numStrips containing the length of each TriangleStrip, respectively </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a6511bf2b294ecaf38ebf6f6668b9a4e4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pvr::assets::Mesh::setUnpackMatrix </td>
          <td>(</td>
          <td class="paramtype">const glm::mat4x4 &amp;&#160;</td>
          <td class="paramname"><em>unpackMatrix</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the Unpack Matrix of this <a class="el" href="classpvr_1_1assets_1_1_mesh.html" title="Mesh class. Represent a Mesh, a collection of primitives (usually, but not necessarily, triangles) together with their per-vertex information. A mesh&#39;s is a grouping where all vertices/primitives will have the same basic transformation (but can then be skinned) and material applied.">Mesh</a>. The unpack matrix is used for some exotic types of vertex position compression.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">unpackMatrix</td><td>An unpack matrix</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a8c901debed7dab92c980c1a5961de874"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pvr::assets::Mesh::setUserDataPtr </td>
          <td>(</td>
          <td class="paramtype">const RefCountedResource&lt; void &gt; &amp;&#160;</td>
          <td class="paramname"><em>ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the UserData of this mesh (wrap the data into a RefCountedResource and cast to Ref Counted void pointer.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptr</td><td>The UserData. Must be wrapped in an appropriate RefCountedResource, and then cast into a RefCountedResource to void</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ae96a1c1ff722b758f6c8940b61289d4b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pvr::assets::Mesh::setVertexAttributeIndex </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>attributeName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>userIndex</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Locate the specified Attribute in a specific position in the vertex attribute array. Can be used to sort the vertex attributes according to a specific order.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">attributeName</td><td>The name of an attribute</td></tr>
    <tr><td class="paramname">userIndex</td><td>The index to put this attribute to. If another attribute is there, indices will be swapped.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>/usr/buildxl/buildroot/sdk/branch/Framework/PVRAssets/Model/<a class="el" href="_mesh_8h_source.html">Mesh.h</a></li>
</ul>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.4-->
<!-- start footer part (NON TREEVIEW ONLY!!) -->
<!--BEGIN GENERATE_TREEVIEW-->
<div id="FooterMainContainer">
	<div id="FooterContainer">
		<div class="footerlogo">
			<a href="http://www.imgtec.com" target="_blank"><img src="img-footer-logo-grey.png" width="100%" height="100%" border="none" /></a>
		</div>
		<div class="copyright"><p>&copy; Imagination Technologies Limited<br> All rights reserved</p></div>
	</div>
</div>
</body>
</html>
