<!-- HTML header for doxygen 1.8.4-->
<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="generator" content="Doxygen 1.8.6"/>
<title>PVRCore: pvr::ContiguousMap&lt; Key_, Value_, Comparator &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="IMGdoxygen.css" rel="stylesheet" type="text/css"/>
<link rel="shortcut icon" href="http://www.imgtec.com/images/img.ico">
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
  <div class="headercontent">
    <div class="PVRlogo">
      <a href="http://www.powervrinsider.com" target="_blank"><img src="PVRlogo.png" width="40%" height="40%"  border="none" /></a>
    </div>
    <a class="SiteTitle"><span id="projectname">PVRCore</span> Documentation</a>
   <tbody>
  </div>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="inherits.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Macros</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacepvr.html">pvr</a></li><li class="navelem"><a class="el" href="classpvr_1_1_contiguous_map.html">ContiguousMap</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classpvr_1_1_contiguous_map-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">pvr::ContiguousMap&lt; Key_, Value_, Comparator &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>A map that uses a std::vector as an underlying sparse storage and uses binary search for logarithmic time key lookup or indexing for constant time lookup. a) it can be indexed either by index in constant time, or by key in logarithmic time. b) Guaranteed to have contiguous storage c) If items are removed, iterators are invalidated. 
 <a href="classpvr_1_1_contiguous_map.html#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:ab48c278981530460f56e7cf5d254d0f5"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab48c278981530460f56e7cf5d254d0f5"></a>
typedef StorageType::const_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1_contiguous_map.html#ab48c278981530460f56e7cf5d254d0f5">const_iterator</a></td></tr>
<tr class="memdesc:ab48c278981530460f56e7cf5d254d0f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">The type of the (linear) const iterator of the map. <br/></td></tr>
<tr class="separator:ab48c278981530460f56e7cf5d254d0f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a21214d3ca79e5f6ead1bc8253d9339"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9a21214d3ca79e5f6ead1bc8253d9339"></a>
typedef <br class="typebreak"/>
StorageType::const_reverse_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1_contiguous_map.html#a9a21214d3ca79e5f6ead1bc8253d9339">const_reverse_iterator</a></td></tr>
<tr class="memdesc:a9a21214d3ca79e5f6ead1bc8253d9339"><td class="mdescLeft">&#160;</td><td class="mdescRight">The type of the (linear) reverse const iterator of the map. <br/></td></tr>
<tr class="separator:a9a21214d3ca79e5f6ead1bc8253d9339"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c4a880b42921b6b6885bbc8bfec332a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6c4a880b42921b6b6885bbc8bfec332a"></a>
typedef std::pair&lt; <a class="el" href="classpvr_1_1_contiguous_map.html#a50962670e777af136321114a9505f9bb">KeyType</a>, <br class="typebreak"/>
<a class="el" href="classpvr_1_1_contiguous_map.html#aad98010369424a965aa331f97f6bc67b">ValueType</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1_contiguous_map.html#a6c4a880b42921b6b6885bbc8bfec332a">EntryType</a></td></tr>
<tr class="memdesc:a6c4a880b42921b6b6885bbc8bfec332a"><td class="mdescLeft">&#160;</td><td class="mdescRight">The type of the map entry (key, value) used in the map. <br/></td></tr>
<tr class="separator:a6c4a880b42921b6b6885bbc8bfec332a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e1ca91ba8f27fe1b464bde581c7029b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3e1ca91ba8f27fe1b464bde581c7029b"></a>
typedef StorageType::iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1_contiguous_map.html#a3e1ca91ba8f27fe1b464bde581c7029b">iterator</a></td></tr>
<tr class="memdesc:a3e1ca91ba8f27fe1b464bde581c7029b"><td class="mdescLeft">&#160;</td><td class="mdescRight">The type of the (linear) iterator of the map. <br/></td></tr>
<tr class="separator:a3e1ca91ba8f27fe1b464bde581c7029b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50962670e777af136321114a9505f9bb"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a50962670e777af136321114a9505f9bb"></a>
typedef Key_&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1_contiguous_map.html#a50962670e777af136321114a9505f9bb">KeyType</a></td></tr>
<tr class="memdesc:a50962670e777af136321114a9505f9bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">The type of the Key stored in the map. <br/></td></tr>
<tr class="separator:a50962670e777af136321114a9505f9bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba6eb7e767be3fcc3deb785a7af11897"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aba6eb7e767be3fcc3deb785a7af11897"></a>
typedef <br class="typebreak"/>
StorageType::reverse_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1_contiguous_map.html#aba6eb7e767be3fcc3deb785a7af11897">reverse_iterator</a></td></tr>
<tr class="memdesc:aba6eb7e767be3fcc3deb785a7af11897"><td class="mdescLeft">&#160;</td><td class="mdescRight">The type of the (linear) reverse iterator of the map. <br/></td></tr>
<tr class="separator:aba6eb7e767be3fcc3deb785a7af11897"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3108122d56def4816936370f41206b2d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3108122d56def4816936370f41206b2d"></a>
typedef std::vector&lt; <a class="el" href="classpvr_1_1_contiguous_map.html#a6c4a880b42921b6b6885bbc8bfec332a">EntryType</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1_contiguous_map.html#a3108122d56def4816936370f41206b2d">StorageType</a></td></tr>
<tr class="memdesc:a3108122d56def4816936370f41206b2d"><td class="mdescLeft">&#160;</td><td class="mdescRight">The type of the contiguous backing store of the map. <br/></td></tr>
<tr class="separator:a3108122d56def4816936370f41206b2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad98010369424a965aa331f97f6bc67b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aad98010369424a965aa331f97f6bc67b"></a>
typedef Value_&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1_contiguous_map.html#aad98010369424a965aa331f97f6bc67b">ValueType</a></td></tr>
<tr class="memdesc:aad98010369424a965aa331f97f6bc67b"><td class="mdescLeft">&#160;</td><td class="mdescRight">The type of the Value stored in the map. <br/></td></tr>
<tr class="separator:aad98010369424a965aa331f97f6bc67b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ad81d50b6fbf97c44712ff10bdf8abead"><td class="memTemplParams" colspan="2">template&lt;typename new_iterator &gt; </td></tr>
<tr class="memitem:ad81d50b6fbf97c44712ff10bdf8abead"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classpvr_1_1_contiguous_map.html">ContiguousMap</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classpvr_1_1_contiguous_map.html#ad81d50b6fbf97c44712ff10bdf8abead">assign</a> (new_iterator beginIt, new_iterator endIt)</td></tr>
<tr class="memdesc:ad81d50b6fbf97c44712ff10bdf8abead"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assign elements in this container <a href="#ad81d50b6fbf97c44712ff10bdf8abead">More...</a><br/></td></tr>
<tr class="separator:ad81d50b6fbf97c44712ff10bdf8abead"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab877ef05a89005c455d498ba8771f40e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpvr_1_1_contiguous_map.html#a3e1ca91ba8f27fe1b464bde581c7029b">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1_contiguous_map.html#ab877ef05a89005c455d498ba8771f40e">begin</a> ()</td></tr>
<tr class="memdesc:ab877ef05a89005c455d498ba8771f40e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return an iterator to tbe begining of the container <a href="#ab877ef05a89005c455d498ba8771f40e">More...</a><br/></td></tr>
<tr class="separator:ab877ef05a89005c455d498ba8771f40e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23dfaa4b47daa04627a1967cf30f1d44"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpvr_1_1_contiguous_map.html#ab48c278981530460f56e7cf5d254d0f5">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1_contiguous_map.html#a23dfaa4b47daa04627a1967cf30f1d44">begin</a> () const </td></tr>
<tr class="memdesc:a23dfaa4b47daa04627a1967cf30f1d44"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a iterator to tbe begining of the container (const). <a href="#a23dfaa4b47daa04627a1967cf30f1d44">More...</a><br/></td></tr>
<tr class="separator:a23dfaa4b47daa04627a1967cf30f1d44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab31d72e5e5756da73b885d83029a9da3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1_contiguous_map.html#ab31d72e5e5756da73b885d83029a9da3">clear</a> ()</td></tr>
<tr class="memdesc:ab31d72e5e5756da73b885d83029a9da3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear all entries in the container <a href="#ab31d72e5e5756da73b885d83029a9da3">More...</a><br/></td></tr>
<tr class="separator:ab31d72e5e5756da73b885d83029a9da3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af286a815ba827610a3c3a859e92971d3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpvr_1_1_contiguous_map.html#a3e1ca91ba8f27fe1b464bde581c7029b">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1_contiguous_map.html#af286a815ba827610a3c3a859e92971d3">end</a> ()</td></tr>
<tr class="memdesc:af286a815ba827610a3c3a859e92971d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a iterator to the end of the container. <a href="#af286a815ba827610a3c3a859e92971d3">More...</a><br/></td></tr>
<tr class="separator:af286a815ba827610a3c3a859e92971d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a6b52dd62586fcf4212379f10392bad"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpvr_1_1_contiguous_map.html#ab48c278981530460f56e7cf5d254d0f5">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1_contiguous_map.html#a7a6b52dd62586fcf4212379f10392bad">end</a> () const </td></tr>
<tr class="memdesc:a7a6b52dd62586fcf4212379f10392bad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a const iterator to the end of the container. <a href="#a7a6b52dd62586fcf4212379f10392bad">More...</a><br/></td></tr>
<tr class="separator:a7a6b52dd62586fcf4212379f10392bad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53ce5999957bc5bb5e7ca69718fcc08b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1_contiguous_map.html#a53ce5999957bc5bb5e7ca69718fcc08b">erase</a> (const <a class="el" href="classpvr_1_1_contiguous_map.html#a50962670e777af136321114a9505f9bb">KeyType</a> &amp;key)</td></tr>
<tr class="memdesc:a53ce5999957bc5bb5e7ca69718fcc08b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes specified elements from the container. <a href="#a53ce5999957bc5bb5e7ca69718fcc08b">More...</a><br/></td></tr>
<tr class="separator:a53ce5999957bc5bb5e7ca69718fcc08b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa285f1fd78f1ccb4bd89568c6b602a15"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpvr_1_1_contiguous_map.html#a3e1ca91ba8f27fe1b464bde581c7029b">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1_contiguous_map.html#aa285f1fd78f1ccb4bd89568c6b602a15">erase</a> (<a class="el" href="classpvr_1_1_contiguous_map.html#a3e1ca91ba8f27fe1b464bde581c7029b">iterator</a> &amp;pos)</td></tr>
<tr class="memdesc:aa285f1fd78f1ccb4bd89568c6b602a15"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes specified elements from the container. <a href="#aa285f1fd78f1ccb4bd89568c6b602a15">More...</a><br/></td></tr>
<tr class="separator:aa285f1fd78f1ccb4bd89568c6b602a15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b9ddf06a1a0cd4ec68c99a407191cd3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpvr_1_1_contiguous_map.html#a3e1ca91ba8f27fe1b464bde581c7029b">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1_contiguous_map.html#a3b9ddf06a1a0cd4ec68c99a407191cd3">erase</a> (<a class="el" href="classpvr_1_1_contiguous_map.html#ab48c278981530460f56e7cf5d254d0f5">const_iterator</a> &amp;pos)</td></tr>
<tr class="memdesc:a3b9ddf06a1a0cd4ec68c99a407191cd3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes specified elements from the container. <a href="#a3b9ddf06a1a0cd4ec68c99a407191cd3">More...</a><br/></td></tr>
<tr class="separator:a3b9ddf06a1a0cd4ec68c99a407191cd3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0efad48cfa01cbcd646b5171ef50fd3b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpvr_1_1_contiguous_map.html#a3e1ca91ba8f27fe1b464bde581c7029b">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1_contiguous_map.html#a0efad48cfa01cbcd646b5171ef50fd3b">find</a> (const <a class="el" href="classpvr_1_1_contiguous_map.html#a50962670e777af136321114a9505f9bb">KeyType</a> &amp;key)</td></tr>
<tr class="memdesc:a0efad48cfa01cbcd646b5171ef50fd3b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find an element <a href="#a0efad48cfa01cbcd646b5171ef50fd3b">More...</a><br/></td></tr>
<tr class="separator:a0efad48cfa01cbcd646b5171ef50fd3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5405844446a49b12e1cd606745a53dc6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpvr_1_1_contiguous_map.html#ab48c278981530460f56e7cf5d254d0f5">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1_contiguous_map.html#a5405844446a49b12e1cd606745a53dc6">find</a> (const <a class="el" href="classpvr_1_1_contiguous_map.html#a50962670e777af136321114a9505f9bb">KeyType</a> &amp;key) const </td></tr>
<tr class="memdesc:a5405844446a49b12e1cd606745a53dc6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find an element (const). <a href="#a5405844446a49b12e1cd606745a53dc6">More...</a><br/></td></tr>
<tr class="separator:a5405844446a49b12e1cd606745a53dc6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5b76b606ad1985303dbce0f430e95aa"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpvr_1_1_contiguous_map.html">ContiguousMap</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1_contiguous_map.html#aa5b76b606ad1985303dbce0f430e95aa">operator=</a> (const std::map&lt; Key_, Value_ &gt; &amp;initialmap)</td></tr>
<tr class="memdesc:aa5b76b606ad1985303dbce0f430e95aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy assignment operator from std::map <a href="#aa5b76b606ad1985303dbce0f430e95aa">More...</a><br/></td></tr>
<tr class="separator:aa5b76b606ad1985303dbce0f430e95aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad847212ca2c442653d20928ec6e2aec5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpvr_1_1_contiguous_map.html#aad98010369424a965aa331f97f6bc67b">ValueType</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1_contiguous_map.html#ad847212ca2c442653d20928ec6e2aec5">operator[]</a> (const <a class="el" href="classpvr_1_1_contiguous_map.html#a50962670e777af136321114a9505f9bb">KeyType</a> &amp;key)</td></tr>
<tr class="memdesc:ad847212ca2c442653d20928ec6e2aec5"><td class="mdescLeft">&#160;</td><td class="mdescRight">operator []. Reference to the mapped value of the new element if no element with key existed. Otherwise a reference to the mapped value of the existing element whose key is equivalent to key. <a href="#ad847212ca2c442653d20928ec6e2aec5">More...</a><br/></td></tr>
<tr class="separator:ad847212ca2c442653d20928ec6e2aec5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f2dad5a6e215616b23ed7c594de8902"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpvr_1_1_contiguous_map.html#aba6eb7e767be3fcc3deb785a7af11897">reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1_contiguous_map.html#a1f2dad5a6e215616b23ed7c594de8902">rbegin</a> ()</td></tr>
<tr class="memdesc:a1f2dad5a6e215616b23ed7c594de8902"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reverse iterator to the beginning <a href="#a1f2dad5a6e215616b23ed7c594de8902">More...</a><br/></td></tr>
<tr class="separator:a1f2dad5a6e215616b23ed7c594de8902"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a836a3a280cc18aee0acec3ebb66f9ff1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpvr_1_1_contiguous_map.html#a9a21214d3ca79e5f6ead1bc8253d9339">const_reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1_contiguous_map.html#a836a3a280cc18aee0acec3ebb66f9ff1">rbegin</a> () const </td></tr>
<tr class="memdesc:a836a3a280cc18aee0acec3ebb66f9ff1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reverse iterator to the beginning (const) <a href="#a836a3a280cc18aee0acec3ebb66f9ff1">More...</a><br/></td></tr>
<tr class="separator:a836a3a280cc18aee0acec3ebb66f9ff1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0311ba3b77b269cce4d51ce04d6c68b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpvr_1_1_contiguous_map.html#aba6eb7e767be3fcc3deb785a7af11897">reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1_contiguous_map.html#aa0311ba3b77b269cce4d51ce04d6c68b">rend</a> ()</td></tr>
<tr class="memdesc:aa0311ba3b77b269cce4d51ce04d6c68b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reverse iterator to the end <a href="#aa0311ba3b77b269cce4d51ce04d6c68b">More...</a><br/></td></tr>
<tr class="separator:aa0311ba3b77b269cce4d51ce04d6c68b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81bc2cf8b769f0d9c875dc5e7cedc8d7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpvr_1_1_contiguous_map.html#a9a21214d3ca79e5f6ead1bc8253d9339">const_reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1_contiguous_map.html#a81bc2cf8b769f0d9c875dc5e7cedc8d7">rend</a> () const </td></tr>
<tr class="memdesc:a81bc2cf8b769f0d9c875dc5e7cedc8d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a const reverse iterator to the end <a href="#a81bc2cf8b769f0d9c875dc5e7cedc8d7">More...</a><br/></td></tr>
<tr class="separator:a81bc2cf8b769f0d9c875dc5e7cedc8d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1106e31cfa4f3cfb221f8fa85eaa0c0b"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1_contiguous_map.html#a1106e31cfa4f3cfb221f8fa85eaa0c0b">size</a> () const </td></tr>
<tr class="memdesc:a1106e31cfa4f3cfb221f8fa85eaa0c0b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return number of entries in the container <a href="#a1106e31cfa4f3cfb221f8fa85eaa0c0b">More...</a><br/></td></tr>
<tr class="separator:a1106e31cfa4f3cfb221f8fa85eaa0c0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename Key_, typename Value_, typename Comparator = std::less&lt;Key_&gt;&gt;<br/>
class pvr::ContiguousMap&lt; Key_, Value_, Comparator &gt;</h3>

<p>A map that uses a std::vector as an underlying sparse storage and uses binary search for logarithmic time key lookup or indexing for constant time lookup. a) it can be indexed either by index in constant time, or by key in logarithmic time. b) Guaranteed to have contiguous storage c) If items are removed, iterators are invalidated.</p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="ad81d50b6fbf97c44712ff10bdf8abead"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key_ , typename Value_ , typename Comparator  = std::less&lt;Key_&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename new_iterator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpvr_1_1_contiguous_map.html">ContiguousMap</a>&amp; <a class="el" href="classpvr_1_1_contiguous_map.html">pvr::ContiguousMap</a>&lt; Key_, Value_, Comparator &gt;::assign </td>
          <td>(</td>
          <td class="paramtype">new_iterator&#160;</td>
          <td class="paramname"><em>beginIt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">new_iterator&#160;</td>
          <td class="paramname"><em>endIt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Assign elements in this container</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">beginIt</td><td>Begin iterator</td></tr>
    <tr><td class="paramname">endIt</td><td>End iterator</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This object</dd></dl>

</div>
</div>
<a class="anchor" id="ab877ef05a89005c455d498ba8771f40e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key_ , typename Value_ , typename Comparator  = std::less&lt;Key_&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpvr_1_1_contiguous_map.html#a3e1ca91ba8f27fe1b464bde581c7029b">iterator</a> <a class="el" href="classpvr_1_1_contiguous_map.html">pvr::ContiguousMap</a>&lt; Key_, Value_, Comparator &gt;::begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return an iterator to tbe begining of the container</p>
<dl class="section return"><dt>Returns</dt><dd>An iterator to the beginning of the backing store</dd></dl>

</div>
</div>
<a class="anchor" id="a23dfaa4b47daa04627a1967cf30f1d44"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key_ , typename Value_ , typename Comparator  = std::less&lt;Key_&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpvr_1_1_contiguous_map.html#ab48c278981530460f56e7cf5d254d0f5">const_iterator</a> <a class="el" href="classpvr_1_1_contiguous_map.html">pvr::ContiguousMap</a>&lt; Key_, Value_, Comparator &gt;::begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a iterator to tbe begining of the container (const).</p>
<dl class="section return"><dt>Returns</dt><dd>A const iterator to the beginning of the backing store</dd></dl>

</div>
</div>
<a class="anchor" id="ab31d72e5e5756da73b885d83029a9da3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key_ , typename Value_ , typename Comparator  = std::less&lt;Key_&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classpvr_1_1_contiguous_map.html">pvr::ContiguousMap</a>&lt; Key_, Value_, Comparator &gt;::clear </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Clear all entries in the container</p>

</div>
</div>
<a class="anchor" id="af286a815ba827610a3c3a859e92971d3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key_ , typename Value_ , typename Comparator  = std::less&lt;Key_&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpvr_1_1_contiguous_map.html#a3e1ca91ba8f27fe1b464bde581c7029b">iterator</a> <a class="el" href="classpvr_1_1_contiguous_map.html">pvr::ContiguousMap</a>&lt; Key_, Value_, Comparator &gt;::end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a iterator to the end of the container.</p>
<dl class="section return"><dt>Returns</dt><dd>An iterator to the end of the backing store</dd></dl>

</div>
</div>
<a class="anchor" id="a7a6b52dd62586fcf4212379f10392bad"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key_ , typename Value_ , typename Comparator  = std::less&lt;Key_&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpvr_1_1_contiguous_map.html#ab48c278981530460f56e7cf5d254d0f5">const_iterator</a> <a class="el" href="classpvr_1_1_contiguous_map.html">pvr::ContiguousMap</a>&lt; Key_, Value_, Comparator &gt;::end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a const iterator to the end of the container.</p>
<dl class="section return"><dt>Returns</dt><dd>A const iterator to the end of the backing store</dd></dl>

</div>
</div>
<a class="anchor" id="a53ce5999957bc5bb5e7ca69718fcc08b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key_ , typename Value_ , typename Comparator  = std::less&lt;Key_&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classpvr_1_1_contiguous_map.html">pvr::ContiguousMap</a>&lt; Key_, Value_, Comparator &gt;::erase </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpvr_1_1_contiguous_map.html#a50962670e777af136321114a9505f9bb">KeyType</a> &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes specified elements from the container.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>key value of the elements to remove</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aa285f1fd78f1ccb4bd89568c6b602a15"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key_ , typename Value_ , typename Comparator  = std::less&lt;Key_&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpvr_1_1_contiguous_map.html#a3e1ca91ba8f27fe1b464bde581c7029b">iterator</a> <a class="el" href="classpvr_1_1_contiguous_map.html">pvr::ContiguousMap</a>&lt; Key_, Value_, Comparator &gt;::erase </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpvr_1_1_contiguous_map.html#a3e1ca91ba8f27fe1b464bde581c7029b">iterator</a> &amp;&#160;</td>
          <td class="paramname"><em>pos</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes specified elements from the container.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pos</td><td>Removes the element at pos</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Return iterator following the last removed element</dd></dl>

</div>
</div>
<a class="anchor" id="a3b9ddf06a1a0cd4ec68c99a407191cd3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key_ , typename Value_ , typename Comparator  = std::less&lt;Key_&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpvr_1_1_contiguous_map.html#a3e1ca91ba8f27fe1b464bde581c7029b">iterator</a> <a class="el" href="classpvr_1_1_contiguous_map.html">pvr::ContiguousMap</a>&lt; Key_, Value_, Comparator &gt;::erase </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpvr_1_1_contiguous_map.html#ab48c278981530460f56e7cf5d254d0f5">const_iterator</a> &amp;&#160;</td>
          <td class="paramname"><em>pos</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes specified elements from the container.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pos</td><td>Removes the element at pos</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Return iterator following the last removed element</dd></dl>

</div>
</div>
<a class="anchor" id="a0efad48cfa01cbcd646b5171ef50fd3b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key_ , typename Value_ , typename Comparator  = std::less&lt;Key_&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpvr_1_1_contiguous_map.html#a3e1ca91ba8f27fe1b464bde581c7029b">iterator</a> <a class="el" href="classpvr_1_1_contiguous_map.html">pvr::ContiguousMap</a>&lt; Key_, Value_, Comparator &gt;::find </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpvr_1_1_contiguous_map.html#a50962670e777af136321114a9505f9bb">KeyType</a> &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find an element</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>Element's key to find</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Return iterator to the element if found, else return iterator to the end of the container.</dd></dl>

</div>
</div>
<a class="anchor" id="a5405844446a49b12e1cd606745a53dc6"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key_ , typename Value_ , typename Comparator  = std::less&lt;Key_&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpvr_1_1_contiguous_map.html#ab48c278981530460f56e7cf5d254d0f5">const_iterator</a> <a class="el" href="classpvr_1_1_contiguous_map.html">pvr::ContiguousMap</a>&lt; Key_, Value_, Comparator &gt;::find </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpvr_1_1_contiguous_map.html#a50962670e777af136321114a9505f9bb">KeyType</a> &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find an element (const).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>Element's key to find</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Return iterator to the element if found, else return iterator to the end of the container.</dd></dl>

</div>
</div>
<a class="anchor" id="aa5b76b606ad1985303dbce0f430e95aa"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key_ , typename Value_ , typename Comparator  = std::less&lt;Key_&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpvr_1_1_contiguous_map.html">ContiguousMap</a>&amp; <a class="el" href="classpvr_1_1_contiguous_map.html">pvr::ContiguousMap</a>&lt; Key_, Value_, Comparator &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const std::map&lt; Key_, Value_ &gt; &amp;&#160;</td>
          <td class="paramname"><em>initialmap</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy assignment operator from std::map</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">initialmap</td><td>std::map whose items will be used to initialize this map</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This object</dd></dl>

</div>
</div>
<a class="anchor" id="ad847212ca2c442653d20928ec6e2aec5"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key_ , typename Value_ , typename Comparator  = std::less&lt;Key_&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpvr_1_1_contiguous_map.html#aad98010369424a965aa331f97f6bc67b">ValueType</a>&amp; <a class="el" href="classpvr_1_1_contiguous_map.html">pvr::ContiguousMap</a>&lt; Key_, Value_, Comparator &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpvr_1_1_contiguous_map.html#a50962670e777af136321114a9505f9bb">KeyType</a> &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>operator []. Reference to the mapped value of the new element if no element with key existed. Otherwise a reference to the mapped value of the existing element whose key is equivalent to key.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>The key the value that corresponds to which will be retrieved</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The value that is stored associated to <em>key</em> </dd></dl>

</div>
</div>
<a class="anchor" id="a1f2dad5a6e215616b23ed7c594de8902"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key_ , typename Value_ , typename Comparator  = std::less&lt;Key_&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpvr_1_1_contiguous_map.html#aba6eb7e767be3fcc3deb785a7af11897">reverse_iterator</a> <a class="el" href="classpvr_1_1_contiguous_map.html">pvr::ContiguousMap</a>&lt; Key_, Value_, Comparator &gt;::rbegin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a reverse iterator to the beginning</p>
<dl class="section return"><dt>Returns</dt><dd>A reverse iterator to the beginning of the backing store</dd></dl>

</div>
</div>
<a class="anchor" id="a836a3a280cc18aee0acec3ebb66f9ff1"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key_ , typename Value_ , typename Comparator  = std::less&lt;Key_&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpvr_1_1_contiguous_map.html#a9a21214d3ca79e5f6ead1bc8253d9339">const_reverse_iterator</a> <a class="el" href="classpvr_1_1_contiguous_map.html">pvr::ContiguousMap</a>&lt; Key_, Value_, Comparator &gt;::rbegin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a reverse iterator to the beginning (const)</p>
<dl class="section return"><dt>Returns</dt><dd>A const reverse iterator to the beginning of the backing store</dd></dl>

</div>
</div>
<a class="anchor" id="aa0311ba3b77b269cce4d51ce04d6c68b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key_ , typename Value_ , typename Comparator  = std::less&lt;Key_&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpvr_1_1_contiguous_map.html#aba6eb7e767be3fcc3deb785a7af11897">reverse_iterator</a> <a class="el" href="classpvr_1_1_contiguous_map.html">pvr::ContiguousMap</a>&lt; Key_, Value_, Comparator &gt;::rend </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a reverse iterator to the end</p>
<dl class="section return"><dt>Returns</dt><dd>A reverse iterator to the end of the backing store</dd></dl>

</div>
</div>
<a class="anchor" id="a81bc2cf8b769f0d9c875dc5e7cedc8d7"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key_ , typename Value_ , typename Comparator  = std::less&lt;Key_&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpvr_1_1_contiguous_map.html#a9a21214d3ca79e5f6ead1bc8253d9339">const_reverse_iterator</a> <a class="el" href="classpvr_1_1_contiguous_map.html">pvr::ContiguousMap</a>&lt; Key_, Value_, Comparator &gt;::rend </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a const reverse iterator to the end</p>
<dl class="section return"><dt>Returns</dt><dd>A const reverse iterator to the end of the backing store</dd></dl>

</div>
</div>
<a class="anchor" id="a1106e31cfa4f3cfb221f8fa85eaa0c0b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key_ , typename Value_ , typename Comparator  = std::less&lt;Key_&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classpvr_1_1_contiguous_map.html">pvr::ContiguousMap</a>&lt; Key_, Value_, Comparator &gt;::size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return number of entries in the container</p>
<dl class="section return"><dt>Returns</dt><dd>Number of elements</dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>/usr/buildxl/buildroot/sdk/branch/Framework/PVRCore/DataStructures/<a class="el" href="_contiguous_map_8h_source.html">ContiguousMap.h</a></li>
</ul>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.4-->
<!-- start footer part (NON TREEVIEW ONLY!!) -->
<!--BEGIN GENERATE_TREEVIEW-->
<div id="FooterMainContainer">
	<div id="FooterContainer">
		<div class="footerlogo">
			<a href="http://www.imgtec.com" target="_blank"><img src="img-footer-logo-grey.png" width="100%" height="100%" border="none" /></a>
		</div>
		<div class="copyright"><p>&copy; Imagination Technologies Limited<br> All rights reserved</p></div>
	</div>
</div>
</body>
</html>
