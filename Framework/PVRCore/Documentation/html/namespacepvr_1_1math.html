<!-- HTML header for doxygen 1.8.4-->
<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="generator" content="Doxygen 1.8.6"/>
<title>PVRCore: pvr::math Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="IMGdoxygen.css" rel="stylesheet" type="text/css"/>
<link rel="shortcut icon" href="http://www.imgtec.com/images/img.ico">
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
  <div class="headercontent">
    <div class="PVRlogo">
      <a href="http://www.powervrinsider.com" target="_blank"><img src="PVRlogo.png" width="40%" height="40%"  border="none" /></a>
    </div>
    <a class="SiteTitle"><span id="projectname">PVRCore</span> Documentation</a>
   <tbody>
  </div>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="inherits.html"><span>Class&#160;Hierarchy</span></a></li>
      <li class="current"><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Macros</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacepvr.html">pvr</a></li><li class="navelem"><a class="el" href="namespacepvr_1_1math.html">math</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">pvr::math Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Contains mathematical functionality and classes, such as bounding box calculations, intersections etc.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1math_1_1_axis_aligned_box.html">AxisAlignedBox</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class provides functionality to handle 3 dimensional Axis Aligned Boxes. Center-halfextent representation. <a href="classpvr_1_1math_1_1_axis_aligned_box.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1math_1_1_axis_aligned_box_min_max.html">AxisAlignedBoxMinMax</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An AABB with a min-max representation. <a href="classpvr_1_1math_1_1_axis_aligned_box_min_max.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1math_1_1_bounding_sphere.html">BoundingSphere</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A class representing a sphere containing at least all points of an object <a href="classpvr_1_1math_1_1_bounding_sphere.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpvr_1_1math_1_1_frustum.html">Frustum</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class provides functionality to handle the volume enclosed by 6 planes, normally the viewing frustum. The planes are represented in Hessian Normal Form (normal, distance) as vec4( (xyz):[normal], w:[distance from 0,0,0] ) <a href="structpvr_1_1math_1_1_frustum.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpvr_1_1math_1_1_viewing_frustum.html">ViewingFrustum</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class provides specialized functionality for when a frustum is a "normal"viewing frustum, that is, the following conditions hold (The conditions ARE NOT checked) Note: A "frustum side" of a plane means "the
quadrilateral of the plane that is enclosed by the 4 other planes not opposite to it" "Opposite" means the "other" side of the frustum (minusX is opposit plusX). 1) Opposite <a class="el" href="structpvr_1_1math_1_1_frustum.html" title="This class provides functionality to handle the volume enclosed by 6 planes, normally the viewing fru...">Frustum</a> sides do not intersect (their planes may do so outside the frustum) 2) The frustum is "opening", or at least not "closing" accross the z axis accross all directions, meaning that the any point of the projection of the negative Z side of the frustum on the positive Z plane, is inside or on the positive Z side of the frustum. 3) Any point of a positive(negative) part of the frustum has a larger(smaller) corresponding coordinate than its opposite part 4) All plane normals point INTO of the frustum These optimizations allow us to greatly reduce the calculations for a viewing frustum.  <a href="structpvr_1_1math_1_1_viewing_frustum.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a45d744e73481d0d55e1ef85e352b9c80"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1math.html#a45d744e73481d0d55e1ef85e352b9c80">aabbInFrustum</a> (const <a class="el" href="classpvr_1_1math_1_1_axis_aligned_box.html">AxisAlignedBox</a> &amp;box, const <a class="el" href="structpvr_1_1math_1_1_viewing_frustum.html">ViewingFrustum</a> &amp;frustum)</td></tr>
<tr class="memdesc:a45d744e73481d0d55e1ef85e352b9c80"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test if an AABB intersects or is inside a frustum. <a href="#a45d744e73481d0d55e1ef85e352b9c80">More...</a><br/></td></tr>
<tr class="separator:a45d744e73481d0d55e1ef85e352b9c80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a604fa4c3a5bcbcdd7ea87858b235e780"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1math.html#a604fa4c3a5bcbcdd7ea87858b235e780">distancePointToPlane</a> (const glm::vec3 &amp;point, const glm::vec4 &amp;plane)</td></tr>
<tr class="memdesc:a604fa4c3a5bcbcdd7ea87858b235e780"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate the signed (in regards to the plane's normal) distance from a point to a plane <a href="#a604fa4c3a5bcbcdd7ea87858b235e780">More...</a><br/></td></tr>
<tr class="separator:a604fa4c3a5bcbcdd7ea87858b235e780"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2d743f7b77ed1970b8cce4720329c1d"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:af2d743f7b77ed1970b8cce4720329c1d"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1math.html#af2d743f7b77ed1970b8cce4720329c1d">gcd</a> (T lhs, T rhs)</td></tr>
<tr class="memdesc:af2d743f7b77ed1970b8cce4720329c1d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate the Greatest Common Divisor of two numbers (the larger number that, if used to divide either value, has a remainder of zero. Order is irrelevant <a href="#af2d743f7b77ed1970b8cce4720329c1d">More...</a><br/></td></tr>
<tr class="separator:af2d743f7b77ed1970b8cce4720329c1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a966396be32d46b25b372882885738b80"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1math.html#a966396be32d46b25b372882885738b80">getFrustumPlanes</a> (const glm::mat4 &amp;projection_from_world, <a class="el" href="structpvr_1_1math_1_1_viewing_frustum.html">ViewingFrustum</a> &amp;frustum_out)</td></tr>
<tr class="memdesc:a966396be32d46b25b372882885738b80"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve the viewing frustum from a projection matrix <a href="#a966396be32d46b25b372882885738b80">More...</a><br/></td></tr>
<tr class="separator:a966396be32d46b25b372882885738b80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9529225771db0ee761416d8932797b78"><td class="memTemplParams" colspan="2">template&lt;typename Vec2 &gt; </td></tr>
<tr class="memitem:a9529225771db0ee761416d8932797b78"><td class="memTemplItemLeft" align="right" valign="top">Vec2&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1math.html#a9529225771db0ee761416d8932797b78">getPerpendicular</a> (Vec2 const &amp;aVector)</td></tr>
<tr class="memdesc:a9529225771db0ee761416d8932797b78"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a vector that is perpendicular to another vector <a href="#a9529225771db0ee761416d8932797b78">More...</a><br/></td></tr>
<tr class="separator:a9529225771db0ee761416d8932797b78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d618e96c7e3333051f2fd4496122a40"><td class="memTemplParams" colspan="2">template&lt;typename genType &gt; </td></tr>
<tr class="memitem:a9d618e96c7e3333051f2fd4496122a40"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1math.html#a9d618e96c7e3333051f2fd4496122a40">intersectLinePlane</a> (genType const &amp;origin, genType const &amp;dir, genType const &amp;planeOrigin, genType const &amp;planeNormal, typename genType::value_type &amp;intersectionDistance, typename genType::value_type epsilon=std::numeric_limits&lt; typename genType::value_type &gt;::epsilon())</td></tr>
<tr class="memdesc:a9d618e96c7e3333051f2fd4496122a40"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs line -to - plane intersection  <a href="#a9d618e96c7e3333051f2fd4496122a40">More...</a><br/></td></tr>
<tr class="separator:a9d618e96c7e3333051f2fd4496122a40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:accd0426359027cb0b7266a8ae9fcc077"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:accd0426359027cb0b7266a8ae9fcc077"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1math.html#accd0426359027cb0b7266a8ae9fcc077">lcm</a> (T lhs, T rhs)</td></tr>
<tr class="memdesc:accd0426359027cb0b7266a8ae9fcc077"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate the Least Common Multiple of two numbers (the smaller integer that is a factor of both numbers). Order is irrelevant. If either of the numbers is 0, will return 0 <a href="#accd0426359027cb0b7266a8ae9fcc077">More...</a><br/></td></tr>
<tr class="separator:accd0426359027cb0b7266a8ae9fcc077"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af05f0c9d9f306695f2efc3483c6ed4b3"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:af05f0c9d9f306695f2efc3483c6ed4b3"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1math.html#af05f0c9d9f306695f2efc3483c6ed4b3">lcm_with_max</a> (T lhs, T rhs)</td></tr>
<tr class="memdesc:af05f0c9d9f306695f2efc3483c6ed4b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate the Least Common Multiple of two numbers (the smaller integer that is a multiple of both numbers), but discards 0: If either number is 0, will return the other number <a href="#af05f0c9d9f306695f2efc3483c6ed4b3">More...</a><br/></td></tr>
<tr class="separator:af05f0c9d9f306695f2efc3483c6ed4b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa79fff0c4934d5ab39edb53695ee3d4"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1math.html#afa79fff0c4934d5ab39edb53695ee3d4">makePowerOfTwoHigh</a> (int32_t iVal)</td></tr>
<tr class="memdesc:afa79fff0c4934d5ab39edb53695ee3d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the smallest power of two that is greater than or equal to the provided value. <a href="#afa79fff0c4934d5ab39edb53695ee3d4">More...</a><br/></td></tr>
<tr class="separator:afa79fff0c4934d5ab39edb53695ee3d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb17baa9649bd59237e2e04eb588c5fb"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1math.html#aeb17baa9649bd59237e2e04eb588c5fb">makePowerOfTwoLow</a> (int32_t iVal)</td></tr>
<tr class="memdesc:aeb17baa9649bd59237e2e04eb588c5fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the smallest power of two that is less than or equal to the provided value. <a href="#aeb17baa9649bd59237e2e04eb588c5fb">More...</a><br/></td></tr>
<tr class="separator:aeb17baa9649bd59237e2e04eb588c5fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00842f73cec1ae62bae0d93c79f5ffbb"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1math.html#a00842f73cec1ae62bae0d93c79f5ffbb">ndcToPixel</a> (float ndc, int32_t screenSize)</td></tr>
<tr class="memdesc:a00842f73cec1ae62bae0d93c79f5ffbb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a normalized device coordinate (-1..1) to a number of pixels from the start (left or top)  <a href="#a00842f73cec1ae62bae0d93c79f5ffbb">More...</a><br/></td></tr>
<tr class="separator:a00842f73cec1ae62bae0d93c79f5ffbb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8e885c1902f9999cb0cfc7a92fd5182"><td class="memItemLeft" align="right" valign="top">glm::mat4&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1math.html#aa8e885c1902f9999cb0cfc7a92fd5182">ortho</a> (<a class="el" href="namespacepvr.html#a74c5d1afa51512f076dd8e5844b171c8">Api</a> api, float left, float right, float bottom, float top, float rotate=0.0f)</td></tr>
<tr class="memdesc:aa8e885c1902f9999cb0cfc7a92fd5182"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculated an orthographic projection tilted projection matrix <a href="#aa8e885c1902f9999cb0cfc7a92fd5182">More...</a><br/></td></tr>
<tr class="separator:aa8e885c1902f9999cb0cfc7a92fd5182"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab837bdd2199db44ea31c5b11d5d30069"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1math.html#ab837bdd2199db44ea31c5b11d5d30069">packRGBA</a> (uint8_t r, uint8_t g, uint8_t b, uint8_t a)</td></tr>
<tr class="memdesc:ab837bdd2199db44ea31c5b11d5d30069"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pack 4 values (red, green, blue, alpha) in the range of 0-255 into a single 32 bit unsigned Integer unsigned. <a href="#ab837bdd2199db44ea31c5b11d5d30069">More...</a><br/></td></tr>
<tr class="separator:ab837bdd2199db44ea31c5b11d5d30069"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5e9c533a69b130284e95500cb66c263"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1math.html#ae5e9c533a69b130284e95500cb66c263">packRGBA</a> (float r, float g, float b, float a)</td></tr>
<tr class="memdesc:ae5e9c533a69b130284e95500cb66c263"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pack 4 values (red, green, blue, alpha) in the range of 0.0-1.0 into a single 32 bit unsigned Integer unsigned. <a href="#ae5e9c533a69b130284e95500cb66c263">More...</a><br/></td></tr>
<tr class="separator:ae5e9c533a69b130284e95500cb66c263"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6ebf3ef98b324b9d155b841d26e47ce"><td class="memItemLeft" align="right" valign="top">glm::mat4&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1math.html#ac6ebf3ef98b324b9d155b841d26e47ce">perspective</a> (<a class="el" href="namespacepvr.html#a74c5d1afa51512f076dd8e5844b171c8">Api</a> api, float fovy, float aspect, float near1, float far1, float rotate=.0f)</td></tr>
<tr class="memdesc:ac6ebf3ef98b324b9d155b841d26e47ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculated a tilted perspective projection matrix <a href="#ac6ebf3ef98b324b9d155b841d26e47ce">More...</a><br/></td></tr>
<tr class="separator:ac6ebf3ef98b324b9d155b841d26e47ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b5c4ba641c13ab4011b91b6cb120354"><td class="memItemLeft" align="right" valign="top">glm::mat4&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1math.html#a8b5c4ba641c13ab4011b91b6cb120354">perspectiveFov</a> (<a class="el" href="namespacepvr.html#a74c5d1afa51512f076dd8e5844b171c8">Api</a> api, float fovy, float width, float height, float near1, float far1, float rotate=.0f)</td></tr>
<tr class="memdesc:a8b5c4ba641c13ab4011b91b6cb120354"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculated a tilted perspective projection matrix <a href="#a8b5c4ba641c13ab4011b91b6cb120354">More...</a><br/></td></tr>
<tr class="separator:a8b5c4ba641c13ab4011b91b6cb120354"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07094ae0eacdff77a4974feb63e69896"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1math.html#a07094ae0eacdff77a4974feb63e69896">pixelToNdc</a> (int32_t pixelCoord, int32_t screenSize)</td></tr>
<tr class="memdesc:a07094ae0eacdff77a4974feb63e69896"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a number of pixels (left or top) to a normalized device coordinate (-1..1) <a href="#a07094ae0eacdff77a4974feb63e69896">More...</a><br/></td></tr>
<tr class="separator:a07094ae0eacdff77a4974feb63e69896"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76ff8b92d0032831704d3502ea7b6abd"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1math.html#a76ff8b92d0032831704d3502ea7b6abd">pointOnSide</a> (const glm::vec3 &amp;point, const glm::vec4 &amp;plane)</td></tr>
<tr class="memdesc:a76ff8b92d0032831704d3502ea7b6abd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate if the point is in the positive half-space defined by the plane (i.e. if it is lying on the same side as the normal points <a href="#a76ff8b92d0032831704d3502ea7b6abd">More...</a><br/></td></tr>
<tr class="separator:a76ff8b92d0032831704d3502ea7b6abd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a338b3dc2160224b23419ae90c52e9d6e"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1math.html#a338b3dc2160224b23419ae90c52e9d6e">quadraticEaseIn</a> (float start, float end, float factor)</td></tr>
<tr class="memdesc:a338b3dc2160224b23419ae90c52e9d6e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs quadratic interpolation between two points, beginning with a slow rate and speeding up.  <a href="#a338b3dc2160224b23419ae90c52e9d6e">More...</a><br/></td></tr>
<tr class="separator:a338b3dc2160224b23419ae90c52e9d6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a516d467fe7ff127e72f7fcfd7c68a22b"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1math.html#a516d467fe7ff127e72f7fcfd7c68a22b">quadraticEaseOut</a> (float start, float end, float factor)</td></tr>
<tr class="memdesc:a516d467fe7ff127e72f7fcfd7c68a22b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs quadratic interpolation between two points, beginning with a faster rate and slowing down.  <a href="#a516d467fe7ff127e72f7fcfd7c68a22b">More...</a><br/></td></tr>
<tr class="separator:a516d467fe7ff127e72f7fcfd7c68a22b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Contains mathematical functionality and classes, such as bounding box calculations, intersections etc. </p>
</div><h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="a45d744e73481d0d55e1ef85e352b9c80"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool pvr::math::aabbInFrustum </td>
          <td>(</td>
          <td class="paramtype">const AxisAlignedBox &amp;&#160;</td>
          <td class="paramname"><em>box</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ViewingFrustum &amp;&#160;</td>
          <td class="paramname"><em>frustum</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Test if an AABB intersects or is inside a frustum.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">box</td><td>A box</td></tr>
    <tr><td class="paramname">frustum</td><td>A frustum</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>False if the AABB is completely outside the frustum, otherwise true</dd></dl>

</div>
</div>
<a class="anchor" id="a604fa4c3a5bcbcdd7ea87858b235e780"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float pvr::math::distancePointToPlane </td>
          <td>(</td>
          <td class="paramtype">const glm::vec3 &amp;&#160;</td>
          <td class="paramname"><em>point</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const glm::vec4 &amp;&#160;</td>
          <td class="paramname"><em>plane</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculate the signed (in regards to the plane's normal) distance from a point to a plane</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">point</td><td>The point</td></tr>
    <tr><td class="paramname">plane</td><td>The plane, defined as a vector4, where (xyz: Normal, w: Distance from the origin)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The distance from the point to the plane (along the normal). Positive if on the side of the normal, otherwise false</dd></dl>

</div>
</div>
<a class="anchor" id="af2d743f7b77ed1970b8cce4720329c1d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T pvr::math::gcd </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculate the Greatest Common Divisor of two numbers (the larger number that, if used to divide either value, has a remainder of zero. Order is irrelevant</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The type of the values. Must have equality, assignment and modulo defined</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>One of the input values</td></tr>
    <tr><td class="paramname">rhs</td><td>The other input values</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The GCD. If the numbers are "coprime" (have no common divisor exept 1), the GCD is 1. </dd></dl>

</div>
</div>
<a class="anchor" id="a966396be32d46b25b372882885738b80"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pvr::math::getFrustumPlanes </td>
          <td>(</td>
          <td class="paramtype">const glm::mat4 &amp;&#160;</td>
          <td class="paramname"><em>projection_from_world</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ViewingFrustum &amp;&#160;</td>
          <td class="paramname"><em>frustum_out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieve the viewing frustum from a projection matrix</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">projection_from_world</td><td>The projection matrix</td></tr>
    <tr><td class="paramname">frustum_out</td><td>The viewing frustum</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a9529225771db0ee761416d8932797b78"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Vec2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Vec2 pvr::math::getPerpendicular </td>
          <td>(</td>
          <td class="paramtype">Vec2 const &amp;&#160;</td>
          <td class="paramname"><em>aVector</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a vector that is perpendicular to another vector</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Vec2</td><td>A vector with two components that can be accessed through .x and .y</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">aVector</td><td>A vector</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A vector that is perpendicular to <em>aVector</em> </dd></dl>

</div>
</div>
<a class="anchor" id="a9d618e96c7e3333051f2fd4496122a40"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename genType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool pvr::math::intersectLinePlane </td>
          <td>(</td>
          <td class="paramtype">genType const &amp;&#160;</td>
          <td class="paramname"><em>origin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">genType const &amp;&#160;</td>
          <td class="paramname"><em>dir</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">genType const &amp;&#160;</td>
          <td class="paramname"><em>planeOrigin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">genType const &amp;&#160;</td>
          <td class="paramname"><em>planeNormal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename genType::value_type &amp;&#160;</td>
          <td class="paramname"><em>intersectionDistance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename genType::value_type&#160;</td>
          <td class="paramname"><em>epsilon</em> = <code>std::numeric_limits&lt;typename&#160;genType::value_type&gt;::epsilon()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs line -to - plane intersection </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">genType</td><td>A glm:: vector type. Otherwise, a type with the following operations defined: A typename member value_type (type of scalar), +/- (vector add/mul), / (divide by scalar), and a dot() function in either the global or glm:: namespace</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">origin</td><td>The start point of the line</td></tr>
    <tr><td class="paramname">dir</td><td>The (positive) direction of the line</td></tr>
    <tr><td class="paramname">planeOrigin</td><td>Any point on the plane</td></tr>
    <tr><td class="paramname">planeNormal</td><td>The normal of the plane</td></tr>
    <tr><td class="paramname">intersectionDistance</td><td>Output parameter: If an intersection happens, this parameter will contain the signed distance from <em>origin</em>  towards <em>dir</em>  of the intersection point.</td></tr>
    <tr><td class="paramname">epsilon</td><td>For any comparison calculations, any value smaller than that will be considered zero (otherwise, if two numbers difference is smaller than this, they are considered equal) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the line and plane intersect, otherwise false</dd></dl>

</div>
</div>
<a class="anchor" id="accd0426359027cb0b7266a8ae9fcc077"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T pvr::math::lcm </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculate the Least Common Multiple of two numbers (the smaller integer that is a factor of both numbers). Order is irrelevant. If either of the numbers is 0, will return 0</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The type of the values. Must have equality, assignment multiplication and either modulo or a gcd function defined</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>One of the input values</td></tr>
    <tr><td class="paramname">rhs</td><td>The other input values</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The LCM. If the inputs don't have any common factors (except 1), the LCM is equal to lhs * rhs. If either input is 0, returns 0.</dd></dl>

</div>
</div>
<a class="anchor" id="af05f0c9d9f306695f2efc3483c6ed4b3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T pvr::math::lcm_with_max </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculate the Least Common Multiple of two numbers (the smaller integer that is a multiple of both numbers), but discards 0: If either number is 0, will return the other number</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The type of the values. Must have equality, assignment multiplication and either modulo or a gcd function defined</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>One of the input values</td></tr>
    <tr><td class="paramname">rhs</td><td>The other input values</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The LCM. If the numbers don't have any common factors (except 1), the LCM is equal to lhs * rhs. If either input is 0, returns the other</dd></dl>

</div>
</div>
<a class="anchor" id="afa79fff0c4934d5ab39edb53695ee3d4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int32_t pvr::math::makePowerOfTwoHigh </td>
          <td>(</td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>iVal</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the smallest power of two that is greater than or equal to the provided value.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">iVal</td><td>An integer value.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The smallest PoT that is greater or equal to iVal</dd></dl>

</div>
</div>
<a class="anchor" id="aeb17baa9649bd59237e2e04eb588c5fb"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int32_t pvr::math::makePowerOfTwoLow </td>
          <td>(</td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>iVal</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the smallest power of two that is less than or equal to the provided value.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">iVal</td><td>An integer value.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The smallest PoT that is less or equal to iVal</dd></dl>

</div>
</div>
<a class="anchor" id="a00842f73cec1ae62bae0d93c79f5ffbb"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int32_t pvr::math::ndcToPixel </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>ndc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>screenSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert a normalized device coordinate (-1..1) to a number of pixels from the start (left or top) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ndc</td><td>The normalised coordinate along the direction in question (same direction as screenSize) </td></tr>
    <tr><td class="paramname">screenSize</td><td>The size of the screen along the direction in question (same as ndc)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pixel coordinates from normalized device coordinates</dd></dl>

</div>
</div>
<a class="anchor" id="aa8e885c1902f9999cb0cfc7a92fd5182"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">glm::mat4 pvr::math::ortho </td>
          <td>(</td>
          <td class="paramtype">Api&#160;</td>
          <td class="paramname"><em>api</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>left</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>right</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>bottom</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>top</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>rotate</em> = <code>0.0f</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculated an orthographic projection tilted projection matrix</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">left</td><td>The x coordinate of the left clipping plane</td></tr>
    <tr><td class="paramname">right</td><td>The x coordinate of the right clipping plane</td></tr>
    <tr><td class="paramname">bottom</td><td>The y coordinate of the bottom clipping plane</td></tr>
    <tr><td class="paramname">top</td><td>The y coordinate of the bottom clipping plane</td></tr>
    <tr><td class="paramname">rotate</td><td>Angle of tilt (rotation around the z axis), in radians</td></tr>
    <tr><td class="paramname">api</td><td>The graphics API for which this matrix will be created. It is used for things such as the Framebuffer coordinate conventions.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An orthographic projection matrix for the specified parameters, tilted by rotate</dd></dl>

</div>
</div>
<a class="anchor" id="ab837bdd2199db44ea31c5b11d5d30069"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t pvr::math::packRGBA </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>a</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Pack 4 values (red, green, blue, alpha) in the range of 0-255 into a single 32 bit unsigned Integer unsigned.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">r</td><td>Red channel (8 bit)</td></tr>
    <tr><td class="paramname">g</td><td>Blue channel (8 bit)</td></tr>
    <tr><td class="paramname">b</td><td>Red channel (8 bit)</td></tr>
    <tr><td class="paramname">a</td><td>Red channel (8 bit)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>32 bit RGBA value</dd></dl>

</div>
</div>
<a class="anchor" id="ae5e9c533a69b130284e95500cb66c263"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t pvr::math::packRGBA </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>a</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Pack 4 values (red, green, blue, alpha) in the range of 0.0-1.0 into a single 32 bit unsigned Integer unsigned.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">r</td><td>Red channel (normalized 0.0-1.0)</td></tr>
    <tr><td class="paramname">g</td><td>Blue channel (normalized 0.0-1.0)</td></tr>
    <tr><td class="paramname">b</td><td>Red channel (normalized 0.0-1.0)</td></tr>
    <tr><td class="paramname">a</td><td>Red channel (normalized 0.0-1.0)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>32 bit RGBA value</dd></dl>

</div>
</div>
<a class="anchor" id="ac6ebf3ef98b324b9d155b841d26e47ce"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">glm::mat4 pvr::math::perspective </td>
          <td>(</td>
          <td class="paramtype">Api&#160;</td>
          <td class="paramname"><em>api</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>fovy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>aspect</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>near1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>far1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>rotate</em> = <code>.0f</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculated a tilted perspective projection matrix</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">api</td><td>The graphics API for which this matrix will be created. It is used for the Framebuffer coordinate convention.</td></tr>
    <tr><td class="paramname">fovy</td><td>The field of vision in the y axis</td></tr>
    <tr><td class="paramname">aspect</td><td>The aspect of the viewport</td></tr>
    <tr><td class="paramname">near1</td><td>The near clipping plane distance (trailing 1 to avoid win32 keyword)</td></tr>
    <tr><td class="paramname">far1</td><td>The far clipping plane distance (trailing 1 to avoid win32 keyword)</td></tr>
    <tr><td class="paramname">rotate</td><td>Angle of tilt (rotation around the z axis), in radians</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A projection matrix for the specified parameters, tilted by rotate</dd></dl>

</div>
</div>
<a class="anchor" id="a8b5c4ba641c13ab4011b91b6cb120354"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">glm::mat4 pvr::math::perspectiveFov </td>
          <td>(</td>
          <td class="paramtype">Api&#160;</td>
          <td class="paramname"><em>api</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>fovy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>height</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>near1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>far1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>rotate</em> = <code>.0f</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculated a tilted perspective projection matrix</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fovy</td><td>The field of vision in the y axis</td></tr>
    <tr><td class="paramname">width</td><td>The width of the viewport</td></tr>
    <tr><td class="paramname">height</td><td>The height of the viewport</td></tr>
    <tr><td class="paramname">near1</td><td>The near clipping plane distance</td></tr>
    <tr><td class="paramname">far1</td><td>The far clipping plane distance</td></tr>
    <tr><td class="paramname">rotate</td><td>Angle of tilt (rotation around the z axis), in radians</td></tr>
    <tr><td class="paramname">api</td><td>The graphics API for which this matrix will be created. It is used for things such as the Framebuffer coordinate conventions.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A projection matrix for the specified parameters, tilted by rotate</dd></dl>

</div>
</div>
<a class="anchor" id="a07094ae0eacdff77a4974feb63e69896"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float pvr::math::pixelToNdc </td>
          <td>(</td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>pixelCoord</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>screenSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert a number of pixels (left or top) to a normalized device coordinate (-1..1)</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pixelCoord</td><td>The pixel coordinate (number of pixels) along the direction in question (same direction as screenSize)</td></tr>
    <tr><td class="paramname">screenSize</td><td>The size of the screen along the direction in question (same as pixelCoord)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Normalized device coordinates (number in the 0..1 range)</dd></dl>

</div>
</div>
<a class="anchor" id="a76ff8b92d0032831704d3502ea7b6abd"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool pvr::math::pointOnSide </td>
          <td>(</td>
          <td class="paramtype">const glm::vec3 &amp;&#160;</td>
          <td class="paramname"><em>point</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const glm::vec4 &amp;&#160;</td>
          <td class="paramname"><em>plane</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculate if the point is in the positive half-space defined by the plane (i.e. if it is lying on the same side as the normal points</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">point</td><td>The point</td></tr>
    <tr><td class="paramname">plane</td><td>The plane, defined as a vector4, where (xyz: Normal, w: Distance from the origin)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the point is on the plane or on the same side as the normal, otherwise false</dd></dl>

</div>
</div>
<a class="anchor" id="a338b3dc2160224b23419ae90c52e9d6e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float pvr::math::quadraticEaseIn </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>factor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs quadratic interpolation between two points, beginning with a slow rate and speeding up. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">start</td><td>The starting point.</td></tr>
    <tr><td class="paramname">end</td><td>The end point</td></tr>
    <tr><td class="paramname">factor</td><td>Interpolation factor. At 0, returns start. At 1, returns end. Closer to 0, the rate of change is slower, closer to 1 faster.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The modified value to use, quadratically interpolated between start and end with factor factor.</dd></dl>

</div>
</div>
<a class="anchor" id="a516d467fe7ff127e72f7fcfd7c68a22b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float pvr::math::quadraticEaseOut </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>factor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs quadratic interpolation between two points, beginning with a faster rate and slowing down. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">start</td><td>The starting point.</td></tr>
    <tr><td class="paramname">end</td><td>The end point</td></tr>
    <tr><td class="paramname">factor</td><td>Current LINEAR interpolation factor, from 0..1</td></tr>
  </table>
  </dd>
</dl>
<p>0 </p>
<dl class="section return"><dt>Returns</dt><dd>For <em>factor</em> =0, returns <em>start</em> . For <em>factor</em> =1, returns <em>end</em> . Closer to 0, the rate of change is faster, closer to 1 slower.</dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.4-->
<!-- start footer part (NON TREEVIEW ONLY!!) -->
<!--BEGIN GENERATE_TREEVIEW-->
<div id="FooterMainContainer">
	<div id="FooterContainer">
		<div class="footerlogo">
			<a href="http://www.imgtec.com" target="_blank"><img src="img-footer-logo-grey.png" width="100%" height="100%" border="none" /></a>
		</div>
		<div class="copyright"><p>&copy; Imagination Technologies Limited<br> All rights reserved</p></div>
	</div>
</div>
</body>
</html>
