<!-- HTML header for doxygen 1.8.4-->
<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="generator" content="Doxygen 1.8.6"/>
<title>PVRVk: pvrvk::impl::Device_ Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="IMGdoxygen.css" rel="stylesheet" type="text/css"/>
<link rel="shortcut icon" href="http://www.imgtec.com/images/img.ico">
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
  <div class="headercontent">
    <div class="PVRlogo">
      <a href="http://www.powervrinsider.com" target="_blank"><img src="PVRlogo.png" width="40%" height="40%"  border="none" /></a>
    </div>
    <a class="SiteTitle"><span id="projectname">PVRVk</span> Documentation</a>
   <tbody>
  </div>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="inherits.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Macros</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacepvrvk.html">pvrvk</a></li><li class="navelem"><a class="el" href="namespacepvrvk_1_1impl.html">impl</a></li><li class="navelem"><a class="el" href="classpvrvk_1_1impl_1_1_device__.html">Device_</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classpvrvk_1_1impl_1_1_device__-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">pvrvk::impl::Device_ Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>GpuDevice implementation that supports Vulkan 
 <a href="classpvrvk_1_1impl_1_1_device__.html#details">More...</a></p>
<div class="dynheader">
Inheritance diagram for pvrvk::impl::Device_:</div>
<div class="dyncontent">
<div class="center"><img src="classpvrvk_1_1impl_1_1_device____inherit__graph.png" border="0" usemap="#pvrvk_1_1impl_1_1_device___inherit__map" alt="Inheritance graph"/></div>
<map name="pvrvk_1_1impl_1_1_device___inherit__map" id="pvrvk_1_1impl_1_1_device___inherit__map">
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:aa28de641a316a51f13c8d184a77bc99c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacepvrvk.html#a634be07eff8c3efd7788c1429c8ff129">DeviceMemory</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvrvk_1_1impl_1_1_device__.html#aa28de641a316a51f13c8d184a77bc99c">allocateMemory</a> (VkDeviceSize size, uint32_t allowedMemoryBits, VkMemoryPropertyFlags memoryProps)</td></tr>
<tr class="memdesc:aa28de641a316a51f13c8d184a77bc99c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create device memory block <a href="#aa28de641a316a51f13c8d184a77bc99c">More...</a><br/></td></tr>
<tr class="separator:aa28de641a316a51f13c8d184a77bc99c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e6dbc060b4add1ee37b8d605dc19d60"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacepvrvk.html#a2a117db0aab25382d050908b2bfa4c8b">Buffer</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvrvk_1_1impl_1_1_device__.html#a9e6dbc060b4add1ee37b8d605dc19d60">createBuffer</a> (VkDeviceSize size, VkBufferUsageFlags bufferUsage, VkBufferCreateFlags bufferCreateFlags=VkBufferCreateFlags(0), bool sharingExclusive=true, const uint32_t *queueFamilyIndices=nullptr, uint32_t numQueueFamilyIndices=0)</td></tr>
<tr class="memdesc:a9e6dbc060b4add1ee37b8d605dc19d60"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new buffer object and (optionally) allocate and bind memory for it <a href="#a9e6dbc060b4add1ee37b8d605dc19d60">More...</a><br/></td></tr>
<tr class="separator:a9e6dbc060b4add1ee37b8d605dc19d60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6b5058cce14b9bf63a1b80118888274"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacepvrvk.html#ae83f7affc0468a1c19e7fef55758015e">BufferView</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvrvk_1_1impl_1_1_device__.html#aa6b5058cce14b9bf63a1b80118888274">createBufferView</a> (const <a class="el" href="namespacepvrvk.html#a2a117db0aab25382d050908b2bfa4c8b">Buffer</a> &amp;buffer, VkFormat format, VkDeviceSize offset, VkDeviceSize range)</td></tr>
<tr class="memdesc:aa6b5058cce14b9bf63a1b80118888274"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create buffer view <a href="#aa6b5058cce14b9bf63a1b80118888274">More...</a><br/></td></tr>
<tr class="separator:aa6b5058cce14b9bf63a1b80118888274"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77e1f9a810685193c383ebf21e283456"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacepvrvk.html#ac9949394db8b3d968a7402b837567f87">CommandPool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvrvk_1_1impl_1_1_device__.html#a77e1f9a810685193c383ebf21e283456">createCommandPool</a> (uint32_t queueFamilyId, VkCommandPoolCreateFlags createFlags)</td></tr>
<tr class="memdesc:a77e1f9a810685193c383ebf21e283456"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create commandpool <a href="#a77e1f9a810685193c383ebf21e283456">More...</a><br/></td></tr>
<tr class="separator:a77e1f9a810685193c383ebf21e283456"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7364473088a3642cdc3803e9646c5a47"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacepvrvk.html#a946a7145c9e18b9a797fa714ce677f32">ComputePipeline</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvrvk_1_1impl_1_1_device__.html#a7364473088a3642cdc3803e9646c5a47">createComputePipeline</a> (const <a class="el" href="structpvrvk_1_1_compute_pipeline_create_info.html">ComputePipelineCreateInfo</a> &amp;createInfo, const <a class="el" href="namespacepvrvk.html#ae5b827461565bea772eda3f04341c828">PipelineCache</a> &amp;pipeCache=<a class="el" href="namespacepvrvk.html#ae5b827461565bea772eda3f04341c828">PipelineCache</a>())</td></tr>
<tr class="memdesc:a7364473088a3642cdc3803e9646c5a47"><td class="mdescLeft">&#160;</td><td class="mdescRight">createComputePipeline <a href="#a7364473088a3642cdc3803e9646c5a47">More...</a><br/></td></tr>
<tr class="separator:a7364473088a3642cdc3803e9646c5a47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc1ad8265492287e7e0ef341441123dc"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvrvk_1_1impl_1_1_device__.html#adc1ad8265492287e7e0ef341441123dc">createComputePipelines</a> (const <a class="el" href="structpvrvk_1_1_compute_pipeline_create_info.html">ComputePipelineCreateInfo</a> *createInfo, uint32_t numCreateInfos, const <a class="el" href="namespacepvrvk.html#ae5b827461565bea772eda3f04341c828">PipelineCache</a> &amp;pipeCache, <a class="el" href="namespacepvrvk.html#a946a7145c9e18b9a797fa714ce677f32">ComputePipeline</a> *outPipelines)</td></tr>
<tr class="memdesc:adc1ad8265492287e7e0ef341441123dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">create array of compute pipelines <a href="#adc1ad8265492287e7e0ef341441123dc">More...</a><br/></td></tr>
<tr class="separator:adc1ad8265492287e7e0ef341441123dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a489e43cb85b154cc0b4066de8c99e0e1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacepvrvk.html#a59d8d2d45d33d613ac2c8c956fa2020a">DescriptorPool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvrvk_1_1impl_1_1_device__.html#a489e43cb85b154cc0b4066de8c99e0e1">createDescriptorPool</a> (const <a class="el" href="structpvrvk_1_1_descriptor_pool_create_info.html">DescriptorPoolCreateInfo</a> &amp;createInfo)</td></tr>
<tr class="memdesc:a489e43cb85b154cc0b4066de8c99e0e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create DescriptorPool <a href="#a489e43cb85b154cc0b4066de8c99e0e1">More...</a><br/></td></tr>
<tr class="separator:a489e43cb85b154cc0b4066de8c99e0e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acdc46f0190baf4ff03edf75703f3b27d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacepvrvk.html#a4e213601eac04718affbe0b7a4c72160">DescriptorSetLayout</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvrvk_1_1impl_1_1_device__.html#acdc46f0190baf4ff03edf75703f3b27d">createDescriptorSetLayout</a> (const <a class="el" href="structpvrvk_1_1_descriptor_set_layout_create_info.html">DescriptorSetLayoutCreateInfo</a> &amp;createInfo)</td></tr>
<tr class="memdesc:acdc46f0190baf4ff03edf75703f3b27d"><td class="mdescLeft">&#160;</td><td class="mdescRight">create Descriptor set layout <a href="#acdc46f0190baf4ff03edf75703f3b27d">More...</a><br/></td></tr>
<tr class="separator:acdc46f0190baf4ff03edf75703f3b27d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a71d838047fb11f86a2cbf1a287d99e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacepvrvk.html#a8d71f5cb38d17c7a8d6ae36a33d07f17">Fence</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvrvk_1_1impl_1_1_device__.html#a5a71d838047fb11f86a2cbf1a287d99e">createFence</a> (VkFenceCreateFlags fenceCreateFlags=VkFenceCreateFlags(0))</td></tr>
<tr class="memdesc:a5a71d838047fb11f86a2cbf1a287d99e"><td class="mdescLeft">&#160;</td><td class="mdescRight">brief Create Fence <a href="#a5a71d838047fb11f86a2cbf1a287d99e">More...</a><br/></td></tr>
<tr class="separator:a5a71d838047fb11f86a2cbf1a287d99e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9921ac57cc547c4c861c5db76828a557"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacepvrvk.html#a7639515cddb57ed4370a5ce02287988a">Framebuffer</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvrvk_1_1impl_1_1_device__.html#a9921ac57cc547c4c861c5db76828a557">createFramebuffer</a> (const <a class="el" href="structpvrvk_1_1_framebuffer_create_info.html">FramebufferCreateInfo</a> &amp;createInfo)</td></tr>
<tr class="memdesc:a9921ac57cc547c4c861c5db76828a557"><td class="mdescLeft">&#160;</td><td class="mdescRight">createFramebuffer Create Framebuffer object <a href="#a9921ac57cc547c4c861c5db76828a557">More...</a><br/></td></tr>
<tr class="separator:a9921ac57cc547c4c861c5db76828a557"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31146c129809460f3fa211acb331856f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacepvrvk.html#aa2443b681960df638797cf93bbf33fb7">GraphicsPipeline</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvrvk_1_1impl_1_1_device__.html#a31146c129809460f3fa211acb331856f">createGraphicsPipeline</a> (const <a class="el" href="structpvrvk_1_1_graphics_pipeline_create_info.html">GraphicsPipelineCreateInfo</a> &amp;createInfo, const <a class="el" href="namespacepvrvk.html#ae5b827461565bea772eda3f04341c828">PipelineCache</a> &amp;pipeCache=<a class="el" href="namespacepvrvk.html#ae5b827461565bea772eda3f04341c828">PipelineCache</a>())</td></tr>
<tr class="memdesc:a31146c129809460f3fa211acb331856f"><td class="mdescLeft">&#160;</td><td class="mdescRight">create graphicsPipeline <a href="#a31146c129809460f3fa211acb331856f">More...</a><br/></td></tr>
<tr class="separator:a31146c129809460f3fa211acb331856f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86b8011cfc0ae87c4c87dae8e6f1da13"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvrvk_1_1impl_1_1_device__.html#a86b8011cfc0ae87c4c87dae8e6f1da13">createGraphicsPipelines</a> (const <a class="el" href="structpvrvk_1_1_graphics_pipeline_create_info.html">GraphicsPipelineCreateInfo</a> *createInfos, uint32_t numCreateInfos, const <a class="el" href="namespacepvrvk.html#ae5b827461565bea772eda3f04341c828">PipelineCache</a> &amp;pipeCache, <a class="el" href="namespacepvrvk.html#aa2443b681960df638797cf93bbf33fb7">GraphicsPipeline</a> *outPipelines)</td></tr>
<tr class="memdesc:a86b8011cfc0ae87c4c87dae8e6f1da13"><td class="mdescLeft">&#160;</td><td class="mdescRight">create array of graphics pipelines <a href="#a86b8011cfc0ae87c4c87dae8e6f1da13">More...</a><br/></td></tr>
<tr class="separator:a86b8011cfc0ae87c4c87dae8e6f1da13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe53eb049fbb57f3559216dae163a3d4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacepvrvk.html#a0dde8112e297d1089979fbdbdcbbe0f4">Image</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvrvk_1_1impl_1_1_device__.html#abe53eb049fbb57f3559216dae163a3d4">createImage</a> (VkImageType imageType, VkFormat format, const <a class="el" href="structpvrvk_1_1_extent3_d.html">Extent3D</a> &amp;dimension, VkImageUsageFlags usage, VkImageCreateFlags flags=VkImageCreateFlags(0), const <a class="el" href="structpvrvk_1_1_image_layers_size.html">ImageLayersSize</a> &amp;layerSize=<a class="el" href="structpvrvk_1_1_image_layers_size.html">ImageLayersSize</a>(), VkSampleCountFlags samples=VkSampleCountFlags::e_1_BIT, bool sharingExclusive=true, const uint32_t *queueFamilyIndices=nullptr, uint32_t numQueueFamilyIndices=0)</td></tr>
<tr class="memdesc:abe53eb049fbb57f3559216dae163a3d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">create 3d Image(sparse or with memory backing, depending on <em>flags</em> . User should not call bindMemory on the image if sparse flags are used. <em>allocMemFlags</em>  is ignored if <em>flags</em>  contains a sparse binding flag.) <a href="#abe53eb049fbb57f3559216dae163a3d4">More...</a><br/></td></tr>
<tr class="separator:abe53eb049fbb57f3559216dae163a3d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a367473c812ec4c17c232f8eba008aa2d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacepvrvk.html#ad4da214c95fffe4edccb14eb2c270f07">ImageView</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvrvk_1_1impl_1_1_device__.html#a367473c812ec4c17c232f8eba008aa2d">createImageView</a> (const <a class="el" href="namespacepvrvk.html#a0dde8112e297d1089979fbdbdcbbe0f4">Image</a> &amp;image, const <a class="el" href="structpvrvk_1_1_component_mapping.html">ComponentMapping</a> &amp;swizzleChannels=<a class="el" href="structpvrvk_1_1_component_mapping.html">ComponentMapping</a>())</td></tr>
<tr class="memdesc:a367473c812ec4c17c232f8eba008aa2d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create image view object. NOTE: for a non sparse image, a valid memory object must have bound on the image <a href="#a367473c812ec4c17c232f8eba008aa2d">More...</a><br/></td></tr>
<tr class="separator:a367473c812ec4c17c232f8eba008aa2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f422f96a2d4c07dd1dd4d4aec378674"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacepvrvk.html#ad4da214c95fffe4edccb14eb2c270f07">ImageView</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvrvk_1_1impl_1_1_device__.html#a4f422f96a2d4c07dd1dd4d4aec378674">createImageView</a> (const <a class="el" href="namespacepvrvk.html#a0dde8112e297d1089979fbdbdcbbe0f4">Image</a> &amp;image, VkImageViewType viewType, VkFormat format, const <a class="el" href="structpvrvk_1_1_image_subresource_range.html">ImageSubresourceRange</a> &amp;range, const <a class="el" href="structpvrvk_1_1_component_mapping.html">ComponentMapping</a> &amp;swizzleChannels=<a class="el" href="structpvrvk_1_1_component_mapping.html">ComponentMapping</a>())</td></tr>
<tr class="memdesc:a4f422f96a2d4c07dd1dd4d4aec378674"><td class="mdescLeft">&#160;</td><td class="mdescRight">create Image view object NOTE: for non sparse image, a valid memory object must have bound on the image <a href="#a4f422f96a2d4c07dd1dd4d4aec378674">More...</a><br/></td></tr>
<tr class="separator:a4f422f96a2d4c07dd1dd4d4aec378674"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a379d89acc280b3e3b5bd4212f9405625"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacepvrvk.html#ae5b827461565bea772eda3f04341c828">PipelineCache</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvrvk_1_1impl_1_1_device__.html#a379d89acc280b3e3b5bd4212f9405625">createPipelineCache</a> (size_t initialDataSize, const void *initialData, VkPipelineCacheCreateFlags flags)</td></tr>
<tr class="memdesc:a379d89acc280b3e3b5bd4212f9405625"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create PipelineCache object <a href="#a379d89acc280b3e3b5bd4212f9405625">More...</a><br/></td></tr>
<tr class="separator:a379d89acc280b3e3b5bd4212f9405625"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3cac7a9436c1bc5cf0c1ec60ffc713a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacepvrvk.html#a34bb21497524a13e145b1398450989d0">PipelineLayout</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvrvk_1_1impl_1_1_device__.html#af3cac7a9436c1bc5cf0c1ec60ffc713a">createPipelineLayout</a> (const <a class="el" href="structpvrvk_1_1_pipeline_layout_create_info.html">PipelineLayoutCreateInfo</a> &amp;createInfo)</td></tr>
<tr class="memdesc:af3cac7a9436c1bc5cf0c1ec60ffc713a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create pipeline layout <a href="#af3cac7a9436c1bc5cf0c1ec60ffc713a">More...</a><br/></td></tr>
<tr class="separator:af3cac7a9436c1bc5cf0c1ec60ffc713a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a290df83f486fb1b1543f4d390c8876"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacepvrvk.html#a55f833c5feaaa65f3aaed3a08a7a55e6">RenderPass</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvrvk_1_1impl_1_1_device__.html#a1a290df83f486fb1b1543f4d390c8876">createRenderPass</a> (const <a class="el" href="structpvrvk_1_1_render_pass_create_info.html">RenderPassCreateInfo</a> &amp;createInfo)</td></tr>
<tr class="memdesc:a1a290df83f486fb1b1543f4d390c8876"><td class="mdescLeft">&#160;</td><td class="mdescRight">create renderpass <a href="#a1a290df83f486fb1b1543f4d390c8876">More...</a><br/></td></tr>
<tr class="separator:a1a290df83f486fb1b1543f4d390c8876"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3737f3192b88453f393143fd8a38d056"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacepvrvk.html#a3dfe5c509c8d09860bb15e2c805dcc25">Sampler</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvrvk_1_1impl_1_1_device__.html#a3737f3192b88453f393143fd8a38d056">createSampler</a> (const <a class="el" href="structpvrvk_1_1_sampler_create_info.html">SamplerCreateInfo</a> &amp;createInfo)</td></tr>
<tr class="memdesc:a3737f3192b88453f393143fd8a38d056"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create sampler object <a href="#a3737f3192b88453f393143fd8a38d056">More...</a><br/></td></tr>
<tr class="separator:a3737f3192b88453f393143fd8a38d056"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a0902988bd8c52158f87af7ad5a1e73"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacepvrvk.html#a571089f58c1ce4d8e60559dbbf312fcc">Semaphore</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvrvk_1_1impl_1_1_device__.html#a3a0902988bd8c52158f87af7ad5a1e73">createSemaphore</a> ()</td></tr>
<tr class="memdesc:a3a0902988bd8c52158f87af7ad5a1e73"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create semaphore <a href="#a3a0902988bd8c52158f87af7ad5a1e73">More...</a><br/></td></tr>
<tr class="separator:a3a0902988bd8c52158f87af7ad5a1e73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b6086ec0499f9bd8bbb19b57d100a21"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacepvrvk.html#a0fce3027dca16ffe07b46603377a0345">Shader</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvrvk_1_1impl_1_1_device__.html#a3b6086ec0499f9bd8bbb19b57d100a21">createShader</a> (const std::vector&lt; uint32_t &gt; &amp;shaderSrc)</td></tr>
<tr class="memdesc:a3b6086ec0499f9bd8bbb19b57d100a21"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create Shader Object <a href="#a3b6086ec0499f9bd8bbb19b57d100a21">More...</a><br/></td></tr>
<tr class="separator:a3b6086ec0499f9bd8bbb19b57d100a21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3918026276ec88a53c78fe6bfdf72023"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacepvrvk.html#a42223c225b66c77fe183f4d908647662">Swapchain</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvrvk_1_1impl_1_1_device__.html#a3918026276ec88a53c78fe6bfdf72023">createSwapchain</a> (const <a class="el" href="structpvrvk_1_1_swapchain_create_info.html">SwapchainCreateInfo</a> &amp;createInfo, const <a class="el" href="namespacepvrvk.html#a3d59bc44473920c3db2866f37829bb4c">Surface</a> &amp;surface)</td></tr>
<tr class="memdesc:a3918026276ec88a53c78fe6bfdf72023"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create Swapchain <a href="#a3918026276ec88a53c78fe6bfdf72023">More...</a><br/></td></tr>
<tr class="separator:a3918026276ec88a53c78fe6bfdf72023"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e5bbd7bc0fc1f2438e4f428cda36edd"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; std::string &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvrvk_1_1impl_1_1_device__.html#a9e5bbd7bc0fc1f2438e4f428cda36edd">getAllEnabledExtensions</a> () const </td></tr>
<tr class="memdesc:a9e5bbd7bc0fc1f2438e4f428cda36edd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get all the enabled extensions <a href="#a9e5bbd7bc0fc1f2438e4f428cda36edd">More...</a><br/></td></tr>
<tr class="separator:a9e5bbd7bc0fc1f2438e4f428cda36edd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad06893831e7f5215ce99e670740f3835"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; std::string &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvrvk_1_1impl_1_1_device__.html#ad06893831e7f5215ce99e670740f3835">getEnabledDeviceExtensions</a> () const </td></tr>
<tr class="memdesc:ad06893831e7f5215ce99e670740f3835"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get List of enabled device extension. <a href="#ad06893831e7f5215ce99e670740f3835">More...</a><br/></td></tr>
<tr class="separator:ad06893831e7f5215ce99e670740f3835"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a013a35d2371a7bb1825aebd9ab03f72b"><td class="memItemLeft" align="right" valign="top">const VkDevice &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvrvk_1_1impl_1_1_device__.html#a013a35d2371a7bb1825aebd9ab03f72b">getNativeObject</a> () const </td></tr>
<tr class="memdesc:a013a35d2371a7bb1825aebd9ab03f72b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the native handle to the context <a href="#a013a35d2371a7bb1825aebd9ab03f72b">More...</a><br/></td></tr>
<tr class="separator:a013a35d2371a7bb1825aebd9ab03f72b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7dffaa880aeea5525dd1141183a02a3"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="namespacepvrvk.html#ae067e978bb54033c87500cbf30bbedb2">PhysicalDeviceWeakPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvrvk_1_1impl_1_1_device__.html#af7dffaa880aeea5525dd1141183a02a3">getPhysicalDevice</a> () const </td></tr>
<tr class="memdesc:af7dffaa880aeea5525dd1141183a02a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">brief Get the physical device which this logical device was created from.(const) <a href="#af7dffaa880aeea5525dd1141183a02a3">More...</a><br/></td></tr>
<tr class="separator:af7dffaa880aeea5525dd1141183a02a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac63ebec6ec18dc7b1f77875be9f46541"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacepvrvk.html#ae067e978bb54033c87500cbf30bbedb2">PhysicalDeviceWeakPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvrvk_1_1impl_1_1_device__.html#ac63ebec6ec18dc7b1f77875be9f46541">getPhysicalDevice</a> ()</td></tr>
<tr class="memdesc:ac63ebec6ec18dc7b1f77875be9f46541"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the physical device which this logical device was created from. <a href="#ac63ebec6ec18dc7b1f77875be9f46541">More...</a><br/></td></tr>
<tr class="separator:ac63ebec6ec18dc7b1f77875be9f46541"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a383ec28d4d04f6382be185120862d5da"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacepvrvk.html#a21c02fb0d74c71bc78b01b1ed0e8fe65">Queue</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvrvk_1_1impl_1_1_device__.html#a383ec28d4d04f6382be185120862d5da">getQueue</a> (uint32_t queueFamily, uint32_t queueId)</td></tr>
<tr class="memdesc:a383ec28d4d04f6382be185120862d5da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get Queue <a href="#a383ec28d4d04f6382be185120862d5da">More...</a><br/></td></tr>
<tr class="separator:a383ec28d4d04f6382be185120862d5da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a793142138d7cf56af81aa92d03d28b70"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvrvk_1_1impl_1_1_device__.html#a793142138d7cf56af81aa92d03d28b70">isDeviceExtensionEnabled</a> (const char *extensionName)</td></tr>
<tr class="memdesc:a793142138d7cf56af81aa92d03d28b70"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if the device extension is enabled. <a href="#a793142138d7cf56af81aa92d03d28b70">More...</a><br/></td></tr>
<tr class="separator:a793142138d7cf56af81aa92d03d28b70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66e8cd7a9b1f69d14f158bf45bb7b72d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvrvk_1_1impl_1_1_device__.html#a66e8cd7a9b1f69d14f158bf45bb7b72d">isExtensionEnabled</a> (const char *extension) const </td></tr>
<tr class="memdesc:a66e8cd7a9b1f69d14f158bf45bb7b72d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if the given extension is enabled (const). <a href="#a66e8cd7a9b1f69d14f158bf45bb7b72d">More...</a><br/></td></tr>
<tr class="separator:a66e8cd7a9b1f69d14f158bf45bb7b72d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2bb717498c57be9495758f9e3a2bc6a2"><td class="memItemLeft" align="right" valign="top">VkResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvrvk_1_1impl_1_1_device__.html#a2bb717498c57be9495758f9e3a2bc6a2">mergePipelineCache</a> (const <a class="el" href="namespacepvrvk.html#ae5b827461565bea772eda3f04341c828">PipelineCache</a> *srcPipeCaches, uint32_t numSrcPipeCaches, <a class="el" href="namespacepvrvk.html#ae5b827461565bea772eda3f04341c828">PipelineCache</a> destPipeCache)</td></tr>
<tr class="memdesc:a2bb717498c57be9495758f9e3a2bc6a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Merge PipelineCache objects <a href="#a2bb717498c57be9495758f9e3a2bc6a2">More...</a><br/></td></tr>
<tr class="separator:a2bb717498c57be9495758f9e3a2bc6a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8700b61e31098329ef50a2d824a146f3"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvrvk_1_1impl_1_1_device__.html#a8700b61e31098329ef50a2d824a146f3">resetFences</a> (const uint32_t numFences, const <a class="el" href="namespacepvrvk.html#a8d71f5cb38d17c7a8d6ae36a33d07f17">Fence</a> *fences)</td></tr>
<tr class="memdesc:a8700b61e31098329ef50a2d824a146f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reset an array of fences <a href="#a8700b61e31098329ef50a2d824a146f3">More...</a><br/></td></tr>
<tr class="separator:a8700b61e31098329ef50a2d824a146f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90fcd5519f1f77908c735ea5e0b844a6"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvrvk_1_1impl_1_1_device__.html#a90fcd5519f1f77908c735ea5e0b844a6">supportsPVRTC</a> () const </td></tr>
<tr class="memdesc:a90fcd5519f1f77908c735ea5e0b844a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if this device support PVRTC image <a href="#a90fcd5519f1f77908c735ea5e0b844a6">More...</a><br/></td></tr>
<tr class="separator:a90fcd5519f1f77908c735ea5e0b844a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70cdb264cce1d22009a5f1b5f2d4c26f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvrvk_1_1impl_1_1_device__.html#a70cdb264cce1d22009a5f1b5f2d4c26f">updateDescriptorSets</a> (const <a class="el" href="structpvrvk_1_1_write_descriptor_set.html">WriteDescriptorSet</a> *writeDescSets, uint32_t numWriteDescSets, const <a class="el" href="structpvrvk_1_1_copy_descriptor_set.html">CopyDescriptorSet</a> *copyDescSets, uint32_t numCopyDescSets)</td></tr>
<tr class="memdesc:a70cdb264cce1d22009a5f1b5f2d4c26f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update Descriptorsets <a href="#a70cdb264cce1d22009a5f1b5f2d4c26f">More...</a><br/></td></tr>
<tr class="separator:a70cdb264cce1d22009a5f1b5f2d4c26f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acba3885386d5a88e4711de53afc430ca"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvrvk_1_1impl_1_1_device__.html#acba3885386d5a88e4711de53afc430ca">waitForFences</a> (const uint32_t numFences, const <a class="el" href="namespacepvrvk.html#a8d71f5cb38d17c7a8d6ae36a33d07f17">Fence</a> *fences, const bool waitAll, const uint64_t timeout)</td></tr>
<tr class="memdesc:acba3885386d5a88e4711de53afc430ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wait this device for an array of fences  <a href="#acba3885386d5a88e4711de53afc430ca">More...</a><br/></td></tr>
<tr class="separator:acba3885386d5a88e4711de53afc430ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97c2fa3df2dc5a61a066268ed8046128"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvrvk_1_1impl_1_1_device__.html#a97c2fa3df2dc5a61a066268ed8046128">waitIdle</a> ()</td></tr>
<tr class="memdesc:a97c2fa3df2dc5a61a066268ed8046128"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wait on the host for the completion of outstanding queue operations for all queues on this device This is equivalent to calling waitIdle for all queues owned by this device. <a href="#a97c2fa3df2dc5a61a066268ed8046128">More...</a><br/></td></tr>
<tr class="separator:a97c2fa3df2dc5a61a066268ed8046128"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>GpuDevice implementation that supports Vulkan</p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="aa28de641a316a51f13c8d184a77bc99c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacepvrvk.html#a634be07eff8c3efd7788c1429c8ff129">DeviceMemory</a> pvrvk::impl::Device_::allocateMemory </td>
          <td>(</td>
          <td class="paramtype">VkDeviceSize&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>allowedMemoryBits</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VkMemoryPropertyFlags&#160;</td>
          <td class="paramname"><em>memoryProps</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create device memory block</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">size</td><td>memory size</td></tr>
    <tr><td class="paramname">allowedMemoryBits</td><td>allowed memory bits</td></tr>
    <tr><td class="paramname">memoryProps</td><td>memory property flags</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Return a valid object if success</dd></dl>
<p>. </p>

</div>
</div>
<a class="anchor" id="a9e6dbc060b4add1ee37b8d605dc19d60"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacepvrvk.html#a2a117db0aab25382d050908b2bfa4c8b">Buffer</a> pvrvk::impl::Device_::createBuffer </td>
          <td>(</td>
          <td class="paramtype">VkDeviceSize&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VkBufferUsageFlags&#160;</td>
          <td class="paramname"><em>bufferUsage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VkBufferCreateFlags&#160;</td>
          <td class="paramname"><em>bufferCreateFlags</em> = <code>VkBufferCreateFlags(0)</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>sharingExclusive</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t *&#160;</td>
          <td class="paramname"><em>queueFamilyIndices</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>numQueueFamilyIndices</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a new buffer object and (optionally) allocate and bind memory for it</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">size</td><td>The total size of the buffer</td></tr>
    <tr><td class="paramname">bufferUsage</td><td>All buffer usages for which this buffer will be valid</td></tr>
    <tr><td class="paramname">bufferCreateFlags</td><td>Buffer creation flags (see Vulkan spec)</td></tr>
    <tr><td class="paramname">sharingExclusive</td><td>indicates whether the buffer is exclusive for some queues or can be used simultaneously multiple queues</td></tr>
    <tr><td class="paramname">queueFamilyIndices</td><td>If not exclusive, indicates which queue families the buffer can be used by</td></tr>
    <tr><td class="paramname">numQueueFamilyIndices</td><td>If not exclusive, the number of queue families for which this buffer is valid</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Return a valid object if success</dd></dl>
<p>. </p>

</div>
</div>
<a class="anchor" id="aa6b5058cce14b9bf63a1b80118888274"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacepvrvk.html#ae83f7affc0468a1c19e7fef55758015e">BufferView</a> pvrvk::impl::Device_::createBufferView </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacepvrvk.html#a2a117db0aab25382d050908b2bfa4c8b">Buffer</a> &amp;&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VkFormat&#160;</td>
          <td class="paramname"><em>format</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VkDeviceSize&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VkDeviceSize&#160;</td>
          <td class="paramname"><em>range</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create buffer view</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buffer</td><td>buffer object</td></tr>
    <tr><td class="paramname">format</td><td>buffer format</td></tr>
    <tr><td class="paramname">offset</td><td>view offset</td></tr>
    <tr><td class="paramname">range</td><td>view range</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Return valid object if success</dd></dl>

</div>
</div>
<a class="anchor" id="a77e1f9a810685193c383ebf21e283456"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacepvrvk.html#ac9949394db8b3d968a7402b837567f87">CommandPool</a> pvrvk::impl::Device_::createCommandPool </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>queueFamilyId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VkCommandPoolCreateFlags&#160;</td>
          <td class="paramname"><em>createFlags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create commandpool</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">queueFamilyId</td><td>All commandbuffer created from this commandpool must be submitted ti the queue </td></tr>
  </table>
  </dd>
</dl>
<p>with the same queue family id. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">createFlags</td><td>Create flags</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Return a valid object if success</dd></dl>
<p>. </p>

</div>
</div>
<a class="anchor" id="a7364473088a3642cdc3803e9646c5a47"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacepvrvk.html#a946a7145c9e18b9a797fa714ce677f32">ComputePipeline</a> pvrvk::impl::Device_::createComputePipeline </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structpvrvk_1_1_compute_pipeline_create_info.html">ComputePipelineCreateInfo</a> &amp;&#160;</td>
          <td class="paramname"><em>createInfo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacepvrvk.html#ae5b827461565bea772eda3f04341c828">PipelineCache</a> &amp;&#160;</td>
          <td class="paramname"><em>pipeCache</em> = <code><a class="el" href="namespacepvrvk.html#ae5b827461565bea772eda3f04341c828">PipelineCache</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>createComputePipeline</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">createInfo</td><td>create info</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Return a valid compute pipeline on success</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pipeCache</td><td>Either null handle, indicating that pipeline caching is disabled; or the handle of a valid pipeline cache object, in which case use of that cache is enabled for the duration of the command.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="adc1ad8265492287e7e0ef341441123dc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool pvrvk::impl::Device_::createComputePipelines </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structpvrvk_1_1_compute_pipeline_create_info.html">ComputePipelineCreateInfo</a> *&#160;</td>
          <td class="paramname"><em>createInfo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>numCreateInfos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacepvrvk.html#ae5b827461565bea772eda3f04341c828">PipelineCache</a> &amp;&#160;</td>
          <td class="paramname"><em>pipeCache</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacepvrvk.html#a946a7145c9e18b9a797fa714ce677f32">ComputePipeline</a> *&#160;</td>
          <td class="paramname"><em>outPipelines</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>create array of compute pipelines</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">createInfo</td><td>Compute pipeline create Infos</td></tr>
    <tr><td class="paramname">numCreateInfos</td><td>Number of compute pipleine to create</td></tr>
    <tr><td class="paramname">outPipelines</td><td>Out pipelines</td></tr>
    <tr><td class="paramname">pipeCache</td><td>Either null handle, indicating that pipeline caching is disabled; or the handle of a valid pipeline cache object, in which case use of that cache is enabled for the duration of the command.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Return true on success</dd></dl>
<p>. </p>

</div>
</div>
<a class="anchor" id="a489e43cb85b154cc0b4066de8c99e0e1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacepvrvk.html#a59d8d2d45d33d613ac2c8c956fa2020a">DescriptorPool</a> pvrvk::impl::Device_::createDescriptorPool </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structpvrvk_1_1_descriptor_pool_create_info.html">DescriptorPoolCreateInfo</a> &amp;&#160;</td>
          <td class="paramname"><em>createInfo</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create DescriptorPool</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">createInfo</td><td>DescriptorPool createInfo</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>return a valid object if success</dd></dl>
<p>. </p>

</div>
</div>
<a class="anchor" id="acdc46f0190baf4ff03edf75703f3b27d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacepvrvk.html#a4e213601eac04718affbe0b7a4c72160">DescriptorSetLayout</a> pvrvk::impl::Device_::createDescriptorSetLayout </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structpvrvk_1_1_descriptor_set_layout_create_info.html">DescriptorSetLayoutCreateInfo</a> &amp;&#160;</td>
          <td class="paramname"><em>createInfo</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>create Descriptor set layout</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">createInfo</td><td>Descriptor layout createInfo</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Return a valid object if success</dd></dl>
<p>. </p>

</div>
</div>
<a class="anchor" id="a5a71d838047fb11f86a2cbf1a287d99e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacepvrvk.html#a8d71f5cb38d17c7a8d6ae36a33d07f17">Fence</a> pvrvk::impl::Device_::createFence </td>
          <td>(</td>
          <td class="paramtype">VkFenceCreateFlags&#160;</td>
          <td class="paramname"><em>fenceCreateFlags</em> = <code>VkFenceCreateFlags(0)</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>brief Create Fence</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fenceCreateFlags</td><td>Fence create flags</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Return a valid object if success</dd></dl>
<p>. </p>

</div>
</div>
<a class="anchor" id="a9921ac57cc547c4c861c5db76828a557"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacepvrvk.html#a7639515cddb57ed4370a5ce02287988a">Framebuffer</a> pvrvk::impl::Device_::createFramebuffer </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structpvrvk_1_1_framebuffer_create_info.html">FramebufferCreateInfo</a> &amp;&#160;</td>
          <td class="paramname"><em>createInfo</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>createFramebuffer Create Framebuffer object</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">createInfo</td><td>Framebuffer createInfo</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>return a valid object if success</dd></dl>
<p>. </p>

</div>
</div>
<a class="anchor" id="a31146c129809460f3fa211acb331856f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacepvrvk.html#aa2443b681960df638797cf93bbf33fb7">GraphicsPipeline</a> pvrvk::impl::Device_::createGraphicsPipeline </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structpvrvk_1_1_graphics_pipeline_create_info.html">GraphicsPipelineCreateInfo</a> &amp;&#160;</td>
          <td class="paramname"><em>createInfo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacepvrvk.html#ae5b827461565bea772eda3f04341c828">PipelineCache</a> &amp;&#160;</td>
          <td class="paramname"><em>pipeCache</em> = <code><a class="el" href="namespacepvrvk.html#ae5b827461565bea772eda3f04341c828">PipelineCache</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>create graphicsPipeline</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">createInfo</td><td>Pipeline create info</td></tr>
    <tr><td class="paramname">pipeCache</td><td>Either null handle, indicating that pipeline caching is disabled; or the handle of a valid pipeline cache object, in which case use of that cache is enabled for the duration of the command.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Return a valid pipeline on success</dd></dl>
<p>. </p>

</div>
</div>
<a class="anchor" id="a86b8011cfc0ae87c4c87dae8e6f1da13"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool pvrvk::impl::Device_::createGraphicsPipelines </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structpvrvk_1_1_graphics_pipeline_create_info.html">GraphicsPipelineCreateInfo</a> *&#160;</td>
          <td class="paramname"><em>createInfos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>numCreateInfos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacepvrvk.html#ae5b827461565bea772eda3f04341c828">PipelineCache</a> &amp;&#160;</td>
          <td class="paramname"><em>pipeCache</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacepvrvk.html#aa2443b681960df638797cf93bbf33fb7">GraphicsPipeline</a> *&#160;</td>
          <td class="paramname"><em>outPipelines</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>create array of graphics pipelines</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">createInfos</td><td>Pipeline create infos</td></tr>
    <tr><td class="paramname">numCreateInfos</td><td>Number of pipeline to create</td></tr>
    <tr><td class="paramname">outPipelines</td><td>Out pipeline</td></tr>
    <tr><td class="paramname">pipeCache</td><td>Either null handle, indicating that pipeline caching is disabled; or the handle of a valid pipeline cache object, in which case use of that cache is enabled for the duration of the command.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>return true if success</dd></dl>
<p>. </p>

</div>
</div>
<a class="anchor" id="abe53eb049fbb57f3559216dae163a3d4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacepvrvk.html#a0dde8112e297d1089979fbdbdcbbe0f4">Image</a> pvrvk::impl::Device_::createImage </td>
          <td>(</td>
          <td class="paramtype">VkImageType&#160;</td>
          <td class="paramname"><em>imageType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VkFormat&#160;</td>
          <td class="paramname"><em>format</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structpvrvk_1_1_extent3_d.html">Extent3D</a> &amp;&#160;</td>
          <td class="paramname"><em>dimension</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VkImageUsageFlags&#160;</td>
          <td class="paramname"><em>usage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VkImageCreateFlags&#160;</td>
          <td class="paramname"><em>flags</em> = <code>VkImageCreateFlags(0)</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structpvrvk_1_1_image_layers_size.html">ImageLayersSize</a> &amp;&#160;</td>
          <td class="paramname"><em>layerSize</em> = <code><a class="el" href="structpvrvk_1_1_image_layers_size.html">ImageLayersSize</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VkSampleCountFlags&#160;</td>
          <td class="paramname"><em>samples</em> = <code>VkSampleCountFlags::e_1_BIT</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>sharingExclusive</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t *&#160;</td>
          <td class="paramname"><em>queueFamilyIndices</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>numQueueFamilyIndices</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>create 3d Image(sparse or with memory backing, depending on <em>flags</em> . User should not call bindMemory on the image if sparse flags are used. <em>allocMemFlags</em>  is ignored if <em>flags</em>  contains a sparse binding flag.)</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">imageType</td><td>The type of the created image (1D/2D/3D etc)</td></tr>
    <tr><td class="paramname">format</td><td>The Image format</td></tr>
    <tr><td class="paramname">dimension</td><td>Image dimension</td></tr>
    <tr><td class="paramname">usage</td><td>Image usage flags</td></tr>
    <tr><td class="paramname">flags</td><td>Image create flags</td></tr>
    <tr><td class="paramname">layerSize</td><td>Image layer size</td></tr>
    <tr><td class="paramname">samples</td><td>NUmber of samples</td></tr>
    <tr><td class="paramname">sharingExclusive</td><td>Specifying the sharing mode of this image. Setting it true means that only a single queue can access it therefore the calle must exclusively transfer queue ownership of this image if they want separate queue family to access this image and the <em>queueFamilyIndices</em> , <em>numQueueFamilyIndices</em>  is ignored. Setting it to false means multiple queue family can access this image at any point in time and requires <em>queueFamilyIndices</em> , <em>numQueueFamilyIndices</em> </td></tr>
    <tr><td class="paramname">queueFamilyIndices</td><td>A c-style array containing the queue family indices that this image is exclusive to</td></tr>
    <tr><td class="paramname">numQueueFamilyIndices</td><td>The number of queues in <em>queueFamilyIndices</em> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The created Imageobject on success, null Image on failure</dd></dl>

</div>
</div>
<a class="anchor" id="a367473c812ec4c17c232f8eba008aa2d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacepvrvk.html#ad4da214c95fffe4edccb14eb2c270f07">ImageView</a> pvrvk::impl::Device_::createImageView </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacepvrvk.html#a0dde8112e297d1089979fbdbdcbbe0f4">Image</a> &amp;&#160;</td>
          <td class="paramname"><em>image</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structpvrvk_1_1_component_mapping.html">ComponentMapping</a> &amp;&#160;</td>
          <td class="paramname"><em>swizzleChannels</em> = <code><a class="el" href="structpvrvk_1_1_component_mapping.html">ComponentMapping</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create image view object. NOTE: for a non sparse image, a valid memory object must have bound on the image</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">image</td><td>The image to use for creating the image view</td></tr>
    <tr><td class="paramname">swizzleChannels</td><td>The channels to swizzle, default Identity</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The created ImageView object on success, null ImageView on failure</dd></dl>

</div>
</div>
<a class="anchor" id="a4f422f96a2d4c07dd1dd4d4aec378674"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacepvrvk.html#ad4da214c95fffe4edccb14eb2c270f07">ImageView</a> pvrvk::impl::Device_::createImageView </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacepvrvk.html#a0dde8112e297d1089979fbdbdcbbe0f4">Image</a> &amp;&#160;</td>
          <td class="paramname"><em>image</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VkImageViewType&#160;</td>
          <td class="paramname"><em>viewType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VkFormat&#160;</td>
          <td class="paramname"><em>format</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structpvrvk_1_1_image_subresource_range.html">ImageSubresourceRange</a> &amp;&#160;</td>
          <td class="paramname"><em>range</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structpvrvk_1_1_component_mapping.html">ComponentMapping</a> &amp;&#160;</td>
          <td class="paramname"><em>swizzleChannels</em> = <code><a class="el" href="structpvrvk_1_1_component_mapping.html">ComponentMapping</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>create Image view object NOTE: for non sparse image, a valid memory object must have bound on the image</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">image</td><td>The image to use for creating the image view</td></tr>
    <tr><td class="paramname">viewType</td><td>The type of the image view</td></tr>
    <tr><td class="paramname">format</td><td>the Format must be the same as the Image format, Unless if the image is created with Mutable format flag</td></tr>
    <tr><td class="paramname">range</td><td>The sub resource image range</td></tr>
    <tr><td class="paramname">swizzleChannels</td><td>The channels to swizzle</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The created ImageView object on success, null ImageView on failure</dd></dl>

</div>
</div>
<a class="anchor" id="a379d89acc280b3e3b5bd4212f9405625"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacepvrvk.html#ae5b827461565bea772eda3f04341c828">PipelineCache</a> pvrvk::impl::Device_::createPipelineCache </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>initialDataSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>initialData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VkPipelineCacheCreateFlags&#160;</td>
          <td class="paramname"><em>flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create PipelineCache object</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">flags</td><td>flags is reserved for future use</td></tr>
    <tr><td class="paramname">initialDataSize</td><td>initialDataSize is the number of bytes in pInitialData. If initialDataSize is zero, the pipeline cache will initially be empty.</td></tr>
    <tr><td class="paramname">pInitialData</td><td>initialData is a pointer to previously retrieved pipeline cache data. If the pipeline cache data is incompatible (as defined below) with the device, the pipeline cache will be initially empty. If initialDataSize is zero, pInitialData is ignored.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Return a valid object if success</dd></dl>
<p>. </p>

</div>
</div>
<a class="anchor" id="af3cac7a9436c1bc5cf0c1ec60ffc713a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacepvrvk.html#a34bb21497524a13e145b1398450989d0">PipelineLayout</a> pvrvk::impl::Device_::createPipelineLayout </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structpvrvk_1_1_pipeline_layout_create_info.html">PipelineLayoutCreateInfo</a> &amp;&#160;</td>
          <td class="paramname"><em>createInfo</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create pipeline layout</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">createInfo</td><td>Pipeline layout create info</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Return a valid object if success</dd></dl>
<p>. </p>

</div>
</div>
<a class="anchor" id="a1a290df83f486fb1b1543f4d390c8876"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacepvrvk.html#a55f833c5feaaa65f3aaed3a08a7a55e6">RenderPass</a> pvrvk::impl::Device_::createRenderPass </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structpvrvk_1_1_render_pass_create_info.html">RenderPassCreateInfo</a> &amp;&#160;</td>
          <td class="paramname"><em>createInfo</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>create renderpass</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">createInfo</td><td>Renderpass createInfo</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>return a valid object if success</dd></dl>
<p>. </p>

</div>
</div>
<a class="anchor" id="a3737f3192b88453f393143fd8a38d056"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacepvrvk.html#a3dfe5c509c8d09860bb15e2c805dcc25">Sampler</a> pvrvk::impl::Device_::createSampler </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structpvrvk_1_1_sampler_create_info.html">SamplerCreateInfo</a> &amp;&#160;</td>
          <td class="paramname"><em>createInfo</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create sampler object</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">createInfo</td><td>Sampler Create info</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Return a valid sampler object on success</dd></dl>
<p>. </p>

</div>
</div>
<a class="anchor" id="a3a0902988bd8c52158f87af7ad5a1e73"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacepvrvk.html#a571089f58c1ce4d8e60559dbbf312fcc">Semaphore</a> pvrvk::impl::Device_::createSemaphore </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create semaphore</p>
<dl class="section return"><dt>Returns</dt><dd>Return a valid object if success</dd></dl>
<p>. </p>

</div>
</div>
<a class="anchor" id="a3b6086ec0499f9bd8bbb19b57d100a21"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacepvrvk.html#a0fce3027dca16ffe07b46603377a0345">Shader</a> pvrvk::impl::Device_::createShader </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; uint32_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>shaderSrc</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create Shader Object</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">shaderSrc</td><td>Shader source data</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Return a valid shader if success</dd></dl>

</div>
</div>
<a class="anchor" id="a3918026276ec88a53c78fe6bfdf72023"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacepvrvk.html#a42223c225b66c77fe183f4d908647662">Swapchain</a> pvrvk::impl::Device_::createSwapchain </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structpvrvk_1_1_swapchain_create_info.html">SwapchainCreateInfo</a> &amp;&#160;</td>
          <td class="paramname"><em>createInfo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacepvrvk.html#a3d59bc44473920c3db2866f37829bb4c">Surface</a> &amp;&#160;</td>
          <td class="paramname"><em>surface</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create Swapchain</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">createInfo</td><td>Swapchain createInfo</td></tr>
    <tr><td class="paramname">surface</td><td>Swapchain's surface</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Return a valid object if success</dd></dl>
<p>. </p>

</div>
</div>
<a class="anchor" id="a9e5bbd7bc0fc1f2438e4f428cda36edd"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt;std::string&gt;&amp; pvrvk::impl::Device_::getAllEnabledExtensions </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get all the enabled extensions</p>
<dl class="section return"><dt>Returns</dt><dd>Extension strings</dd></dl>

</div>
</div>
<a class="anchor" id="ad06893831e7f5215ce99e670740f3835"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt;std::string&gt;&amp; pvrvk::impl::Device_::getEnabledDeviceExtensions </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get List of enabled device extension.</p>
<dl class="section return"><dt>Returns</dt><dd>Device extensions</dd></dl>

</div>
</div>
<a class="anchor" id="a013a35d2371a7bb1825aebd9ab03f72b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const VkDevice&amp; pvrvk::impl::Device_::getNativeObject </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the native handle to the context</p>
<dl class="section return"><dt>Returns</dt><dd>Return the context native handle</dd></dl>

</div>
</div>
<a class="anchor" id="af7dffaa880aeea5525dd1141183a02a3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="namespacepvrvk.html#ae067e978bb54033c87500cbf30bbedb2">PhysicalDeviceWeakPtr</a> pvrvk::impl::Device_::getPhysicalDevice </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>brief Get the physical device which this logical device was created from.(const)</p>
<dl class="section return"><dt>Returns</dt><dd>Return the physical device</dd></dl>
<p>. </p>

</div>
</div>
<a class="anchor" id="ac63ebec6ec18dc7b1f77875be9f46541"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacepvrvk.html#ae067e978bb54033c87500cbf30bbedb2">PhysicalDeviceWeakPtr</a> pvrvk::impl::Device_::getPhysicalDevice </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the physical device which this logical device was created from.</p>
<dl class="section return"><dt>Returns</dt><dd>Return the physical device</dd></dl>
<p>. </p>

</div>
</div>
<a class="anchor" id="a383ec28d4d04f6382be185120862d5da"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacepvrvk.html#a21c02fb0d74c71bc78b01b1ed0e8fe65">Queue</a> pvrvk::impl::Device_::getQueue </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>queueFamily</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>queueId</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get Queue</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">queueFamily</td><td>Queue Family id</td></tr>
    <tr><td class="paramname">queueId</td><td>Queue Id</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Return the queue</dd></dl>

</div>
</div>
<a class="anchor" id="a793142138d7cf56af81aa92d03d28b70"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool pvrvk::impl::Device_::isDeviceExtensionEnabled </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>extensionName</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return true if the device extension is enabled.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">extensionName</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

</div>
</div>
<a class="anchor" id="a66e8cd7a9b1f69d14f158bf45bb7b72d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool pvrvk::impl::Device_::isExtensionEnabled </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>extension</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return true if the given extension is enabled (const).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">extension</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

</div>
</div>
<a class="anchor" id="a2bb717498c57be9495758f9e3a2bc6a2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VkResult pvrvk::impl::Device_::mergePipelineCache </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacepvrvk.html#ae5b827461565bea772eda3f04341c828">PipelineCache</a> *&#160;</td>
          <td class="paramname"><em>srcPipeCaches</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>numSrcPipeCaches</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacepvrvk.html#ae5b827461565bea772eda3f04341c828">PipelineCache</a>&#160;</td>
          <td class="paramname"><em>destPipeCache</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Merge PipelineCache objects</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">srcPipeCaches</td><td>Pipeline caches, which will be merged into destPipeCache</td></tr>
    <tr><td class="paramname">numSrcPipeCaches</td><td>Number of source pipeline caches to be merged</td></tr>
    <tr><td class="paramname">destPipeCache</td><td>Pipeline cache to merge results into. The previous contents of destPipeCache are included after the merge</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Return result</dd></dl>
<p>. </p>

</div>
</div>
<a class="anchor" id="a8700b61e31098329ef50a2d824a146f3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool pvrvk::impl::Device_::resetFences </td>
          <td>(</td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>numFences</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacepvrvk.html#a8d71f5cb38d17c7a8d6ae36a33d07f17">Fence</a> *&#160;</td>
          <td class="paramname"><em>fences</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reset an array of fences</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">numFences</td><td>Number of fence to reset</td></tr>
    <tr><td class="paramname">fences</td><td>Fence to reset</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Return true if success</dd></dl>
<p>. </p>

</div>
</div>
<a class="anchor" id="a90fcd5519f1f77908c735ea5e0b844a6"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool pvrvk::impl::Device_::supportsPVRTC </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return true if this device support PVRTC image</p>
<dl class="section return"><dt>Returns</dt><dd>Return true if supported</dd></dl>

</div>
</div>
<a class="anchor" id="a70cdb264cce1d22009a5f1b5f2d4c26f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pvrvk::impl::Device_::updateDescriptorSets </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structpvrvk_1_1_write_descriptor_set.html">WriteDescriptorSet</a> *&#160;</td>
          <td class="paramname"><em>writeDescSets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>numWriteDescSets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structpvrvk_1_1_copy_descriptor_set.html">CopyDescriptorSet</a> *&#160;</td>
          <td class="paramname"><em>copyDescSets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>numCopyDescSets</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Update Descriptorsets</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">writeDescSets</td><td>Write descriptor sets</td></tr>
    <tr><td class="paramname">numWriteDescSets</td><td>Number of write Descriptor sets</td></tr>
    <tr><td class="paramname">copyDescSets</td><td>Copy operation happens after the Write operation.</td></tr>
    <tr><td class="paramname">numCopyDescSets</td><td>Number of copy descriptor sets</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="acba3885386d5a88e4711de53afc430ca"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool pvrvk::impl::Device_::waitForFences </td>
          <td>(</td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>numFences</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacepvrvk.html#a8d71f5cb38d17c7a8d6ae36a33d07f17">Fence</a> *&#160;</td>
          <td class="paramname"><em>fences</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>waitAll</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint64_t&#160;</td>
          <td class="paramname"><em>timeout</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Wait this device for an array of fences </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">numFences</td><td>Number of fence to wait</td></tr>
    <tr><td class="paramname">fences</td><td>Fences to wait for</td></tr>
    <tr><td class="paramname">waitAll</td><td>Wait for all fence if flags set to true</td></tr>
    <tr><td class="paramname">timeout</td><td>Wait timeout</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Return true if fence waits successfull</dd></dl>
<p>. </p>

</div>
</div>
<a class="anchor" id="a97c2fa3df2dc5a61a066268ed8046128"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pvrvk::impl::Device_::waitIdle </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Wait on the host for the completion of outstanding queue operations for all queues on this device This is equivalent to calling waitIdle for all queues owned by this device.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>/usr/buildxl/buildroot/sdk/branch/Framework/PVRVk/<a class="el" href="_device_vk_8h_source.html">DeviceVk.h</a></li>
</ul>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.4-->
<!-- start footer part (NON TREEVIEW ONLY!!) -->
<!--BEGIN GENERATE_TREEVIEW-->
<div id="FooterMainContainer">
	<div id="FooterContainer">
		<div class="footerlogo">
			<a href="http://www.imgtec.com" target="_blank"><img src="img-footer-logo-grey.png" width="100%" height="100%" border="none" /></a>
		</div>
		<div class="copyright"><p>&copy; Imagination Technologies Limited<br> All rights reserved</p></div>
	</div>
</div>
</body>
</html>
