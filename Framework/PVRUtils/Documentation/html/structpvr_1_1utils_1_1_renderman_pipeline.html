<!-- HTML header for doxygen 1.8.4-->
<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="generator" content="Doxygen 1.8.6"/>
<title>PVRUtils: pvr::utils::RendermanPipeline Struct Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="IMGdoxygen.css" rel="stylesheet" type="text/css"/>
<link rel="shortcut icon" href="http://www.imgtec.com/images/img.ico">
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
  <div class="headercontent">
    <div class="PVRlogo">
      <a href="http://www.powervrinsider.com" target="_blank"><img src="PVRlogo.png" width="40%" height="40%"  border="none" /></a>
    </div>
    <a class="SiteTitle"><span id="projectname">PVRUtils</span> Documentation</a>
   <tbody>
  </div>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="inherits.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Macros</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacepvr.html">pvr</a></li><li class="navelem"><a class="el" href="namespacepvr_1_1utils.html">utils</a></li><li class="navelem"><a class="el" href="structpvr_1_1utils_1_1_renderman_pipeline.html">RendermanPipeline</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="structpvr_1_1utils_1_1_renderman_pipeline-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">pvr::utils::RendermanPipeline Struct Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Part of <a class="el" href="structpvr_1_1utils_1_1_renderman_structure.html" title="Internal class containing the Render Manager tree structure representation of a scene">RendermanStructure</a>. This class is a cooked EffectPipeline, exactly mirroring the PFX pipelines. It is affected on creation time by the meshes that use it (for the Vertex Input configuration) but after that it is used for rendering directly when traversing the scene. 
 <a href="structpvr_1_1utils_1_1_renderman_pipeline.html#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a43b230101243779f5b27d4b63d2ab5a8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structpvr_1_1utils_1_1_renderman_effect.html">RendermanEffect</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpvr_1_1utils_1_1_renderman_pipeline.html#a43b230101243779f5b27d4b63d2ab5a8">backToRendermanEffect</a> ()</td></tr>
<tr class="memdesc:a43b230101243779f5b27d4b63d2ab5a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Navigate (in the Rendering structure) to the Renderman Effect this object belongs to <a href="#a43b230101243779f5b27d4b63d2ab5a8">More...</a><br/></td></tr>
<tr class="separator:a43b230101243779f5b27d4b63d2ab5a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6440cf83e7569a1de682142c00472a27"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structpvr_1_1utils_1_1_renderman_subpass.html">RendermanSubpass</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpvr_1_1utils_1_1_renderman_pipeline.html#a6440cf83e7569a1de682142c00472a27">backToSubpass</a> ()</td></tr>
<tr class="memdesc:a6440cf83e7569a1de682142c00472a27"><td class="mdescLeft">&#160;</td><td class="mdescRight">Navigate (in the Rendering structure) to the Renderman Pass this object belongs to <a href="#a6440cf83e7569a1de682142c00472a27">More...</a><br/></td></tr>
<tr class="separator:a6440cf83e7569a1de682142c00472a27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab28ff5efeebaacb4c41e2dc436e4c78"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structpvr_1_1utils_1_1_renderman_subpass_group.html">RendermanSubpassGroup</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpvr_1_1utils_1_1_renderman_pipeline.html#aab28ff5efeebaacb4c41e2dc436e4c78">backToSubpassGroup</a> ()</td></tr>
<tr class="memdesc:aab28ff5efeebaacb4c41e2dc436e4c78"><td class="mdescLeft">&#160;</td><td class="mdescRight">Navigate (in the Rendering structure) to the Renderman Subpass this object belongs to <a href="#aab28ff5efeebaacb4c41e2dc436e4c78">More...</a><br/></td></tr>
<tr class="separator:aab28ff5efeebaacb4c41e2dc436e4c78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f8721ef884a8f798da417a89f2dad40"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpvr_1_1utils_1_1_renderman_pipeline.html#a9f8721ef884a8f798da417a89f2dad40">createAutomaticModelSemantics</a> (uint32_t useMainModelId=0)</td></tr>
<tr class="memdesc:a9f8721ef884a8f798da417a89f2dad40"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates a list of all the semantics that this pipeline requires, that are defined per-Model (e.g. V/VP matrices, light positions etc). Then, searches the connected asset Model for these semantics, and creates connections between them so that when updateAutomaticSemantics is called, the new values are updated in the semantics so that they can be read (with setUniformPtr, or updating buffers etc.). <a href="#a9f8721ef884a8f798da417a89f2dad40">More...</a><br/></td></tr>
<tr class="separator:a9f8721ef884a8f798da417a89f2dad40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2244dda6e21a7c5993a2bce155771c23"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpvr_1_1utils_1_1_renderman_pipeline.html#a2244dda6e21a7c5993a2bce155771c23">recordUpdateAllUniformEffectSemantics</a> (pvrvk::CommandBufferBase cbuff)</td></tr>
<tr class="memdesc:a2244dda6e21a7c5993a2bce155771c23"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate Uniform updating commands (setUniformPtr) for all Effect scope uniform semantics The commands will read the values from the built-in Semantics objects. <a href="#a2244dda6e21a7c5993a2bce155771c23">More...</a><br/></td></tr>
<tr class="separator:a2244dda6e21a7c5993a2bce155771c23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59791e5d03200ce214eb17b922f9ea8b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpvr_1_1utils_1_1_renderman_pipeline.html#a59791e5d03200ce214eb17b922f9ea8b">recordUpdateAllUniformModelSemantics</a> (pvrvk::CommandBufferBase cbuff)</td></tr>
<tr class="memdesc:a59791e5d03200ce214eb17b922f9ea8b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate Uniform updating commands (setUniformPtr) for all Model scope uniform semantics The commands will read the values from the built-in Semantics objects. <a href="#a59791e5d03200ce214eb17b922f9ea8b">More...</a><br/></td></tr>
<tr class="separator:a59791e5d03200ce214eb17b922f9ea8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeac596793b87da00dbcd6005a8e9c2e3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpvr_1_1utils_1_1_renderman_pipeline.html#aeac596793b87da00dbcd6005a8e9c2e3">recordUpdateAllUniformNodeSemantics</a> (pvrvk::CommandBufferBase cbuff, <a class="el" href="structpvr_1_1utils_1_1_renderman_node.html">RendermanNode</a> &amp;node)</td></tr>
<tr class="memdesc:aeac596793b87da00dbcd6005a8e9c2e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate Uniform updating commands (setUniformPtr) for a specific Node The commands will read the values from the built-in Semantics objects. <a href="#aeac596793b87da00dbcd6005a8e9c2e3">More...</a><br/></td></tr>
<tr class="separator:aeac596793b87da00dbcd6005a8e9c2e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2fa4248e4f1ae9edb478b790a6901209"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpvr_1_1utils_1_1_renderman_pipeline.html#a2fa4248e4f1ae9edb478b790a6901209">recordUpdateAllUniformSemantics</a> (pvrvk::CommandBufferBase cbuff)</td></tr>
<tr class="memdesc:a2fa4248e4f1ae9edb478b790a6901209"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate Uniform updating commands (setUniformPtr) for all the uniform semantics of this pipeline, including Effect and Model semantics, but excluding node semantics. The commands will read the values from the built-in Semantics objects. <a href="#a2fa4248e4f1ae9edb478b790a6901209">More...</a><br/></td></tr>
<tr class="separator:a2fa4248e4f1ae9edb478b790a6901209"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aecb0856cdff82b311d0c2fbc5f68d972"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpvr_1_1utils_1_1_renderman_pipeline.html#aecb0856cdff82b311d0c2fbc5f68d972">recordUpdateUniformCommandsEffectSemantic</a> (pvrvk::CommandBufferBase cbuff, const StringHash &amp;semantic)</td></tr>
<tr class="memdesc:aecb0856cdff82b311d0c2fbc5f68d972"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate Uniform update commands (setUniformPtr) for a specific Effect semantic The commands will read the values from the built-in Semantics objects. <a href="#aecb0856cdff82b311d0c2fbc5f68d972">More...</a><br/></td></tr>
<tr class="separator:aecb0856cdff82b311d0c2fbc5f68d972"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8138825a657d416806183d4da9a6bdfd"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpvr_1_1utils_1_1_renderman_pipeline.html#a8138825a657d416806183d4da9a6bdfd">recordUpdateUniformCommandsModelSemantic</a> (pvrvk::CommandBufferBase cbuff, const StringHash &amp;semantic)</td></tr>
<tr class="memdesc:a8138825a657d416806183d4da9a6bdfd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate Uniform update commands (setUniformPtr) for a specific Model semantic The commands will read the values from the built-in Semantics objects. <a href="#a8138825a657d416806183d4da9a6bdfd">More...</a><br/></td></tr>
<tr class="separator:a8138825a657d416806183d4da9a6bdfd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2306eb0189d962b0f27c444a775ca87d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpvr_1_1utils_1_1_renderman_pipeline.html#a2306eb0189d962b0f27c444a775ca87d">recordUpdateUniformCommandsNodeSemantic</a> (pvrvk::CommandBufferBase cbuff, const StringHash &amp;semantic, <a class="el" href="structpvr_1_1utils_1_1_renderman_node.html">RendermanNode</a> &amp;node)</td></tr>
<tr class="memdesc:a2306eb0189d962b0f27c444a775ca87d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate Uniform update commands (setUniformPtr) for a specific Node semantic <a href="#a2306eb0189d962b0f27c444a775ca87d">More...</a><br/></td></tr>
<tr class="separator:a2306eb0189d962b0f27c444a775ca87d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d0eafe2c10cb607a90b34de6eb40381"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpvr_1_1utils_1_1_renderman_pipeline.html#a1d0eafe2c10cb607a90b34de6eb40381">updateAutomaticModelSemantics</a> (uint32_t swapIdx)</td></tr>
<tr class="memdesc:a1d0eafe2c10cb607a90b34de6eb40381"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update the value of all automatic per-Model semantics. The values are updated immediately in the corresponding buffer, and where the Uniform values are located, but Uniform values will only be visible in rendering when the recorded update uniform commands are executed (i.e. the commands generated by recordUpdateUniformCommandsXXXXX) <a href="#a1d0eafe2c10cb607a90b34de6eb40381">More...</a><br/></td></tr>
<tr class="separator:a1d0eafe2c10cb607a90b34de6eb40381"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1cf36513212e1214e1510e55b8959349"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpvr_1_1utils_1_1_renderman_pipeline.html#a1cf36513212e1214e1510e55b8959349">updateBufferEntryEffectSemantic</a> (const StringHash &amp;semantic, const FreeValue &amp;value, uint32_t swapid, uint32_t dynamicClientId=0)</td></tr>
<tr class="memdesc:a1cf36513212e1214e1510e55b8959349"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update buffer entry effect semantic <a href="#a1cf36513212e1214e1510e55b8959349">More...</a><br/></td></tr>
<tr class="separator:a1cf36513212e1214e1510e55b8959349"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7be91bc562c9c52097deef9929495e8e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpvr_1_1utils_1_1_renderman_pipeline.html#a7be91bc562c9c52097deef9929495e8e">updateBufferEntryEffectSemantics</a> (const StringHash *semantics, const FreeValue *values, uint32_t numSemantics, uint32_t swapid, uint32_t dynamicClientId=0)</td></tr>
<tr class="memdesc:a7be91bc562c9c52097deef9929495e8e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update the value of multiple per-Effect pvrvk::Buffer Entry semantic. The values is updated immediately in the corresponding buffer. The dynamic client id of the buffer (i.e. the Offset into the dynamic buffer) is automatically retrieved from the Node. <a href="#a7be91bc562c9c52097deef9929495e8e">More...</a><br/></td></tr>
<tr class="separator:a7be91bc562c9c52097deef9929495e8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a275b7e7c6e7fa0f203e5c2e22948d881"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpvr_1_1utils_1_1_renderman_pipeline.html#a275b7e7c6e7fa0f203e5c2e22948d881">updateBufferEntryModelSemantic</a> (const StringHash &amp;semantic, const FreeValue &amp;value, uint32_t dynamicSlice=0)</td></tr>
<tr class="memdesc:a275b7e7c6e7fa0f203e5c2e22948d881"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update the value of a per-Model pvrvk::Buffer Entry semantic. The value is updated immediately in the corresponding buffer. <a href="#a275b7e7c6e7fa0f203e5c2e22948d881">More...</a><br/></td></tr>
<tr class="separator:a275b7e7c6e7fa0f203e5c2e22948d881"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f02d397036ff234fa1b4b24b463a847"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpvr_1_1utils_1_1_renderman_pipeline.html#a6f02d397036ff234fa1b4b24b463a847">updateBufferEntryModelSemantics</a> (const StringHash *semantics, const FreeValue *values, uint32_t numSemantics, uint32_t dynamicSlice)</td></tr>
<tr class="memdesc:a6f02d397036ff234fa1b4b24b463a847"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update the value of multiple per-Effect pvrvk::Buffer Entry semantics. The values are updated immediately in the corresponding buffer. <a href="#a6f02d397036ff234fa1b4b24b463a847">More...</a><br/></td></tr>
<tr class="separator:a6f02d397036ff234fa1b4b24b463a847"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9aede89288c82937860b5a9d8bfad12"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpvr_1_1utils_1_1_renderman_pipeline.html#aa9aede89288c82937860b5a9d8bfad12">updateBufferEntryNodeSemantic</a> (const StringHash &amp;semantic, const FreeValue &amp;value, uint32_t swapid, <a class="el" href="structpvr_1_1utils_1_1_renderman_node.html">RendermanNode</a> &amp;node)</td></tr>
<tr class="memdesc:aa9aede89288c82937860b5a9d8bfad12"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update the value of a per-Node pvrvk::Buffer Entry semantic. The value is updated immediately in the corresponding buffer. The dynamic client id of the buffer (i.e. the Offset into the dynamic buffer) is automatically retrieved from the Node. <a href="#aa9aede89288c82937860b5a9d8bfad12">More...</a><br/></td></tr>
<tr class="separator:aa9aede89288c82937860b5a9d8bfad12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab66bace2d899054a0c70899cbfaf631d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpvr_1_1utils_1_1_renderman_pipeline.html#ab66bace2d899054a0c70899cbfaf631d">updateBufferEntryNodeSemantics</a> (const StringHash *semantics, const FreeValue *values, uint32_t numSemantics, uint32_t swapid, <a class="el" href="structpvr_1_1utils_1_1_renderman_node.html">RendermanNode</a> &amp;node)</td></tr>
<tr class="memdesc:ab66bace2d899054a0c70899cbfaf631d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update the values of a per-Node pvrvk::Buffer Entry semantics. The values is updated immediately in the corresponding buffer. The dynamic client id of the buffer (i.e. the Offset into the dynamic buffer) is automatically retrieved from the Node. <a href="#ab66bace2d899054a0c70899cbfaf631d">More...</a><br/></td></tr>
<tr class="separator:ab66bace2d899054a0c70899cbfaf631d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77c5703fe4a950a3f90c3fcb40d87613"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpvr_1_1utils_1_1_renderman_pipeline.html#a77c5703fe4a950a3f90c3fcb40d87613">updateBufferEntrySemantic</a> (const StringHash &amp;semantic, const FreeValue &amp;value, uint32_t swapid, uint32_t dynamicClientId=0)</td></tr>
<tr class="memdesc:a77c5703fe4a950a3f90c3fcb40d87613"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update the value of a per-Effect or Per-Model pvrvk::Buffer Entry semantic. The value is updated immediately in the corresponding buffer. <a href="#a77c5703fe4a950a3f90c3fcb40d87613">More...</a><br/></td></tr>
<tr class="separator:a77c5703fe4a950a3f90c3fcb40d87613"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adad8a898577f0a8d0bc27769b95b1c44"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpvr_1_1utils_1_1_renderman_pipeline.html#adad8a898577f0a8d0bc27769b95b1c44">updateUniformEffectSemantic</a> (const StringHash &amp;semantic, const TypedMem &amp;value)</td></tr>
<tr class="memdesc:adad8a898577f0a8d0bc27769b95b1c44"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update the value of an Effect Uniform semantic (the updated value will be read when the corresponding recorded update command is executed). <a href="#adad8a898577f0a8d0bc27769b95b1c44">More...</a><br/></td></tr>
<tr class="separator:adad8a898577f0a8d0bc27769b95b1c44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58445a5ef6ad908c74e918eba705c61c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpvr_1_1utils_1_1_renderman_pipeline.html#a58445a5ef6ad908c74e918eba705c61c">updateUniformModelSemantic</a> (const StringHash &amp;semantic, const TypedMem &amp;value)</td></tr>
<tr class="memdesc:a58445a5ef6ad908c74e918eba705c61c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update the value of a Model Uniform semantic (the updated value will be read when the corresponding recorded update command is executed). <a href="#a58445a5ef6ad908c74e918eba705c61c">More...</a><br/></td></tr>
<tr class="separator:a58445a5ef6ad908c74e918eba705c61c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12dac10c764b31422cf493358ad69efb"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpvr_1_1utils_1_1_renderman_pipeline.html#a12dac10c764b31422cf493358ad69efb">updateUniformNodeSemantic</a> (const StringHash &amp;semantic, const TypedMem &amp;value, <a class="el" href="structpvr_1_1utils_1_1_renderman_node.html">RendermanNode</a> &amp;node)</td></tr>
<tr class="memdesc:a12dac10c764b31422cf493358ad69efb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update the value of a per-Node Uniform semantic (the updated value will be read when the corresponding recorded update command is executed). <a href="#a12dac10c764b31422cf493358ad69efb">More...</a><br/></td></tr>
<tr class="separator:a12dac10c764b31422cf493358ad69efb"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:abe6439665ebaa611e3d6b3789dd51991"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abe6439665ebaa611e3d6b3789dd51991"></a>
pvrvk::GraphicsPipeline&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpvr_1_1utils_1_1_renderman_pipeline.html#abe6439665ebaa611e3d6b3789dd51991">apiPipeline</a></td></tr>
<tr class="memdesc:abe6439665ebaa611e3d6b3789dd51991"><td class="mdescLeft">&#160;</td><td class="mdescRight">The Vulkan Pipeline object. <br/></td></tr>
<tr class="separator:abe6439665ebaa611e3d6b3789dd51991"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c50a9dc285e17727dcba6b95b364ebe"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9c50a9dc285e17727dcba6b95b364ebe"></a>
std::vector<br class="typebreak"/>
&lt; <a class="el" href="structpvr_1_1utils_1_1_automatic_model_buffer_entry_semantic.html">AutomaticModelBufferEntrySemantic</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpvr_1_1utils_1_1_renderman_pipeline.html#a9c50a9dc285e17727dcba6b95b364ebe">automaticModelBufferEntrySemantics</a></td></tr>
<tr class="memdesc:a9c50a9dc285e17727dcba6b95b364ebe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Automatic Model /pvrvk::Buffer Entry semantics generated for this pipeline (Node scope semantics can be found in nodes) <br/></td></tr>
<tr class="separator:a9c50a9dc285e17727dcba6b95b364ebe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac219689a8480f1ae4dae7cee85b03af0"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac219689a8480f1ae4dae7cee85b03af0"></a>
std::vector<br class="typebreak"/>
&lt; <a class="el" href="structpvr_1_1utils_1_1_automatic_model_uniform_semantic.html">AutomaticModelUniformSemantic</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpvr_1_1utils_1_1_renderman_pipeline.html#ac219689a8480f1ae4dae7cee85b03af0">automaticModelUniformSemantics</a></td></tr>
<tr class="memdesc:ac219689a8480f1ae4dae7cee85b03af0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Automatic Model /Uniform semantics generated for this pipeline (Node scope semantics can be found in nodes) <br/></td></tr>
<tr class="separator:ac219689a8480f1ae4dae7cee85b03af0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31ba35967245856169966f77b3de6062"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a31ba35967245856169966f77b3de6062"></a>
std::map&lt; StringHash, <br class="typebreak"/>
<a class="el" href="structpvr_1_1utils_1_1_renderman_buffer_binding.html">RendermanBufferBinding</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpvr_1_1utils_1_1_renderman_pipeline.html#a31ba35967245856169966f77b3de6062">bufferBindings</a></td></tr>
<tr class="memdesc:a31ba35967245856169966f77b3de6062"><td class="mdescLeft">&#160;</td><td class="mdescRight">The bindings of the buffers (references to the buffer objects) <br/></td></tr>
<tr class="separator:a31ba35967245856169966f77b3de6062"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a20a691b5986fb9c97aa30e1ebc70f4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5a20a691b5986fb9c97aa30e1ebc70f4"></a>
std::map&lt; StringHash, <br class="typebreak"/>
<a class="el" href="structpvr_1_1utils_1_1_buffer_entry_semantic.html">BufferEntrySemantic</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpvr_1_1utils_1_1_renderman_pipeline.html#a5a20a691b5986fb9c97aa30e1ebc70f4">bufferEntrySemantics</a></td></tr>
<tr class="memdesc:a5a20a691b5986fb9c97aa30e1ebc70f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Connection of buffer entries to semantics. <br/></td></tr>
<tr class="separator:a5a20a691b5986fb9c97aa30e1ebc70f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30d7f6cd50fc600306b7f80608e55919"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a30d7f6cd50fc600306b7f80608e55919"></a>
std::map&lt; StringHash, <br class="typebreak"/>
<a class="el" href="classpvr_1_1utils_1_1_structured_buffer_view.html">utils::StructuredBufferView</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpvr_1_1utils_1_1_renderman_pipeline.html#a30d7f6cd50fc600306b7f80608e55919">bufferSemantics</a></td></tr>
<tr class="memdesc:a30d7f6cd50fc600306b7f80608e55919"><td class="mdescLeft">&#160;</td><td class="mdescRight">The corresponding buffer objects. <br/></td></tr>
<tr class="separator:a30d7f6cd50fc600306b7f80608e55919"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6afc3db59d2601b214967fafaf0fc76d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6afc3db59d2601b214967fafaf0fc76d"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpvr_1_1utils_1_1_renderman_pipeline.html#a6afc3db59d2601b214967fafaf0fc76d">descSetExists</a> [4]</td></tr>
<tr class="memdesc:a6afc3db59d2601b214967fafaf0fc76d"><td class="mdescLeft">&#160;</td><td class="mdescRight">If it does not "exist", do not do anything for it... <br/></td></tr>
<tr class="separator:a6afc3db59d2601b214967fafaf0fc76d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89201fdddf9248482afee0c1b9d5406a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a89201fdddf9248482afee0c1b9d5406a"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpvr_1_1utils_1_1_renderman_pipeline.html#a89201fdddf9248482afee0c1b9d5406a">descSetIsFixed</a> [4]</td></tr>
<tr class="memdesc:a89201fdddf9248482afee0c1b9d5406a"><td class="mdescLeft">&#160;</td><td class="mdescRight">If it is "fixed", it means that it is set by the PFX and no members of it are exported through semantics. <br/></td></tr>
<tr class="separator:a89201fdddf9248482afee0c1b9d5406a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6b99d38f45407247bccbce5273c3989"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac6b99d38f45407247bccbce5273c3989"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpvr_1_1utils_1_1_renderman_pipeline.html#ac6b99d38f45407247bccbce5273c3989">descSetIsMultibuffered</a> [4]</td></tr>
<tr class="memdesc:ac6b99d38f45407247bccbce5273c3989"><td class="mdescLeft">&#160;</td><td class="mdescRight">If it is "multibuffered", it means that it points to different buffers based on the swapchain index. <br/></td></tr>
<tr class="separator:ac6b99d38f45407247bccbce5273c3989"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f3fe5318a66dd3defe98e20be6ec004"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7f3fe5318a66dd3defe98e20be6ec004"></a>
Multi&lt; pvrvk::DescriptorSet &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpvr_1_1utils_1_1_renderman_pipeline.html#a7f3fe5318a66dd3defe98e20be6ec004">fixedDescSet</a> [4]</td></tr>
<tr class="memdesc:a7f3fe5318a66dd3defe98e20be6ec004"><td class="mdescLeft">&#160;</td><td class="mdescRight">Storage for the Fixed descriptor sets. A set is fixed if it contains no members with semantics. <br/></td></tr>
<tr class="separator:a7f3fe5318a66dd3defe98e20be6ec004"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d15fc81ac6824c2a074f2bc97ea7d7f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1d15fc81ac6824c2a074f2bc97ea7d7f"></a>
StringHash&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpvr_1_1utils_1_1_renderman_pipeline.html#a1d15fc81ac6824c2a074f2bc97ea7d7f">name</a></td></tr>
<tr class="memdesc:a1d15fc81ac6824c2a074f2bc97ea7d7f"><td class="mdescLeft">&#160;</td><td class="mdescRight">The name of the pipeline object. <br/></td></tr>
<tr class="separator:a1d15fc81ac6824c2a074f2bc97ea7d7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c210be0f7f7f0cf75bd7b63f69fa713"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5c210be0f7f7f0cf75bd7b63f69fa713"></a>
<a class="el" href="structpvr_1_1effect_1_1_pipeline_def.html">effect::PipelineDef</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpvr_1_1utils_1_1_renderman_pipeline.html#a5c210be0f7f7f0cf75bd7b63f69fa713">pipelineInfo</a></td></tr>
<tr class="memdesc:a5c210be0f7f7f0cf75bd7b63f69fa713"><td class="mdescLeft">&#160;</td><td class="mdescRight">Additional info on the pipeline. <br/></td></tr>
<tr class="separator:a5c210be0f7f7f0cf75bd7b63f69fa713"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ea85eabd5176419e0ad7f929ffdfd93"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8ea85eabd5176419e0ad7f929ffdfd93"></a>
struct <a class="el" href="structpvr_1_1utils_1_1_renderman_subpass_group.html">RendermanSubpassGroup</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpvr_1_1utils_1_1_renderman_pipeline.html#a8ea85eabd5176419e0ad7f929ffdfd93">subpassGroup_</a></td></tr>
<tr class="memdesc:a8ea85eabd5176419e0ad7f929ffdfd93"><td class="mdescLeft">&#160;</td><td class="mdescRight">The Subpass Group this pipeline belongs to. <br/></td></tr>
<tr class="separator:a8ea85eabd5176419e0ad7f929ffdfd93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae424bd27df90238138007b4788d8ba03"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae424bd27df90238138007b4788d8ba03"></a>
std::vector<br class="typebreak"/>
&lt; <a class="el" href="structpvr_1_1utils_1_1_renderman_subpass_material.html">RendermanSubpassMaterial</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpvr_1_1utils_1_1_renderman_pipeline.html#ae424bd27df90238138007b4788d8ba03">subpassMaterials</a></td></tr>
<tr class="memdesc:ae424bd27df90238138007b4788d8ba03"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pointers to the Subpass Materials that this pipeline makes use of. <br/></td></tr>
<tr class="separator:ae424bd27df90238138007b4788d8ba03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7c085a37d7b6be2dfc216131e223b12"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae7c085a37d7b6be2dfc216131e223b12"></a>
pvr::ContiguousMap&lt; StringHash, <br class="typebreak"/>
<a class="el" href="structpvr_1_1utils_1_1_uniform_semantic.html">UniformSemantic</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpvr_1_1utils_1_1_renderman_pipeline.html#ae7c085a37d7b6be2dfc216131e223b12">uniformSemantics</a></td></tr>
<tr class="memdesc:ae7c085a37d7b6be2dfc216131e223b12"><td class="mdescLeft">&#160;</td><td class="mdescRight">Connection of uniforms to semantics. <br/></td></tr>
<tr class="separator:ae7c085a37d7b6be2dfc216131e223b12"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Part of <a class="el" href="structpvr_1_1utils_1_1_renderman_structure.html" title="Internal class containing the Render Manager tree structure representation of a scene">RendermanStructure</a>. This class is a cooked EffectPipeline, exactly mirroring the PFX pipelines. It is affected on creation time by the meshes that use it (for the Vertex Input configuration) but after that it is used for rendering directly when traversing the scene.</p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a43b230101243779f5b27d4b63d2ab5a8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structpvr_1_1utils_1_1_renderman_effect.html">RendermanEffect</a>&amp; pvr::utils::RendermanPipeline::backToRendermanEffect </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Navigate (in the Rendering structure) to the Renderman Effect this object belongs to</p>
<dl class="section return"><dt>Returns</dt><dd>A reference to the Renderman Effect this object belongs to</dd></dl>

</div>
</div>
<a class="anchor" id="a6440cf83e7569a1de682142c00472a27"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structpvr_1_1utils_1_1_renderman_subpass.html">RendermanSubpass</a>&amp; pvr::utils::RendermanPipeline::backToSubpass </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Navigate (in the Rendering structure) to the Renderman Pass this object belongs to</p>
<dl class="section return"><dt>Returns</dt><dd>A reference to the Renderman Pass this object belongs to</dd></dl>

</div>
</div>
<a class="anchor" id="aab28ff5efeebaacb4c41e2dc436e4c78"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structpvr_1_1utils_1_1_renderman_subpass_group.html">RendermanSubpassGroup</a>&amp; pvr::utils::RendermanPipeline::backToSubpassGroup </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Navigate (in the Rendering structure) to the Renderman Subpass this object belongs to</p>
<dl class="section return"><dt>Returns</dt><dd>A reference to the Renderman Subpass this object belongs to</dd></dl>

</div>
</div>
<a class="anchor" id="a9f8721ef884a8f798da417a89f2dad40"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool pvr::utils::RendermanPipeline::createAutomaticModelSemantics </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>useMainModelId</em> = <code>0</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generates a list of all the semantics that this pipeline requires, that are defined per-Model (e.g. V/VP matrices, light positions etc). Then, searches the connected asset Model for these semantics, and creates connections between them so that when updateAutomaticSemantics is called, the new values are updated in the semantics so that they can be read (with setUniformPtr, or updating buffers etc.).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">useMainModelId</td><td>The model ID to use to read the values from. Default O (the first model). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if successful, false on any error</dd></dl>

</div>
</div>
<a class="anchor" id="a2244dda6e21a7c5993a2bce155771c23"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pvr::utils::RendermanPipeline::recordUpdateAllUniformEffectSemantics </td>
          <td>(</td>
          <td class="paramtype">pvrvk::CommandBufferBase&#160;</td>
          <td class="paramname"><em>cbuff</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generate Uniform updating commands (setUniformPtr) for all Effect scope uniform semantics The commands will read the values from the built-in Semantics objects.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cbuff</td><td>A command buffer to record the commands to</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a59791e5d03200ce214eb17b922f9ea8b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pvr::utils::RendermanPipeline::recordUpdateAllUniformModelSemantics </td>
          <td>(</td>
          <td class="paramtype">pvrvk::CommandBufferBase&#160;</td>
          <td class="paramname"><em>cbuff</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generate Uniform updating commands (setUniformPtr) for all Model scope uniform semantics The commands will read the values from the built-in Semantics objects.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cbuff</td><td>A command buffer to record the commands to</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aeac596793b87da00dbcd6005a8e9c2e3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pvr::utils::RendermanPipeline::recordUpdateAllUniformNodeSemantics </td>
          <td>(</td>
          <td class="paramtype">pvrvk::CommandBufferBase&#160;</td>
          <td class="paramname"><em>cbuff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structpvr_1_1utils_1_1_renderman_node.html">RendermanNode</a> &amp;&#160;</td>
          <td class="paramname"><em>node</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generate Uniform updating commands (setUniformPtr) for a specific Node The commands will read the values from the built-in Semantics objects.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cbuff</td><td>A command buffer to record the commands to</td></tr>
    <tr><td class="paramname">node</td><td>The node to record commands for</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a2fa4248e4f1ae9edb478b790a6901209"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pvr::utils::RendermanPipeline::recordUpdateAllUniformSemantics </td>
          <td>(</td>
          <td class="paramtype">pvrvk::CommandBufferBase&#160;</td>
          <td class="paramname"><em>cbuff</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generate Uniform updating commands (setUniformPtr) for all the uniform semantics of this pipeline, including Effect and Model semantics, but excluding node semantics. The commands will read the values from the built-in Semantics objects.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cbuff</td><td>A command buffer to record the commands to</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aecb0856cdff82b311d0c2fbc5f68d972"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool pvr::utils::RendermanPipeline::recordUpdateUniformCommandsEffectSemantic </td>
          <td>(</td>
          <td class="paramtype">pvrvk::CommandBufferBase&#160;</td>
          <td class="paramname"><em>cbuff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const StringHash &amp;&#160;</td>
          <td class="paramname"><em>semantic</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generate Uniform update commands (setUniformPtr) for a specific Effect semantic The commands will read the values from the built-in Semantics objects.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cbuff</td><td>A command buffer to record the commands to</td></tr>
    <tr><td class="paramname">semantic</td><td>The effect semantic to update</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Return true on success</dd></dl>

</div>
</div>
<a class="anchor" id="a8138825a657d416806183d4da9a6bdfd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool pvr::utils::RendermanPipeline::recordUpdateUniformCommandsModelSemantic </td>
          <td>(</td>
          <td class="paramtype">pvrvk::CommandBufferBase&#160;</td>
          <td class="paramname"><em>cbuff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const StringHash &amp;&#160;</td>
          <td class="paramname"><em>semantic</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generate Uniform update commands (setUniformPtr) for a specific Model semantic The commands will read the values from the built-in Semantics objects.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cbuff</td><td>A command buffer to record the commands to</td></tr>
    <tr><td class="paramname">semantic</td><td>The Model semantic to update</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true on success</dd></dl>

</div>
</div>
<a class="anchor" id="a2306eb0189d962b0f27c444a775ca87d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool pvr::utils::RendermanPipeline::recordUpdateUniformCommandsNodeSemantic </td>
          <td>(</td>
          <td class="paramtype">pvrvk::CommandBufferBase&#160;</td>
          <td class="paramname"><em>cbuff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const StringHash &amp;&#160;</td>
          <td class="paramname"><em>semantic</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structpvr_1_1utils_1_1_renderman_node.html">RendermanNode</a> &amp;&#160;</td>
          <td class="paramname"><em>node</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generate Uniform update commands (setUniformPtr) for a specific Node semantic</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cbuff</td><td>A command buffer to record the commands to</td></tr>
    <tr><td class="paramname">semantic</td><td>The effect semantic to update</td></tr>
    <tr><td class="paramname">node</td><td>The node whose semantics to update</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Return true on success</dd></dl>

</div>
</div>
<a class="anchor" id="a1d0eafe2c10cb607a90b34de6eb40381"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool pvr::utils::RendermanPipeline::updateAutomaticModelSemantics </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>swapIdx</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Update the value of all automatic per-Model semantics. The values are updated immediately in the corresponding buffer, and where the Uniform values are located, but Uniform values will only be visible in rendering when the recorded update uniform commands are executed (i.e. the commands generated by recordUpdateUniformCommandsXXXXX)</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">swapIdx</td><td>The swapchain index to generate commands for (ignored for Uniforms)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Return true on success, false on any error</dd></dl>

</div>
</div>
<a class="anchor" id="a1cf36513212e1214e1510e55b8959349"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool pvr::utils::RendermanPipeline::updateBufferEntryEffectSemantic </td>
          <td>(</td>
          <td class="paramtype">const StringHash &amp;&#160;</td>
          <td class="paramname"><em>semantic</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const FreeValue &amp;&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>swapid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>dynamicClientId</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Update buffer entry effect semantic</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">semantic</td><td>Effect semantic to update</td></tr>
    <tr><td class="paramname">value</td><td>New value</td></tr>
    <tr><td class="paramname">swapid</td><td>swapchain id</td></tr>
    <tr><td class="paramname">dynamicClientId</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Return true on success</dd></dl>

</div>
</div>
<a class="anchor" id="a7be91bc562c9c52097deef9929495e8e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool pvr::utils::RendermanPipeline::updateBufferEntryEffectSemantics </td>
          <td>(</td>
          <td class="paramtype">const StringHash *&#160;</td>
          <td class="paramname"><em>semantics</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const FreeValue *&#160;</td>
          <td class="paramname"><em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>numSemantics</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>swapid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>dynamicClientId</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Update the value of multiple per-Effect pvrvk::Buffer Entry semantic. The values is updated immediately in the corresponding buffer. The dynamic client id of the buffer (i.e. the Offset into the dynamic buffer) is automatically retrieved from the Node.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">semantics</td><td>A c-style array of Semantic names. Must point to at least <em>numSemantics</em> elements</td></tr>
    <tr><td class="paramname">values</td><td>A c-style array of the Values to set. Must point to at least <em>numSemantics</em> elements</td></tr>
    <tr><td class="paramname">numSemantics</td><td>The number of semantics to set</td></tr>
    <tr><td class="paramname">swapid</td><td>The current swapchain index</td></tr>
    <tr><td class="paramname">dynamicClientId</td><td>(Optional) In the case of a Dynamic buffer, the "dynamic client id" is the index of the "slice" of the buffer. Built-in functionality does NOT use this parameter for either Effect or Model semantics. Default 0.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Return true on success, false if the semantic is not found.</dd></dl>

</div>
</div>
<a class="anchor" id="a275b7e7c6e7fa0f203e5c2e22948d881"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool pvr::utils::RendermanPipeline::updateBufferEntryModelSemantic </td>
          <td>(</td>
          <td class="paramtype">const StringHash &amp;&#160;</td>
          <td class="paramname"><em>semantic</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const FreeValue &amp;&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>dynamicSlice</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Update the value of a per-Model pvrvk::Buffer Entry semantic. The value is updated immediately in the corresponding buffer.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">semantic</td><td>The Model semantic to update</td></tr>
    <tr><td class="paramname">value</td><td>The new value to set</td></tr>
    <tr><td class="paramname">dynamicSlice</td><td>(Optional) In the case of a Dynamic buffer, the "dynamic slice" or "dynamic
client id" is the index in the "slice" of the buffer. Default 0.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Return true on success, false if the semantic is not found.</dd></dl>

</div>
</div>
<a class="anchor" id="a6f02d397036ff234fa1b4b24b463a847"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool pvr::utils::RendermanPipeline::updateBufferEntryModelSemantics </td>
          <td>(</td>
          <td class="paramtype">const StringHash *&#160;</td>
          <td class="paramname"><em>semantics</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const FreeValue *&#160;</td>
          <td class="paramname"><em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>numSemantics</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>dynamicSlice</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Update the value of multiple per-Effect pvrvk::Buffer Entry semantics. The values are updated immediately in the corresponding buffer.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">semantics</td><td>The Effect semantic to update</td></tr>
    <tr><td class="paramname">values</td><td>The new values to set</td></tr>
    <tr><td class="paramname">numSemantics</td><td>The number of semantics to set.</td></tr>
    <tr><td class="paramname">dynamicSlice</td><td>(Optional) In the case of a Dynamic buffer, the "dynamic slice", or "dynamic client id" is the index of the "slice" of the buffer.Default 0. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Return true on success, false if the semantic is not found.</dd></dl>

</div>
</div>
<a class="anchor" id="aa9aede89288c82937860b5a9d8bfad12"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool pvr::utils::RendermanPipeline::updateBufferEntryNodeSemantic </td>
          <td>(</td>
          <td class="paramtype">const StringHash &amp;&#160;</td>
          <td class="paramname"><em>semantic</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const FreeValue &amp;&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>swapid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structpvr_1_1utils_1_1_renderman_node.html">RendermanNode</a> &amp;&#160;</td>
          <td class="paramname"><em>node</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Update the value of a per-Node pvrvk::Buffer Entry semantic. The value is updated immediately in the corresponding buffer. The dynamic client id of the buffer (i.e. the Offset into the dynamic buffer) is automatically retrieved from the Node.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">semantic</td><td>The Node semantic to update</td></tr>
    <tr><td class="paramname">value</td><td>The new value to set</td></tr>
    <tr><td class="paramname">swapid</td><td>The current swapchain index</td></tr>
    <tr><td class="paramname">node</td><td>The <a class="el" href="structpvr_1_1utils_1_1_renderman_node.html" title="Part of RendermanStructure. This class matches everything together: A pipelineMaterial, with a RendermanMeshSubpass, to render. Unique per rendering node AND mesh bone batch combination. NOTE: if bone batching is used, then multiple nodes will be generated per meshnode. Contains a reference to the mesh, the material, and also contains the dynamic offsets required to render with it. Loop through those to render. ">RendermanNode</a> for which to set the value.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Return true on success, false if the semantic is not found.</dd></dl>

</div>
</div>
<a class="anchor" id="ab66bace2d899054a0c70899cbfaf631d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool pvr::utils::RendermanPipeline::updateBufferEntryNodeSemantics </td>
          <td>(</td>
          <td class="paramtype">const StringHash *&#160;</td>
          <td class="paramname"><em>semantics</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const FreeValue *&#160;</td>
          <td class="paramname"><em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>numSemantics</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>swapid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structpvr_1_1utils_1_1_renderman_node.html">RendermanNode</a> &amp;&#160;</td>
          <td class="paramname"><em>node</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Update the values of a per-Node pvrvk::Buffer Entry semantics. The values is updated immediately in the corresponding buffer. The dynamic client id of the buffer (i.e. the Offset into the dynamic buffer) is automatically retrieved from the Node.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">semantics</td><td>The Node semantics to update. C-style array</td></tr>
    <tr><td class="paramname">values</td><td>The new values to set. C-style array</td></tr>
    <tr><td class="paramname">numSemantics</td><td>The number of semantics in <em>values</em>  and <em>semantics</em> </td></tr>
    <tr><td class="paramname">swapid</td><td>The current swapchain index</td></tr>
    <tr><td class="paramname">node</td><td>The <a class="el" href="structpvr_1_1utils_1_1_renderman_node.html" title="Part of RendermanStructure. This class matches everything together: A pipelineMaterial, with a RendermanMeshSubpass, to render. Unique per rendering node AND mesh bone batch combination. NOTE: if bone batching is used, then multiple nodes will be generated per meshnode. Contains a reference to the mesh, the material, and also contains the dynamic offsets required to render with it. Loop through those to render. ">RendermanNode</a> for which to set the value.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Return true on success, false if the semantic is not found.</dd></dl>

</div>
</div>
<a class="anchor" id="a77c5703fe4a950a3f90c3fcb40d87613"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool pvr::utils::RendermanPipeline::updateBufferEntrySemantic </td>
          <td>(</td>
          <td class="paramtype">const StringHash &amp;&#160;</td>
          <td class="paramname"><em>semantic</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const FreeValue &amp;&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>swapid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>dynamicClientId</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Update the value of a per-Effect or Per-Model pvrvk::Buffer Entry semantic. The value is updated immediately in the corresponding buffer.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">semantic</td><td>The Effect or Model semantic to update</td></tr>
    <tr><td class="paramname">value</td><td>The new value to set</td></tr>
    <tr><td class="paramname">swapid</td><td>The current swapchain index</td></tr>
    <tr><td class="paramname">dynamicClientId</td><td>(Optional) In the case of a Dynamic buffer, the "dynamic client id" is the index of the "slice" of the buffer. Built-in functionality does NOT use this parameter for either Effect or Model semantics. Default 0.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Return true on success, false if the semantic is not found.</dd></dl>

</div>
</div>
<a class="anchor" id="adad8a898577f0a8d0bc27769b95b1c44"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool pvr::utils::RendermanPipeline::updateUniformEffectSemantic </td>
          <td>(</td>
          <td class="paramtype">const StringHash &amp;&#160;</td>
          <td class="paramname"><em>semantic</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TypedMem &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Update the value of an Effect Uniform semantic (the updated value will be read when the corresponding recorded update command is executed).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">semantic</td><td>The Effect semantic to update</td></tr>
    <tr><td class="paramname">value</td><td>The new value, contained in a TypedMem object.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true on success, false if the semantic is not found</dd></dl>

</div>
</div>
<a class="anchor" id="a58445a5ef6ad908c74e918eba705c61c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool pvr::utils::RendermanPipeline::updateUniformModelSemantic </td>
          <td>(</td>
          <td class="paramtype">const StringHash &amp;&#160;</td>
          <td class="paramname"><em>semantic</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TypedMem &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Update the value of a Model Uniform semantic (the updated value will be read when the corresponding recorded update command is executed).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">semantic</td><td>The Model semantic to update</td></tr>
    <tr><td class="paramname">value</td><td>The new value, contained in a TypedMem object.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true on success, false if the semantic is not found</dd></dl>

</div>
</div>
<a class="anchor" id="a12dac10c764b31422cf493358ad69efb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool pvr::utils::RendermanPipeline::updateUniformNodeSemantic </td>
          <td>(</td>
          <td class="paramtype">const StringHash &amp;&#160;</td>
          <td class="paramname"><em>semantic</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TypedMem &amp;&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structpvr_1_1utils_1_1_renderman_node.html">RendermanNode</a> &amp;&#160;</td>
          <td class="paramname"><em>node</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Update the value of a per-Node Uniform semantic (the updated value will be read when the corresponding recorded update command is executed).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">semantic</td><td>The Node semantic to update</td></tr>
    <tr><td class="paramname">value</td><td>The new value, contained in a TypedMem object.</td></tr>
    <tr><td class="paramname">node</td><td>The Node for which to update the uniform</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true on success, false if the semantic is not found</dd></dl>

</div>
</div>
<hr/>The documentation for this struct was generated from the following file:<ul>
<li>/usr/buildxl/buildroot/sdk/branch/Framework/PVRUtils/Vulkan/<a class="el" href="_render_manager_vk_8h_source.html">RenderManagerVk.h</a></li>
</ul>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.4-->
<!-- start footer part (NON TREEVIEW ONLY!!) -->
<!--BEGIN GENERATE_TREEVIEW-->
<div id="FooterMainContainer">
	<div id="FooterContainer">
		<div class="footerlogo">
			<a href="http://www.imgtec.com" target="_blank"><img src="img-footer-logo-grey.png" width="100%" height="100%" border="none" /></a>
		</div>
		<div class="copyright"><p>&copy; Imagination Technologies Limited<br> All rights reserved</p></div>
	</div>
</div>
</body>
</html>
