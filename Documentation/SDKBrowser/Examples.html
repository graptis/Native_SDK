<!DOCTYPE html>
<html lang="en">
<head>
	<title>The PowerVR SDK Browser</title>
	<meta charset="UTF-8" />
	<link rel="stylesheet" type="text/css" href="style.css">
    <link rel="icon" type="image/png" href="./images/img-icon.png">
</head>

<body>
	<div id="GlobalHeaderContainer">
		<div id="GlobalHeader">
			<div class="logo">
				<a href="http://www.powervrinsider.com" target="_blank"><img src="./images/PVRlogo.png" width="40%" height="40%" /></a>
            </div>
			<div class="sitetitle">PowerVR SDK Browser</div>
		</div>
	</div>
	<div id="NavContainer">
		<nav>
			<div class="navlink">
				<a href="Home.html">Home</a>
			</div>
			<div class="navlink">
				<a href="GettingStarted.html">Getting Started</a>
			</div>
			<div class="navlink">
				<a href="Examples.html" class="current">Examples</a>
			</div>
			<div class="navlink">
				<a href="Framework.html">Framework</a>
			</div>
			<div class="navlink">
				<a href="Documentation.html">Documentation</a>
			</div>
			<div class="navlink">
				<a href="PowerVRTools.html">PowerVR Tools</a>
			</div>
			<div class="navlink">
				<a href="Licence.html">EULA</a>
			</div>
			<div class="navlink">
				<a href="Contact.html">Contact Us</a>
			</div>
		</nav>
	</div>

<!--API_TAB-->

    <div class="content">
        <div id="Section" class="section">
<!--API_DESCRIPTION-->
<div class="content">	<h1>Examples</h1>	<p>This section of the PowerVR SDK Browser provides a range of example applications and tutorials that are implemented across multiple APIs. These examples include optimized and thoroughly commented code. They also make consistent use of our Framework and provide a wealth of techniques for the novice user to the advanced developer.</p><p>The examples are classified into Beginner, Intermediate and Advanced categories. Browse to the desired example to view its details. Check the example description to know which APIs are supported by any specific example. Additionally, use the <a href="../../Examples" target="_blank">Examples</a> folder supplied with this SDK to explore them.</p>	<p><em><strong>Note:</strong> Some of the examples do not handle screen rotation, in order to keep the code as simple as possible. On devices with a portrait display the example images may appear stretched.</em></p>	<p> Controls are defined as follows for mouse, touch screen and keyboard:<br>	Action1: <i>Click/Touch center of screen, Space, Enter.</i><br>	Action2: <i>Click/Touch left 30% of screen, Key "1".</i><br>	Action3: <i>Click/Touch right 30% of screen, Key "2".</i><br>	Left/Right/Up/Down: <i>Swipe/Drag Left/Right/Up/Down, Cursor keys.</i><br>	Quit:<i> Home/Back button,Close window, Escape/Q key</i><br>	</p>	<br></div>		<p><a href="#Beginner" class="link">Beginner</a>  |  <a href="#Intermediate" class="link">Intermediate</a>  |  <a href="#Advanced" class="link">Advanced</a>|  <a href="#Advanced" class="link">Navigation</a></p>
<!--EXAMPLE_TEMPLATE-->


<div id="Beginner"><h2>Beginner</h2><ul class="accordion">

				<li id="HelloAPI">
					<div class="title">
						<a href="../../Examples//Beginner/01_HelloAPI/HelloAPI.png" title="Click to view image" target="_blank"><img class="examplesmall" src="../../Examples//Beginner/01_HelloAPI/HelloAPI.png" alt="HelloAPI" /></a>
						<input type="checkbox" id="HelloAPIFull2">
							<label for="HelloAPIFull2" title="Click for more information"><h3>HelloAPI</h3></label>
							<div class="ShortDescription" id="TexturingShort"><p>Draw a basic triangle to the screen.
</p><small><b>Vulkan, OpenGL ES 2.0
</small></b></div>
							<br>
							<div class="FullDescription" id="TexturingFull">
								<p><strong>Description:</strong></p>
								<p>A basic tutorial that guides the user, step-by-step, through the process of initializing a window using the "raw" API, (Vulkan or OpenGL ES 2), drawing a triangle with a simple shader, and then terminating the window (depending on the platform, either after a few seconds, or when the user closes the window).
</p>
								<p><strong>Controls:</strong></p>
								<p><p>	Quit	:	Close the application</p></p>
								<p><strong>Links:</strong></p>
								<p class="source"><a href="../../Examples//Beginner/01_HelloAPI/" target="_blank">HelloAPI source</a>  |  <a href="" target="_blank"></a></p>
							</div>
						</input>
					</div>
				</li>
				<li id="IntroducingPVRShell">
					<div class="title">
						<a href="../../Examples//Beginner/02_IntroducingPVRShell/IntroducingPVRShell.png" title="Click to view image" target="_blank"><img class="examplesmall" src="../../Examples//Beginner/02_IntroducingPVRShell/IntroducingPVRShell.png" alt="IntroducingPVRShell" /></a>
						<input type="checkbox" id="IntroducingPVRShellFull2">
							<label for="IntroducingPVRShellFull2" title="Click for more information"><h3>IntroducingPVRShell</h3></label>
							<div class="ShortDescription" id="TexturingShort"><p>This training course introduces the PVRShell library.
</p><small><b>Vulkan, OpenGL ES 2.0+
</small></b></div>
							<br>
							<div class="FullDescription" id="TexturingFull">
								<p><strong>Description:</strong></p>
								<p>This demo shows basic use of the PVRShell library.  The PowerVR Shell handles all OS specific initialisation code, and has several built in command line features which allow for the specifying of attributes such as window width/height, quitting after a number of frames, taking screenshots and others. When using the PVR Shell, the application uses the class 'pvr::Shell' as its base class, and is constructed and returned from a 'pvr::newDemo' function.
</p>
								<p><strong>Controls:</strong></p>
								<p><p>	Quit	:	Close the application</p></p>
								<p><strong>Links:</strong></p>
								<p class="source"><a href="../../Examples//Beginner/02_IntroducingPVRShell/" target="_blank">IntroducingPVRShell source</a>  |  <a href="" target="_blank"></a></p>
							</div>
						</input>
					</div>
				</li>
				<li id="IntroducingPVRUtils">
					<div class="title">
						<a href="../../Examples//Beginner/03_IntroducingPVRUtils/IntroducingPVRUtils.png" title="Click to view image" target="_blank"><img class="examplesmall" src="../../Examples//Beginner/03_IntroducingPVRUtils/IntroducingPVRUtils.png" alt="IntroducingPVRUtils" /></a>
						<input type="checkbox" id="IntroducingPVRUtilsFull2">
							<label for="IntroducingPVRUtilsFull2" title="Click for more information"><h3>IntroducingPVRUtils</h3></label>
							<div class="ShortDescription" id="TexturingShort"><p>Render a .pod scene using a a simple vertex and fragment shader making use of the PVRUtils library for various utility functions.
</p><small><b>Vulkan, OpenGL ES 2.0+
</small></b></div>
							<br>
							<div class="FullDescription" id="TexturingFull">
								<p><strong>Description:</strong></p>
								<p>This training course demonstrates how to make the most of the PVRUtils library for handling various api agnostic utility functions such as loading shaders and creating buffers. Various api specific utility functions are also provided such as the OGLES specific EGL context creation and Vulkan swapchain and instance creation helper. The PVRUtils library is also used to display simple text on screen.
</p>
								<p><strong>Controls:</strong></p>
								<p><p>	Quit	:	Close the application</p></p>
								<p><strong>Links:</strong></p>
								<p class="source"><a href="../../Examples//Beginner/03_IntroducingPVRUtils/" target="_blank">IntroducingPVRUtils source</a>  |  <a href="" target="_blank"></a></p>
							</div>
						</input>
					</div>
				</li>
				<li id="IntroducingUIRenderer">
					<div class="title">
						<a href="../../Examples//Beginner/04_IntroducingUIRenderer/IntroducingUIRenderer.png" title="Click to view image" target="_blank"><img class="examplesmall" src="../../Examples//Beginner/04_IntroducingUIRenderer/IntroducingUIRenderer.png" alt="IntroducingUIRenderer" /></a>
						<input type="checkbox" id="IntroducingUIRendererFull2">
							<label for="IntroducingUIRendererFull2" title="Click for more information"><h3>IntroducingUIRenderer</h3></label>
							<div class="ShortDescription" id="TexturingShort"><p>This example introduces the UIRenderer from the PVRUtils library to do advanced Text tasks.
</p><small><b>Vulkan, OpenGL ES 2.0
</small></b></div>
							<br>
							<div class="FullDescription" id="TexturingFull">
								<p><strong>Description:</strong></p>
								<p>The UIRenderer allows the user to create "Sprites" (2D elements) which can be grouped in 2D and/or 3D groups to be displayed
as UI's or world text. 2D transformations (pixel and/or NDC coordinates) both single and in a group, anchoring on different 
parts of the screen or the group and 3D transformations of groups of sprites are all possible.
In this example, UIRendererer is used to display images and Unicode text, screen aligned and with 3D transformations. 
</p>
								<p><strong>Controls:</strong></p>
								<p><p>	Quit	:	Close the application</p></p>
								<p><strong>Links:</strong></p>
								<p class="source"><a href="../../Examples//Beginner/04_IntroducingUIRenderer/" target="_blank">IntroducingUIRenderer source</a>  |  <a href="" target="_blank"></a></p>
							</div>
						</input>
					</div>
				</li>
				<li id="IntroducingPVRCamera">
					<div class="title">
						<a href="../../Examples//Beginner/05_IntroducingPVRCamera/IntroducingPVRCamera.png" title="Click to view image" target="_blank"><img class="examplesmall" src="../../Examples//Beginner/05_IntroducingPVRCamera/IntroducingPVRCamera.png" alt="IntroducingPVRCamera" /></a>
						<input type="checkbox" id="IntroducingPVRCameraFull2">
							<label for="IntroducingPVRCameraFull2" title="Click for more information"><h3>IntroducingPVRCamera</h3></label>
							<div class="ShortDescription" id="TexturingShort"><p>Use the PVRCamera library to get the hardware camera of a device, and apply a simple color inversion shader to it.
</p><small><b>OpenGL ES 2.0+
</small></b></div>
							<br>
							<div class="FullDescription" id="TexturingFull">
								<p><strong>Description:</strong></p>
								<p>The PVRCamera library gives a very simple, unified API to access the video feed of an iOS or Android device as an OpenGL ES texture. This demo displays this texture on the screen using a very simple shader that inverts the colours.
Note: On desctop platforms, the camera interface returns a dummy static texture to facilitate development. On android N, the Camera permission must be given to the application.
</p>
								<p><strong>Controls:</strong></p>
								<p><p>	Quit	:	Close the application</p></p>
								<p><strong>Links:</strong></p>
								<p class="source"><a href="../../Examples//Beginner/05_IntroducingPVRCamera/" target="_blank">IntroducingPVRCamera source</a>  |  <a href="" target="_blank"></a></p>
							</div>
						</input>
					</div>
				</li></div></ul>


<div id="Intermediate"><h2>Intermediate</h2><ul class="accordion">

				<li id="Bumpmap">
					<div class="title">
						<a href="../../Examples//Intermediate/Bumpmap/Bumpmap.png" title="Click to view image" target="_blank"><img class="examplesmall" src="../../Examples//Intermediate/Bumpmap/Bumpmap.png" alt="Bumpmap" /></a>
						<input type="checkbox" id="BumpmapFull2">
							<label for="BumpmapFull2" title="Click for more information"><h3>Bumpmap</h3></label>
							<div class="ShortDescription" id="TexturingShort"><p>This training course demonstrates using a normal map to implement bump mapping using the PowerVR Framework.
</p><small><b>Vulkan
</small></b></div>
							<br>
							<div class="FullDescription" id="TexturingFull">
								<p><strong>Description:</strong></p>
								<p>Bump mapping is a technique for simulating bumps and wrinkles on the surface of an object. This is achieved by perturbing the surface normals of the object and using the perturbed normal during the illumination calculations. The result is an apparently bumpy surface rather than a perfectly smooth surface although the surface of the underlying object is not actually changed. This technique is used extensively in graphics applications to add perceived detail to models without adding further geometry, and could be considered the baseline for rendering nowadays.
</p>
								<p><strong>Controls:</strong></p>
								<p><p>	Quit	:	Close the application</p></p>
								<p><strong>Links:</strong></p>
								<p class="source"><a href="../../Examples//Intermediate/Bumpmap/" target="_blank">Bumpmap source</a>  |  <a href="" target="_blank"></a></p>
							</div>
						</input>
					</div>
				</li>
				<li id="GaussianBlur">
					<div class="title">
						<a href="../../Examples//Intermediate/GaussianBlur/GaussianBlur.png" title="Click to view image" target="_blank"><img class="examplesmall" src="../../Examples//Intermediate/GaussianBlur/GaussianBlur.png" alt="GaussianBlur" /></a>
						<input type="checkbox" id="GaussianBlurFull2">
							<label for="GaussianBlurFull2" title="Click for more information"><h3>GaussianBlur</h3></label>
							<div class="ShortDescription" id="TexturingShort"><p>Shows how to perform a extremely wide, highly optimized Gaussian Blur using Compute shaders.
</p><small><b>Vulkan, OpenGL ES 3.0
</small></b></div>
							<br>
							<div class="FullDescription" id="TexturingFull">
								<p><strong>Description:</strong></p>
								<p>This training course demonstrates how to perform a 19x19 Gaussian Blur leveraging every input and output step
to blur an image by reading from an input using compute while blurring in one direction, and then writing to 
the output with a Fragment shader while blurring in the other direction.
This technique used has been highly optimized for PowerVR and is highly suitable for very large convolution width.
</p>
								<p><strong>Controls:</strong></p>
								<p><p>	Quit	:	Close the application</p></p>
								<p><strong>Links:</strong></p>
								<p class="source"><a href="../../Examples//Intermediate/GaussianBlur/" target="_blank">GaussianBlur source</a>  |  <a href="" target="_blank"></a></p>
							</div>
						</input>
					</div>
				</li>
				<li id="IMGFramebufferDownsample">
					<div class="title">
						<a href="../../Examples//Intermediate/IMGFramebufferDownsample/IMGFramebufferDownsample.png" title="Click to view image" target="_blank"><img class="examplesmall" src="../../Examples//Intermediate/IMGFramebufferDownsample/IMGFramebufferDownsample.png" alt="IMGFramebufferDownsample" /></a>
						<input type="checkbox" id="IMGFramebufferDownsampleFull2">
							<label for="IMGFramebufferDownsampleFull2" title="Click for more information"><h3>IMGFramebufferDownsample</h3></label>
							<div class="ShortDescription" id="TexturingShort"><p>Demonstrates the power of the extension GL_IMG_framebuffer_downsample which enables automatic downsampling of textures.
</p><small><b>OpenGL ES 2.0+
</small></b></div>
							<br>
							<div class="FullDescription" id="TexturingFull">
								<p><strong>Description:</strong></p>
								<p>Demonstrates the advantages of using the extension GL_IMG_framebuffer_downsample. A triangle is first rendered to a special FBO with a texture of half size set as a downsampled texture using glFramebufferTexture2DDownsampleIMG and a full size texture set as normal. The application then renders to both the full size texture and half size texture and the GPU automatically downsamples the color attachment render. The left hand side of the rendered image has been sampled from the full size texture while the right hand side samples from the half size texture. This extension can be tremendously useful for various post processing techniques where it is desirable to generate downsamples images efficiently.
</p>
								<p><strong>Controls:</strong></p>
								<p><p>	Quit	:	Close the application</p></p>
								<p><strong>Links:</strong></p>
								<p class="source"><a href="../../Examples//Intermediate/IMGFramebufferDownsample/" target="_blank">IMGFramebufferDownsample source</a>  |  <a href="" target="_blank"></a></p>
							</div>
						</input>
					</div>
				</li>
				<li id="IMGTextureFilterCubic">
					<div class="title">
						<a href="../../Examples//Intermediate/IMGTextureFilterCubic/IMGTextureFilterCubic.png" title="Click to view image" target="_blank"><img class="examplesmall" src="../../Examples//Intermediate/IMGTextureFilterCubic/IMGTextureFilterCubic.png" alt="IMGTextureFilterCubic" /></a>
						<input type="checkbox" id="IMGTextureFilterCubicFull2">
							<label for="IMGTextureFilterCubicFull2" title="Click for more information"><h3>IMGTextureFilterCubic</h3></label>
							<div class="ShortDescription" id="TexturingShort"><p>Demonstrate the advantages of using the extension for cubic texture filtering
</p><small><b>OpenGL ES 2.0+
</small></b></div>
							<br>
							<div class="FullDescription" id="TexturingFull">
								<p><strong>Description:</strong></p>
								<p>Demonstrates the advantages of using cubic texture filtering using the extension GL_IMG_texture_filter_cubic. The left side of the image is rendered using traditional bilinear texture filtering with mipmapping and then right side of the image is rendered using cubic texture filtering.
</p>
								<p><strong>Controls:</strong></p>
								<p><p>	Quit	:	Close the application</p></p>
								<p><strong>Links:</strong></p>
								<p class="source"><a href="../../Examples//Intermediate/IMGTextureFilterCubic/" target="_blank">IMGTextureFilterCubic source</a>  |  <a href="" target="_blank"></a></p>
							</div>
						</input>
					</div>
				</li>
				<li id="MultiSampling">
					<div class="title">
						<a href="../../Examples//Intermediate/MultiSampling/MultiSampling.png" title="Click to view image" target="_blank"><img class="examplesmall" src="../../Examples//Intermediate/MultiSampling/MultiSampling.png" alt="MultiSampling" /></a>
						<input type="checkbox" id="MultiSamplingFull2">
							<label for="MultiSamplingFull2" title="Click for more information"><h3>MultiSampling</h3></label>
							<div class="ShortDescription" id="TexturingShort"><p>Render a scene to a multisampling frame buffer object.
</p><small><b>Vulkan, OpenGL ES 2.0+
</small></b></div>
							<br>
							<div class="FullDescription" id="TexturingFull">
								<p><strong>Description:</strong></p>
								<p>This training course demonstrates how to use the framework to render a scene using multisampling feature. Provided for Vulkan (with SpirV shaders) and OpenGL ES 2.0+.
</p>
								<p><strong>Controls:</strong></p>
								<p><p>	Quit	:	Close the application</p></p>
								<p><strong>Links:</strong></p>
								<p class="source"><a href="../../Examples//Intermediate/MultiSampling/" target="_blank">MultiSampling source</a>  |  <a href="" target="_blank"></a></p>
							</div>
						</input>
					</div>
				</li>
				<li id="Multithreading">
					<div class="title">
						<a href="../../Examples//Intermediate/Multithreading/Multithreading.png" title="Click to view image" target="_blank"><img class="examplesmall" src="../../Examples//Intermediate/Multithreading/Multithreading.png" alt="Multithreading" /></a>
						<input type="checkbox" id="MultithreadingFull2">
							<label for="MultithreadingFull2" title="Click for more information"><h3>Multithreading</h3></label>
							<div class="ShortDescription" id="TexturingShort"><p>This training course demonstrates using the PowerVR Framework to stream assets asynchronously into an application
</p><small><b>Vulkan
</small></b></div>
							<br>
							<div class="FullDescription" id="TexturingFull">
								<p><strong>Description:</strong></p>
								<p>This training course will display a loading screen (using UIRenderer) while assets are being loaded in, and then 
switch to displaying the statue from the BumpMap demo.
</p>
								<p><strong>Controls:</strong></p>
								<p><p>	Quit	:	Close the application</p></p>
								<p><strong>Links:</strong></p>
								<p class="source"><a href="../../Examples//Intermediate/Multithreading/" target="_blank">Multithreading source</a>  |  <a href="" target="_blank"></a></p>
							</div>
						</input>
					</div>
				</li>
				<li id="MultiviewVR">
					<div class="title">
						<a href="../../Examples//Intermediate/MultiviewVR/MultiviewVR.png" title="Click to view image" target="_blank"><img class="examplesmall" src="../../Examples//Intermediate/MultiviewVR/MultiviewVR.png" alt="MultiviewVR" /></a>
						<input type="checkbox" id="MultiviewVRFull2">
							<label for="MultiviewVRFull2" title="Click for more information"><h3>MultiviewVR</h3></label>
							<div class="ShortDescription" id="TexturingShort"><p>Render a scene stereoscopically intended for VR hardware it using the GL_OVR_multiview extension.
</p><small><b>OpenGL ES 3.0+
</small></b></div>
							<br>
							<div class="FullDescription" id="TexturingFull">
								<p><strong>Description:</strong></p>
								<p>This training course introduces the GL_OVR_multiview extension, and shows how to use the extension to render the scene from two different eye locations.
Additionally, two sets of FBOs are being used (one low and one high resolution), with the intent of rendering the center of the screen in high res, and
the edges of the screen (which will be distorted by the VR lenses anyway) in lower resolution. The end result is a split screen suitable for VR.
</p>
								<p><strong>Controls:</strong></p>
								<p><p>	Quit	:	Close the application</p></p>
								<p><strong>Links:</strong></p>
								<p class="source"><a href="../../Examples//Intermediate/MultiviewVR/" target="_blank">MultiviewVR source</a>  |  <a href="" target="_blank"></a></p>
							</div>
						</input>
					</div>
				</li>
				<li id="OpenCLExample">
					<div class="title">
						<a href="../../Examples//Intermediate/OpenCLExample/OpenCLExample.png" title="Click to view image" target="_blank"><img class="examplesmall" src="../../Examples//Intermediate/OpenCLExample/OpenCLExample.png" alt="OpenCLExample" /></a>
						<input type="checkbox" id="OpenCLExampleFull2">
							<label for="OpenCLExampleFull2" title="Click for more information"><h3>OpenCLExample</h3></label>
							<div class="ShortDescription" id="TexturingShort"><p>This training course demonstrates using small image convolution OpenCL kernels.
</p><small><b>OpenGL ES 2.0+ with OpenCL
</small></b></div>
							<br>
							<div class="FullDescription" id="TexturingFull">
								<p><strong>Description:</strong></p>
								<p>This training course shows how to structure an application with OpenCL / OpenGL interoperability or, if necessary, CPU fallback for it, to process images on the GPU using OpenCL. Several 3x3 convolution filters are shown (Gaussian Blur, erode/dilate, edge detection, emboss).
</p>
								<p><strong>Controls:</strong></p>
								<p><p>	Left/Right	:	Change the convolution filter</p><p>	Quit	:	Close the application</p></p>
								<p><strong>Links:</strong></p>
								<p class="source"><a href="../../Examples//Intermediate/OpenCLExample/" target="_blank">OpenCLExample source</a>  |  <a href="" target="_blank"></a></p>
							</div>
						</input>
					</div>
				</li>
				<li id="PostProcessing">
					<div class="title">
						<a href="../../Examples//Intermediate/PostProcessing/PostProcessing.png" title="Click to view image" target="_blank"><img class="examplesmall" src="../../Examples//Intermediate/PostProcessing/PostProcessing.png" alt="PostProcessing" /></a>
						<input type="checkbox" id="PostProcessingFull2">
							<label for="PostProcessingFull2" title="Click for more information"><h3>PostProcessing</h3></label>
							<div class="ShortDescription" id="TexturingShort"><p>This training course demonstrates a simple implementation of a 'bloom' post processing effect.
</p><small><b>Vulkan , OpenGL ES 2.0+
</small></b></div>
							<br>
							<div class="FullDescription" id="TexturingFull">
								<p><strong>Description:</strong></p>
								<p>This training course demonstrates a simple implementation of a 'bloom' post processing effect, using Render Passes (Vulkan)/ Render To Texture (OpenGL ES)
to render an intermediate scene and use it for postprocessing. The bright parts of the picture are extracted in lower resolution in a post processing step,
blurred and then added over the final image to create a glow around the object's borders.
</p>
								<p><strong>Controls:</strong></p>
								<p><p>	Left/Right	:	Change the rendering mode (Object with bloom, object w/o bloom, bloom textures)</p><p>	Up/Down	:	Increase/Decrease bloom intensity</p><p>	Any Action	:	Pause</p><p>	Quit	:	Close the application</p></p>
								<p><strong>Links:</strong></p>
								<p class="source"><a href="../../Examples//Intermediate/PostProcessing/" target="_blank">PostProcessing source</a>  |  <a href="" target="_blank"></a></p>
							</div>
						</input>
					</div>
				</li></div></ul>


<div id="Advanced"><h2>Advanced</h2><ul class="accordion">

				<li id="DeferredShading">
					<div class="title">
						<a href="../../Examples//Advanced/DeferredShading/DeferredShading.png" title="Click to view image" target="_blank"><img class="examplesmall" src="../../Examples//Advanced/DeferredShading/DeferredShading.png" alt="DeferredShading" /></a>
						<input type="checkbox" id="DeferredShadingFull2">
							<label for="DeferredShadingFull2" title="Click for more information"><h3>DeferredShading</h3></label>
							<div class="ShortDescription" id="TexturingShort"><p>Demonstrates optimal deferred shading using Pixel Local Storage (PLS), or Subpasses with Transient Attachments (Vulkan)
</p><small><b>Vulkan, OpenGL ES 3.0
</small></b></div>
							<br>
							<div class="FullDescription" id="TexturingFull">
								<p><strong>Description:</strong></p>
								<p>Traditional rendering algorithms submit geometry and immediately apply shading effects to the rasterized primitives. Complex shading effects may require multiple draw calls (one per object per light) or render passes to produce the final pixel color, with the geometry submitted every pass. Deferred shading is an alternative rendering technique that submits the scene geometry once, storing per-pixel attributes into local video memory to be used in the subsequent rendering passes. 
In these later passes, light volume primitives are rendered, and the per-pixel attributes contained in the buffer are retrieved at a 1:1 mapping ratio so that each pixel is shaded individually.
In the PowerVR architecture, the user can use fast on-chip memory instead of the render target, by utilising the Pixel Local Storage OpenGL ES extension, or correctly defining Subpasses for those operations.
Requires the extension GL_EXT_shader_pixel_local_storage for PLS.
</p>
								<p><strong>Controls:</strong></p>
								<p><p>	Action1	:	Pause</p><p>	Action2	:	Orbit camera</p><p>	Quit	:	Close the application</p></p>
								<p><strong>Links:</strong></p>
								<p class="source"><a href="../../Examples//Advanced/DeferredShading/" target="_blank">DeferredShading source</a>  |  <a href="" target="_blank"></a></p>
							</div>
						</input>
					</div>
				</li>
				<li id="DeferredShadingPFX">
					<div class="title">
						<a href="../../Examples//Advanced/DeferredShadingPFX/DeferredShadingPFX.png" title="Click to view image" target="_blank"><img class="examplesmall" src="../../Examples//Advanced/DeferredShadingPFX/DeferredShadingPFX.png" alt="DeferredShadingPFX" /></a>
						<input type="checkbox" id="DeferredShadingPFXFull2">
							<label for="DeferredShadingPFXFull2" title="Click for more information"><h3>DeferredShadingPFX</h3></label>
							<div class="ShortDescription" id="TexturingShort"><p>Duplicates the DeferredShading example using simple PFX scene description to describe this complex rendering scenario
</p><small><b>Vulkan
</small></b></div>
							<br>
							<div class="FullDescription" id="TexturingFull">
								<p><strong>Description:</strong></p>
								<p>The DeferredShading example uses a multi-subpass technique (in Vulkan) or Pixel Local Storage (in OpenGL ES) to implement a Deferred Shading technique. In
this example, this exact same technique is described in a PFX file, and rendered with the RenderManager, effectively avoiding almost all the code in the example
except the most basics, demonstrating the power of the RenderManager combined with PFX files as a scene description.
</p>
								<p><strong>Controls:</strong></p>
								<p><p>	Action1	:	Pause</p><p>	Action2	:	Orbit camera</p><p>	Quit	:	Close the application</p></p>
								<p><strong>Links:</strong></p>
								<p class="source"><a href="../../Examples//Advanced/DeferredShadingPFX/" target="_blank">DeferredShadingPFX source</a>  |  <a href="" target="_blank"></a></p>
							</div>
						</input>
					</div>
				</li>
				<li id="ExampleUI">
					<div class="title">
						<a href="../../Examples//Advanced/ExampleUI/ExampleUI.png" title="Click to view image" target="_blank"><img class="examplesmall" src="../../Examples//Advanced/ExampleUI/ExampleUI.png" alt="ExampleUI" /></a>
						<input type="checkbox" id="ExampleUIFull2">
							<label for="ExampleUIFull2" title="Click for more information"><h3>ExampleUI</h3></label>
							<div class="ShortDescription" id="TexturingShort"><p>Use the PVRUtils to efficiently render sprites to form a comples User Interface.
</p><small><b>Vulkan
</small></b></div>
							<br>
							<div class="FullDescription" id="TexturingFull">
								<p><strong>Description:</strong></p>
								<p>Rendering graphical user interfaces can quickly become overly complex. The PVRUtils can assist in rendering a lot of sprites with different complicated transformations, while remaining crisp and responsive. Usability and performance optimizations can both be found in this example, such as UIRenderer transformation groups.
</p>
								<p><strong>Controls:</strong></p>
								<p><p>	Left/Right	:	Change UI Page</p><p>	Quit	:	Close the application</p></p>
								<p><strong>Links:</strong></p>
								<p class="source"><a href="../../Examples//Advanced/ExampleUI/" target="_blank">ExampleUI source</a>  |  <a href="" target="_blank"></a></p>
							</div>
						</input>
					</div>
				</li>
				<li id="Glass">
					<div class="title">
						<a href="../../Examples//Advanced/Glass/Glass.png" title="Click to view image" target="_blank"><img class="examplesmall" src="../../Examples//Advanced/Glass/Glass.png" alt="Glass" /></a>
						<input type="checkbox" id="GlassFull2">
							<label for="GlassFull2" title="Click for more information"><h3>Glass</h3></label>
							<div class="ShortDescription" id="TexturingShort"><p>Demonstrates dynamic reflection and refraction using a dual paraboloid environment map.
</p><small><b>Vulkan
</small></b></div>
							<br>
							<div class="FullDescription" id="TexturingFull">
								<p><strong>Description:</strong></p>
								<p>This example shows a technique to maintain a dynamic environment map by rendering both hemispheres of the scene to two halves of a single rectangular texture. In addition, this also demonstrates rendering skyboxes with a full screen quad, reflection and refraction with chromatic dispersion.
</p>
								<p><strong>Controls:</strong></p>
								<p><p>	Quit	:	Close the application</p><p>	Left/Right : Change the effect between combinations of Reflection and Refraction/Chromatic Dispersion</p><p>	Up/Down	:	Look up or down.</p></p>
								<p><strong>Links:</strong></p>
								<p class="source"><a href="../../Examples//Advanced/Glass/" target="_blank">Glass source</a>  |  <a href="" target="_blank"></a></p>
							</div>
						</input>
					</div>
				</li>
				<li id="GnomeHorde">
					<div class="title">
						<a href="../../Examples//Advanced/GnomeHorde/GnomeHorde.png" title="Click to view image" target="_blank"><img class="examplesmall" src="../../Examples//Advanced/GnomeHorde/GnomeHorde.png" alt="GnomeHorde" /></a>
						<input type="checkbox" id="GnomeHordeFull2">
							<label for="GnomeHordeFull2" title="Click for more information"><h3>GnomeHorde</h3></label>
							<div class="ShortDescription" id="TexturingShort"><p>This demo shows a very efficient technique for multithreaded command buffer generation and rendering.
</p><small><b>Vulkan
</small></b></div>
							<br>
							<div class="FullDescription" id="TexturingFull">
								<p><strong>Description:</strong></p>
								<p>The GnomeHorde divides its world into tiles, each containing a small number of objects.
It uses 3 groups of threads - the Main thread, which kicks all other tasks and does the
actual command buffer submisison (rendering), a number of Visibility threads, each of 
which processes large groups of tiles, and a number of Tile Processing threads, each of
which generate command buffers for a tile. Command buffers are created (when the tile has
just become visible), recalculated (when the tile's Level Of Detail has changed) or 
recycled (when the tile has just become nonvisible) as required.
The communication of the threads is abstracted using Producer-Consumer Queues passing the
coordinates of tiles as parameters.
When all generation is done, the main thread collects all secondary command buffers and
submits them to the GPU rendering Queue.
</p>
								<p><strong>Controls:</strong></p>
								<p><p>	Esc	:	Close</p></p>
								<p><strong>Links:</strong></p>
								<p class="source"><a href="../../Examples//Advanced/GnomeHorde/" target="_blank">GnomeHorde source</a>  |  <a href="" target="_blank"></a></p>
							</div>
						</input>
					</div>
				</li>
				<li id="PVRScopeExample">
					<div class="title">
						<a href="../../Examples//Advanced/PVRScopeExample/PVRScopeExample.png" title="Click to view image" target="_blank"><img class="examplesmall" src="../../Examples//Advanced/PVRScopeExample/PVRScopeExample.png" alt="PVRScopeExample" /></a>
						<input type="checkbox" id="PVRScopeExampleFull2">
							<label for="PVRScopeExampleFull2" title="Click for more information"><h3>PVRScopeExample</h3></label>
							<div class="ShortDescription" id="TexturingShort"><p>Demonstrates the use of PVRScope and the example graphing code.
</p><small><b>OpenGL ES 2.0+
</small></b></div>
							<br>
							<div class="FullDescription" id="TexturingFull">
								<p><strong>Description:</strong></p>
								<p>This demo uses a simple PBR-style shader and shows the use of PVRScope to allow an application to return performance statistics from the GPU in real time. It uses the example graphing code to render a graph of the selected counters on the screen. For further details, refer to the PVRScope User Manual. 
</p>
								<p><strong>Controls:</strong></p>
								<p><p>	Quit	:	Close demo</p><p>	Up/Down	:	Select a counter from the available list of HW counters</p><p>	Action1	:	Add/remove selected counter to the graph</p></p>
								<p><strong>Links:</strong></p>
								<p class="source"><a href="../../Examples//Advanced/PVRScopeExample/" target="_blank">PVRScopeExample source</a>  |  <a href="" target="_blank"></a></p>
							</div>
						</input>
					</div>
				</li>
				<li id="PVRScopeRemote">
					<div class="title">
						<a href="../../Examples//Advanced/PVRScopeRemote/PVRScopeRemote.png" title="Click to view image" target="_blank"><img class="examplesmall" src="../../Examples//Advanced/PVRScopeRemote/PVRScopeRemote.png" alt="PVRScopeRemote" /></a>
						<input type="checkbox" id="PVRScopeRemoteFull2">
							<label for="PVRScopeRemoteFull2" title="Click for more information"><h3>PVRScopeRemote</h3></label>
							<div class="ShortDescription" id="TexturingShort"><p>Demonstrates the use of PVRScope's remote communication features.
</p><small><b>OpenGL ES 2.0+
</small></b></div>
							<br>
							<div class="FullDescription" id="TexturingFull">
								<p><strong>Description:</strong></p>
								<p>This example shows how to use the editable data and custom mark functionality of PVRScope. PVRTune must be running and connected to an instance of PVRPerfServer running on the target device for this demo to function. 
A simple Physically Based shader is provided with properties of Albedo, Metallicity and Glossines, all of which - together with the shaders - can be edited from the PVRTune GUI immediately modifying the appearance of the statue.
</p>
								<p><strong>Controls:</strong></p>
								<p><p>	Quit	:	Close demo</p><p>	PVRTune	:	Control demo variables through PVRTune</p></p>
								<p><strong>Links:</strong></p>
								<p class="source"><a href="../../Examples//Advanced/PVRScopeRemote/" target="_blank">PVRScopeRemote source</a>  |  <a href="" target="_blank"></a></p>
							</div>
						</input>
					</div>
				</li>
				<li id="ParticleSystem">
					<div class="title">
						<a href="../../Examples//Advanced/ParticleSystem/ParticleSystem.png" title="Click to view image" target="_blank"><img class="examplesmall" src="../../Examples//Advanced/ParticleSystem/ParticleSystem.png" alt="ParticleSystem" /></a>
						<input type="checkbox" id="ParticleSystemFull2">
							<label for="ParticleSystemFull2" title="Click for more information"><h3>ParticleSystem</h3></label>
							<div class="ShortDescription" id="TexturingShort"><p>Shows how to implement a simple particle system using GPGPU.
</p><small><b>Vulkan, OpenGL ES 3.1
</small></b></div>
							<br>
							<div class="FullDescription" id="TexturingFull">
								<p><strong>Description:</strong></p>
								<p>The demo utilises GPGPU (GPU Compute) to implement a particle system, a simple integration-based simulation which is advanced and then rendered every frame strictly on the GPU, without any CPU access of that data. Particle systems are techniques that use a large amount of sprites to simulate phenomena that would be difficult to reproduce with conventional rendering techniques. Furthermore, it also highlights the interaction between the Compute and the Rendering part of a simulation.
Requires OpenGL ES 3.1 or Vulkan capable platform.
</p>
								<p><strong>Controls:</strong></p>
								<p><p>	Quit	:	Close demo</p><p> 	Left/Right	:	Decrease/increase number of particles</p><p>	Up/Down	:	Switch between GPU Compute and CPU Particle System implementation.</p></p>
								<p><strong>Links:</strong></p>
								<p class="source"><a href="../../Examples//Advanced/ParticleSystem/" target="_blank">ParticleSystem source</a>  |  <a href="" target="_blank"></a></p>
							</div>
						</input>
					</div>
				</li>
				<li id="Skinning">
					<div class="title">
						<a href="../../Examples//Advanced/Skinning/Skinning.png" title="Click to view image" target="_blank"><img class="examplesmall" src="../../Examples//Advanced/Skinning/Skinning.png" alt="Skinning" /></a>
						<input type="checkbox" id="SkinningFull2">
							<label for="SkinningFull2" title="Click for more information"><h3>Skinning</h3></label>
							<div class="ShortDescription" id="TexturingShort"><p>This demo shows a scene with a combination of a skinned, bumpmapped character with non-skinned, non-bumpmapped objects.
</p><small><b>Vulkan, OpenGL ES 3.0
</small></b></div>
							<br>
							<div class="FullDescription" id="TexturingFull">
								<p><strong>Description:</strong></p>
								<p>The Skinning demo shows a Skinned Character in combination with bump mapping. Skinning is the act of animating a vertex over time given a set (palette) of matrices and a known set of blend weights assigned to those matrices. For each frame the Matrix Palette is recomputed based on time. PVRAssets and POD files support skinning. either full transformation Matrices, or Quaternion rotation with Scaling and Translation vectors. The provided POD file contains matrix animation.
Up to 4 matrices  from the palette, along with 4 weights can used for each vertex by the vertex shader to update the position to obtain the current animation frame position.
</p>
								<p><strong>Controls:</strong></p>
								<p><p>	Action1/2/3	:	Pause</p><p>	Esc	:	Close</p></p>
								<p><strong>Links:</strong></p>
								<p class="source"><a href="../../Examples//Advanced/Skinning/" target="_blank">Skinning source</a>  |  <a href="" target="_blank"></a></p>
							</div>
						</input>
					</div>
				</li></div></ul>


<div id="Navigation"><h2>Navigation</h2><ul class="accordion">

				<li id="Navigation2D">
					<div class="title">
						<a href="../../Examples//Navigation/Navigation2D/Navigation2D.png" title="Click to view image" target="_blank"><img class="examplesmall" src="../../Examples//Navigation/Navigation2D/Navigation2D.png" alt="Navigation2D" /></a>
						<input type="checkbox" id="Navigation2DFull2">
							<label for="Navigation2DFull2" title="Click for more information"><h3>Navigation2D</h3></label>
							<div class="ShortDescription" id="TexturingShort"><p>Demonstrates parsing, processing and rendering of raw OSM data as a 2D navigational map.
</p><small><b>OpenGL ES 2.0+, Vulkan
</small></b></div>
							<br>
							<div class="FullDescription" id="TexturingFull">
								<p><strong>Description:</strong></p>
								<p>The 2D navigation example demonstrates the entire process of creating a navigational map from raw data, in this 
case the Open Street Map data. The example demonstrates loading and parsing of the XML, the processing of the raw 
data, triangulation with the ear clipping algorithm to generate triangles, defining the roads, and batching all 
of that into tiles as renderable polygons.
This example also shows several rendering techniques such as; anti-aliased lines with outline for roads, 
UI elements for road names and places of interest and an effective tile based approach to batching 
and culling the geometry. 
</p>
								<p><strong>Controls:</strong></p>
								<p><p>	Quit	:	Close the application</p></p>
								<p><strong>Links:</strong></p>
								<p class="source"><a href="../../Examples//Navigation/Navigation2D/" target="_blank">Navigation2D source</a>  |  <a href="" target="_blank"></a></p>
							</div>
						</input>
					</div>
				</li></div></ul>
		</div>
	</div>
	
	<div id="FooterMainContainer">
		<div id="FooterContainer">
			<div class="footerlogo">
				<a href="http://www.imgtec.com" target="_blank"><img src="./images/img-footer-logo-grey.png" width="100%" height="100%" /></a>
			</div>
			<div class="copyright">&copy; Imagination Technologies Limited<br> All rights reserved</div>
		</div>
	</div>
	
</body>

</html>