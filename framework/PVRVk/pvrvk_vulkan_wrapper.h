// *** THIS FILE IS GENERATED - DO NOT EDIT ***
// See pvrvk_vulkan_wrapper_generator.py for modifications

/*
\brief vulkan.h wrapper used by PVRVk.
\file pvrvk_vulkan_wrapper.h
\author PowerVR by Imagination, Developer Technology Team
\copyright Copyright (c) Imagination Technologies Limited.
*/

//!\cond NO_DOXYGEN
// clang-format off
#pragma once
#include "vulkan/vulkan.h"
#if defined (X11)
// undef these macros from the xlib files, they are breaking the framework types.
#undef Success
#undef Enum
#undef None
#undef Always
#undef byte
#undef char8
#undef ShaderStageFlags
#undef capability
#endif
#include "PVRVk/Log.h"
#include <stdexcept>

#define DEFINE_ENUM_BITWISE_OPERATORS(type_) \
inline type_ operator | (type_ lhs, type_ rhs) \
{ \
    return (type_)(static_cast<uint32_t>(lhs) | static_cast<uint32_t>(rhs)); \
} \
inline type_& operator |= (type_& lhs, type_ rhs) \
{ \
    return lhs = (type_)(static_cast<uint32_t>(lhs) | static_cast<uint32_t>(rhs)); \
} \
inline type_ operator & (type_ lhs, type_ rhs) \
{ \
    return (type_)(static_cast<uint32_t>(lhs) & static_cast<uint32_t>(rhs)); \
} \
inline type_& operator &= (type_& lhs, type_ rhs) \
{ \
    return lhs = (type_)(static_cast<uint32_t>(lhs) & static_cast<uint32_t>(rhs)); \
} \
inline type_ operator ^ (type_ lhs, type_ rhs) \
{ \
    return (type_)(static_cast<uint32_t>(lhs) ^ static_cast<uint32_t>(rhs)); \
} \
inline type_& operator ^= (type_& lhs, type_ rhs) \
{ \
    return lhs = (type_)(static_cast<uint32_t>(lhs) ^ static_cast<uint32_t>(rhs)); \
} \
inline type_ operator <<(type_ lhs, uint32_t rhs) \
{ \
    return (type_)(static_cast<uint32_t>(lhs) << rhs); \
} \
inline type_& operator <<=(type_& lhs, uint32_t rhs) \
{ \
    return lhs = (type_)(static_cast<uint32_t>(lhs) << rhs); \
} \
inline type_ operator >>(type_ lhs, uint32_t rhs) \
{ \
    return (type_)(static_cast<uint32_t>(lhs) >> rhs); \
} \
inline type_& operator >>=(type_& lhs, uint32_t rhs) \
{ \
    return lhs = (type_)(static_cast<uint32_t>(lhs) >> rhs); \
} \
inline bool operator ==(type_ lhs, uint32_t rhs) \
{ \
    return static_cast<uint32_t>(lhs) == rhs; \
} \
inline bool operator !=(type_ lhs, uint32_t rhs) \
{ \
    return static_cast<uint32_t>(lhs) != rhs; \
} \
inline bool operator ==(uint32_t lhs, type_ rhs) \
{ \
    return lhs == static_cast<uint32_t>(rhs); \
}\
inline bool operator !=(uint32_t lhs, type_ rhs) \
{ \
    return lhs != static_cast<uint32_t>(rhs); \
}\
inline type_ operator ~(type_ lhs) \
{ \
    return (type_)(~static_cast<uint32_t>(lhs)); \
}\
inline int operator *(uint32_t lhs, type_ rhs) \
{ \
    return (lhs * static_cast<uint32_t>(rhs)); \
}\
inline type_ operator *(type_ lhs, uint32_t rhs) \
{ \
    return (type_)(static_cast<uint32_t>(lhs) * rhs); \
}\


namespace pvrvk {


// PVRVk Structures defined in PVRVk/Types.h. These are excluded from autogeneration so we need to forward declare them here 
struct ClearValue;
struct ClearColorValue;
struct ClearAttachment;
struct AttachmentDescription;
struct SubpassDescription;



// PVRVk Basetypes
typedef VkFlags Flags;
typedef VkBool32 Bool32;
typedef VkDeviceSize DeviceSize;
typedef VkSampleMask SampleMask;



// PVRVk Bitmasks
enum class InstanceCreateFlags : uint32_t { e_NONE };
DEFINE_ENUM_BITWISE_OPERATORS(InstanceCreateFlags)
inline std::string to_string(InstanceCreateFlags value)
{
    (void)value;
    return "reserved";
}

enum class DeviceCreateFlags : uint32_t { e_NONE };
DEFINE_ENUM_BITWISE_OPERATORS(DeviceCreateFlags)
inline std::string to_string(DeviceCreateFlags value)
{
    (void)value;
    return "reserved";
}

enum class MemoryMapFlags : uint32_t { e_NONE };
DEFINE_ENUM_BITWISE_OPERATORS(MemoryMapFlags)
inline std::string to_string(MemoryMapFlags value)
{
    (void)value;
    return "reserved";
}

enum class SemaphoreCreateFlags : uint32_t { e_NONE };
DEFINE_ENUM_BITWISE_OPERATORS(SemaphoreCreateFlags)
inline std::string to_string(SemaphoreCreateFlags value)
{
    (void)value;
    return "reserved";
}

enum class EventCreateFlags : uint32_t { e_NONE };
DEFINE_ENUM_BITWISE_OPERATORS(EventCreateFlags)
inline std::string to_string(EventCreateFlags value)
{
    (void)value;
    return "reserved";
}

enum class QueryPoolCreateFlags : uint32_t { e_NONE };
DEFINE_ENUM_BITWISE_OPERATORS(QueryPoolCreateFlags)
inline std::string to_string(QueryPoolCreateFlags value)
{
    (void)value;
    return "reserved";
}

enum class BufferViewCreateFlags : uint32_t { e_NONE };
DEFINE_ENUM_BITWISE_OPERATORS(BufferViewCreateFlags)
inline std::string to_string(BufferViewCreateFlags value)
{
    (void)value;
    return "reserved";
}

enum class ImageViewCreateFlags : uint32_t { e_NONE };
DEFINE_ENUM_BITWISE_OPERATORS(ImageViewCreateFlags)
inline std::string to_string(ImageViewCreateFlags value)
{
    (void)value;
    return "reserved";
}

enum class ShaderModuleCreateFlags : uint32_t { e_NONE };
DEFINE_ENUM_BITWISE_OPERATORS(ShaderModuleCreateFlags)
inline std::string to_string(ShaderModuleCreateFlags value)
{
    (void)value;
    return "reserved";
}

enum class PipelineCacheCreateFlags : uint32_t { e_NONE };
DEFINE_ENUM_BITWISE_OPERATORS(PipelineCacheCreateFlags)
inline std::string to_string(PipelineCacheCreateFlags value)
{
    (void)value;
    return "reserved";
}

enum class PipelineShaderStageCreateFlags : uint32_t { e_NONE };
DEFINE_ENUM_BITWISE_OPERATORS(PipelineShaderStageCreateFlags)
inline std::string to_string(PipelineShaderStageCreateFlags value)
{
    (void)value;
    return "reserved";
}

enum class PipelineVertexInputStateCreateFlags : uint32_t { e_NONE };
DEFINE_ENUM_BITWISE_OPERATORS(PipelineVertexInputStateCreateFlags)
inline std::string to_string(PipelineVertexInputStateCreateFlags value)
{
    (void)value;
    return "reserved";
}

enum class PipelineInputAssemblyStateCreateFlags : uint32_t { e_NONE };
DEFINE_ENUM_BITWISE_OPERATORS(PipelineInputAssemblyStateCreateFlags)
inline std::string to_string(PipelineInputAssemblyStateCreateFlags value)
{
    (void)value;
    return "reserved";
}

enum class PipelineTessellationStateCreateFlags : uint32_t { e_NONE };
DEFINE_ENUM_BITWISE_OPERATORS(PipelineTessellationStateCreateFlags)
inline std::string to_string(PipelineTessellationStateCreateFlags value)
{
    (void)value;
    return "reserved";
}

enum class PipelineViewportStateCreateFlags : uint32_t { e_NONE };
DEFINE_ENUM_BITWISE_OPERATORS(PipelineViewportStateCreateFlags)
inline std::string to_string(PipelineViewportStateCreateFlags value)
{
    (void)value;
    return "reserved";
}

enum class PipelineRasterizationStateCreateFlags : uint32_t { e_NONE };
DEFINE_ENUM_BITWISE_OPERATORS(PipelineRasterizationStateCreateFlags)
inline std::string to_string(PipelineRasterizationStateCreateFlags value)
{
    (void)value;
    return "reserved";
}

enum class PipelineMultisampleStateCreateFlags : uint32_t { e_NONE };
DEFINE_ENUM_BITWISE_OPERATORS(PipelineMultisampleStateCreateFlags)
inline std::string to_string(PipelineMultisampleStateCreateFlags value)
{
    (void)value;
    return "reserved";
}

enum class PipelineDepthStencilStateCreateFlags : uint32_t { e_NONE };
DEFINE_ENUM_BITWISE_OPERATORS(PipelineDepthStencilStateCreateFlags)
inline std::string to_string(PipelineDepthStencilStateCreateFlags value)
{
    (void)value;
    return "reserved";
}

enum class PipelineColorBlendStateCreateFlags : uint32_t { e_NONE };
DEFINE_ENUM_BITWISE_OPERATORS(PipelineColorBlendStateCreateFlags)
inline std::string to_string(PipelineColorBlendStateCreateFlags value)
{
    (void)value;
    return "reserved";
}

enum class PipelineDynamicStateCreateFlags : uint32_t { e_NONE };
DEFINE_ENUM_BITWISE_OPERATORS(PipelineDynamicStateCreateFlags)
inline std::string to_string(PipelineDynamicStateCreateFlags value)
{
    (void)value;
    return "reserved";
}

enum class PipelineLayoutCreateFlags : uint32_t { e_NONE };
DEFINE_ENUM_BITWISE_OPERATORS(PipelineLayoutCreateFlags)
inline std::string to_string(PipelineLayoutCreateFlags value)
{
    (void)value;
    return "reserved";
}

enum class SamplerCreateFlags : uint32_t { e_NONE };
DEFINE_ENUM_BITWISE_OPERATORS(SamplerCreateFlags)
inline std::string to_string(SamplerCreateFlags value)
{
    (void)value;
    return "reserved";
}

enum class DescriptorPoolResetFlags : uint32_t { e_NONE };
DEFINE_ENUM_BITWISE_OPERATORS(DescriptorPoolResetFlags)
inline std::string to_string(DescriptorPoolResetFlags value)
{
    (void)value;
    return "reserved";
}

enum class FramebufferCreateFlags : uint32_t { e_NONE };
DEFINE_ENUM_BITWISE_OPERATORS(FramebufferCreateFlags)
inline std::string to_string(FramebufferCreateFlags value)
{
    (void)value;
    return "reserved";
}

enum class RenderPassCreateFlags : uint32_t { e_NONE };
DEFINE_ENUM_BITWISE_OPERATORS(RenderPassCreateFlags)
inline std::string to_string(RenderPassCreateFlags value)
{
    (void)value;
    return "reserved";
}

enum class CommandPoolTrimFlags : uint32_t { e_NONE };
DEFINE_ENUM_BITWISE_OPERATORS(CommandPoolTrimFlags)
inline std::string to_string(CommandPoolTrimFlags value)
{
    (void)value;
    return "reserved";
}

enum class DescriptorUpdateTemplateCreateFlags : uint32_t { e_NONE };
DEFINE_ENUM_BITWISE_OPERATORS(DescriptorUpdateTemplateCreateFlags)
inline std::string to_string(DescriptorUpdateTemplateCreateFlags value)
{
    (void)value;
    return "reserved";
}

enum class DisplayModeCreateFlagsKHR : uint32_t { e_NONE };
DEFINE_ENUM_BITWISE_OPERATORS(DisplayModeCreateFlagsKHR)
inline std::string to_string(DisplayModeCreateFlagsKHR value)
{
    (void)value;
    return "reserved";
}

enum class DisplaySurfaceCreateFlagsKHR : uint32_t { e_NONE };
DEFINE_ENUM_BITWISE_OPERATORS(DisplaySurfaceCreateFlagsKHR)
inline std::string to_string(DisplaySurfaceCreateFlagsKHR value)
{
    (void)value;
    return "reserved";
}

#ifdef VK_USE_PLATFORM_XLIB_KHR
enum class XlibSurfaceCreateFlagsKHR : uint32_t { e_NONE };
DEFINE_ENUM_BITWISE_OPERATORS(XlibSurfaceCreateFlagsKHR)
inline std::string to_string(XlibSurfaceCreateFlagsKHR value)
{
    (void)value;
    return "reserved";
}
#endif // VK_USE_PLATFORM_XLIB_KHR

#ifdef VK_USE_PLATFORM_XCB_KHR
enum class XcbSurfaceCreateFlagsKHR : uint32_t { e_NONE };
DEFINE_ENUM_BITWISE_OPERATORS(XcbSurfaceCreateFlagsKHR)
inline std::string to_string(XcbSurfaceCreateFlagsKHR value)
{
    (void)value;
    return "reserved";
}
#endif // VK_USE_PLATFORM_XCB_KHR

#ifdef VK_USE_PLATFORM_WAYLAND_KHR
enum class WaylandSurfaceCreateFlagsKHR : uint32_t { e_NONE };
DEFINE_ENUM_BITWISE_OPERATORS(WaylandSurfaceCreateFlagsKHR)
inline std::string to_string(WaylandSurfaceCreateFlagsKHR value)
{
    (void)value;
    return "reserved";
}
#endif // VK_USE_PLATFORM_WAYLAND_KHR

#ifdef VK_USE_PLATFORM_MIR_KHR
enum class MirSurfaceCreateFlagsKHR : uint32_t { e_NONE };
DEFINE_ENUM_BITWISE_OPERATORS(MirSurfaceCreateFlagsKHR)
inline std::string to_string(MirSurfaceCreateFlagsKHR value)
{
    (void)value;
    return "reserved";
}
#endif // VK_USE_PLATFORM_MIR_KHR

#ifdef VK_USE_PLATFORM_ANDROID_KHR
enum class AndroidSurfaceCreateFlagsKHR : uint32_t { e_NONE };
DEFINE_ENUM_BITWISE_OPERATORS(AndroidSurfaceCreateFlagsKHR)
inline std::string to_string(AndroidSurfaceCreateFlagsKHR value)
{
    (void)value;
    return "reserved";
}
#endif // VK_USE_PLATFORM_ANDROID_KHR

#ifdef VK_USE_PLATFORM_WIN32_KHR
enum class Win32SurfaceCreateFlagsKHR : uint32_t { e_NONE };
DEFINE_ENUM_BITWISE_OPERATORS(Win32SurfaceCreateFlagsKHR)
inline std::string to_string(Win32SurfaceCreateFlagsKHR value)
{
    (void)value;
    return "reserved";
}
#endif // VK_USE_PLATFORM_WIN32_KHR

enum class CommandPoolTrimFlagsKHR : uint32_t { e_NONE };
DEFINE_ENUM_BITWISE_OPERATORS(CommandPoolTrimFlagsKHR)
inline std::string to_string(CommandPoolTrimFlagsKHR value)
{
    (void)value;
    return "reserved";
}

enum class DescriptorUpdateTemplateCreateFlagsKHR : uint32_t { e_NONE };
DEFINE_ENUM_BITWISE_OPERATORS(DescriptorUpdateTemplateCreateFlagsKHR)
inline std::string to_string(DescriptorUpdateTemplateCreateFlagsKHR value)
{
    (void)value;
    return "reserved";
}

#ifdef VK_USE_PLATFORM_VI_NN
enum class ViSurfaceCreateFlagsNN : uint32_t { e_NONE };
DEFINE_ENUM_BITWISE_OPERATORS(ViSurfaceCreateFlagsNN)
inline std::string to_string(ViSurfaceCreateFlagsNN value)
{
    (void)value;
    return "reserved";
}
#endif // VK_USE_PLATFORM_VI_NN

enum class PipelineViewportSwizzleStateCreateFlagsNV : uint32_t { e_NONE };
DEFINE_ENUM_BITWISE_OPERATORS(PipelineViewportSwizzleStateCreateFlagsNV)
inline std::string to_string(PipelineViewportSwizzleStateCreateFlagsNV value)
{
    (void)value;
    return "reserved";
}

enum class PipelineDiscardRectangleStateCreateFlagsEXT : uint32_t { e_NONE };
DEFINE_ENUM_BITWISE_OPERATORS(PipelineDiscardRectangleStateCreateFlagsEXT)
inline std::string to_string(PipelineDiscardRectangleStateCreateFlagsEXT value)
{
    (void)value;
    return "reserved";
}

enum class PipelineRasterizationConservativeStateCreateFlagsEXT : uint32_t { e_NONE };
DEFINE_ENUM_BITWISE_OPERATORS(PipelineRasterizationConservativeStateCreateFlagsEXT)
inline std::string to_string(PipelineRasterizationConservativeStateCreateFlagsEXT value)
{
    (void)value;
    return "reserved";
}

#ifdef VK_USE_PLATFORM_IOS_MVK
enum class IOSSurfaceCreateFlagsMVK : uint32_t { e_NONE };
DEFINE_ENUM_BITWISE_OPERATORS(IOSSurfaceCreateFlagsMVK)
inline std::string to_string(IOSSurfaceCreateFlagsMVK value)
{
    (void)value;
    return "reserved";
}
#endif // VK_USE_PLATFORM_IOS_MVK

#ifdef VK_USE_PLATFORM_MACOS_MVK
enum class MacOSSurfaceCreateFlagsMVK : uint32_t { e_NONE };
DEFINE_ENUM_BITWISE_OPERATORS(MacOSSurfaceCreateFlagsMVK)
inline std::string to_string(MacOSSurfaceCreateFlagsMVK value)
{
    (void)value;
    return "reserved";
}
#endif // VK_USE_PLATFORM_MACOS_MVK

enum class DebugUtilsMessengerCallbackDataFlagsEXT : uint32_t { e_NONE };
DEFINE_ENUM_BITWISE_OPERATORS(DebugUtilsMessengerCallbackDataFlagsEXT)
inline std::string to_string(DebugUtilsMessengerCallbackDataFlagsEXT value)
{
    (void)value;
    return "reserved";
}

enum class DebugUtilsMessengerCreateFlagsEXT : uint32_t { e_NONE };
DEFINE_ENUM_BITWISE_OPERATORS(DebugUtilsMessengerCreateFlagsEXT)
inline std::string to_string(DebugUtilsMessengerCreateFlagsEXT value)
{
    (void)value;
    return "reserved";
}

enum class PipelineCoverageToColorStateCreateFlagsNV : uint32_t { e_NONE };
DEFINE_ENUM_BITWISE_OPERATORS(PipelineCoverageToColorStateCreateFlagsNV)
inline std::string to_string(PipelineCoverageToColorStateCreateFlagsNV value)
{
    (void)value;
    return "reserved";
}

enum class PipelineCoverageModulationStateCreateFlagsNV : uint32_t { e_NONE };
DEFINE_ENUM_BITWISE_OPERATORS(PipelineCoverageModulationStateCreateFlagsNV)
inline std::string to_string(PipelineCoverageModulationStateCreateFlagsNV value)
{
    (void)value;
    return "reserved";
}

enum class ValidationCacheCreateFlagsEXT : uint32_t { e_NONE };
DEFINE_ENUM_BITWISE_OPERATORS(ValidationCacheCreateFlagsEXT)
inline std::string to_string(ValidationCacheCreateFlagsEXT value)
{
    (void)value;
    return "reserved";
}




// PVRVk Enums
enum class PipelineCacheHeaderVersion
{
    e_NONE = 0,
    e_ONE = VK_PIPELINE_CACHE_HEADER_VERSION_ONE,
    e_BEGIN_RANGE = VK_PIPELINE_CACHE_HEADER_VERSION_BEGIN_RANGE,
    e_END_RANGE = VK_PIPELINE_CACHE_HEADER_VERSION_END_RANGE,
    e_RANGE_SIZE = VK_PIPELINE_CACHE_HEADER_VERSION_RANGE_SIZE,
    e_MAX_ENUM = 0x7FFFFFFF

};
DEFINE_ENUM_BITWISE_OPERATORS(PipelineCacheHeaderVersion)
inline std::string to_string(PipelineCacheHeaderVersion value)
{
    switch(value)
    {
    case PipelineCacheHeaderVersion::e_ONE: return "VK_PIPELINE_CACHE_HEADER_VERSION_ONE";
    default: return "invalid";
    }
}

enum class Result
{
    e_NONE = 0,
    e_SUCCESS = VK_SUCCESS,
    e_NOT_READY = VK_NOT_READY,
    e_TIMEOUT = VK_TIMEOUT,
    e_EVENT_SET = VK_EVENT_SET,
    e_EVENT_RESET = VK_EVENT_RESET,
    e_INCOMPLETE = VK_INCOMPLETE,
    e_ERROR_OUT_OF_HOST_MEMORY = VK_ERROR_OUT_OF_HOST_MEMORY,
    e_ERROR_OUT_OF_DEVICE_MEMORY = VK_ERROR_OUT_OF_DEVICE_MEMORY,
    e_ERROR_INITIALIZATION_FAILED = VK_ERROR_INITIALIZATION_FAILED,
    e_ERROR_DEVICE_LOST = VK_ERROR_DEVICE_LOST,
    e_ERROR_MEMORY_MAP_FAILED = VK_ERROR_MEMORY_MAP_FAILED,
    e_ERROR_LAYER_NOT_PRESENT = VK_ERROR_LAYER_NOT_PRESENT,
    e_ERROR_EXTENSION_NOT_PRESENT = VK_ERROR_EXTENSION_NOT_PRESENT,
    e_ERROR_FEATURE_NOT_PRESENT = VK_ERROR_FEATURE_NOT_PRESENT,
    e_ERROR_INCOMPATIBLE_DRIVER = VK_ERROR_INCOMPATIBLE_DRIVER,
    e_ERROR_TOO_MANY_OBJECTS = VK_ERROR_TOO_MANY_OBJECTS,
    e_ERROR_FORMAT_NOT_SUPPORTED = VK_ERROR_FORMAT_NOT_SUPPORTED,
    e_ERROR_FRAGMENTED_POOL = VK_ERROR_FRAGMENTED_POOL,
    e_ERROR_OUT_OF_POOL_MEMORY = VK_ERROR_OUT_OF_POOL_MEMORY,
    e_ERROR_INVALID_EXTERNAL_HANDLE = VK_ERROR_INVALID_EXTERNAL_HANDLE,
    e_ERROR_SURFACE_LOST_KHR = VK_ERROR_SURFACE_LOST_KHR,
    e_ERROR_NATIVE_WINDOW_IN_USE_KHR = VK_ERROR_NATIVE_WINDOW_IN_USE_KHR,
    e_SUBOPTIMAL_KHR = VK_SUBOPTIMAL_KHR,
    e_ERROR_OUT_OF_DATE_KHR = VK_ERROR_OUT_OF_DATE_KHR,
    e_ERROR_INCOMPATIBLE_DISPLAY_KHR = VK_ERROR_INCOMPATIBLE_DISPLAY_KHR,
    e_ERROR_VALIDATION_FAILED_EXT = VK_ERROR_VALIDATION_FAILED_EXT,
    e_ERROR_INVALID_SHADER_NV = VK_ERROR_INVALID_SHADER_NV,
    e_ERROR_OUT_OF_POOL_MEMORY_KHR = VK_ERROR_OUT_OF_POOL_MEMORY_KHR,
    e_ERROR_INVALID_EXTERNAL_HANDLE_KHR = VK_ERROR_INVALID_EXTERNAL_HANDLE_KHR,
    e_ERROR_FRAGMENTATION_EXT = VK_ERROR_FRAGMENTATION_EXT,
    e_ERROR_NOT_PERMITTED_EXT = VK_ERROR_NOT_PERMITTED_EXT,
    e_BEGIN_RANGE = VK_RESULT_BEGIN_RANGE,
    e_END_RANGE = VK_RESULT_END_RANGE,
    e_RANGE_SIZE = VK_RESULT_RANGE_SIZE,
    e_MAX_ENUM = 0x7FFFFFFF

};
DEFINE_ENUM_BITWISE_OPERATORS(Result)
inline std::string to_string(Result value)
{
    switch(value)
    {
    case Result::e_SUCCESS: return "VK_SUCCESS";
    case Result::e_NOT_READY: return "VK_NOT_READY";
    case Result::e_TIMEOUT: return "VK_TIMEOUT";
    case Result::e_EVENT_SET: return "VK_EVENT_SET";
    case Result::e_EVENT_RESET: return "VK_EVENT_RESET";
    case Result::e_INCOMPLETE: return "VK_INCOMPLETE";
    case Result::e_ERROR_OUT_OF_HOST_MEMORY: return "VK_ERROR_OUT_OF_HOST_MEMORY";
    case Result::e_ERROR_OUT_OF_DEVICE_MEMORY: return "VK_ERROR_OUT_OF_DEVICE_MEMORY";
    case Result::e_ERROR_INITIALIZATION_FAILED: return "VK_ERROR_INITIALIZATION_FAILED";
    case Result::e_ERROR_DEVICE_LOST: return "VK_ERROR_DEVICE_LOST";
    case Result::e_ERROR_MEMORY_MAP_FAILED: return "VK_ERROR_MEMORY_MAP_FAILED";
    case Result::e_ERROR_LAYER_NOT_PRESENT: return "VK_ERROR_LAYER_NOT_PRESENT";
    case Result::e_ERROR_EXTENSION_NOT_PRESENT: return "VK_ERROR_EXTENSION_NOT_PRESENT";
    case Result::e_ERROR_FEATURE_NOT_PRESENT: return "VK_ERROR_FEATURE_NOT_PRESENT";
    case Result::e_ERROR_INCOMPATIBLE_DRIVER: return "VK_ERROR_INCOMPATIBLE_DRIVER";
    case Result::e_ERROR_TOO_MANY_OBJECTS: return "VK_ERROR_TOO_MANY_OBJECTS";
    case Result::e_ERROR_FORMAT_NOT_SUPPORTED: return "VK_ERROR_FORMAT_NOT_SUPPORTED";
    case Result::e_ERROR_FRAGMENTED_POOL: return "VK_ERROR_FRAGMENTED_POOL";
    case Result::e_ERROR_OUT_OF_POOL_MEMORY: return "VK_ERROR_OUT_OF_POOL_MEMORY";
    case Result::e_ERROR_INVALID_EXTERNAL_HANDLE: return "VK_ERROR_INVALID_EXTERNAL_HANDLE";
    case Result::e_ERROR_SURFACE_LOST_KHR: return "VK_ERROR_SURFACE_LOST_KHR";
    case Result::e_ERROR_NATIVE_WINDOW_IN_USE_KHR: return "VK_ERROR_NATIVE_WINDOW_IN_USE_KHR";
    case Result::e_SUBOPTIMAL_KHR: return "VK_SUBOPTIMAL_KHR";
    case Result::e_ERROR_OUT_OF_DATE_KHR: return "VK_ERROR_OUT_OF_DATE_KHR";
    case Result::e_ERROR_INCOMPATIBLE_DISPLAY_KHR: return "VK_ERROR_INCOMPATIBLE_DISPLAY_KHR";
    case Result::e_ERROR_VALIDATION_FAILED_EXT: return "VK_ERROR_VALIDATION_FAILED_EXT";
    case Result::e_ERROR_INVALID_SHADER_NV: return "VK_ERROR_INVALID_SHADER_NV";
    case Result::e_ERROR_FRAGMENTATION_EXT: return "VK_ERROR_FRAGMENTATION_EXT";
    case Result::e_ERROR_NOT_PERMITTED_EXT: return "VK_ERROR_NOT_PERMITTED_EXT";
    default: return "invalid";
    }
}

enum class StructureType
{
    e_NONE = 0,
    e_APPLICATION_INFO = VK_STRUCTURE_TYPE_APPLICATION_INFO,
    e_INSTANCE_CREATE_INFO = VK_STRUCTURE_TYPE_INSTANCE_CREATE_INFO,
    e_DEVICE_QUEUE_CREATE_INFO = VK_STRUCTURE_TYPE_DEVICE_QUEUE_CREATE_INFO,
    e_DEVICE_CREATE_INFO = VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO,
    e_SUBMIT_INFO = VK_STRUCTURE_TYPE_SUBMIT_INFO,
    e_MEMORY_ALLOCATE_INFO = VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_INFO,
    e_MAPPED_MEMORY_RANGE = VK_STRUCTURE_TYPE_MAPPED_MEMORY_RANGE,
    e_BIND_SPARSE_INFO = VK_STRUCTURE_TYPE_BIND_SPARSE_INFO,
    e_FENCE_CREATE_INFO = VK_STRUCTURE_TYPE_FENCE_CREATE_INFO,
    e_SEMAPHORE_CREATE_INFO = VK_STRUCTURE_TYPE_SEMAPHORE_CREATE_INFO,
    e_EVENT_CREATE_INFO = VK_STRUCTURE_TYPE_EVENT_CREATE_INFO,
    e_QUERY_POOL_CREATE_INFO = VK_STRUCTURE_TYPE_QUERY_POOL_CREATE_INFO,
    e_BUFFER_CREATE_INFO = VK_STRUCTURE_TYPE_BUFFER_CREATE_INFO,
    e_BUFFER_VIEW_CREATE_INFO = VK_STRUCTURE_TYPE_BUFFER_VIEW_CREATE_INFO,
    e_IMAGE_CREATE_INFO = VK_STRUCTURE_TYPE_IMAGE_CREATE_INFO,
    e_IMAGE_VIEW_CREATE_INFO = VK_STRUCTURE_TYPE_IMAGE_VIEW_CREATE_INFO,
    e_SHADER_MODULE_CREATE_INFO = VK_STRUCTURE_TYPE_SHADER_MODULE_CREATE_INFO,
    e_PIPELINE_CACHE_CREATE_INFO = VK_STRUCTURE_TYPE_PIPELINE_CACHE_CREATE_INFO,
    e_PIPELINE_SHADER_STAGE_CREATE_INFO = VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO,
    e_PIPELINE_VERTEX_INPUT_STATE_CREATE_INFO = VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_STATE_CREATE_INFO,
    e_PIPELINE_INPUT_ASSEMBLY_STATE_CREATE_INFO = VK_STRUCTURE_TYPE_PIPELINE_INPUT_ASSEMBLY_STATE_CREATE_INFO,
    e_PIPELINE_TESSELLATION_STATE_CREATE_INFO = VK_STRUCTURE_TYPE_PIPELINE_TESSELLATION_STATE_CREATE_INFO,
    e_PIPELINE_VIEWPORT_STATE_CREATE_INFO = VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_STATE_CREATE_INFO,
    e_PIPELINE_RASTERIZATION_STATE_CREATE_INFO = VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_CREATE_INFO,
    e_PIPELINE_MULTISAMPLE_STATE_CREATE_INFO = VK_STRUCTURE_TYPE_PIPELINE_MULTISAMPLE_STATE_CREATE_INFO,
    e_PIPELINE_DEPTH_STENCIL_STATE_CREATE_INFO = VK_STRUCTURE_TYPE_PIPELINE_DEPTH_STENCIL_STATE_CREATE_INFO,
    e_PIPELINE_COLOR_BLEND_STATE_CREATE_INFO = VK_STRUCTURE_TYPE_PIPELINE_COLOR_BLEND_STATE_CREATE_INFO,
    e_PIPELINE_DYNAMIC_STATE_CREATE_INFO = VK_STRUCTURE_TYPE_PIPELINE_DYNAMIC_STATE_CREATE_INFO,
    e_GRAPHICS_PIPELINE_CREATE_INFO = VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_CREATE_INFO,
    e_COMPUTE_PIPELINE_CREATE_INFO = VK_STRUCTURE_TYPE_COMPUTE_PIPELINE_CREATE_INFO,
    e_PIPELINE_LAYOUT_CREATE_INFO = VK_STRUCTURE_TYPE_PIPELINE_LAYOUT_CREATE_INFO,
    e_SAMPLER_CREATE_INFO = VK_STRUCTURE_TYPE_SAMPLER_CREATE_INFO,
    e_DESCRIPTOR_SET_LAYOUT_CREATE_INFO = VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_CREATE_INFO,
    e_DESCRIPTOR_POOL_CREATE_INFO = VK_STRUCTURE_TYPE_DESCRIPTOR_POOL_CREATE_INFO,
    e_DESCRIPTOR_SET_ALLOCATE_INFO = VK_STRUCTURE_TYPE_DESCRIPTOR_SET_ALLOCATE_INFO,
    e_WRITE_DESCRIPTOR_SET = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET,
    e_COPY_DESCRIPTOR_SET = VK_STRUCTURE_TYPE_COPY_DESCRIPTOR_SET,
    e_FRAMEBUFFER_CREATE_INFO = VK_STRUCTURE_TYPE_FRAMEBUFFER_CREATE_INFO,
    e_RENDER_PASS_CREATE_INFO = VK_STRUCTURE_TYPE_RENDER_PASS_CREATE_INFO,
    e_COMMAND_POOL_CREATE_INFO = VK_STRUCTURE_TYPE_COMMAND_POOL_CREATE_INFO,
    e_COMMAND_BUFFER_ALLOCATE_INFO = VK_STRUCTURE_TYPE_COMMAND_BUFFER_ALLOCATE_INFO,
    e_COMMAND_BUFFER_INHERITANCE_INFO = VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_INFO,
    e_COMMAND_BUFFER_BEGIN_INFO = VK_STRUCTURE_TYPE_COMMAND_BUFFER_BEGIN_INFO,
    e_RENDER_PASS_BEGIN_INFO = VK_STRUCTURE_TYPE_RENDER_PASS_BEGIN_INFO,
    e_BUFFER_MEMORY_BARRIER = VK_STRUCTURE_TYPE_BUFFER_MEMORY_BARRIER,
    e_IMAGE_MEMORY_BARRIER = VK_STRUCTURE_TYPE_IMAGE_MEMORY_BARRIER,
    e_MEMORY_BARRIER = VK_STRUCTURE_TYPE_MEMORY_BARRIER,
    e_LOADER_INSTANCE_CREATE_INFO = VK_STRUCTURE_TYPE_LOADER_INSTANCE_CREATE_INFO,
    e_LOADER_DEVICE_CREATE_INFO = VK_STRUCTURE_TYPE_LOADER_DEVICE_CREATE_INFO,
    e_PHYSICAL_DEVICE_SUBGROUP_PROPERTIES = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBGROUP_PROPERTIES,
    e_BIND_BUFFER_MEMORY_INFO = VK_STRUCTURE_TYPE_BIND_BUFFER_MEMORY_INFO,
    e_BIND_IMAGE_MEMORY_INFO = VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_INFO,
    e_PHYSICAL_DEVICE_16BIT_STORAGE_FEATURES = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_16BIT_STORAGE_FEATURES,
    e_MEMORY_DEDICATED_REQUIREMENTS = VK_STRUCTURE_TYPE_MEMORY_DEDICATED_REQUIREMENTS,
    e_MEMORY_DEDICATED_ALLOCATE_INFO = VK_STRUCTURE_TYPE_MEMORY_DEDICATED_ALLOCATE_INFO,
    e_MEMORY_ALLOCATE_FLAGS_INFO = VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_FLAGS_INFO,
    e_DEVICE_GROUP_RENDER_PASS_BEGIN_INFO = VK_STRUCTURE_TYPE_DEVICE_GROUP_RENDER_PASS_BEGIN_INFO,
    e_DEVICE_GROUP_COMMAND_BUFFER_BEGIN_INFO = VK_STRUCTURE_TYPE_DEVICE_GROUP_COMMAND_BUFFER_BEGIN_INFO,
    e_DEVICE_GROUP_SUBMIT_INFO = VK_STRUCTURE_TYPE_DEVICE_GROUP_SUBMIT_INFO,
    e_DEVICE_GROUP_BIND_SPARSE_INFO = VK_STRUCTURE_TYPE_DEVICE_GROUP_BIND_SPARSE_INFO,
    e_BIND_BUFFER_MEMORY_DEVICE_GROUP_INFO = VK_STRUCTURE_TYPE_BIND_BUFFER_MEMORY_DEVICE_GROUP_INFO,
    e_BIND_IMAGE_MEMORY_DEVICE_GROUP_INFO = VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_DEVICE_GROUP_INFO,
    e_PHYSICAL_DEVICE_GROUP_PROPERTIES = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GROUP_PROPERTIES,
    e_DEVICE_GROUP_DEVICE_CREATE_INFO = VK_STRUCTURE_TYPE_DEVICE_GROUP_DEVICE_CREATE_INFO,
    e_BUFFER_MEMORY_REQUIREMENTS_INFO_2 = VK_STRUCTURE_TYPE_BUFFER_MEMORY_REQUIREMENTS_INFO_2,
    e_IMAGE_MEMORY_REQUIREMENTS_INFO_2 = VK_STRUCTURE_TYPE_IMAGE_MEMORY_REQUIREMENTS_INFO_2,
    e_IMAGE_SPARSE_MEMORY_REQUIREMENTS_INFO_2 = VK_STRUCTURE_TYPE_IMAGE_SPARSE_MEMORY_REQUIREMENTS_INFO_2,
    e_MEMORY_REQUIREMENTS_2 = VK_STRUCTURE_TYPE_MEMORY_REQUIREMENTS_2,
    e_SPARSE_IMAGE_MEMORY_REQUIREMENTS_2 = VK_STRUCTURE_TYPE_SPARSE_IMAGE_MEMORY_REQUIREMENTS_2,
    e_PHYSICAL_DEVICE_FEATURES_2 = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2,
    e_PHYSICAL_DEVICE_PROPERTIES_2 = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROPERTIES_2,
    e_FORMAT_PROPERTIES_2 = VK_STRUCTURE_TYPE_FORMAT_PROPERTIES_2,
    e_IMAGE_FORMAT_PROPERTIES_2 = VK_STRUCTURE_TYPE_IMAGE_FORMAT_PROPERTIES_2,
    e_PHYSICAL_DEVICE_IMAGE_FORMAT_INFO_2 = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_FORMAT_INFO_2,
    e_QUEUE_FAMILY_PROPERTIES_2 = VK_STRUCTURE_TYPE_QUEUE_FAMILY_PROPERTIES_2,
    e_PHYSICAL_DEVICE_MEMORY_PROPERTIES_2 = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_PROPERTIES_2,
    e_SPARSE_IMAGE_FORMAT_PROPERTIES_2 = VK_STRUCTURE_TYPE_SPARSE_IMAGE_FORMAT_PROPERTIES_2,
    e_PHYSICAL_DEVICE_SPARSE_IMAGE_FORMAT_INFO_2 = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SPARSE_IMAGE_FORMAT_INFO_2,
    e_PHYSICAL_DEVICE_POINT_CLIPPING_PROPERTIES = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_POINT_CLIPPING_PROPERTIES,
    e_RENDER_PASS_INPUT_ATTACHMENT_ASPECT_CREATE_INFO = VK_STRUCTURE_TYPE_RENDER_PASS_INPUT_ATTACHMENT_ASPECT_CREATE_INFO,
    e_IMAGE_VIEW_USAGE_CREATE_INFO = VK_STRUCTURE_TYPE_IMAGE_VIEW_USAGE_CREATE_INFO,
    e_PIPELINE_TESSELLATION_DOMAIN_ORIGIN_STATE_CREATE_INFO = VK_STRUCTURE_TYPE_PIPELINE_TESSELLATION_DOMAIN_ORIGIN_STATE_CREATE_INFO,
    e_RENDER_PASS_MULTIVIEW_CREATE_INFO = VK_STRUCTURE_TYPE_RENDER_PASS_MULTIVIEW_CREATE_INFO,
    e_PHYSICAL_DEVICE_MULTIVIEW_FEATURES = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_FEATURES,
    e_PHYSICAL_DEVICE_MULTIVIEW_PROPERTIES = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PROPERTIES,
    e_PHYSICAL_DEVICE_VARIABLE_POINTER_FEATURES = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VARIABLE_POINTER_FEATURES,
    e_PROTECTED_SUBMIT_INFO = VK_STRUCTURE_TYPE_PROTECTED_SUBMIT_INFO,
    e_PHYSICAL_DEVICE_PROTECTED_MEMORY_FEATURES = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROTECTED_MEMORY_FEATURES,
    e_PHYSICAL_DEVICE_PROTECTED_MEMORY_PROPERTIES = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROTECTED_MEMORY_PROPERTIES,
    e_DEVICE_QUEUE_INFO_2 = VK_STRUCTURE_TYPE_DEVICE_QUEUE_INFO_2,
    e_SAMPLER_YCBCR_CONVERSION_CREATE_INFO = VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_CREATE_INFO,
    e_SAMPLER_YCBCR_CONVERSION_INFO = VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_INFO,
    e_BIND_IMAGE_PLANE_MEMORY_INFO = VK_STRUCTURE_TYPE_BIND_IMAGE_PLANE_MEMORY_INFO,
    e_IMAGE_PLANE_MEMORY_REQUIREMENTS_INFO = VK_STRUCTURE_TYPE_IMAGE_PLANE_MEMORY_REQUIREMENTS_INFO,
    e_PHYSICAL_DEVICE_SAMPLER_YCBCR_CONVERSION_FEATURES = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLER_YCBCR_CONVERSION_FEATURES,
    e_SAMPLER_YCBCR_CONVERSION_IMAGE_FORMAT_PROPERTIES = VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_IMAGE_FORMAT_PROPERTIES,
    e_DESCRIPTOR_UPDATE_TEMPLATE_CREATE_INFO = VK_STRUCTURE_TYPE_DESCRIPTOR_UPDATE_TEMPLATE_CREATE_INFO,
    e_PHYSICAL_DEVICE_EXTERNAL_IMAGE_FORMAT_INFO = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_IMAGE_FORMAT_INFO,
    e_EXTERNAL_IMAGE_FORMAT_PROPERTIES = VK_STRUCTURE_TYPE_EXTERNAL_IMAGE_FORMAT_PROPERTIES,
    e_PHYSICAL_DEVICE_EXTERNAL_BUFFER_INFO = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_BUFFER_INFO,
    e_EXTERNAL_BUFFER_PROPERTIES = VK_STRUCTURE_TYPE_EXTERNAL_BUFFER_PROPERTIES,
    e_PHYSICAL_DEVICE_ID_PROPERTIES = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ID_PROPERTIES,
    e_EXTERNAL_MEMORY_BUFFER_CREATE_INFO = VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_BUFFER_CREATE_INFO,
    e_EXTERNAL_MEMORY_IMAGE_CREATE_INFO = VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_IMAGE_CREATE_INFO,
    e_EXPORT_MEMORY_ALLOCATE_INFO = VK_STRUCTURE_TYPE_EXPORT_MEMORY_ALLOCATE_INFO,
    e_PHYSICAL_DEVICE_EXTERNAL_FENCE_INFO = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_FENCE_INFO,
    e_EXTERNAL_FENCE_PROPERTIES = VK_STRUCTURE_TYPE_EXTERNAL_FENCE_PROPERTIES,
    e_EXPORT_FENCE_CREATE_INFO = VK_STRUCTURE_TYPE_EXPORT_FENCE_CREATE_INFO,
    e_EXPORT_SEMAPHORE_CREATE_INFO = VK_STRUCTURE_TYPE_EXPORT_SEMAPHORE_CREATE_INFO,
    e_PHYSICAL_DEVICE_EXTERNAL_SEMAPHORE_INFO = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_SEMAPHORE_INFO,
    e_EXTERNAL_SEMAPHORE_PROPERTIES = VK_STRUCTURE_TYPE_EXTERNAL_SEMAPHORE_PROPERTIES,
    e_PHYSICAL_DEVICE_MAINTENANCE_3_PROPERTIES = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_3_PROPERTIES,
    e_DESCRIPTOR_SET_LAYOUT_SUPPORT = VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_SUPPORT,
    e_PHYSICAL_DEVICE_SHADER_DRAW_PARAMETER_FEATURES = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_DRAW_PARAMETER_FEATURES,
    e_SWAPCHAIN_CREATE_INFO_KHR = VK_STRUCTURE_TYPE_SWAPCHAIN_CREATE_INFO_KHR,
    e_PRESENT_INFO_KHR = VK_STRUCTURE_TYPE_PRESENT_INFO_KHR,
    e_DEVICE_GROUP_PRESENT_CAPABILITIES_KHR = VK_STRUCTURE_TYPE_DEVICE_GROUP_PRESENT_CAPABILITIES_KHR,
    e_IMAGE_SWAPCHAIN_CREATE_INFO_KHR = VK_STRUCTURE_TYPE_IMAGE_SWAPCHAIN_CREATE_INFO_KHR,
    e_BIND_IMAGE_MEMORY_SWAPCHAIN_INFO_KHR = VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_SWAPCHAIN_INFO_KHR,
    e_ACQUIRE_NEXT_IMAGE_INFO_KHR = VK_STRUCTURE_TYPE_ACQUIRE_NEXT_IMAGE_INFO_KHR,
    e_DEVICE_GROUP_PRESENT_INFO_KHR = VK_STRUCTURE_TYPE_DEVICE_GROUP_PRESENT_INFO_KHR,
    e_DEVICE_GROUP_SWAPCHAIN_CREATE_INFO_KHR = VK_STRUCTURE_TYPE_DEVICE_GROUP_SWAPCHAIN_CREATE_INFO_KHR,
    e_DISPLAY_MODE_CREATE_INFO_KHR = VK_STRUCTURE_TYPE_DISPLAY_MODE_CREATE_INFO_KHR,
    e_DISPLAY_SURFACE_CREATE_INFO_KHR = VK_STRUCTURE_TYPE_DISPLAY_SURFACE_CREATE_INFO_KHR,
    e_DISPLAY_PRESENT_INFO_KHR = VK_STRUCTURE_TYPE_DISPLAY_PRESENT_INFO_KHR,
    e_XLIB_SURFACE_CREATE_INFO_KHR = VK_STRUCTURE_TYPE_XLIB_SURFACE_CREATE_INFO_KHR,
    e_XCB_SURFACE_CREATE_INFO_KHR = VK_STRUCTURE_TYPE_XCB_SURFACE_CREATE_INFO_KHR,
    e_WAYLAND_SURFACE_CREATE_INFO_KHR = VK_STRUCTURE_TYPE_WAYLAND_SURFACE_CREATE_INFO_KHR,
    e_MIR_SURFACE_CREATE_INFO_KHR = VK_STRUCTURE_TYPE_MIR_SURFACE_CREATE_INFO_KHR,
    e_ANDROID_SURFACE_CREATE_INFO_KHR = VK_STRUCTURE_TYPE_ANDROID_SURFACE_CREATE_INFO_KHR,
    e_WIN32_SURFACE_CREATE_INFO_KHR = VK_STRUCTURE_TYPE_WIN32_SURFACE_CREATE_INFO_KHR,
    e_DEBUG_REPORT_CALLBACK_CREATE_INFO_EXT = VK_STRUCTURE_TYPE_DEBUG_REPORT_CALLBACK_CREATE_INFO_EXT,
    e_PIPELINE_RASTERIZATION_STATE_RASTERIZATION_ORDER_AMD = VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_RASTERIZATION_ORDER_AMD,
    e_DEBUG_MARKER_OBJECT_NAME_INFO_EXT = VK_STRUCTURE_TYPE_DEBUG_MARKER_OBJECT_NAME_INFO_EXT,
    e_DEBUG_MARKER_OBJECT_TAG_INFO_EXT = VK_STRUCTURE_TYPE_DEBUG_MARKER_OBJECT_TAG_INFO_EXT,
    e_DEBUG_MARKER_MARKER_INFO_EXT = VK_STRUCTURE_TYPE_DEBUG_MARKER_MARKER_INFO_EXT,
    e_DEDICATED_ALLOCATION_IMAGE_CREATE_INFO_NV = VK_STRUCTURE_TYPE_DEDICATED_ALLOCATION_IMAGE_CREATE_INFO_NV,
    e_DEDICATED_ALLOCATION_BUFFER_CREATE_INFO_NV = VK_STRUCTURE_TYPE_DEDICATED_ALLOCATION_BUFFER_CREATE_INFO_NV,
    e_DEDICATED_ALLOCATION_MEMORY_ALLOCATE_INFO_NV = VK_STRUCTURE_TYPE_DEDICATED_ALLOCATION_MEMORY_ALLOCATE_INFO_NV,
    e_TEXTURE_LOD_GATHER_FORMAT_PROPERTIES_AMD = VK_STRUCTURE_TYPE_TEXTURE_LOD_GATHER_FORMAT_PROPERTIES_AMD,
    e_RENDER_PASS_MULTIVIEW_CREATE_INFO_KHR = VK_STRUCTURE_TYPE_RENDER_PASS_MULTIVIEW_CREATE_INFO_KHR,
    e_PHYSICAL_DEVICE_MULTIVIEW_FEATURES_KHR = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_FEATURES_KHR,
    e_PHYSICAL_DEVICE_MULTIVIEW_PROPERTIES_KHR = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PROPERTIES_KHR,
    e_EXTERNAL_MEMORY_IMAGE_CREATE_INFO_NV = VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_IMAGE_CREATE_INFO_NV,
    e_EXPORT_MEMORY_ALLOCATE_INFO_NV = VK_STRUCTURE_TYPE_EXPORT_MEMORY_ALLOCATE_INFO_NV,
    e_IMPORT_MEMORY_WIN32_HANDLE_INFO_NV = VK_STRUCTURE_TYPE_IMPORT_MEMORY_WIN32_HANDLE_INFO_NV,
    e_EXPORT_MEMORY_WIN32_HANDLE_INFO_NV = VK_STRUCTURE_TYPE_EXPORT_MEMORY_WIN32_HANDLE_INFO_NV,
    e_WIN32_KEYED_MUTEX_ACQUIRE_RELEASE_INFO_NV = VK_STRUCTURE_TYPE_WIN32_KEYED_MUTEX_ACQUIRE_RELEASE_INFO_NV,
    e_PHYSICAL_DEVICE_FEATURES_2_KHR = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2_KHR,
    e_PHYSICAL_DEVICE_PROPERTIES_2_KHR = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROPERTIES_2_KHR,
    e_FORMAT_PROPERTIES_2_KHR = VK_STRUCTURE_TYPE_FORMAT_PROPERTIES_2_KHR,
    e_IMAGE_FORMAT_PROPERTIES_2_KHR = VK_STRUCTURE_TYPE_IMAGE_FORMAT_PROPERTIES_2_KHR,
    e_PHYSICAL_DEVICE_IMAGE_FORMAT_INFO_2_KHR = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_FORMAT_INFO_2_KHR,
    e_QUEUE_FAMILY_PROPERTIES_2_KHR = VK_STRUCTURE_TYPE_QUEUE_FAMILY_PROPERTIES_2_KHR,
    e_PHYSICAL_DEVICE_MEMORY_PROPERTIES_2_KHR = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_PROPERTIES_2_KHR,
    e_SPARSE_IMAGE_FORMAT_PROPERTIES_2_KHR = VK_STRUCTURE_TYPE_SPARSE_IMAGE_FORMAT_PROPERTIES_2_KHR,
    e_PHYSICAL_DEVICE_SPARSE_IMAGE_FORMAT_INFO_2_KHR = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SPARSE_IMAGE_FORMAT_INFO_2_KHR,
    e_MEMORY_ALLOCATE_FLAGS_INFO_KHR = VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_FLAGS_INFO_KHR,
    e_DEVICE_GROUP_RENDER_PASS_BEGIN_INFO_KHR = VK_STRUCTURE_TYPE_DEVICE_GROUP_RENDER_PASS_BEGIN_INFO_KHR,
    e_DEVICE_GROUP_COMMAND_BUFFER_BEGIN_INFO_KHR = VK_STRUCTURE_TYPE_DEVICE_GROUP_COMMAND_BUFFER_BEGIN_INFO_KHR,
    e_DEVICE_GROUP_SUBMIT_INFO_KHR = VK_STRUCTURE_TYPE_DEVICE_GROUP_SUBMIT_INFO_KHR,
    e_DEVICE_GROUP_BIND_SPARSE_INFO_KHR = VK_STRUCTURE_TYPE_DEVICE_GROUP_BIND_SPARSE_INFO_KHR,
    e_BIND_BUFFER_MEMORY_DEVICE_GROUP_INFO_KHR = VK_STRUCTURE_TYPE_BIND_BUFFER_MEMORY_DEVICE_GROUP_INFO_KHR,
    e_BIND_IMAGE_MEMORY_DEVICE_GROUP_INFO_KHR = VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_DEVICE_GROUP_INFO_KHR,
    e_VALIDATION_FLAGS_EXT = VK_STRUCTURE_TYPE_VALIDATION_FLAGS_EXT,
    e_VI_SURFACE_CREATE_INFO_NN = VK_STRUCTURE_TYPE_VI_SURFACE_CREATE_INFO_NN,
    e_PHYSICAL_DEVICE_GROUP_PROPERTIES_KHR = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GROUP_PROPERTIES_KHR,
    e_DEVICE_GROUP_DEVICE_CREATE_INFO_KHR = VK_STRUCTURE_TYPE_DEVICE_GROUP_DEVICE_CREATE_INFO_KHR,
    e_PHYSICAL_DEVICE_EXTERNAL_IMAGE_FORMAT_INFO_KHR = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_IMAGE_FORMAT_INFO_KHR,
    e_EXTERNAL_IMAGE_FORMAT_PROPERTIES_KHR = VK_STRUCTURE_TYPE_EXTERNAL_IMAGE_FORMAT_PROPERTIES_KHR,
    e_PHYSICAL_DEVICE_EXTERNAL_BUFFER_INFO_KHR = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_BUFFER_INFO_KHR,
    e_EXTERNAL_BUFFER_PROPERTIES_KHR = VK_STRUCTURE_TYPE_EXTERNAL_BUFFER_PROPERTIES_KHR,
    e_PHYSICAL_DEVICE_ID_PROPERTIES_KHR = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ID_PROPERTIES_KHR,
    e_EXTERNAL_MEMORY_BUFFER_CREATE_INFO_KHR = VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_BUFFER_CREATE_INFO_KHR,
    e_EXTERNAL_MEMORY_IMAGE_CREATE_INFO_KHR = VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_IMAGE_CREATE_INFO_KHR,
    e_EXPORT_MEMORY_ALLOCATE_INFO_KHR = VK_STRUCTURE_TYPE_EXPORT_MEMORY_ALLOCATE_INFO_KHR,
    e_IMPORT_MEMORY_WIN32_HANDLE_INFO_KHR = VK_STRUCTURE_TYPE_IMPORT_MEMORY_WIN32_HANDLE_INFO_KHR,
    e_EXPORT_MEMORY_WIN32_HANDLE_INFO_KHR = VK_STRUCTURE_TYPE_EXPORT_MEMORY_WIN32_HANDLE_INFO_KHR,
    e_MEMORY_WIN32_HANDLE_PROPERTIES_KHR = VK_STRUCTURE_TYPE_MEMORY_WIN32_HANDLE_PROPERTIES_KHR,
    e_MEMORY_GET_WIN32_HANDLE_INFO_KHR = VK_STRUCTURE_TYPE_MEMORY_GET_WIN32_HANDLE_INFO_KHR,
    e_IMPORT_MEMORY_FD_INFO_KHR = VK_STRUCTURE_TYPE_IMPORT_MEMORY_FD_INFO_KHR,
    e_MEMORY_FD_PROPERTIES_KHR = VK_STRUCTURE_TYPE_MEMORY_FD_PROPERTIES_KHR,
    e_MEMORY_GET_FD_INFO_KHR = VK_STRUCTURE_TYPE_MEMORY_GET_FD_INFO_KHR,
    e_WIN32_KEYED_MUTEX_ACQUIRE_RELEASE_INFO_KHR = VK_STRUCTURE_TYPE_WIN32_KEYED_MUTEX_ACQUIRE_RELEASE_INFO_KHR,
    e_PHYSICAL_DEVICE_EXTERNAL_SEMAPHORE_INFO_KHR = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_SEMAPHORE_INFO_KHR,
    e_EXTERNAL_SEMAPHORE_PROPERTIES_KHR = VK_STRUCTURE_TYPE_EXTERNAL_SEMAPHORE_PROPERTIES_KHR,
    e_EXPORT_SEMAPHORE_CREATE_INFO_KHR = VK_STRUCTURE_TYPE_EXPORT_SEMAPHORE_CREATE_INFO_KHR,
    e_IMPORT_SEMAPHORE_WIN32_HANDLE_INFO_KHR = VK_STRUCTURE_TYPE_IMPORT_SEMAPHORE_WIN32_HANDLE_INFO_KHR,
    e_EXPORT_SEMAPHORE_WIN32_HANDLE_INFO_KHR = VK_STRUCTURE_TYPE_EXPORT_SEMAPHORE_WIN32_HANDLE_INFO_KHR,
    e_D3D12_FENCE_SUBMIT_INFO_KHR = VK_STRUCTURE_TYPE_D3D12_FENCE_SUBMIT_INFO_KHR,
    e_SEMAPHORE_GET_WIN32_HANDLE_INFO_KHR = VK_STRUCTURE_TYPE_SEMAPHORE_GET_WIN32_HANDLE_INFO_KHR,
    e_IMPORT_SEMAPHORE_FD_INFO_KHR = VK_STRUCTURE_TYPE_IMPORT_SEMAPHORE_FD_INFO_KHR,
    e_SEMAPHORE_GET_FD_INFO_KHR = VK_STRUCTURE_TYPE_SEMAPHORE_GET_FD_INFO_KHR,
    e_PHYSICAL_DEVICE_PUSH_DESCRIPTOR_PROPERTIES_KHR = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PUSH_DESCRIPTOR_PROPERTIES_KHR,
    e_PHYSICAL_DEVICE_16BIT_STORAGE_FEATURES_KHR = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_16BIT_STORAGE_FEATURES_KHR,
    e_PRESENT_REGIONS_KHR = VK_STRUCTURE_TYPE_PRESENT_REGIONS_KHR,
    e_DESCRIPTOR_UPDATE_TEMPLATE_CREATE_INFO_KHR = VK_STRUCTURE_TYPE_DESCRIPTOR_UPDATE_TEMPLATE_CREATE_INFO_KHR,
    e_OBJECT_TABLE_CREATE_INFO_NVX = VK_STRUCTURE_TYPE_OBJECT_TABLE_CREATE_INFO_NVX,
    e_INDIRECT_COMMANDS_LAYOUT_CREATE_INFO_NVX = VK_STRUCTURE_TYPE_INDIRECT_COMMANDS_LAYOUT_CREATE_INFO_NVX,
    e_CMD_PROCESS_COMMANDS_INFO_NVX = VK_STRUCTURE_TYPE_CMD_PROCESS_COMMANDS_INFO_NVX,
    e_CMD_RESERVE_SPACE_FOR_COMMANDS_INFO_NVX = VK_STRUCTURE_TYPE_CMD_RESERVE_SPACE_FOR_COMMANDS_INFO_NVX,
    e_DEVICE_GENERATED_COMMANDS_LIMITS_NVX = VK_STRUCTURE_TYPE_DEVICE_GENERATED_COMMANDS_LIMITS_NVX,
    e_DEVICE_GENERATED_COMMANDS_FEATURES_NVX = VK_STRUCTURE_TYPE_DEVICE_GENERATED_COMMANDS_FEATURES_NVX,
    e_PIPELINE_VIEWPORT_W_SCALING_STATE_CREATE_INFO_NV = VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_W_SCALING_STATE_CREATE_INFO_NV,
    e_SURFACE_CAPABILITIES_2_EXT = VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES_2_EXT,
    e_DISPLAY_POWER_INFO_EXT = VK_STRUCTURE_TYPE_DISPLAY_POWER_INFO_EXT,
    e_DEVICE_EVENT_INFO_EXT = VK_STRUCTURE_TYPE_DEVICE_EVENT_INFO_EXT,
    e_DISPLAY_EVENT_INFO_EXT = VK_STRUCTURE_TYPE_DISPLAY_EVENT_INFO_EXT,
    e_SWAPCHAIN_COUNTER_CREATE_INFO_EXT = VK_STRUCTURE_TYPE_SWAPCHAIN_COUNTER_CREATE_INFO_EXT,
    e_PRESENT_TIMES_INFO_GOOGLE = VK_STRUCTURE_TYPE_PRESENT_TIMES_INFO_GOOGLE,
    e_PHYSICAL_DEVICE_MULTIVIEW_PER_VIEW_ATTRIBUTES_PROPERTIES_NVX = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PER_VIEW_ATTRIBUTES_PROPERTIES_NVX,
    e_PIPELINE_VIEWPORT_SWIZZLE_STATE_CREATE_INFO_NV = VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_SWIZZLE_STATE_CREATE_INFO_NV,
    e_PHYSICAL_DEVICE_DISCARD_RECTANGLE_PROPERTIES_EXT = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DISCARD_RECTANGLE_PROPERTIES_EXT,
    e_PIPELINE_DISCARD_RECTANGLE_STATE_CREATE_INFO_EXT = VK_STRUCTURE_TYPE_PIPELINE_DISCARD_RECTANGLE_STATE_CREATE_INFO_EXT,
    e_PHYSICAL_DEVICE_CONSERVATIVE_RASTERIZATION_PROPERTIES_EXT = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CONSERVATIVE_RASTERIZATION_PROPERTIES_EXT,
    e_PIPELINE_RASTERIZATION_CONSERVATIVE_STATE_CREATE_INFO_EXT = VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_CONSERVATIVE_STATE_CREATE_INFO_EXT,
    e_HDR_METADATA_EXT = VK_STRUCTURE_TYPE_HDR_METADATA_EXT,
    e_SHARED_PRESENT_SURFACE_CAPABILITIES_KHR = VK_STRUCTURE_TYPE_SHARED_PRESENT_SURFACE_CAPABILITIES_KHR,
    e_PHYSICAL_DEVICE_EXTERNAL_FENCE_INFO_KHR = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_FENCE_INFO_KHR,
    e_EXTERNAL_FENCE_PROPERTIES_KHR = VK_STRUCTURE_TYPE_EXTERNAL_FENCE_PROPERTIES_KHR,
    e_EXPORT_FENCE_CREATE_INFO_KHR = VK_STRUCTURE_TYPE_EXPORT_FENCE_CREATE_INFO_KHR,
    e_IMPORT_FENCE_WIN32_HANDLE_INFO_KHR = VK_STRUCTURE_TYPE_IMPORT_FENCE_WIN32_HANDLE_INFO_KHR,
    e_EXPORT_FENCE_WIN32_HANDLE_INFO_KHR = VK_STRUCTURE_TYPE_EXPORT_FENCE_WIN32_HANDLE_INFO_KHR,
    e_FENCE_GET_WIN32_HANDLE_INFO_KHR = VK_STRUCTURE_TYPE_FENCE_GET_WIN32_HANDLE_INFO_KHR,
    e_IMPORT_FENCE_FD_INFO_KHR = VK_STRUCTURE_TYPE_IMPORT_FENCE_FD_INFO_KHR,
    e_FENCE_GET_FD_INFO_KHR = VK_STRUCTURE_TYPE_FENCE_GET_FD_INFO_KHR,
    e_PHYSICAL_DEVICE_POINT_CLIPPING_PROPERTIES_KHR = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_POINT_CLIPPING_PROPERTIES_KHR,
    e_RENDER_PASS_INPUT_ATTACHMENT_ASPECT_CREATE_INFO_KHR = VK_STRUCTURE_TYPE_RENDER_PASS_INPUT_ATTACHMENT_ASPECT_CREATE_INFO_KHR,
    e_IMAGE_VIEW_USAGE_CREATE_INFO_KHR = VK_STRUCTURE_TYPE_IMAGE_VIEW_USAGE_CREATE_INFO_KHR,
    e_PIPELINE_TESSELLATION_DOMAIN_ORIGIN_STATE_CREATE_INFO_KHR = VK_STRUCTURE_TYPE_PIPELINE_TESSELLATION_DOMAIN_ORIGIN_STATE_CREATE_INFO_KHR,
    e_PHYSICAL_DEVICE_SURFACE_INFO_2_KHR = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SURFACE_INFO_2_KHR,
    e_SURFACE_CAPABILITIES_2_KHR = VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES_2_KHR,
    e_SURFACE_FORMAT_2_KHR = VK_STRUCTURE_TYPE_SURFACE_FORMAT_2_KHR,
    e_PHYSICAL_DEVICE_VARIABLE_POINTER_FEATURES_KHR = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VARIABLE_POINTER_FEATURES_KHR,
    e_IOS_SURFACE_CREATE_INFO_MVK = VK_STRUCTURE_TYPE_IOS_SURFACE_CREATE_INFO_MVK,
    e_MACOS_SURFACE_CREATE_INFO_MVK = VK_STRUCTURE_TYPE_MACOS_SURFACE_CREATE_INFO_MVK,
    e_MEMORY_DEDICATED_REQUIREMENTS_KHR = VK_STRUCTURE_TYPE_MEMORY_DEDICATED_REQUIREMENTS_KHR,
    e_MEMORY_DEDICATED_ALLOCATE_INFO_KHR = VK_STRUCTURE_TYPE_MEMORY_DEDICATED_ALLOCATE_INFO_KHR,
    e_DEBUG_UTILS_OBJECT_NAME_INFO_EXT = VK_STRUCTURE_TYPE_DEBUG_UTILS_OBJECT_NAME_INFO_EXT,
    e_DEBUG_UTILS_OBJECT_TAG_INFO_EXT = VK_STRUCTURE_TYPE_DEBUG_UTILS_OBJECT_TAG_INFO_EXT,
    e_DEBUG_UTILS_LABEL_EXT = VK_STRUCTURE_TYPE_DEBUG_UTILS_LABEL_EXT,
    e_DEBUG_UTILS_MESSENGER_CALLBACK_DATA_EXT = VK_STRUCTURE_TYPE_DEBUG_UTILS_MESSENGER_CALLBACK_DATA_EXT,
    e_DEBUG_UTILS_MESSENGER_CREATE_INFO_EXT = VK_STRUCTURE_TYPE_DEBUG_UTILS_MESSENGER_CREATE_INFO_EXT,
    e_ANDROID_HARDWARE_BUFFER_USAGE_ANDROID = VK_STRUCTURE_TYPE_ANDROID_HARDWARE_BUFFER_USAGE_ANDROID,
    e_ANDROID_HARDWARE_BUFFER_PROPERTIES_ANDROID = VK_STRUCTURE_TYPE_ANDROID_HARDWARE_BUFFER_PROPERTIES_ANDROID,
    e_ANDROID_HARDWARE_BUFFER_FORMAT_PROPERTIES_ANDROID = VK_STRUCTURE_TYPE_ANDROID_HARDWARE_BUFFER_FORMAT_PROPERTIES_ANDROID,
    e_IMPORT_ANDROID_HARDWARE_BUFFER_INFO_ANDROID = VK_STRUCTURE_TYPE_IMPORT_ANDROID_HARDWARE_BUFFER_INFO_ANDROID,
    e_MEMORY_GET_ANDROID_HARDWARE_BUFFER_INFO_ANDROID = VK_STRUCTURE_TYPE_MEMORY_GET_ANDROID_HARDWARE_BUFFER_INFO_ANDROID,
    e_EXTERNAL_FORMAT_ANDROID = VK_STRUCTURE_TYPE_EXTERNAL_FORMAT_ANDROID,
    e_PHYSICAL_DEVICE_SAMPLER_FILTER_MINMAX_PROPERTIES_EXT = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLER_FILTER_MINMAX_PROPERTIES_EXT,
    e_SAMPLER_REDUCTION_MODE_CREATE_INFO_EXT = VK_STRUCTURE_TYPE_SAMPLER_REDUCTION_MODE_CREATE_INFO_EXT,
    e_SAMPLE_LOCATIONS_INFO_EXT = VK_STRUCTURE_TYPE_SAMPLE_LOCATIONS_INFO_EXT,
    e_RENDER_PASS_SAMPLE_LOCATIONS_BEGIN_INFO_EXT = VK_STRUCTURE_TYPE_RENDER_PASS_SAMPLE_LOCATIONS_BEGIN_INFO_EXT,
    e_PIPELINE_SAMPLE_LOCATIONS_STATE_CREATE_INFO_EXT = VK_STRUCTURE_TYPE_PIPELINE_SAMPLE_LOCATIONS_STATE_CREATE_INFO_EXT,
    e_PHYSICAL_DEVICE_SAMPLE_LOCATIONS_PROPERTIES_EXT = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLE_LOCATIONS_PROPERTIES_EXT,
    e_MULTISAMPLE_PROPERTIES_EXT = VK_STRUCTURE_TYPE_MULTISAMPLE_PROPERTIES_EXT,
    e_BUFFER_MEMORY_REQUIREMENTS_INFO_2_KHR = VK_STRUCTURE_TYPE_BUFFER_MEMORY_REQUIREMENTS_INFO_2_KHR,
    e_IMAGE_MEMORY_REQUIREMENTS_INFO_2_KHR = VK_STRUCTURE_TYPE_IMAGE_MEMORY_REQUIREMENTS_INFO_2_KHR,
    e_IMAGE_SPARSE_MEMORY_REQUIREMENTS_INFO_2_KHR = VK_STRUCTURE_TYPE_IMAGE_SPARSE_MEMORY_REQUIREMENTS_INFO_2_KHR,
    e_MEMORY_REQUIREMENTS_2_KHR = VK_STRUCTURE_TYPE_MEMORY_REQUIREMENTS_2_KHR,
    e_SPARSE_IMAGE_MEMORY_REQUIREMENTS_2_KHR = VK_STRUCTURE_TYPE_SPARSE_IMAGE_MEMORY_REQUIREMENTS_2_KHR,
    e_IMAGE_FORMAT_LIST_CREATE_INFO_KHR = VK_STRUCTURE_TYPE_IMAGE_FORMAT_LIST_CREATE_INFO_KHR,
    e_PHYSICAL_DEVICE_BLEND_OPERATION_ADVANCED_FEATURES_EXT = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BLEND_OPERATION_ADVANCED_FEATURES_EXT,
    e_PHYSICAL_DEVICE_BLEND_OPERATION_ADVANCED_PROPERTIES_EXT = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BLEND_OPERATION_ADVANCED_PROPERTIES_EXT,
    e_PIPELINE_COLOR_BLEND_ADVANCED_STATE_CREATE_INFO_EXT = VK_STRUCTURE_TYPE_PIPELINE_COLOR_BLEND_ADVANCED_STATE_CREATE_INFO_EXT,
    e_PIPELINE_COVERAGE_TO_COLOR_STATE_CREATE_INFO_NV = VK_STRUCTURE_TYPE_PIPELINE_COVERAGE_TO_COLOR_STATE_CREATE_INFO_NV,
    e_PIPELINE_COVERAGE_MODULATION_STATE_CREATE_INFO_NV = VK_STRUCTURE_TYPE_PIPELINE_COVERAGE_MODULATION_STATE_CREATE_INFO_NV,
    e_SAMPLER_YCBCR_CONVERSION_CREATE_INFO_KHR = VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_CREATE_INFO_KHR,
    e_SAMPLER_YCBCR_CONVERSION_INFO_KHR = VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_INFO_KHR,
    e_BIND_IMAGE_PLANE_MEMORY_INFO_KHR = VK_STRUCTURE_TYPE_BIND_IMAGE_PLANE_MEMORY_INFO_KHR,
    e_IMAGE_PLANE_MEMORY_REQUIREMENTS_INFO_KHR = VK_STRUCTURE_TYPE_IMAGE_PLANE_MEMORY_REQUIREMENTS_INFO_KHR,
    e_PHYSICAL_DEVICE_SAMPLER_YCBCR_CONVERSION_FEATURES_KHR = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLER_YCBCR_CONVERSION_FEATURES_KHR,
    e_SAMPLER_YCBCR_CONVERSION_IMAGE_FORMAT_PROPERTIES_KHR = VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_IMAGE_FORMAT_PROPERTIES_KHR,
    e_BIND_BUFFER_MEMORY_INFO_KHR = VK_STRUCTURE_TYPE_BIND_BUFFER_MEMORY_INFO_KHR,
    e_BIND_IMAGE_MEMORY_INFO_KHR = VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_INFO_KHR,
    e_VALIDATION_CACHE_CREATE_INFO_EXT = VK_STRUCTURE_TYPE_VALIDATION_CACHE_CREATE_INFO_EXT,
    e_SHADER_MODULE_VALIDATION_CACHE_CREATE_INFO_EXT = VK_STRUCTURE_TYPE_SHADER_MODULE_VALIDATION_CACHE_CREATE_INFO_EXT,
    e_DESCRIPTOR_SET_LAYOUT_BINDING_FLAGS_CREATE_INFO_EXT = VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_BINDING_FLAGS_CREATE_INFO_EXT,
    e_PHYSICAL_DEVICE_DESCRIPTOR_INDEXING_FEATURES_EXT = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_INDEXING_FEATURES_EXT,
    e_PHYSICAL_DEVICE_DESCRIPTOR_INDEXING_PROPERTIES_EXT = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_INDEXING_PROPERTIES_EXT,
    e_DESCRIPTOR_SET_VARIABLE_DESCRIPTOR_COUNT_ALLOCATE_INFO_EXT = VK_STRUCTURE_TYPE_DESCRIPTOR_SET_VARIABLE_DESCRIPTOR_COUNT_ALLOCATE_INFO_EXT,
    e_DESCRIPTOR_SET_VARIABLE_DESCRIPTOR_COUNT_LAYOUT_SUPPORT_EXT = VK_STRUCTURE_TYPE_DESCRIPTOR_SET_VARIABLE_DESCRIPTOR_COUNT_LAYOUT_SUPPORT_EXT,
    e_PHYSICAL_DEVICE_MAINTENANCE_3_PROPERTIES_KHR = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_3_PROPERTIES_KHR,
    e_DESCRIPTOR_SET_LAYOUT_SUPPORT_KHR = VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_SUPPORT_KHR,
    e_DEVICE_QUEUE_GLOBAL_PRIORITY_CREATE_INFO_EXT = VK_STRUCTURE_TYPE_DEVICE_QUEUE_GLOBAL_PRIORITY_CREATE_INFO_EXT,
    e_IMPORT_MEMORY_HOST_POINTER_INFO_EXT = VK_STRUCTURE_TYPE_IMPORT_MEMORY_HOST_POINTER_INFO_EXT,
    e_MEMORY_HOST_POINTER_PROPERTIES_EXT = VK_STRUCTURE_TYPE_MEMORY_HOST_POINTER_PROPERTIES_EXT,
    e_PHYSICAL_DEVICE_EXTERNAL_MEMORY_HOST_PROPERTIES_EXT = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_MEMORY_HOST_PROPERTIES_EXT,
    e_PHYSICAL_DEVICE_SHADER_CORE_PROPERTIES_AMD = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CORE_PROPERTIES_AMD,
    e_PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_DIVISOR_PROPERTIES_EXT = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_DIVISOR_PROPERTIES_EXT,
    e_PIPELINE_VERTEX_INPUT_DIVISOR_STATE_CREATE_INFO_EXT = VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_DIVISOR_STATE_CREATE_INFO_EXT,
    e_BEGIN_RANGE = VK_STRUCTURE_TYPE_BEGIN_RANGE,
    e_END_RANGE = VK_STRUCTURE_TYPE_END_RANGE,
    e_RANGE_SIZE = VK_STRUCTURE_TYPE_RANGE_SIZE,
    e_MAX_ENUM = 0x7FFFFFFF

};
DEFINE_ENUM_BITWISE_OPERATORS(StructureType)
inline std::string to_string(StructureType value)
{
    switch(value)
    {
    case StructureType::e_APPLICATION_INFO: return "VK_STRUCTURE_TYPE_APPLICATION_INFO";
    case StructureType::e_INSTANCE_CREATE_INFO: return "VK_STRUCTURE_TYPE_INSTANCE_CREATE_INFO";
    case StructureType::e_DEVICE_QUEUE_CREATE_INFO: return "VK_STRUCTURE_TYPE_DEVICE_QUEUE_CREATE_INFO";
    case StructureType::e_DEVICE_CREATE_INFO: return "VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO";
    case StructureType::e_SUBMIT_INFO: return "VK_STRUCTURE_TYPE_SUBMIT_INFO";
    case StructureType::e_MEMORY_ALLOCATE_INFO: return "VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_INFO";
    case StructureType::e_MAPPED_MEMORY_RANGE: return "VK_STRUCTURE_TYPE_MAPPED_MEMORY_RANGE";
    case StructureType::e_BIND_SPARSE_INFO: return "VK_STRUCTURE_TYPE_BIND_SPARSE_INFO";
    case StructureType::e_FENCE_CREATE_INFO: return "VK_STRUCTURE_TYPE_FENCE_CREATE_INFO";
    case StructureType::e_SEMAPHORE_CREATE_INFO: return "VK_STRUCTURE_TYPE_SEMAPHORE_CREATE_INFO";
    case StructureType::e_EVENT_CREATE_INFO: return "VK_STRUCTURE_TYPE_EVENT_CREATE_INFO";
    case StructureType::e_QUERY_POOL_CREATE_INFO: return "VK_STRUCTURE_TYPE_QUERY_POOL_CREATE_INFO";
    case StructureType::e_BUFFER_CREATE_INFO: return "VK_STRUCTURE_TYPE_BUFFER_CREATE_INFO";
    case StructureType::e_BUFFER_VIEW_CREATE_INFO: return "VK_STRUCTURE_TYPE_BUFFER_VIEW_CREATE_INFO";
    case StructureType::e_IMAGE_CREATE_INFO: return "VK_STRUCTURE_TYPE_IMAGE_CREATE_INFO";
    case StructureType::e_IMAGE_VIEW_CREATE_INFO: return "VK_STRUCTURE_TYPE_IMAGE_VIEW_CREATE_INFO";
    case StructureType::e_SHADER_MODULE_CREATE_INFO: return "VK_STRUCTURE_TYPE_SHADER_MODULE_CREATE_INFO";
    case StructureType::e_PIPELINE_CACHE_CREATE_INFO: return "VK_STRUCTURE_TYPE_PIPELINE_CACHE_CREATE_INFO";
    case StructureType::e_PIPELINE_SHADER_STAGE_CREATE_INFO: return "VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO";
    case StructureType::e_PIPELINE_VERTEX_INPUT_STATE_CREATE_INFO: return "VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_STATE_CREATE_INFO";
    case StructureType::e_PIPELINE_INPUT_ASSEMBLY_STATE_CREATE_INFO: return "VK_STRUCTURE_TYPE_PIPELINE_INPUT_ASSEMBLY_STATE_CREATE_INFO";
    case StructureType::e_PIPELINE_TESSELLATION_STATE_CREATE_INFO: return "VK_STRUCTURE_TYPE_PIPELINE_TESSELLATION_STATE_CREATE_INFO";
    case StructureType::e_PIPELINE_VIEWPORT_STATE_CREATE_INFO: return "VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_STATE_CREATE_INFO";
    case StructureType::e_PIPELINE_RASTERIZATION_STATE_CREATE_INFO: return "VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_CREATE_INFO";
    case StructureType::e_PIPELINE_MULTISAMPLE_STATE_CREATE_INFO: return "VK_STRUCTURE_TYPE_PIPELINE_MULTISAMPLE_STATE_CREATE_INFO";
    case StructureType::e_PIPELINE_DEPTH_STENCIL_STATE_CREATE_INFO: return "VK_STRUCTURE_TYPE_PIPELINE_DEPTH_STENCIL_STATE_CREATE_INFO";
    case StructureType::e_PIPELINE_COLOR_BLEND_STATE_CREATE_INFO: return "VK_STRUCTURE_TYPE_PIPELINE_COLOR_BLEND_STATE_CREATE_INFO";
    case StructureType::e_PIPELINE_DYNAMIC_STATE_CREATE_INFO: return "VK_STRUCTURE_TYPE_PIPELINE_DYNAMIC_STATE_CREATE_INFO";
    case StructureType::e_GRAPHICS_PIPELINE_CREATE_INFO: return "VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_CREATE_INFO";
    case StructureType::e_COMPUTE_PIPELINE_CREATE_INFO: return "VK_STRUCTURE_TYPE_COMPUTE_PIPELINE_CREATE_INFO";
    case StructureType::e_PIPELINE_LAYOUT_CREATE_INFO: return "VK_STRUCTURE_TYPE_PIPELINE_LAYOUT_CREATE_INFO";
    case StructureType::e_SAMPLER_CREATE_INFO: return "VK_STRUCTURE_TYPE_SAMPLER_CREATE_INFO";
    case StructureType::e_DESCRIPTOR_SET_LAYOUT_CREATE_INFO: return "VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_CREATE_INFO";
    case StructureType::e_DESCRIPTOR_POOL_CREATE_INFO: return "VK_STRUCTURE_TYPE_DESCRIPTOR_POOL_CREATE_INFO";
    case StructureType::e_DESCRIPTOR_SET_ALLOCATE_INFO: return "VK_STRUCTURE_TYPE_DESCRIPTOR_SET_ALLOCATE_INFO";
    case StructureType::e_WRITE_DESCRIPTOR_SET: return "VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET";
    case StructureType::e_COPY_DESCRIPTOR_SET: return "VK_STRUCTURE_TYPE_COPY_DESCRIPTOR_SET";
    case StructureType::e_FRAMEBUFFER_CREATE_INFO: return "VK_STRUCTURE_TYPE_FRAMEBUFFER_CREATE_INFO";
    case StructureType::e_RENDER_PASS_CREATE_INFO: return "VK_STRUCTURE_TYPE_RENDER_PASS_CREATE_INFO";
    case StructureType::e_COMMAND_POOL_CREATE_INFO: return "VK_STRUCTURE_TYPE_COMMAND_POOL_CREATE_INFO";
    case StructureType::e_COMMAND_BUFFER_ALLOCATE_INFO: return "VK_STRUCTURE_TYPE_COMMAND_BUFFER_ALLOCATE_INFO";
    case StructureType::e_COMMAND_BUFFER_INHERITANCE_INFO: return "VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_INFO";
    case StructureType::e_COMMAND_BUFFER_BEGIN_INFO: return "VK_STRUCTURE_TYPE_COMMAND_BUFFER_BEGIN_INFO";
    case StructureType::e_RENDER_PASS_BEGIN_INFO: return "VK_STRUCTURE_TYPE_RENDER_PASS_BEGIN_INFO";
    case StructureType::e_BUFFER_MEMORY_BARRIER: return "VK_STRUCTURE_TYPE_BUFFER_MEMORY_BARRIER";
    case StructureType::e_IMAGE_MEMORY_BARRIER: return "VK_STRUCTURE_TYPE_IMAGE_MEMORY_BARRIER";
    case StructureType::e_MEMORY_BARRIER: return "VK_STRUCTURE_TYPE_MEMORY_BARRIER";
    case StructureType::e_LOADER_INSTANCE_CREATE_INFO: return "VK_STRUCTURE_TYPE_LOADER_INSTANCE_CREATE_INFO";
    case StructureType::e_LOADER_DEVICE_CREATE_INFO: return "VK_STRUCTURE_TYPE_LOADER_DEVICE_CREATE_INFO";
    case StructureType::e_PHYSICAL_DEVICE_SUBGROUP_PROPERTIES: return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBGROUP_PROPERTIES";
    case StructureType::e_BIND_BUFFER_MEMORY_INFO: return "VK_STRUCTURE_TYPE_BIND_BUFFER_MEMORY_INFO";
    case StructureType::e_BIND_IMAGE_MEMORY_INFO: return "VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_INFO";
    case StructureType::e_PHYSICAL_DEVICE_16BIT_STORAGE_FEATURES: return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_16BIT_STORAGE_FEATURES";
    case StructureType::e_MEMORY_DEDICATED_REQUIREMENTS: return "VK_STRUCTURE_TYPE_MEMORY_DEDICATED_REQUIREMENTS";
    case StructureType::e_MEMORY_DEDICATED_ALLOCATE_INFO: return "VK_STRUCTURE_TYPE_MEMORY_DEDICATED_ALLOCATE_INFO";
    case StructureType::e_MEMORY_ALLOCATE_FLAGS_INFO: return "VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_FLAGS_INFO";
    case StructureType::e_DEVICE_GROUP_RENDER_PASS_BEGIN_INFO: return "VK_STRUCTURE_TYPE_DEVICE_GROUP_RENDER_PASS_BEGIN_INFO";
    case StructureType::e_DEVICE_GROUP_COMMAND_BUFFER_BEGIN_INFO: return "VK_STRUCTURE_TYPE_DEVICE_GROUP_COMMAND_BUFFER_BEGIN_INFO";
    case StructureType::e_DEVICE_GROUP_SUBMIT_INFO: return "VK_STRUCTURE_TYPE_DEVICE_GROUP_SUBMIT_INFO";
    case StructureType::e_DEVICE_GROUP_BIND_SPARSE_INFO: return "VK_STRUCTURE_TYPE_DEVICE_GROUP_BIND_SPARSE_INFO";
    case StructureType::e_BIND_BUFFER_MEMORY_DEVICE_GROUP_INFO: return "VK_STRUCTURE_TYPE_BIND_BUFFER_MEMORY_DEVICE_GROUP_INFO";
    case StructureType::e_BIND_IMAGE_MEMORY_DEVICE_GROUP_INFO: return "VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_DEVICE_GROUP_INFO";
    case StructureType::e_PHYSICAL_DEVICE_GROUP_PROPERTIES: return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GROUP_PROPERTIES";
    case StructureType::e_DEVICE_GROUP_DEVICE_CREATE_INFO: return "VK_STRUCTURE_TYPE_DEVICE_GROUP_DEVICE_CREATE_INFO";
    case StructureType::e_BUFFER_MEMORY_REQUIREMENTS_INFO_2: return "VK_STRUCTURE_TYPE_BUFFER_MEMORY_REQUIREMENTS_INFO_2";
    case StructureType::e_IMAGE_MEMORY_REQUIREMENTS_INFO_2: return "VK_STRUCTURE_TYPE_IMAGE_MEMORY_REQUIREMENTS_INFO_2";
    case StructureType::e_IMAGE_SPARSE_MEMORY_REQUIREMENTS_INFO_2: return "VK_STRUCTURE_TYPE_IMAGE_SPARSE_MEMORY_REQUIREMENTS_INFO_2";
    case StructureType::e_MEMORY_REQUIREMENTS_2: return "VK_STRUCTURE_TYPE_MEMORY_REQUIREMENTS_2";
    case StructureType::e_SPARSE_IMAGE_MEMORY_REQUIREMENTS_2: return "VK_STRUCTURE_TYPE_SPARSE_IMAGE_MEMORY_REQUIREMENTS_2";
    case StructureType::e_PHYSICAL_DEVICE_FEATURES_2: return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2";
    case StructureType::e_PHYSICAL_DEVICE_PROPERTIES_2: return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROPERTIES_2";
    case StructureType::e_FORMAT_PROPERTIES_2: return "VK_STRUCTURE_TYPE_FORMAT_PROPERTIES_2";
    case StructureType::e_IMAGE_FORMAT_PROPERTIES_2: return "VK_STRUCTURE_TYPE_IMAGE_FORMAT_PROPERTIES_2";
    case StructureType::e_PHYSICAL_DEVICE_IMAGE_FORMAT_INFO_2: return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_FORMAT_INFO_2";
    case StructureType::e_QUEUE_FAMILY_PROPERTIES_2: return "VK_STRUCTURE_TYPE_QUEUE_FAMILY_PROPERTIES_2";
    case StructureType::e_PHYSICAL_DEVICE_MEMORY_PROPERTIES_2: return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_PROPERTIES_2";
    case StructureType::e_SPARSE_IMAGE_FORMAT_PROPERTIES_2: return "VK_STRUCTURE_TYPE_SPARSE_IMAGE_FORMAT_PROPERTIES_2";
    case StructureType::e_PHYSICAL_DEVICE_SPARSE_IMAGE_FORMAT_INFO_2: return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SPARSE_IMAGE_FORMAT_INFO_2";
    case StructureType::e_PHYSICAL_DEVICE_POINT_CLIPPING_PROPERTIES: return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_POINT_CLIPPING_PROPERTIES";
    case StructureType::e_RENDER_PASS_INPUT_ATTACHMENT_ASPECT_CREATE_INFO: return "VK_STRUCTURE_TYPE_RENDER_PASS_INPUT_ATTACHMENT_ASPECT_CREATE_INFO";
    case StructureType::e_IMAGE_VIEW_USAGE_CREATE_INFO: return "VK_STRUCTURE_TYPE_IMAGE_VIEW_USAGE_CREATE_INFO";
    case StructureType::e_PIPELINE_TESSELLATION_DOMAIN_ORIGIN_STATE_CREATE_INFO: return "VK_STRUCTURE_TYPE_PIPELINE_TESSELLATION_DOMAIN_ORIGIN_STATE_CREATE_INFO";
    case StructureType::e_RENDER_PASS_MULTIVIEW_CREATE_INFO: return "VK_STRUCTURE_TYPE_RENDER_PASS_MULTIVIEW_CREATE_INFO";
    case StructureType::e_PHYSICAL_DEVICE_MULTIVIEW_FEATURES: return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_FEATURES";
    case StructureType::e_PHYSICAL_DEVICE_MULTIVIEW_PROPERTIES: return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PROPERTIES";
    case StructureType::e_PHYSICAL_DEVICE_VARIABLE_POINTER_FEATURES: return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VARIABLE_POINTER_FEATURES";
    case StructureType::e_PROTECTED_SUBMIT_INFO: return "VK_STRUCTURE_TYPE_PROTECTED_SUBMIT_INFO";
    case StructureType::e_PHYSICAL_DEVICE_PROTECTED_MEMORY_FEATURES: return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROTECTED_MEMORY_FEATURES";
    case StructureType::e_PHYSICAL_DEVICE_PROTECTED_MEMORY_PROPERTIES: return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROTECTED_MEMORY_PROPERTIES";
    case StructureType::e_DEVICE_QUEUE_INFO_2: return "VK_STRUCTURE_TYPE_DEVICE_QUEUE_INFO_2";
    case StructureType::e_SAMPLER_YCBCR_CONVERSION_CREATE_INFO: return "VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_CREATE_INFO";
    case StructureType::e_SAMPLER_YCBCR_CONVERSION_INFO: return "VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_INFO";
    case StructureType::e_BIND_IMAGE_PLANE_MEMORY_INFO: return "VK_STRUCTURE_TYPE_BIND_IMAGE_PLANE_MEMORY_INFO";
    case StructureType::e_IMAGE_PLANE_MEMORY_REQUIREMENTS_INFO: return "VK_STRUCTURE_TYPE_IMAGE_PLANE_MEMORY_REQUIREMENTS_INFO";
    case StructureType::e_PHYSICAL_DEVICE_SAMPLER_YCBCR_CONVERSION_FEATURES: return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLER_YCBCR_CONVERSION_FEATURES";
    case StructureType::e_SAMPLER_YCBCR_CONVERSION_IMAGE_FORMAT_PROPERTIES: return "VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_IMAGE_FORMAT_PROPERTIES";
    case StructureType::e_DESCRIPTOR_UPDATE_TEMPLATE_CREATE_INFO: return "VK_STRUCTURE_TYPE_DESCRIPTOR_UPDATE_TEMPLATE_CREATE_INFO";
    case StructureType::e_PHYSICAL_DEVICE_EXTERNAL_IMAGE_FORMAT_INFO: return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_IMAGE_FORMAT_INFO";
    case StructureType::e_EXTERNAL_IMAGE_FORMAT_PROPERTIES: return "VK_STRUCTURE_TYPE_EXTERNAL_IMAGE_FORMAT_PROPERTIES";
    case StructureType::e_PHYSICAL_DEVICE_EXTERNAL_BUFFER_INFO: return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_BUFFER_INFO";
    case StructureType::e_EXTERNAL_BUFFER_PROPERTIES: return "VK_STRUCTURE_TYPE_EXTERNAL_BUFFER_PROPERTIES";
    case StructureType::e_PHYSICAL_DEVICE_ID_PROPERTIES: return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ID_PROPERTIES";
    case StructureType::e_EXTERNAL_MEMORY_BUFFER_CREATE_INFO: return "VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_BUFFER_CREATE_INFO";
    case StructureType::e_EXTERNAL_MEMORY_IMAGE_CREATE_INFO: return "VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_IMAGE_CREATE_INFO";
    case StructureType::e_EXPORT_MEMORY_ALLOCATE_INFO: return "VK_STRUCTURE_TYPE_EXPORT_MEMORY_ALLOCATE_INFO";
    case StructureType::e_PHYSICAL_DEVICE_EXTERNAL_FENCE_INFO: return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_FENCE_INFO";
    case StructureType::e_EXTERNAL_FENCE_PROPERTIES: return "VK_STRUCTURE_TYPE_EXTERNAL_FENCE_PROPERTIES";
    case StructureType::e_EXPORT_FENCE_CREATE_INFO: return "VK_STRUCTURE_TYPE_EXPORT_FENCE_CREATE_INFO";
    case StructureType::e_EXPORT_SEMAPHORE_CREATE_INFO: return "VK_STRUCTURE_TYPE_EXPORT_SEMAPHORE_CREATE_INFO";
    case StructureType::e_PHYSICAL_DEVICE_EXTERNAL_SEMAPHORE_INFO: return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_SEMAPHORE_INFO";
    case StructureType::e_EXTERNAL_SEMAPHORE_PROPERTIES: return "VK_STRUCTURE_TYPE_EXTERNAL_SEMAPHORE_PROPERTIES";
    case StructureType::e_PHYSICAL_DEVICE_MAINTENANCE_3_PROPERTIES: return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_3_PROPERTIES";
    case StructureType::e_DESCRIPTOR_SET_LAYOUT_SUPPORT: return "VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_SUPPORT";
    case StructureType::e_PHYSICAL_DEVICE_SHADER_DRAW_PARAMETER_FEATURES: return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_DRAW_PARAMETER_FEATURES";
    case StructureType::e_SWAPCHAIN_CREATE_INFO_KHR: return "VK_STRUCTURE_TYPE_SWAPCHAIN_CREATE_INFO_KHR";
    case StructureType::e_PRESENT_INFO_KHR: return "VK_STRUCTURE_TYPE_PRESENT_INFO_KHR";
    case StructureType::e_DEVICE_GROUP_PRESENT_CAPABILITIES_KHR: return "VK_STRUCTURE_TYPE_DEVICE_GROUP_PRESENT_CAPABILITIES_KHR";
    case StructureType::e_IMAGE_SWAPCHAIN_CREATE_INFO_KHR: return "VK_STRUCTURE_TYPE_IMAGE_SWAPCHAIN_CREATE_INFO_KHR";
    case StructureType::e_BIND_IMAGE_MEMORY_SWAPCHAIN_INFO_KHR: return "VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_SWAPCHAIN_INFO_KHR";
    case StructureType::e_ACQUIRE_NEXT_IMAGE_INFO_KHR: return "VK_STRUCTURE_TYPE_ACQUIRE_NEXT_IMAGE_INFO_KHR";
    case StructureType::e_DEVICE_GROUP_PRESENT_INFO_KHR: return "VK_STRUCTURE_TYPE_DEVICE_GROUP_PRESENT_INFO_KHR";
    case StructureType::e_DEVICE_GROUP_SWAPCHAIN_CREATE_INFO_KHR: return "VK_STRUCTURE_TYPE_DEVICE_GROUP_SWAPCHAIN_CREATE_INFO_KHR";
    case StructureType::e_DISPLAY_MODE_CREATE_INFO_KHR: return "VK_STRUCTURE_TYPE_DISPLAY_MODE_CREATE_INFO_KHR";
    case StructureType::e_DISPLAY_SURFACE_CREATE_INFO_KHR: return "VK_STRUCTURE_TYPE_DISPLAY_SURFACE_CREATE_INFO_KHR";
    case StructureType::e_DISPLAY_PRESENT_INFO_KHR: return "VK_STRUCTURE_TYPE_DISPLAY_PRESENT_INFO_KHR";
    case StructureType::e_XLIB_SURFACE_CREATE_INFO_KHR: return "VK_STRUCTURE_TYPE_XLIB_SURFACE_CREATE_INFO_KHR";
    case StructureType::e_XCB_SURFACE_CREATE_INFO_KHR: return "VK_STRUCTURE_TYPE_XCB_SURFACE_CREATE_INFO_KHR";
    case StructureType::e_WAYLAND_SURFACE_CREATE_INFO_KHR: return "VK_STRUCTURE_TYPE_WAYLAND_SURFACE_CREATE_INFO_KHR";
    case StructureType::e_MIR_SURFACE_CREATE_INFO_KHR: return "VK_STRUCTURE_TYPE_MIR_SURFACE_CREATE_INFO_KHR";
    case StructureType::e_ANDROID_SURFACE_CREATE_INFO_KHR: return "VK_STRUCTURE_TYPE_ANDROID_SURFACE_CREATE_INFO_KHR";
    case StructureType::e_WIN32_SURFACE_CREATE_INFO_KHR: return "VK_STRUCTURE_TYPE_WIN32_SURFACE_CREATE_INFO_KHR";
    case StructureType::e_DEBUG_REPORT_CALLBACK_CREATE_INFO_EXT: return "VK_STRUCTURE_TYPE_DEBUG_REPORT_CALLBACK_CREATE_INFO_EXT";
    case StructureType::e_PIPELINE_RASTERIZATION_STATE_RASTERIZATION_ORDER_AMD: return "VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_RASTERIZATION_ORDER_AMD";
    case StructureType::e_DEBUG_MARKER_OBJECT_NAME_INFO_EXT: return "VK_STRUCTURE_TYPE_DEBUG_MARKER_OBJECT_NAME_INFO_EXT";
    case StructureType::e_DEBUG_MARKER_OBJECT_TAG_INFO_EXT: return "VK_STRUCTURE_TYPE_DEBUG_MARKER_OBJECT_TAG_INFO_EXT";
    case StructureType::e_DEBUG_MARKER_MARKER_INFO_EXT: return "VK_STRUCTURE_TYPE_DEBUG_MARKER_MARKER_INFO_EXT";
    case StructureType::e_DEDICATED_ALLOCATION_IMAGE_CREATE_INFO_NV: return "VK_STRUCTURE_TYPE_DEDICATED_ALLOCATION_IMAGE_CREATE_INFO_NV";
    case StructureType::e_DEDICATED_ALLOCATION_BUFFER_CREATE_INFO_NV: return "VK_STRUCTURE_TYPE_DEDICATED_ALLOCATION_BUFFER_CREATE_INFO_NV";
    case StructureType::e_DEDICATED_ALLOCATION_MEMORY_ALLOCATE_INFO_NV: return "VK_STRUCTURE_TYPE_DEDICATED_ALLOCATION_MEMORY_ALLOCATE_INFO_NV";
    case StructureType::e_TEXTURE_LOD_GATHER_FORMAT_PROPERTIES_AMD: return "VK_STRUCTURE_TYPE_TEXTURE_LOD_GATHER_FORMAT_PROPERTIES_AMD";
    case StructureType::e_EXTERNAL_MEMORY_IMAGE_CREATE_INFO_NV: return "VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_IMAGE_CREATE_INFO_NV";
    case StructureType::e_EXPORT_MEMORY_ALLOCATE_INFO_NV: return "VK_STRUCTURE_TYPE_EXPORT_MEMORY_ALLOCATE_INFO_NV";
    case StructureType::e_IMPORT_MEMORY_WIN32_HANDLE_INFO_NV: return "VK_STRUCTURE_TYPE_IMPORT_MEMORY_WIN32_HANDLE_INFO_NV";
    case StructureType::e_EXPORT_MEMORY_WIN32_HANDLE_INFO_NV: return "VK_STRUCTURE_TYPE_EXPORT_MEMORY_WIN32_HANDLE_INFO_NV";
    case StructureType::e_WIN32_KEYED_MUTEX_ACQUIRE_RELEASE_INFO_NV: return "VK_STRUCTURE_TYPE_WIN32_KEYED_MUTEX_ACQUIRE_RELEASE_INFO_NV";
    case StructureType::e_VALIDATION_FLAGS_EXT: return "VK_STRUCTURE_TYPE_VALIDATION_FLAGS_EXT";
    case StructureType::e_VI_SURFACE_CREATE_INFO_NN: return "VK_STRUCTURE_TYPE_VI_SURFACE_CREATE_INFO_NN";
    case StructureType::e_IMPORT_MEMORY_WIN32_HANDLE_INFO_KHR: return "VK_STRUCTURE_TYPE_IMPORT_MEMORY_WIN32_HANDLE_INFO_KHR";
    case StructureType::e_EXPORT_MEMORY_WIN32_HANDLE_INFO_KHR: return "VK_STRUCTURE_TYPE_EXPORT_MEMORY_WIN32_HANDLE_INFO_KHR";
    case StructureType::e_MEMORY_WIN32_HANDLE_PROPERTIES_KHR: return "VK_STRUCTURE_TYPE_MEMORY_WIN32_HANDLE_PROPERTIES_KHR";
    case StructureType::e_MEMORY_GET_WIN32_HANDLE_INFO_KHR: return "VK_STRUCTURE_TYPE_MEMORY_GET_WIN32_HANDLE_INFO_KHR";
    case StructureType::e_IMPORT_MEMORY_FD_INFO_KHR: return "VK_STRUCTURE_TYPE_IMPORT_MEMORY_FD_INFO_KHR";
    case StructureType::e_MEMORY_FD_PROPERTIES_KHR: return "VK_STRUCTURE_TYPE_MEMORY_FD_PROPERTIES_KHR";
    case StructureType::e_MEMORY_GET_FD_INFO_KHR: return "VK_STRUCTURE_TYPE_MEMORY_GET_FD_INFO_KHR";
    case StructureType::e_WIN32_KEYED_MUTEX_ACQUIRE_RELEASE_INFO_KHR: return "VK_STRUCTURE_TYPE_WIN32_KEYED_MUTEX_ACQUIRE_RELEASE_INFO_KHR";
    case StructureType::e_IMPORT_SEMAPHORE_WIN32_HANDLE_INFO_KHR: return "VK_STRUCTURE_TYPE_IMPORT_SEMAPHORE_WIN32_HANDLE_INFO_KHR";
    case StructureType::e_EXPORT_SEMAPHORE_WIN32_HANDLE_INFO_KHR: return "VK_STRUCTURE_TYPE_EXPORT_SEMAPHORE_WIN32_HANDLE_INFO_KHR";
    case StructureType::e_D3D12_FENCE_SUBMIT_INFO_KHR: return "VK_STRUCTURE_TYPE_D3D12_FENCE_SUBMIT_INFO_KHR";
    case StructureType::e_SEMAPHORE_GET_WIN32_HANDLE_INFO_KHR: return "VK_STRUCTURE_TYPE_SEMAPHORE_GET_WIN32_HANDLE_INFO_KHR";
    case StructureType::e_IMPORT_SEMAPHORE_FD_INFO_KHR: return "VK_STRUCTURE_TYPE_IMPORT_SEMAPHORE_FD_INFO_KHR";
    case StructureType::e_SEMAPHORE_GET_FD_INFO_KHR: return "VK_STRUCTURE_TYPE_SEMAPHORE_GET_FD_INFO_KHR";
    case StructureType::e_PHYSICAL_DEVICE_PUSH_DESCRIPTOR_PROPERTIES_KHR: return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PUSH_DESCRIPTOR_PROPERTIES_KHR";
    case StructureType::e_PRESENT_REGIONS_KHR: return "VK_STRUCTURE_TYPE_PRESENT_REGIONS_KHR";
    case StructureType::e_OBJECT_TABLE_CREATE_INFO_NVX: return "VK_STRUCTURE_TYPE_OBJECT_TABLE_CREATE_INFO_NVX";
    case StructureType::e_INDIRECT_COMMANDS_LAYOUT_CREATE_INFO_NVX: return "VK_STRUCTURE_TYPE_INDIRECT_COMMANDS_LAYOUT_CREATE_INFO_NVX";
    case StructureType::e_CMD_PROCESS_COMMANDS_INFO_NVX: return "VK_STRUCTURE_TYPE_CMD_PROCESS_COMMANDS_INFO_NVX";
    case StructureType::e_CMD_RESERVE_SPACE_FOR_COMMANDS_INFO_NVX: return "VK_STRUCTURE_TYPE_CMD_RESERVE_SPACE_FOR_COMMANDS_INFO_NVX";
    case StructureType::e_DEVICE_GENERATED_COMMANDS_LIMITS_NVX: return "VK_STRUCTURE_TYPE_DEVICE_GENERATED_COMMANDS_LIMITS_NVX";
    case StructureType::e_DEVICE_GENERATED_COMMANDS_FEATURES_NVX: return "VK_STRUCTURE_TYPE_DEVICE_GENERATED_COMMANDS_FEATURES_NVX";
    case StructureType::e_PIPELINE_VIEWPORT_W_SCALING_STATE_CREATE_INFO_NV: return "VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_W_SCALING_STATE_CREATE_INFO_NV";
    case StructureType::e_SURFACE_CAPABILITIES_2_EXT: return "VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES_2_EXT";
    case StructureType::e_DISPLAY_POWER_INFO_EXT: return "VK_STRUCTURE_TYPE_DISPLAY_POWER_INFO_EXT";
    case StructureType::e_DEVICE_EVENT_INFO_EXT: return "VK_STRUCTURE_TYPE_DEVICE_EVENT_INFO_EXT";
    case StructureType::e_DISPLAY_EVENT_INFO_EXT: return "VK_STRUCTURE_TYPE_DISPLAY_EVENT_INFO_EXT";
    case StructureType::e_SWAPCHAIN_COUNTER_CREATE_INFO_EXT: return "VK_STRUCTURE_TYPE_SWAPCHAIN_COUNTER_CREATE_INFO_EXT";
    case StructureType::e_PRESENT_TIMES_INFO_GOOGLE: return "VK_STRUCTURE_TYPE_PRESENT_TIMES_INFO_GOOGLE";
    case StructureType::e_PHYSICAL_DEVICE_MULTIVIEW_PER_VIEW_ATTRIBUTES_PROPERTIES_NVX: return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PER_VIEW_ATTRIBUTES_PROPERTIES_NVX";
    case StructureType::e_PIPELINE_VIEWPORT_SWIZZLE_STATE_CREATE_INFO_NV: return "VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_SWIZZLE_STATE_CREATE_INFO_NV";
    case StructureType::e_PHYSICAL_DEVICE_DISCARD_RECTANGLE_PROPERTIES_EXT: return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DISCARD_RECTANGLE_PROPERTIES_EXT";
    case StructureType::e_PIPELINE_DISCARD_RECTANGLE_STATE_CREATE_INFO_EXT: return "VK_STRUCTURE_TYPE_PIPELINE_DISCARD_RECTANGLE_STATE_CREATE_INFO_EXT";
    case StructureType::e_PHYSICAL_DEVICE_CONSERVATIVE_RASTERIZATION_PROPERTIES_EXT: return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CONSERVATIVE_RASTERIZATION_PROPERTIES_EXT";
    case StructureType::e_PIPELINE_RASTERIZATION_CONSERVATIVE_STATE_CREATE_INFO_EXT: return "VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_CONSERVATIVE_STATE_CREATE_INFO_EXT";
    case StructureType::e_HDR_METADATA_EXT: return "VK_STRUCTURE_TYPE_HDR_METADATA_EXT";
    case StructureType::e_SHARED_PRESENT_SURFACE_CAPABILITIES_KHR: return "VK_STRUCTURE_TYPE_SHARED_PRESENT_SURFACE_CAPABILITIES_KHR";
    case StructureType::e_IMPORT_FENCE_WIN32_HANDLE_INFO_KHR: return "VK_STRUCTURE_TYPE_IMPORT_FENCE_WIN32_HANDLE_INFO_KHR";
    case StructureType::e_EXPORT_FENCE_WIN32_HANDLE_INFO_KHR: return "VK_STRUCTURE_TYPE_EXPORT_FENCE_WIN32_HANDLE_INFO_KHR";
    case StructureType::e_FENCE_GET_WIN32_HANDLE_INFO_KHR: return "VK_STRUCTURE_TYPE_FENCE_GET_WIN32_HANDLE_INFO_KHR";
    case StructureType::e_IMPORT_FENCE_FD_INFO_KHR: return "VK_STRUCTURE_TYPE_IMPORT_FENCE_FD_INFO_KHR";
    case StructureType::e_FENCE_GET_FD_INFO_KHR: return "VK_STRUCTURE_TYPE_FENCE_GET_FD_INFO_KHR";
    case StructureType::e_PHYSICAL_DEVICE_SURFACE_INFO_2_KHR: return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SURFACE_INFO_2_KHR";
    case StructureType::e_SURFACE_CAPABILITIES_2_KHR: return "VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES_2_KHR";
    case StructureType::e_SURFACE_FORMAT_2_KHR: return "VK_STRUCTURE_TYPE_SURFACE_FORMAT_2_KHR";
    case StructureType::e_IOS_SURFACE_CREATE_INFO_MVK: return "VK_STRUCTURE_TYPE_IOS_SURFACE_CREATE_INFO_MVK";
    case StructureType::e_MACOS_SURFACE_CREATE_INFO_MVK: return "VK_STRUCTURE_TYPE_MACOS_SURFACE_CREATE_INFO_MVK";
    case StructureType::e_DEBUG_UTILS_OBJECT_NAME_INFO_EXT: return "VK_STRUCTURE_TYPE_DEBUG_UTILS_OBJECT_NAME_INFO_EXT";
    case StructureType::e_DEBUG_UTILS_OBJECT_TAG_INFO_EXT: return "VK_STRUCTURE_TYPE_DEBUG_UTILS_OBJECT_TAG_INFO_EXT";
    case StructureType::e_DEBUG_UTILS_LABEL_EXT: return "VK_STRUCTURE_TYPE_DEBUG_UTILS_LABEL_EXT";
    case StructureType::e_DEBUG_UTILS_MESSENGER_CALLBACK_DATA_EXT: return "VK_STRUCTURE_TYPE_DEBUG_UTILS_MESSENGER_CALLBACK_DATA_EXT";
    case StructureType::e_DEBUG_UTILS_MESSENGER_CREATE_INFO_EXT: return "VK_STRUCTURE_TYPE_DEBUG_UTILS_MESSENGER_CREATE_INFO_EXT";
    case StructureType::e_ANDROID_HARDWARE_BUFFER_USAGE_ANDROID: return "VK_STRUCTURE_TYPE_ANDROID_HARDWARE_BUFFER_USAGE_ANDROID";
    case StructureType::e_ANDROID_HARDWARE_BUFFER_PROPERTIES_ANDROID: return "VK_STRUCTURE_TYPE_ANDROID_HARDWARE_BUFFER_PROPERTIES_ANDROID";
    case StructureType::e_ANDROID_HARDWARE_BUFFER_FORMAT_PROPERTIES_ANDROID: return "VK_STRUCTURE_TYPE_ANDROID_HARDWARE_BUFFER_FORMAT_PROPERTIES_ANDROID";
    case StructureType::e_IMPORT_ANDROID_HARDWARE_BUFFER_INFO_ANDROID: return "VK_STRUCTURE_TYPE_IMPORT_ANDROID_HARDWARE_BUFFER_INFO_ANDROID";
    case StructureType::e_MEMORY_GET_ANDROID_HARDWARE_BUFFER_INFO_ANDROID: return "VK_STRUCTURE_TYPE_MEMORY_GET_ANDROID_HARDWARE_BUFFER_INFO_ANDROID";
    case StructureType::e_EXTERNAL_FORMAT_ANDROID: return "VK_STRUCTURE_TYPE_EXTERNAL_FORMAT_ANDROID";
    case StructureType::e_PHYSICAL_DEVICE_SAMPLER_FILTER_MINMAX_PROPERTIES_EXT: return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLER_FILTER_MINMAX_PROPERTIES_EXT";
    case StructureType::e_SAMPLER_REDUCTION_MODE_CREATE_INFO_EXT: return "VK_STRUCTURE_TYPE_SAMPLER_REDUCTION_MODE_CREATE_INFO_EXT";
    case StructureType::e_SAMPLE_LOCATIONS_INFO_EXT: return "VK_STRUCTURE_TYPE_SAMPLE_LOCATIONS_INFO_EXT";
    case StructureType::e_RENDER_PASS_SAMPLE_LOCATIONS_BEGIN_INFO_EXT: return "VK_STRUCTURE_TYPE_RENDER_PASS_SAMPLE_LOCATIONS_BEGIN_INFO_EXT";
    case StructureType::e_PIPELINE_SAMPLE_LOCATIONS_STATE_CREATE_INFO_EXT: return "VK_STRUCTURE_TYPE_PIPELINE_SAMPLE_LOCATIONS_STATE_CREATE_INFO_EXT";
    case StructureType::e_PHYSICAL_DEVICE_SAMPLE_LOCATIONS_PROPERTIES_EXT: return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLE_LOCATIONS_PROPERTIES_EXT";
    case StructureType::e_MULTISAMPLE_PROPERTIES_EXT: return "VK_STRUCTURE_TYPE_MULTISAMPLE_PROPERTIES_EXT";
    case StructureType::e_IMAGE_FORMAT_LIST_CREATE_INFO_KHR: return "VK_STRUCTURE_TYPE_IMAGE_FORMAT_LIST_CREATE_INFO_KHR";
    case StructureType::e_PHYSICAL_DEVICE_BLEND_OPERATION_ADVANCED_FEATURES_EXT: return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BLEND_OPERATION_ADVANCED_FEATURES_EXT";
    case StructureType::e_PHYSICAL_DEVICE_BLEND_OPERATION_ADVANCED_PROPERTIES_EXT: return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BLEND_OPERATION_ADVANCED_PROPERTIES_EXT";
    case StructureType::e_PIPELINE_COLOR_BLEND_ADVANCED_STATE_CREATE_INFO_EXT: return "VK_STRUCTURE_TYPE_PIPELINE_COLOR_BLEND_ADVANCED_STATE_CREATE_INFO_EXT";
    case StructureType::e_PIPELINE_COVERAGE_TO_COLOR_STATE_CREATE_INFO_NV: return "VK_STRUCTURE_TYPE_PIPELINE_COVERAGE_TO_COLOR_STATE_CREATE_INFO_NV";
    case StructureType::e_PIPELINE_COVERAGE_MODULATION_STATE_CREATE_INFO_NV: return "VK_STRUCTURE_TYPE_PIPELINE_COVERAGE_MODULATION_STATE_CREATE_INFO_NV";
    case StructureType::e_VALIDATION_CACHE_CREATE_INFO_EXT: return "VK_STRUCTURE_TYPE_VALIDATION_CACHE_CREATE_INFO_EXT";
    case StructureType::e_SHADER_MODULE_VALIDATION_CACHE_CREATE_INFO_EXT: return "VK_STRUCTURE_TYPE_SHADER_MODULE_VALIDATION_CACHE_CREATE_INFO_EXT";
    case StructureType::e_DESCRIPTOR_SET_LAYOUT_BINDING_FLAGS_CREATE_INFO_EXT: return "VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_BINDING_FLAGS_CREATE_INFO_EXT";
    case StructureType::e_PHYSICAL_DEVICE_DESCRIPTOR_INDEXING_FEATURES_EXT: return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_INDEXING_FEATURES_EXT";
    case StructureType::e_PHYSICAL_DEVICE_DESCRIPTOR_INDEXING_PROPERTIES_EXT: return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_INDEXING_PROPERTIES_EXT";
    case StructureType::e_DESCRIPTOR_SET_VARIABLE_DESCRIPTOR_COUNT_ALLOCATE_INFO_EXT: return "VK_STRUCTURE_TYPE_DESCRIPTOR_SET_VARIABLE_DESCRIPTOR_COUNT_ALLOCATE_INFO_EXT";
    case StructureType::e_DESCRIPTOR_SET_VARIABLE_DESCRIPTOR_COUNT_LAYOUT_SUPPORT_EXT: return "VK_STRUCTURE_TYPE_DESCRIPTOR_SET_VARIABLE_DESCRIPTOR_COUNT_LAYOUT_SUPPORT_EXT";
    case StructureType::e_DEVICE_QUEUE_GLOBAL_PRIORITY_CREATE_INFO_EXT: return "VK_STRUCTURE_TYPE_DEVICE_QUEUE_GLOBAL_PRIORITY_CREATE_INFO_EXT";
    case StructureType::e_IMPORT_MEMORY_HOST_POINTER_INFO_EXT: return "VK_STRUCTURE_TYPE_IMPORT_MEMORY_HOST_POINTER_INFO_EXT";
    case StructureType::e_MEMORY_HOST_POINTER_PROPERTIES_EXT: return "VK_STRUCTURE_TYPE_MEMORY_HOST_POINTER_PROPERTIES_EXT";
    case StructureType::e_PHYSICAL_DEVICE_EXTERNAL_MEMORY_HOST_PROPERTIES_EXT: return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_MEMORY_HOST_PROPERTIES_EXT";
    case StructureType::e_PHYSICAL_DEVICE_SHADER_CORE_PROPERTIES_AMD: return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CORE_PROPERTIES_AMD";
    case StructureType::e_PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_DIVISOR_PROPERTIES_EXT: return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_DIVISOR_PROPERTIES_EXT";
    case StructureType::e_PIPELINE_VERTEX_INPUT_DIVISOR_STATE_CREATE_INFO_EXT: return "VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_DIVISOR_STATE_CREATE_INFO_EXT";
    default: return "invalid";
    }
}

enum class SystemAllocationScope
{
    e_NONE = 0,
    e_COMMAND = VK_SYSTEM_ALLOCATION_SCOPE_COMMAND,
    e_OBJECT = VK_SYSTEM_ALLOCATION_SCOPE_OBJECT,
    e_CACHE = VK_SYSTEM_ALLOCATION_SCOPE_CACHE,
    e_DEVICE = VK_SYSTEM_ALLOCATION_SCOPE_DEVICE,
    e_INSTANCE = VK_SYSTEM_ALLOCATION_SCOPE_INSTANCE,
    e_BEGIN_RANGE = VK_SYSTEM_ALLOCATION_SCOPE_BEGIN_RANGE,
    e_END_RANGE = VK_SYSTEM_ALLOCATION_SCOPE_END_RANGE,
    e_RANGE_SIZE = VK_SYSTEM_ALLOCATION_SCOPE_RANGE_SIZE,
    e_MAX_ENUM = 0x7FFFFFFF

};
DEFINE_ENUM_BITWISE_OPERATORS(SystemAllocationScope)
inline std::string to_string(SystemAllocationScope value)
{
    switch(value)
    {
    case SystemAllocationScope::e_COMMAND: return "VK_SYSTEM_ALLOCATION_SCOPE_COMMAND";
    case SystemAllocationScope::e_OBJECT: return "VK_SYSTEM_ALLOCATION_SCOPE_OBJECT";
    case SystemAllocationScope::e_CACHE: return "VK_SYSTEM_ALLOCATION_SCOPE_CACHE";
    case SystemAllocationScope::e_DEVICE: return "VK_SYSTEM_ALLOCATION_SCOPE_DEVICE";
    case SystemAllocationScope::e_INSTANCE: return "VK_SYSTEM_ALLOCATION_SCOPE_INSTANCE";
    default: return "invalid";
    }
}

enum class InternalAllocationType
{
    e_NONE = 0,
    e_EXECUTABLE = VK_INTERNAL_ALLOCATION_TYPE_EXECUTABLE,
    e_BEGIN_RANGE = VK_INTERNAL_ALLOCATION_TYPE_BEGIN_RANGE,
    e_END_RANGE = VK_INTERNAL_ALLOCATION_TYPE_END_RANGE,
    e_RANGE_SIZE = VK_INTERNAL_ALLOCATION_TYPE_RANGE_SIZE,
    e_MAX_ENUM = 0x7FFFFFFF

};
DEFINE_ENUM_BITWISE_OPERATORS(InternalAllocationType)
inline std::string to_string(InternalAllocationType value)
{
    switch(value)
    {
    case InternalAllocationType::e_EXECUTABLE: return "VK_INTERNAL_ALLOCATION_TYPE_EXECUTABLE";
    default: return "invalid";
    }
}

enum class Format
{
    e_NONE = 0,
    e_UNDEFINED = VK_FORMAT_UNDEFINED,
    e_R4G4_UNORM_PACK8 = VK_FORMAT_R4G4_UNORM_PACK8,
    e_R4G4B4A4_UNORM_PACK16 = VK_FORMAT_R4G4B4A4_UNORM_PACK16,
    e_B4G4R4A4_UNORM_PACK16 = VK_FORMAT_B4G4R4A4_UNORM_PACK16,
    e_R5G6B5_UNORM_PACK16 = VK_FORMAT_R5G6B5_UNORM_PACK16,
    e_B5G6R5_UNORM_PACK16 = VK_FORMAT_B5G6R5_UNORM_PACK16,
    e_R5G5B5A1_UNORM_PACK16 = VK_FORMAT_R5G5B5A1_UNORM_PACK16,
    e_B5G5R5A1_UNORM_PACK16 = VK_FORMAT_B5G5R5A1_UNORM_PACK16,
    e_A1R5G5B5_UNORM_PACK16 = VK_FORMAT_A1R5G5B5_UNORM_PACK16,
    e_R8_UNORM = VK_FORMAT_R8_UNORM,
    e_R8_SNORM = VK_FORMAT_R8_SNORM,
    e_R8_USCALED = VK_FORMAT_R8_USCALED,
    e_R8_SSCALED = VK_FORMAT_R8_SSCALED,
    e_R8_UINT = VK_FORMAT_R8_UINT,
    e_R8_SINT = VK_FORMAT_R8_SINT,
    e_R8_SRGB = VK_FORMAT_R8_SRGB,
    e_R8G8_UNORM = VK_FORMAT_R8G8_UNORM,
    e_R8G8_SNORM = VK_FORMAT_R8G8_SNORM,
    e_R8G8_USCALED = VK_FORMAT_R8G8_USCALED,
    e_R8G8_SSCALED = VK_FORMAT_R8G8_SSCALED,
    e_R8G8_UINT = VK_FORMAT_R8G8_UINT,
    e_R8G8_SINT = VK_FORMAT_R8G8_SINT,
    e_R8G8_SRGB = VK_FORMAT_R8G8_SRGB,
    e_R8G8B8_UNORM = VK_FORMAT_R8G8B8_UNORM,
    e_R8G8B8_SNORM = VK_FORMAT_R8G8B8_SNORM,
    e_R8G8B8_USCALED = VK_FORMAT_R8G8B8_USCALED,
    e_R8G8B8_SSCALED = VK_FORMAT_R8G8B8_SSCALED,
    e_R8G8B8_UINT = VK_FORMAT_R8G8B8_UINT,
    e_R8G8B8_SINT = VK_FORMAT_R8G8B8_SINT,
    e_R8G8B8_SRGB = VK_FORMAT_R8G8B8_SRGB,
    e_B8G8R8_UNORM = VK_FORMAT_B8G8R8_UNORM,
    e_B8G8R8_SNORM = VK_FORMAT_B8G8R8_SNORM,
    e_B8G8R8_USCALED = VK_FORMAT_B8G8R8_USCALED,
    e_B8G8R8_SSCALED = VK_FORMAT_B8G8R8_SSCALED,
    e_B8G8R8_UINT = VK_FORMAT_B8G8R8_UINT,
    e_B8G8R8_SINT = VK_FORMAT_B8G8R8_SINT,
    e_B8G8R8_SRGB = VK_FORMAT_B8G8R8_SRGB,
    e_R8G8B8A8_UNORM = VK_FORMAT_R8G8B8A8_UNORM,
    e_R8G8B8A8_SNORM = VK_FORMAT_R8G8B8A8_SNORM,
    e_R8G8B8A8_USCALED = VK_FORMAT_R8G8B8A8_USCALED,
    e_R8G8B8A8_SSCALED = VK_FORMAT_R8G8B8A8_SSCALED,
    e_R8G8B8A8_UINT = VK_FORMAT_R8G8B8A8_UINT,
    e_R8G8B8A8_SINT = VK_FORMAT_R8G8B8A8_SINT,
    e_R8G8B8A8_SRGB = VK_FORMAT_R8G8B8A8_SRGB,
    e_B8G8R8A8_UNORM = VK_FORMAT_B8G8R8A8_UNORM,
    e_B8G8R8A8_SNORM = VK_FORMAT_B8G8R8A8_SNORM,
    e_B8G8R8A8_USCALED = VK_FORMAT_B8G8R8A8_USCALED,
    e_B8G8R8A8_SSCALED = VK_FORMAT_B8G8R8A8_SSCALED,
    e_B8G8R8A8_UINT = VK_FORMAT_B8G8R8A8_UINT,
    e_B8G8R8A8_SINT = VK_FORMAT_B8G8R8A8_SINT,
    e_B8G8R8A8_SRGB = VK_FORMAT_B8G8R8A8_SRGB,
    e_A8B8G8R8_UNORM_PACK32 = VK_FORMAT_A8B8G8R8_UNORM_PACK32,
    e_A8B8G8R8_SNORM_PACK32 = VK_FORMAT_A8B8G8R8_SNORM_PACK32,
    e_A8B8G8R8_USCALED_PACK32 = VK_FORMAT_A8B8G8R8_USCALED_PACK32,
    e_A8B8G8R8_SSCALED_PACK32 = VK_FORMAT_A8B8G8R8_SSCALED_PACK32,
    e_A8B8G8R8_UINT_PACK32 = VK_FORMAT_A8B8G8R8_UINT_PACK32,
    e_A8B8G8R8_SINT_PACK32 = VK_FORMAT_A8B8G8R8_SINT_PACK32,
    e_A8B8G8R8_SRGB_PACK32 = VK_FORMAT_A8B8G8R8_SRGB_PACK32,
    e_A2R10G10B10_UNORM_PACK32 = VK_FORMAT_A2R10G10B10_UNORM_PACK32,
    e_A2R10G10B10_SNORM_PACK32 = VK_FORMAT_A2R10G10B10_SNORM_PACK32,
    e_A2R10G10B10_USCALED_PACK32 = VK_FORMAT_A2R10G10B10_USCALED_PACK32,
    e_A2R10G10B10_SSCALED_PACK32 = VK_FORMAT_A2R10G10B10_SSCALED_PACK32,
    e_A2R10G10B10_UINT_PACK32 = VK_FORMAT_A2R10G10B10_UINT_PACK32,
    e_A2R10G10B10_SINT_PACK32 = VK_FORMAT_A2R10G10B10_SINT_PACK32,
    e_A2B10G10R10_UNORM_PACK32 = VK_FORMAT_A2B10G10R10_UNORM_PACK32,
    e_A2B10G10R10_SNORM_PACK32 = VK_FORMAT_A2B10G10R10_SNORM_PACK32,
    e_A2B10G10R10_USCALED_PACK32 = VK_FORMAT_A2B10G10R10_USCALED_PACK32,
    e_A2B10G10R10_SSCALED_PACK32 = VK_FORMAT_A2B10G10R10_SSCALED_PACK32,
    e_A2B10G10R10_UINT_PACK32 = VK_FORMAT_A2B10G10R10_UINT_PACK32,
    e_A2B10G10R10_SINT_PACK32 = VK_FORMAT_A2B10G10R10_SINT_PACK32,
    e_R16_UNORM = VK_FORMAT_R16_UNORM,
    e_R16_SNORM = VK_FORMAT_R16_SNORM,
    e_R16_USCALED = VK_FORMAT_R16_USCALED,
    e_R16_SSCALED = VK_FORMAT_R16_SSCALED,
    e_R16_UINT = VK_FORMAT_R16_UINT,
    e_R16_SINT = VK_FORMAT_R16_SINT,
    e_R16_SFLOAT = VK_FORMAT_R16_SFLOAT,
    e_R16G16_UNORM = VK_FORMAT_R16G16_UNORM,
    e_R16G16_SNORM = VK_FORMAT_R16G16_SNORM,
    e_R16G16_USCALED = VK_FORMAT_R16G16_USCALED,
    e_R16G16_SSCALED = VK_FORMAT_R16G16_SSCALED,
    e_R16G16_UINT = VK_FORMAT_R16G16_UINT,
    e_R16G16_SINT = VK_FORMAT_R16G16_SINT,
    e_R16G16_SFLOAT = VK_FORMAT_R16G16_SFLOAT,
    e_R16G16B16_UNORM = VK_FORMAT_R16G16B16_UNORM,
    e_R16G16B16_SNORM = VK_FORMAT_R16G16B16_SNORM,
    e_R16G16B16_USCALED = VK_FORMAT_R16G16B16_USCALED,
    e_R16G16B16_SSCALED = VK_FORMAT_R16G16B16_SSCALED,
    e_R16G16B16_UINT = VK_FORMAT_R16G16B16_UINT,
    e_R16G16B16_SINT = VK_FORMAT_R16G16B16_SINT,
    e_R16G16B16_SFLOAT = VK_FORMAT_R16G16B16_SFLOAT,
    e_R16G16B16A16_UNORM = VK_FORMAT_R16G16B16A16_UNORM,
    e_R16G16B16A16_SNORM = VK_FORMAT_R16G16B16A16_SNORM,
    e_R16G16B16A16_USCALED = VK_FORMAT_R16G16B16A16_USCALED,
    e_R16G16B16A16_SSCALED = VK_FORMAT_R16G16B16A16_SSCALED,
    e_R16G16B16A16_UINT = VK_FORMAT_R16G16B16A16_UINT,
    e_R16G16B16A16_SINT = VK_FORMAT_R16G16B16A16_SINT,
    e_R16G16B16A16_SFLOAT = VK_FORMAT_R16G16B16A16_SFLOAT,
    e_R32_UINT = VK_FORMAT_R32_UINT,
    e_R32_SINT = VK_FORMAT_R32_SINT,
    e_R32_SFLOAT = VK_FORMAT_R32_SFLOAT,
    e_R32G32_UINT = VK_FORMAT_R32G32_UINT,
    e_R32G32_SINT = VK_FORMAT_R32G32_SINT,
    e_R32G32_SFLOAT = VK_FORMAT_R32G32_SFLOAT,
    e_R32G32B32_UINT = VK_FORMAT_R32G32B32_UINT,
    e_R32G32B32_SINT = VK_FORMAT_R32G32B32_SINT,
    e_R32G32B32_SFLOAT = VK_FORMAT_R32G32B32_SFLOAT,
    e_R32G32B32A32_UINT = VK_FORMAT_R32G32B32A32_UINT,
    e_R32G32B32A32_SINT = VK_FORMAT_R32G32B32A32_SINT,
    e_R32G32B32A32_SFLOAT = VK_FORMAT_R32G32B32A32_SFLOAT,
    e_R64_UINT = VK_FORMAT_R64_UINT,
    e_R64_SINT = VK_FORMAT_R64_SINT,
    e_R64_SFLOAT = VK_FORMAT_R64_SFLOAT,
    e_R64G64_UINT = VK_FORMAT_R64G64_UINT,
    e_R64G64_SINT = VK_FORMAT_R64G64_SINT,
    e_R64G64_SFLOAT = VK_FORMAT_R64G64_SFLOAT,
    e_R64G64B64_UINT = VK_FORMAT_R64G64B64_UINT,
    e_R64G64B64_SINT = VK_FORMAT_R64G64B64_SINT,
    e_R64G64B64_SFLOAT = VK_FORMAT_R64G64B64_SFLOAT,
    e_R64G64B64A64_UINT = VK_FORMAT_R64G64B64A64_UINT,
    e_R64G64B64A64_SINT = VK_FORMAT_R64G64B64A64_SINT,
    e_R64G64B64A64_SFLOAT = VK_FORMAT_R64G64B64A64_SFLOAT,
    e_B10G11R11_UFLOAT_PACK32 = VK_FORMAT_B10G11R11_UFLOAT_PACK32,
    e_E5B9G9R9_UFLOAT_PACK32 = VK_FORMAT_E5B9G9R9_UFLOAT_PACK32,
    e_D16_UNORM = VK_FORMAT_D16_UNORM,
    e_X8_D24_UNORM_PACK32 = VK_FORMAT_X8_D24_UNORM_PACK32,
    e_D32_SFLOAT = VK_FORMAT_D32_SFLOAT,
    e_S8_UINT = VK_FORMAT_S8_UINT,
    e_D16_UNORM_S8_UINT = VK_FORMAT_D16_UNORM_S8_UINT,
    e_D24_UNORM_S8_UINT = VK_FORMAT_D24_UNORM_S8_UINT,
    e_D32_SFLOAT_S8_UINT = VK_FORMAT_D32_SFLOAT_S8_UINT,
    e_BC1_RGB_UNORM_BLOCK = VK_FORMAT_BC1_RGB_UNORM_BLOCK,
    e_BC1_RGB_SRGB_BLOCK = VK_FORMAT_BC1_RGB_SRGB_BLOCK,
    e_BC1_RGBA_UNORM_BLOCK = VK_FORMAT_BC1_RGBA_UNORM_BLOCK,
    e_BC1_RGBA_SRGB_BLOCK = VK_FORMAT_BC1_RGBA_SRGB_BLOCK,
    e_BC2_UNORM_BLOCK = VK_FORMAT_BC2_UNORM_BLOCK,
    e_BC2_SRGB_BLOCK = VK_FORMAT_BC2_SRGB_BLOCK,
    e_BC3_UNORM_BLOCK = VK_FORMAT_BC3_UNORM_BLOCK,
    e_BC3_SRGB_BLOCK = VK_FORMAT_BC3_SRGB_BLOCK,
    e_BC4_UNORM_BLOCK = VK_FORMAT_BC4_UNORM_BLOCK,
    e_BC4_SNORM_BLOCK = VK_FORMAT_BC4_SNORM_BLOCK,
    e_BC5_UNORM_BLOCK = VK_FORMAT_BC5_UNORM_BLOCK,
    e_BC5_SNORM_BLOCK = VK_FORMAT_BC5_SNORM_BLOCK,
    e_BC6H_UFLOAT_BLOCK = VK_FORMAT_BC6H_UFLOAT_BLOCK,
    e_BC6H_SFLOAT_BLOCK = VK_FORMAT_BC6H_SFLOAT_BLOCK,
    e_BC7_UNORM_BLOCK = VK_FORMAT_BC7_UNORM_BLOCK,
    e_BC7_SRGB_BLOCK = VK_FORMAT_BC7_SRGB_BLOCK,
    e_ETC2_R8G8B8_UNORM_BLOCK = VK_FORMAT_ETC2_R8G8B8_UNORM_BLOCK,
    e_ETC2_R8G8B8_SRGB_BLOCK = VK_FORMAT_ETC2_R8G8B8_SRGB_BLOCK,
    e_ETC2_R8G8B8A1_UNORM_BLOCK = VK_FORMAT_ETC2_R8G8B8A1_UNORM_BLOCK,
    e_ETC2_R8G8B8A1_SRGB_BLOCK = VK_FORMAT_ETC2_R8G8B8A1_SRGB_BLOCK,
    e_ETC2_R8G8B8A8_UNORM_BLOCK = VK_FORMAT_ETC2_R8G8B8A8_UNORM_BLOCK,
    e_ETC2_R8G8B8A8_SRGB_BLOCK = VK_FORMAT_ETC2_R8G8B8A8_SRGB_BLOCK,
    e_EAC_R11_UNORM_BLOCK = VK_FORMAT_EAC_R11_UNORM_BLOCK,
    e_EAC_R11_SNORM_BLOCK = VK_FORMAT_EAC_R11_SNORM_BLOCK,
    e_EAC_R11G11_UNORM_BLOCK = VK_FORMAT_EAC_R11G11_UNORM_BLOCK,
    e_EAC_R11G11_SNORM_BLOCK = VK_FORMAT_EAC_R11G11_SNORM_BLOCK,
    e_ASTC_4x4_UNORM_BLOCK = VK_FORMAT_ASTC_4x4_UNORM_BLOCK,
    e_ASTC_4x4_SRGB_BLOCK = VK_FORMAT_ASTC_4x4_SRGB_BLOCK,
    e_ASTC_5x4_UNORM_BLOCK = VK_FORMAT_ASTC_5x4_UNORM_BLOCK,
    e_ASTC_5x4_SRGB_BLOCK = VK_FORMAT_ASTC_5x4_SRGB_BLOCK,
    e_ASTC_5x5_UNORM_BLOCK = VK_FORMAT_ASTC_5x5_UNORM_BLOCK,
    e_ASTC_5x5_SRGB_BLOCK = VK_FORMAT_ASTC_5x5_SRGB_BLOCK,
    e_ASTC_6x5_UNORM_BLOCK = VK_FORMAT_ASTC_6x5_UNORM_BLOCK,
    e_ASTC_6x5_SRGB_BLOCK = VK_FORMAT_ASTC_6x5_SRGB_BLOCK,
    e_ASTC_6x6_UNORM_BLOCK = VK_FORMAT_ASTC_6x6_UNORM_BLOCK,
    e_ASTC_6x6_SRGB_BLOCK = VK_FORMAT_ASTC_6x6_SRGB_BLOCK,
    e_ASTC_8x5_UNORM_BLOCK = VK_FORMAT_ASTC_8x5_UNORM_BLOCK,
    e_ASTC_8x5_SRGB_BLOCK = VK_FORMAT_ASTC_8x5_SRGB_BLOCK,
    e_ASTC_8x6_UNORM_BLOCK = VK_FORMAT_ASTC_8x6_UNORM_BLOCK,
    e_ASTC_8x6_SRGB_BLOCK = VK_FORMAT_ASTC_8x6_SRGB_BLOCK,
    e_ASTC_8x8_UNORM_BLOCK = VK_FORMAT_ASTC_8x8_UNORM_BLOCK,
    e_ASTC_8x8_SRGB_BLOCK = VK_FORMAT_ASTC_8x8_SRGB_BLOCK,
    e_ASTC_10x5_UNORM_BLOCK = VK_FORMAT_ASTC_10x5_UNORM_BLOCK,
    e_ASTC_10x5_SRGB_BLOCK = VK_FORMAT_ASTC_10x5_SRGB_BLOCK,
    e_ASTC_10x6_UNORM_BLOCK = VK_FORMAT_ASTC_10x6_UNORM_BLOCK,
    e_ASTC_10x6_SRGB_BLOCK = VK_FORMAT_ASTC_10x6_SRGB_BLOCK,
    e_ASTC_10x8_UNORM_BLOCK = VK_FORMAT_ASTC_10x8_UNORM_BLOCK,
    e_ASTC_10x8_SRGB_BLOCK = VK_FORMAT_ASTC_10x8_SRGB_BLOCK,
    e_ASTC_10x10_UNORM_BLOCK = VK_FORMAT_ASTC_10x10_UNORM_BLOCK,
    e_ASTC_10x10_SRGB_BLOCK = VK_FORMAT_ASTC_10x10_SRGB_BLOCK,
    e_ASTC_12x10_UNORM_BLOCK = VK_FORMAT_ASTC_12x10_UNORM_BLOCK,
    e_ASTC_12x10_SRGB_BLOCK = VK_FORMAT_ASTC_12x10_SRGB_BLOCK,
    e_ASTC_12x12_UNORM_BLOCK = VK_FORMAT_ASTC_12x12_UNORM_BLOCK,
    e_ASTC_12x12_SRGB_BLOCK = VK_FORMAT_ASTC_12x12_SRGB_BLOCK,
    e_G8B8G8R8_422_UNORM = VK_FORMAT_G8B8G8R8_422_UNORM,
    e_B8G8R8G8_422_UNORM = VK_FORMAT_B8G8R8G8_422_UNORM,
    e_G8_B8_R8_3PLANE_420_UNORM = VK_FORMAT_G8_B8_R8_3PLANE_420_UNORM,
    e_G8_B8R8_2PLANE_420_UNORM = VK_FORMAT_G8_B8R8_2PLANE_420_UNORM,
    e_G8_B8_R8_3PLANE_422_UNORM = VK_FORMAT_G8_B8_R8_3PLANE_422_UNORM,
    e_G8_B8R8_2PLANE_422_UNORM = VK_FORMAT_G8_B8R8_2PLANE_422_UNORM,
    e_G8_B8_R8_3PLANE_444_UNORM = VK_FORMAT_G8_B8_R8_3PLANE_444_UNORM,
    e_R10X6_UNORM_PACK16 = VK_FORMAT_R10X6_UNORM_PACK16,
    e_R10X6G10X6_UNORM_2PACK16 = VK_FORMAT_R10X6G10X6_UNORM_2PACK16,
    e_R10X6G10X6B10X6A10X6_UNORM_4PACK16 = VK_FORMAT_R10X6G10X6B10X6A10X6_UNORM_4PACK16,
    e_G10X6B10X6G10X6R10X6_422_UNORM_4PACK16 = VK_FORMAT_G10X6B10X6G10X6R10X6_422_UNORM_4PACK16,
    e_B10X6G10X6R10X6G10X6_422_UNORM_4PACK16 = VK_FORMAT_B10X6G10X6R10X6G10X6_422_UNORM_4PACK16,
    e_G10X6_B10X6_R10X6_3PLANE_420_UNORM_3PACK16 = VK_FORMAT_G10X6_B10X6_R10X6_3PLANE_420_UNORM_3PACK16,
    e_G10X6_B10X6R10X6_2PLANE_420_UNORM_3PACK16 = VK_FORMAT_G10X6_B10X6R10X6_2PLANE_420_UNORM_3PACK16,
    e_G10X6_B10X6_R10X6_3PLANE_422_UNORM_3PACK16 = VK_FORMAT_G10X6_B10X6_R10X6_3PLANE_422_UNORM_3PACK16,
    e_G10X6_B10X6R10X6_2PLANE_422_UNORM_3PACK16 = VK_FORMAT_G10X6_B10X6R10X6_2PLANE_422_UNORM_3PACK16,
    e_G10X6_B10X6_R10X6_3PLANE_444_UNORM_3PACK16 = VK_FORMAT_G10X6_B10X6_R10X6_3PLANE_444_UNORM_3PACK16,
    e_R12X4_UNORM_PACK16 = VK_FORMAT_R12X4_UNORM_PACK16,
    e_R12X4G12X4_UNORM_2PACK16 = VK_FORMAT_R12X4G12X4_UNORM_2PACK16,
    e_R12X4G12X4B12X4A12X4_UNORM_4PACK16 = VK_FORMAT_R12X4G12X4B12X4A12X4_UNORM_4PACK16,
    e_G12X4B12X4G12X4R12X4_422_UNORM_4PACK16 = VK_FORMAT_G12X4B12X4G12X4R12X4_422_UNORM_4PACK16,
    e_B12X4G12X4R12X4G12X4_422_UNORM_4PACK16 = VK_FORMAT_B12X4G12X4R12X4G12X4_422_UNORM_4PACK16,
    e_G12X4_B12X4_R12X4_3PLANE_420_UNORM_3PACK16 = VK_FORMAT_G12X4_B12X4_R12X4_3PLANE_420_UNORM_3PACK16,
    e_G12X4_B12X4R12X4_2PLANE_420_UNORM_3PACK16 = VK_FORMAT_G12X4_B12X4R12X4_2PLANE_420_UNORM_3PACK16,
    e_G12X4_B12X4_R12X4_3PLANE_422_UNORM_3PACK16 = VK_FORMAT_G12X4_B12X4_R12X4_3PLANE_422_UNORM_3PACK16,
    e_G12X4_B12X4R12X4_2PLANE_422_UNORM_3PACK16 = VK_FORMAT_G12X4_B12X4R12X4_2PLANE_422_UNORM_3PACK16,
    e_G12X4_B12X4_R12X4_3PLANE_444_UNORM_3PACK16 = VK_FORMAT_G12X4_B12X4_R12X4_3PLANE_444_UNORM_3PACK16,
    e_G16B16G16R16_422_UNORM = VK_FORMAT_G16B16G16R16_422_UNORM,
    e_B16G16R16G16_422_UNORM = VK_FORMAT_B16G16R16G16_422_UNORM,
    e_G16_B16_R16_3PLANE_420_UNORM = VK_FORMAT_G16_B16_R16_3PLANE_420_UNORM,
    e_G16_B16R16_2PLANE_420_UNORM = VK_FORMAT_G16_B16R16_2PLANE_420_UNORM,
    e_G16_B16_R16_3PLANE_422_UNORM = VK_FORMAT_G16_B16_R16_3PLANE_422_UNORM,
    e_G16_B16R16_2PLANE_422_UNORM = VK_FORMAT_G16_B16R16_2PLANE_422_UNORM,
    e_G16_B16_R16_3PLANE_444_UNORM = VK_FORMAT_G16_B16_R16_3PLANE_444_UNORM,
    e_PVRTC1_2BPP_UNORM_BLOCK_IMG = VK_FORMAT_PVRTC1_2BPP_UNORM_BLOCK_IMG,
    e_PVRTC1_4BPP_UNORM_BLOCK_IMG = VK_FORMAT_PVRTC1_4BPP_UNORM_BLOCK_IMG,
    e_PVRTC2_2BPP_UNORM_BLOCK_IMG = VK_FORMAT_PVRTC2_2BPP_UNORM_BLOCK_IMG,
    e_PVRTC2_4BPP_UNORM_BLOCK_IMG = VK_FORMAT_PVRTC2_4BPP_UNORM_BLOCK_IMG,
    e_PVRTC1_2BPP_SRGB_BLOCK_IMG = VK_FORMAT_PVRTC1_2BPP_SRGB_BLOCK_IMG,
    e_PVRTC1_4BPP_SRGB_BLOCK_IMG = VK_FORMAT_PVRTC1_4BPP_SRGB_BLOCK_IMG,
    e_PVRTC2_2BPP_SRGB_BLOCK_IMG = VK_FORMAT_PVRTC2_2BPP_SRGB_BLOCK_IMG,
    e_PVRTC2_4BPP_SRGB_BLOCK_IMG = VK_FORMAT_PVRTC2_4BPP_SRGB_BLOCK_IMG,
    e_G8B8G8R8_422_UNORM_KHR = VK_FORMAT_G8B8G8R8_422_UNORM_KHR,
    e_B8G8R8G8_422_UNORM_KHR = VK_FORMAT_B8G8R8G8_422_UNORM_KHR,
    e_G8_B8_R8_3PLANE_420_UNORM_KHR = VK_FORMAT_G8_B8_R8_3PLANE_420_UNORM_KHR,
    e_G8_B8R8_2PLANE_420_UNORM_KHR = VK_FORMAT_G8_B8R8_2PLANE_420_UNORM_KHR,
    e_G8_B8_R8_3PLANE_422_UNORM_KHR = VK_FORMAT_G8_B8_R8_3PLANE_422_UNORM_KHR,
    e_G8_B8R8_2PLANE_422_UNORM_KHR = VK_FORMAT_G8_B8R8_2PLANE_422_UNORM_KHR,
    e_G8_B8_R8_3PLANE_444_UNORM_KHR = VK_FORMAT_G8_B8_R8_3PLANE_444_UNORM_KHR,
    e_R10X6_UNORM_PACK16_KHR = VK_FORMAT_R10X6_UNORM_PACK16_KHR,
    e_R10X6G10X6_UNORM_2PACK16_KHR = VK_FORMAT_R10X6G10X6_UNORM_2PACK16_KHR,
    e_R10X6G10X6B10X6A10X6_UNORM_4PACK16_KHR = VK_FORMAT_R10X6G10X6B10X6A10X6_UNORM_4PACK16_KHR,
    e_G10X6B10X6G10X6R10X6_422_UNORM_4PACK16_KHR = VK_FORMAT_G10X6B10X6G10X6R10X6_422_UNORM_4PACK16_KHR,
    e_B10X6G10X6R10X6G10X6_422_UNORM_4PACK16_KHR = VK_FORMAT_B10X6G10X6R10X6G10X6_422_UNORM_4PACK16_KHR,
    e_G10X6_B10X6_R10X6_3PLANE_420_UNORM_3PACK16_KHR = VK_FORMAT_G10X6_B10X6_R10X6_3PLANE_420_UNORM_3PACK16_KHR,
    e_G10X6_B10X6R10X6_2PLANE_420_UNORM_3PACK16_KHR = VK_FORMAT_G10X6_B10X6R10X6_2PLANE_420_UNORM_3PACK16_KHR,
    e_G10X6_B10X6_R10X6_3PLANE_422_UNORM_3PACK16_KHR = VK_FORMAT_G10X6_B10X6_R10X6_3PLANE_422_UNORM_3PACK16_KHR,
    e_G10X6_B10X6R10X6_2PLANE_422_UNORM_3PACK16_KHR = VK_FORMAT_G10X6_B10X6R10X6_2PLANE_422_UNORM_3PACK16_KHR,
    e_G10X6_B10X6_R10X6_3PLANE_444_UNORM_3PACK16_KHR = VK_FORMAT_G10X6_B10X6_R10X6_3PLANE_444_UNORM_3PACK16_KHR,
    e_R12X4_UNORM_PACK16_KHR = VK_FORMAT_R12X4_UNORM_PACK16_KHR,
    e_R12X4G12X4_UNORM_2PACK16_KHR = VK_FORMAT_R12X4G12X4_UNORM_2PACK16_KHR,
    e_R12X4G12X4B12X4A12X4_UNORM_4PACK16_KHR = VK_FORMAT_R12X4G12X4B12X4A12X4_UNORM_4PACK16_KHR,
    e_G12X4B12X4G12X4R12X4_422_UNORM_4PACK16_KHR = VK_FORMAT_G12X4B12X4G12X4R12X4_422_UNORM_4PACK16_KHR,
    e_B12X4G12X4R12X4G12X4_422_UNORM_4PACK16_KHR = VK_FORMAT_B12X4G12X4R12X4G12X4_422_UNORM_4PACK16_KHR,
    e_G12X4_B12X4_R12X4_3PLANE_420_UNORM_3PACK16_KHR = VK_FORMAT_G12X4_B12X4_R12X4_3PLANE_420_UNORM_3PACK16_KHR,
    e_G12X4_B12X4R12X4_2PLANE_420_UNORM_3PACK16_KHR = VK_FORMAT_G12X4_B12X4R12X4_2PLANE_420_UNORM_3PACK16_KHR,
    e_G12X4_B12X4_R12X4_3PLANE_422_UNORM_3PACK16_KHR = VK_FORMAT_G12X4_B12X4_R12X4_3PLANE_422_UNORM_3PACK16_KHR,
    e_G12X4_B12X4R12X4_2PLANE_422_UNORM_3PACK16_KHR = VK_FORMAT_G12X4_B12X4R12X4_2PLANE_422_UNORM_3PACK16_KHR,
    e_G12X4_B12X4_R12X4_3PLANE_444_UNORM_3PACK16_KHR = VK_FORMAT_G12X4_B12X4_R12X4_3PLANE_444_UNORM_3PACK16_KHR,
    e_G16B16G16R16_422_UNORM_KHR = VK_FORMAT_G16B16G16R16_422_UNORM_KHR,
    e_B16G16R16G16_422_UNORM_KHR = VK_FORMAT_B16G16R16G16_422_UNORM_KHR,
    e_G16_B16_R16_3PLANE_420_UNORM_KHR = VK_FORMAT_G16_B16_R16_3PLANE_420_UNORM_KHR,
    e_G16_B16R16_2PLANE_420_UNORM_KHR = VK_FORMAT_G16_B16R16_2PLANE_420_UNORM_KHR,
    e_G16_B16_R16_3PLANE_422_UNORM_KHR = VK_FORMAT_G16_B16_R16_3PLANE_422_UNORM_KHR,
    e_G16_B16R16_2PLANE_422_UNORM_KHR = VK_FORMAT_G16_B16R16_2PLANE_422_UNORM_KHR,
    e_G16_B16_R16_3PLANE_444_UNORM_KHR = VK_FORMAT_G16_B16_R16_3PLANE_444_UNORM_KHR,
    e_BEGIN_RANGE = VK_FORMAT_BEGIN_RANGE,
    e_END_RANGE = VK_FORMAT_END_RANGE,
    e_RANGE_SIZE = VK_FORMAT_RANGE_SIZE,
    e_MAX_ENUM = 0x7FFFFFFF

};
DEFINE_ENUM_BITWISE_OPERATORS(Format)
inline std::string to_string(Format value)
{
    switch(value)
    {
    case Format::e_UNDEFINED: return "VK_FORMAT_UNDEFINED";
    case Format::e_R4G4_UNORM_PACK8: return "VK_FORMAT_R4G4_UNORM_PACK8";
    case Format::e_R4G4B4A4_UNORM_PACK16: return "VK_FORMAT_R4G4B4A4_UNORM_PACK16";
    case Format::e_B4G4R4A4_UNORM_PACK16: return "VK_FORMAT_B4G4R4A4_UNORM_PACK16";
    case Format::e_R5G6B5_UNORM_PACK16: return "VK_FORMAT_R5G6B5_UNORM_PACK16";
    case Format::e_B5G6R5_UNORM_PACK16: return "VK_FORMAT_B5G6R5_UNORM_PACK16";
    case Format::e_R5G5B5A1_UNORM_PACK16: return "VK_FORMAT_R5G5B5A1_UNORM_PACK16";
    case Format::e_B5G5R5A1_UNORM_PACK16: return "VK_FORMAT_B5G5R5A1_UNORM_PACK16";
    case Format::e_A1R5G5B5_UNORM_PACK16: return "VK_FORMAT_A1R5G5B5_UNORM_PACK16";
    case Format::e_R8_UNORM: return "VK_FORMAT_R8_UNORM";
    case Format::e_R8_SNORM: return "VK_FORMAT_R8_SNORM";
    case Format::e_R8_USCALED: return "VK_FORMAT_R8_USCALED";
    case Format::e_R8_SSCALED: return "VK_FORMAT_R8_SSCALED";
    case Format::e_R8_UINT: return "VK_FORMAT_R8_UINT";
    case Format::e_R8_SINT: return "VK_FORMAT_R8_SINT";
    case Format::e_R8_SRGB: return "VK_FORMAT_R8_SRGB";
    case Format::e_R8G8_UNORM: return "VK_FORMAT_R8G8_UNORM";
    case Format::e_R8G8_SNORM: return "VK_FORMAT_R8G8_SNORM";
    case Format::e_R8G8_USCALED: return "VK_FORMAT_R8G8_USCALED";
    case Format::e_R8G8_SSCALED: return "VK_FORMAT_R8G8_SSCALED";
    case Format::e_R8G8_UINT: return "VK_FORMAT_R8G8_UINT";
    case Format::e_R8G8_SINT: return "VK_FORMAT_R8G8_SINT";
    case Format::e_R8G8_SRGB: return "VK_FORMAT_R8G8_SRGB";
    case Format::e_R8G8B8_UNORM: return "VK_FORMAT_R8G8B8_UNORM";
    case Format::e_R8G8B8_SNORM: return "VK_FORMAT_R8G8B8_SNORM";
    case Format::e_R8G8B8_USCALED: return "VK_FORMAT_R8G8B8_USCALED";
    case Format::e_R8G8B8_SSCALED: return "VK_FORMAT_R8G8B8_SSCALED";
    case Format::e_R8G8B8_UINT: return "VK_FORMAT_R8G8B8_UINT";
    case Format::e_R8G8B8_SINT: return "VK_FORMAT_R8G8B8_SINT";
    case Format::e_R8G8B8_SRGB: return "VK_FORMAT_R8G8B8_SRGB";
    case Format::e_B8G8R8_UNORM: return "VK_FORMAT_B8G8R8_UNORM";
    case Format::e_B8G8R8_SNORM: return "VK_FORMAT_B8G8R8_SNORM";
    case Format::e_B8G8R8_USCALED: return "VK_FORMAT_B8G8R8_USCALED";
    case Format::e_B8G8R8_SSCALED: return "VK_FORMAT_B8G8R8_SSCALED";
    case Format::e_B8G8R8_UINT: return "VK_FORMAT_B8G8R8_UINT";
    case Format::e_B8G8R8_SINT: return "VK_FORMAT_B8G8R8_SINT";
    case Format::e_B8G8R8_SRGB: return "VK_FORMAT_B8G8R8_SRGB";
    case Format::e_R8G8B8A8_UNORM: return "VK_FORMAT_R8G8B8A8_UNORM";
    case Format::e_R8G8B8A8_SNORM: return "VK_FORMAT_R8G8B8A8_SNORM";
    case Format::e_R8G8B8A8_USCALED: return "VK_FORMAT_R8G8B8A8_USCALED";
    case Format::e_R8G8B8A8_SSCALED: return "VK_FORMAT_R8G8B8A8_SSCALED";
    case Format::e_R8G8B8A8_UINT: return "VK_FORMAT_R8G8B8A8_UINT";
    case Format::e_R8G8B8A8_SINT: return "VK_FORMAT_R8G8B8A8_SINT";
    case Format::e_R8G8B8A8_SRGB: return "VK_FORMAT_R8G8B8A8_SRGB";
    case Format::e_B8G8R8A8_UNORM: return "VK_FORMAT_B8G8R8A8_UNORM";
    case Format::e_B8G8R8A8_SNORM: return "VK_FORMAT_B8G8R8A8_SNORM";
    case Format::e_B8G8R8A8_USCALED: return "VK_FORMAT_B8G8R8A8_USCALED";
    case Format::e_B8G8R8A8_SSCALED: return "VK_FORMAT_B8G8R8A8_SSCALED";
    case Format::e_B8G8R8A8_UINT: return "VK_FORMAT_B8G8R8A8_UINT";
    case Format::e_B8G8R8A8_SINT: return "VK_FORMAT_B8G8R8A8_SINT";
    case Format::e_B8G8R8A8_SRGB: return "VK_FORMAT_B8G8R8A8_SRGB";
    case Format::e_A8B8G8R8_UNORM_PACK32: return "VK_FORMAT_A8B8G8R8_UNORM_PACK32";
    case Format::e_A8B8G8R8_SNORM_PACK32: return "VK_FORMAT_A8B8G8R8_SNORM_PACK32";
    case Format::e_A8B8G8R8_USCALED_PACK32: return "VK_FORMAT_A8B8G8R8_USCALED_PACK32";
    case Format::e_A8B8G8R8_SSCALED_PACK32: return "VK_FORMAT_A8B8G8R8_SSCALED_PACK32";
    case Format::e_A8B8G8R8_UINT_PACK32: return "VK_FORMAT_A8B8G8R8_UINT_PACK32";
    case Format::e_A8B8G8R8_SINT_PACK32: return "VK_FORMAT_A8B8G8R8_SINT_PACK32";
    case Format::e_A8B8G8R8_SRGB_PACK32: return "VK_FORMAT_A8B8G8R8_SRGB_PACK32";
    case Format::e_A2R10G10B10_UNORM_PACK32: return "VK_FORMAT_A2R10G10B10_UNORM_PACK32";
    case Format::e_A2R10G10B10_SNORM_PACK32: return "VK_FORMAT_A2R10G10B10_SNORM_PACK32";
    case Format::e_A2R10G10B10_USCALED_PACK32: return "VK_FORMAT_A2R10G10B10_USCALED_PACK32";
    case Format::e_A2R10G10B10_SSCALED_PACK32: return "VK_FORMAT_A2R10G10B10_SSCALED_PACK32";
    case Format::e_A2R10G10B10_UINT_PACK32: return "VK_FORMAT_A2R10G10B10_UINT_PACK32";
    case Format::e_A2R10G10B10_SINT_PACK32: return "VK_FORMAT_A2R10G10B10_SINT_PACK32";
    case Format::e_A2B10G10R10_UNORM_PACK32: return "VK_FORMAT_A2B10G10R10_UNORM_PACK32";
    case Format::e_A2B10G10R10_SNORM_PACK32: return "VK_FORMAT_A2B10G10R10_SNORM_PACK32";
    case Format::e_A2B10G10R10_USCALED_PACK32: return "VK_FORMAT_A2B10G10R10_USCALED_PACK32";
    case Format::e_A2B10G10R10_SSCALED_PACK32: return "VK_FORMAT_A2B10G10R10_SSCALED_PACK32";
    case Format::e_A2B10G10R10_UINT_PACK32: return "VK_FORMAT_A2B10G10R10_UINT_PACK32";
    case Format::e_A2B10G10R10_SINT_PACK32: return "VK_FORMAT_A2B10G10R10_SINT_PACK32";
    case Format::e_R16_UNORM: return "VK_FORMAT_R16_UNORM";
    case Format::e_R16_SNORM: return "VK_FORMAT_R16_SNORM";
    case Format::e_R16_USCALED: return "VK_FORMAT_R16_USCALED";
    case Format::e_R16_SSCALED: return "VK_FORMAT_R16_SSCALED";
    case Format::e_R16_UINT: return "VK_FORMAT_R16_UINT";
    case Format::e_R16_SINT: return "VK_FORMAT_R16_SINT";
    case Format::e_R16_SFLOAT: return "VK_FORMAT_R16_SFLOAT";
    case Format::e_R16G16_UNORM: return "VK_FORMAT_R16G16_UNORM";
    case Format::e_R16G16_SNORM: return "VK_FORMAT_R16G16_SNORM";
    case Format::e_R16G16_USCALED: return "VK_FORMAT_R16G16_USCALED";
    case Format::e_R16G16_SSCALED: return "VK_FORMAT_R16G16_SSCALED";
    case Format::e_R16G16_UINT: return "VK_FORMAT_R16G16_UINT";
    case Format::e_R16G16_SINT: return "VK_FORMAT_R16G16_SINT";
    case Format::e_R16G16_SFLOAT: return "VK_FORMAT_R16G16_SFLOAT";
    case Format::e_R16G16B16_UNORM: return "VK_FORMAT_R16G16B16_UNORM";
    case Format::e_R16G16B16_SNORM: return "VK_FORMAT_R16G16B16_SNORM";
    case Format::e_R16G16B16_USCALED: return "VK_FORMAT_R16G16B16_USCALED";
    case Format::e_R16G16B16_SSCALED: return "VK_FORMAT_R16G16B16_SSCALED";
    case Format::e_R16G16B16_UINT: return "VK_FORMAT_R16G16B16_UINT";
    case Format::e_R16G16B16_SINT: return "VK_FORMAT_R16G16B16_SINT";
    case Format::e_R16G16B16_SFLOAT: return "VK_FORMAT_R16G16B16_SFLOAT";
    case Format::e_R16G16B16A16_UNORM: return "VK_FORMAT_R16G16B16A16_UNORM";
    case Format::e_R16G16B16A16_SNORM: return "VK_FORMAT_R16G16B16A16_SNORM";
    case Format::e_R16G16B16A16_USCALED: return "VK_FORMAT_R16G16B16A16_USCALED";
    case Format::e_R16G16B16A16_SSCALED: return "VK_FORMAT_R16G16B16A16_SSCALED";
    case Format::e_R16G16B16A16_UINT: return "VK_FORMAT_R16G16B16A16_UINT";
    case Format::e_R16G16B16A16_SINT: return "VK_FORMAT_R16G16B16A16_SINT";
    case Format::e_R16G16B16A16_SFLOAT: return "VK_FORMAT_R16G16B16A16_SFLOAT";
    case Format::e_R32_UINT: return "VK_FORMAT_R32_UINT";
    case Format::e_R32_SINT: return "VK_FORMAT_R32_SINT";
    case Format::e_R32_SFLOAT: return "VK_FORMAT_R32_SFLOAT";
    case Format::e_R32G32_UINT: return "VK_FORMAT_R32G32_UINT";
    case Format::e_R32G32_SINT: return "VK_FORMAT_R32G32_SINT";
    case Format::e_R32G32_SFLOAT: return "VK_FORMAT_R32G32_SFLOAT";
    case Format::e_R32G32B32_UINT: return "VK_FORMAT_R32G32B32_UINT";
    case Format::e_R32G32B32_SINT: return "VK_FORMAT_R32G32B32_SINT";
    case Format::e_R32G32B32_SFLOAT: return "VK_FORMAT_R32G32B32_SFLOAT";
    case Format::e_R32G32B32A32_UINT: return "VK_FORMAT_R32G32B32A32_UINT";
    case Format::e_R32G32B32A32_SINT: return "VK_FORMAT_R32G32B32A32_SINT";
    case Format::e_R32G32B32A32_SFLOAT: return "VK_FORMAT_R32G32B32A32_SFLOAT";
    case Format::e_R64_UINT: return "VK_FORMAT_R64_UINT";
    case Format::e_R64_SINT: return "VK_FORMAT_R64_SINT";
    case Format::e_R64_SFLOAT: return "VK_FORMAT_R64_SFLOAT";
    case Format::e_R64G64_UINT: return "VK_FORMAT_R64G64_UINT";
    case Format::e_R64G64_SINT: return "VK_FORMAT_R64G64_SINT";
    case Format::e_R64G64_SFLOAT: return "VK_FORMAT_R64G64_SFLOAT";
    case Format::e_R64G64B64_UINT: return "VK_FORMAT_R64G64B64_UINT";
    case Format::e_R64G64B64_SINT: return "VK_FORMAT_R64G64B64_SINT";
    case Format::e_R64G64B64_SFLOAT: return "VK_FORMAT_R64G64B64_SFLOAT";
    case Format::e_R64G64B64A64_UINT: return "VK_FORMAT_R64G64B64A64_UINT";
    case Format::e_R64G64B64A64_SINT: return "VK_FORMAT_R64G64B64A64_SINT";
    case Format::e_R64G64B64A64_SFLOAT: return "VK_FORMAT_R64G64B64A64_SFLOAT";
    case Format::e_B10G11R11_UFLOAT_PACK32: return "VK_FORMAT_B10G11R11_UFLOAT_PACK32";
    case Format::e_E5B9G9R9_UFLOAT_PACK32: return "VK_FORMAT_E5B9G9R9_UFLOAT_PACK32";
    case Format::e_D16_UNORM: return "VK_FORMAT_D16_UNORM";
    case Format::e_X8_D24_UNORM_PACK32: return "VK_FORMAT_X8_D24_UNORM_PACK32";
    case Format::e_D32_SFLOAT: return "VK_FORMAT_D32_SFLOAT";
    case Format::e_S8_UINT: return "VK_FORMAT_S8_UINT";
    case Format::e_D16_UNORM_S8_UINT: return "VK_FORMAT_D16_UNORM_S8_UINT";
    case Format::e_D24_UNORM_S8_UINT: return "VK_FORMAT_D24_UNORM_S8_UINT";
    case Format::e_D32_SFLOAT_S8_UINT: return "VK_FORMAT_D32_SFLOAT_S8_UINT";
    case Format::e_BC1_RGB_UNORM_BLOCK: return "VK_FORMAT_BC1_RGB_UNORM_BLOCK";
    case Format::e_BC1_RGB_SRGB_BLOCK: return "VK_FORMAT_BC1_RGB_SRGB_BLOCK";
    case Format::e_BC1_RGBA_UNORM_BLOCK: return "VK_FORMAT_BC1_RGBA_UNORM_BLOCK";
    case Format::e_BC1_RGBA_SRGB_BLOCK: return "VK_FORMAT_BC1_RGBA_SRGB_BLOCK";
    case Format::e_BC2_UNORM_BLOCK: return "VK_FORMAT_BC2_UNORM_BLOCK";
    case Format::e_BC2_SRGB_BLOCK: return "VK_FORMAT_BC2_SRGB_BLOCK";
    case Format::e_BC3_UNORM_BLOCK: return "VK_FORMAT_BC3_UNORM_BLOCK";
    case Format::e_BC3_SRGB_BLOCK: return "VK_FORMAT_BC3_SRGB_BLOCK";
    case Format::e_BC4_UNORM_BLOCK: return "VK_FORMAT_BC4_UNORM_BLOCK";
    case Format::e_BC4_SNORM_BLOCK: return "VK_FORMAT_BC4_SNORM_BLOCK";
    case Format::e_BC5_UNORM_BLOCK: return "VK_FORMAT_BC5_UNORM_BLOCK";
    case Format::e_BC5_SNORM_BLOCK: return "VK_FORMAT_BC5_SNORM_BLOCK";
    case Format::e_BC6H_UFLOAT_BLOCK: return "VK_FORMAT_BC6H_UFLOAT_BLOCK";
    case Format::e_BC6H_SFLOAT_BLOCK: return "VK_FORMAT_BC6H_SFLOAT_BLOCK";
    case Format::e_BC7_UNORM_BLOCK: return "VK_FORMAT_BC7_UNORM_BLOCK";
    case Format::e_BC7_SRGB_BLOCK: return "VK_FORMAT_BC7_SRGB_BLOCK";
    case Format::e_ETC2_R8G8B8_UNORM_BLOCK: return "VK_FORMAT_ETC2_R8G8B8_UNORM_BLOCK";
    case Format::e_ETC2_R8G8B8_SRGB_BLOCK: return "VK_FORMAT_ETC2_R8G8B8_SRGB_BLOCK";
    case Format::e_ETC2_R8G8B8A1_UNORM_BLOCK: return "VK_FORMAT_ETC2_R8G8B8A1_UNORM_BLOCK";
    case Format::e_ETC2_R8G8B8A1_SRGB_BLOCK: return "VK_FORMAT_ETC2_R8G8B8A1_SRGB_BLOCK";
    case Format::e_ETC2_R8G8B8A8_UNORM_BLOCK: return "VK_FORMAT_ETC2_R8G8B8A8_UNORM_BLOCK";
    case Format::e_ETC2_R8G8B8A8_SRGB_BLOCK: return "VK_FORMAT_ETC2_R8G8B8A8_SRGB_BLOCK";
    case Format::e_EAC_R11_UNORM_BLOCK: return "VK_FORMAT_EAC_R11_UNORM_BLOCK";
    case Format::e_EAC_R11_SNORM_BLOCK: return "VK_FORMAT_EAC_R11_SNORM_BLOCK";
    case Format::e_EAC_R11G11_UNORM_BLOCK: return "VK_FORMAT_EAC_R11G11_UNORM_BLOCK";
    case Format::e_EAC_R11G11_SNORM_BLOCK: return "VK_FORMAT_EAC_R11G11_SNORM_BLOCK";
    case Format::e_ASTC_4x4_UNORM_BLOCK: return "VK_FORMAT_ASTC_4x4_UNORM_BLOCK";
    case Format::e_ASTC_4x4_SRGB_BLOCK: return "VK_FORMAT_ASTC_4x4_SRGB_BLOCK";
    case Format::e_ASTC_5x4_UNORM_BLOCK: return "VK_FORMAT_ASTC_5x4_UNORM_BLOCK";
    case Format::e_ASTC_5x4_SRGB_BLOCK: return "VK_FORMAT_ASTC_5x4_SRGB_BLOCK";
    case Format::e_ASTC_5x5_UNORM_BLOCK: return "VK_FORMAT_ASTC_5x5_UNORM_BLOCK";
    case Format::e_ASTC_5x5_SRGB_BLOCK: return "VK_FORMAT_ASTC_5x5_SRGB_BLOCK";
    case Format::e_ASTC_6x5_UNORM_BLOCK: return "VK_FORMAT_ASTC_6x5_UNORM_BLOCK";
    case Format::e_ASTC_6x5_SRGB_BLOCK: return "VK_FORMAT_ASTC_6x5_SRGB_BLOCK";
    case Format::e_ASTC_6x6_UNORM_BLOCK: return "VK_FORMAT_ASTC_6x6_UNORM_BLOCK";
    case Format::e_ASTC_6x6_SRGB_BLOCK: return "VK_FORMAT_ASTC_6x6_SRGB_BLOCK";
    case Format::e_ASTC_8x5_UNORM_BLOCK: return "VK_FORMAT_ASTC_8x5_UNORM_BLOCK";
    case Format::e_ASTC_8x5_SRGB_BLOCK: return "VK_FORMAT_ASTC_8x5_SRGB_BLOCK";
    case Format::e_ASTC_8x6_UNORM_BLOCK: return "VK_FORMAT_ASTC_8x6_UNORM_BLOCK";
    case Format::e_ASTC_8x6_SRGB_BLOCK: return "VK_FORMAT_ASTC_8x6_SRGB_BLOCK";
    case Format::e_ASTC_8x8_UNORM_BLOCK: return "VK_FORMAT_ASTC_8x8_UNORM_BLOCK";
    case Format::e_ASTC_8x8_SRGB_BLOCK: return "VK_FORMAT_ASTC_8x8_SRGB_BLOCK";
    case Format::e_ASTC_10x5_UNORM_BLOCK: return "VK_FORMAT_ASTC_10x5_UNORM_BLOCK";
    case Format::e_ASTC_10x5_SRGB_BLOCK: return "VK_FORMAT_ASTC_10x5_SRGB_BLOCK";
    case Format::e_ASTC_10x6_UNORM_BLOCK: return "VK_FORMAT_ASTC_10x6_UNORM_BLOCK";
    case Format::e_ASTC_10x6_SRGB_BLOCK: return "VK_FORMAT_ASTC_10x6_SRGB_BLOCK";
    case Format::e_ASTC_10x8_UNORM_BLOCK: return "VK_FORMAT_ASTC_10x8_UNORM_BLOCK";
    case Format::e_ASTC_10x8_SRGB_BLOCK: return "VK_FORMAT_ASTC_10x8_SRGB_BLOCK";
    case Format::e_ASTC_10x10_UNORM_BLOCK: return "VK_FORMAT_ASTC_10x10_UNORM_BLOCK";
    case Format::e_ASTC_10x10_SRGB_BLOCK: return "VK_FORMAT_ASTC_10x10_SRGB_BLOCK";
    case Format::e_ASTC_12x10_UNORM_BLOCK: return "VK_FORMAT_ASTC_12x10_UNORM_BLOCK";
    case Format::e_ASTC_12x10_SRGB_BLOCK: return "VK_FORMAT_ASTC_12x10_SRGB_BLOCK";
    case Format::e_ASTC_12x12_UNORM_BLOCK: return "VK_FORMAT_ASTC_12x12_UNORM_BLOCK";
    case Format::e_ASTC_12x12_SRGB_BLOCK: return "VK_FORMAT_ASTC_12x12_SRGB_BLOCK";
    case Format::e_G8B8G8R8_422_UNORM: return "VK_FORMAT_G8B8G8R8_422_UNORM";
    case Format::e_B8G8R8G8_422_UNORM: return "VK_FORMAT_B8G8R8G8_422_UNORM";
    case Format::e_G8_B8_R8_3PLANE_420_UNORM: return "VK_FORMAT_G8_B8_R8_3PLANE_420_UNORM";
    case Format::e_G8_B8R8_2PLANE_420_UNORM: return "VK_FORMAT_G8_B8R8_2PLANE_420_UNORM";
    case Format::e_G8_B8_R8_3PLANE_422_UNORM: return "VK_FORMAT_G8_B8_R8_3PLANE_422_UNORM";
    case Format::e_G8_B8R8_2PLANE_422_UNORM: return "VK_FORMAT_G8_B8R8_2PLANE_422_UNORM";
    case Format::e_G8_B8_R8_3PLANE_444_UNORM: return "VK_FORMAT_G8_B8_R8_3PLANE_444_UNORM";
    case Format::e_R10X6_UNORM_PACK16: return "VK_FORMAT_R10X6_UNORM_PACK16";
    case Format::e_R10X6G10X6_UNORM_2PACK16: return "VK_FORMAT_R10X6G10X6_UNORM_2PACK16";
    case Format::e_R10X6G10X6B10X6A10X6_UNORM_4PACK16: return "VK_FORMAT_R10X6G10X6B10X6A10X6_UNORM_4PACK16";
    case Format::e_G10X6B10X6G10X6R10X6_422_UNORM_4PACK16: return "VK_FORMAT_G10X6B10X6G10X6R10X6_422_UNORM_4PACK16";
    case Format::e_B10X6G10X6R10X6G10X6_422_UNORM_4PACK16: return "VK_FORMAT_B10X6G10X6R10X6G10X6_422_UNORM_4PACK16";
    case Format::e_G10X6_B10X6_R10X6_3PLANE_420_UNORM_3PACK16: return "VK_FORMAT_G10X6_B10X6_R10X6_3PLANE_420_UNORM_3PACK16";
    case Format::e_G10X6_B10X6R10X6_2PLANE_420_UNORM_3PACK16: return "VK_FORMAT_G10X6_B10X6R10X6_2PLANE_420_UNORM_3PACK16";
    case Format::e_G10X6_B10X6_R10X6_3PLANE_422_UNORM_3PACK16: return "VK_FORMAT_G10X6_B10X6_R10X6_3PLANE_422_UNORM_3PACK16";
    case Format::e_G10X6_B10X6R10X6_2PLANE_422_UNORM_3PACK16: return "VK_FORMAT_G10X6_B10X6R10X6_2PLANE_422_UNORM_3PACK16";
    case Format::e_G10X6_B10X6_R10X6_3PLANE_444_UNORM_3PACK16: return "VK_FORMAT_G10X6_B10X6_R10X6_3PLANE_444_UNORM_3PACK16";
    case Format::e_R12X4_UNORM_PACK16: return "VK_FORMAT_R12X4_UNORM_PACK16";
    case Format::e_R12X4G12X4_UNORM_2PACK16: return "VK_FORMAT_R12X4G12X4_UNORM_2PACK16";
    case Format::e_R12X4G12X4B12X4A12X4_UNORM_4PACK16: return "VK_FORMAT_R12X4G12X4B12X4A12X4_UNORM_4PACK16";
    case Format::e_G12X4B12X4G12X4R12X4_422_UNORM_4PACK16: return "VK_FORMAT_G12X4B12X4G12X4R12X4_422_UNORM_4PACK16";
    case Format::e_B12X4G12X4R12X4G12X4_422_UNORM_4PACK16: return "VK_FORMAT_B12X4G12X4R12X4G12X4_422_UNORM_4PACK16";
    case Format::e_G12X4_B12X4_R12X4_3PLANE_420_UNORM_3PACK16: return "VK_FORMAT_G12X4_B12X4_R12X4_3PLANE_420_UNORM_3PACK16";
    case Format::e_G12X4_B12X4R12X4_2PLANE_420_UNORM_3PACK16: return "VK_FORMAT_G12X4_B12X4R12X4_2PLANE_420_UNORM_3PACK16";
    case Format::e_G12X4_B12X4_R12X4_3PLANE_422_UNORM_3PACK16: return "VK_FORMAT_G12X4_B12X4_R12X4_3PLANE_422_UNORM_3PACK16";
    case Format::e_G12X4_B12X4R12X4_2PLANE_422_UNORM_3PACK16: return "VK_FORMAT_G12X4_B12X4R12X4_2PLANE_422_UNORM_3PACK16";
    case Format::e_G12X4_B12X4_R12X4_3PLANE_444_UNORM_3PACK16: return "VK_FORMAT_G12X4_B12X4_R12X4_3PLANE_444_UNORM_3PACK16";
    case Format::e_G16B16G16R16_422_UNORM: return "VK_FORMAT_G16B16G16R16_422_UNORM";
    case Format::e_B16G16R16G16_422_UNORM: return "VK_FORMAT_B16G16R16G16_422_UNORM";
    case Format::e_G16_B16_R16_3PLANE_420_UNORM: return "VK_FORMAT_G16_B16_R16_3PLANE_420_UNORM";
    case Format::e_G16_B16R16_2PLANE_420_UNORM: return "VK_FORMAT_G16_B16R16_2PLANE_420_UNORM";
    case Format::e_G16_B16_R16_3PLANE_422_UNORM: return "VK_FORMAT_G16_B16_R16_3PLANE_422_UNORM";
    case Format::e_G16_B16R16_2PLANE_422_UNORM: return "VK_FORMAT_G16_B16R16_2PLANE_422_UNORM";
    case Format::e_G16_B16_R16_3PLANE_444_UNORM: return "VK_FORMAT_G16_B16_R16_3PLANE_444_UNORM";
    case Format::e_PVRTC1_2BPP_UNORM_BLOCK_IMG: return "VK_FORMAT_PVRTC1_2BPP_UNORM_BLOCK_IMG";
    case Format::e_PVRTC1_4BPP_UNORM_BLOCK_IMG: return "VK_FORMAT_PVRTC1_4BPP_UNORM_BLOCK_IMG";
    case Format::e_PVRTC2_2BPP_UNORM_BLOCK_IMG: return "VK_FORMAT_PVRTC2_2BPP_UNORM_BLOCK_IMG";
    case Format::e_PVRTC2_4BPP_UNORM_BLOCK_IMG: return "VK_FORMAT_PVRTC2_4BPP_UNORM_BLOCK_IMG";
    case Format::e_PVRTC1_2BPP_SRGB_BLOCK_IMG: return "VK_FORMAT_PVRTC1_2BPP_SRGB_BLOCK_IMG";
    case Format::e_PVRTC1_4BPP_SRGB_BLOCK_IMG: return "VK_FORMAT_PVRTC1_4BPP_SRGB_BLOCK_IMG";
    case Format::e_PVRTC2_2BPP_SRGB_BLOCK_IMG: return "VK_FORMAT_PVRTC2_2BPP_SRGB_BLOCK_IMG";
    case Format::e_PVRTC2_4BPP_SRGB_BLOCK_IMG: return "VK_FORMAT_PVRTC2_4BPP_SRGB_BLOCK_IMG";
    default: return "invalid";
    }
}

enum class FormatFeatureFlags
{
    e_NONE = 0,
    e_SAMPLED_IMAGE_BIT = VK_FORMAT_FEATURE_SAMPLED_IMAGE_BIT,
    e_STORAGE_IMAGE_BIT = VK_FORMAT_FEATURE_STORAGE_IMAGE_BIT,
    e_STORAGE_IMAGE_ATOMIC_BIT = VK_FORMAT_FEATURE_STORAGE_IMAGE_ATOMIC_BIT,
    e_UNIFORM_TEXEL_BUFFER_BIT = VK_FORMAT_FEATURE_UNIFORM_TEXEL_BUFFER_BIT,
    e_STORAGE_TEXEL_BUFFER_BIT = VK_FORMAT_FEATURE_STORAGE_TEXEL_BUFFER_BIT,
    e_STORAGE_TEXEL_BUFFER_ATOMIC_BIT = VK_FORMAT_FEATURE_STORAGE_TEXEL_BUFFER_ATOMIC_BIT,
    e_VERTEX_BUFFER_BIT = VK_FORMAT_FEATURE_VERTEX_BUFFER_BIT,
    e_COLOR_ATTACHMENT_BIT = VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BIT,
    e_COLOR_ATTACHMENT_BLEND_BIT = VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BLEND_BIT,
    e_DEPTH_STENCIL_ATTACHMENT_BIT = VK_FORMAT_FEATURE_DEPTH_STENCIL_ATTACHMENT_BIT,
    e_BLIT_SRC_BIT = VK_FORMAT_FEATURE_BLIT_SRC_BIT,
    e_BLIT_DST_BIT = VK_FORMAT_FEATURE_BLIT_DST_BIT,
    e_SAMPLED_IMAGE_FILTER_LINEAR_BIT = VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_LINEAR_BIT,
    e_TRANSFER_SRC_BIT = VK_FORMAT_FEATURE_TRANSFER_SRC_BIT,
    e_TRANSFER_DST_BIT = VK_FORMAT_FEATURE_TRANSFER_DST_BIT,
    e_MIDPOINT_CHROMA_SAMPLES_BIT = VK_FORMAT_FEATURE_MIDPOINT_CHROMA_SAMPLES_BIT,
    e_SAMPLED_IMAGE_YCBCR_CONVERSION_LINEAR_FILTER_BIT = VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_LINEAR_FILTER_BIT,
    e_SAMPLED_IMAGE_YCBCR_CONVERSION_SEPARATE_RECONSTRUCTION_FILTER_BIT = VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_SEPARATE_RECONSTRUCTION_FILTER_BIT,
    e_SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_BIT = VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_BIT,
    e_SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_FORCEABLE_BIT = VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_FORCEABLE_BIT,
    e_DISJOINT_BIT = VK_FORMAT_FEATURE_DISJOINT_BIT,
    e_COSITED_CHROMA_SAMPLES_BIT = VK_FORMAT_FEATURE_COSITED_CHROMA_SAMPLES_BIT,
    e_SAMPLED_IMAGE_FILTER_CUBIC_BIT_IMG = VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_CUBIC_BIT_IMG,
    e_TRANSFER_SRC_BIT_KHR = VK_FORMAT_FEATURE_TRANSFER_SRC_BIT_KHR,
    e_TRANSFER_DST_BIT_KHR = VK_FORMAT_FEATURE_TRANSFER_DST_BIT_KHR,
    e_SAMPLED_IMAGE_FILTER_MINMAX_BIT_EXT = VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_MINMAX_BIT_EXT,
    e_MIDPOINT_CHROMA_SAMPLES_BIT_KHR = VK_FORMAT_FEATURE_MIDPOINT_CHROMA_SAMPLES_BIT_KHR,
    e_SAMPLED_IMAGE_YCBCR_CONVERSION_LINEAR_FILTER_BIT_KHR = VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_LINEAR_FILTER_BIT_KHR,
    e_SAMPLED_IMAGE_YCBCR_CONVERSION_SEPARATE_RECONSTRUCTION_FILTER_BIT_KHR = VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_SEPARATE_RECONSTRUCTION_FILTER_BIT_KHR,
    e_SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_BIT_KHR = VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_BIT_KHR,
    e_SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_FORCEABLE_BIT_KHR = VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_FORCEABLE_BIT_KHR,
    e_DISJOINT_BIT_KHR = VK_FORMAT_FEATURE_DISJOINT_BIT_KHR,
    e_COSITED_CHROMA_SAMPLES_BIT_KHR = VK_FORMAT_FEATURE_COSITED_CHROMA_SAMPLES_BIT_KHR,
    e_MAX_ENUM = 0x7FFFFFFF,
    e_ALL_BITS = e_SAMPLED_IMAGE_BIT | e_STORAGE_IMAGE_BIT | e_STORAGE_IMAGE_ATOMIC_BIT | e_UNIFORM_TEXEL_BUFFER_BIT | e_STORAGE_TEXEL_BUFFER_BIT | e_STORAGE_TEXEL_BUFFER_ATOMIC_BIT | e_VERTEX_BUFFER_BIT | e_COLOR_ATTACHMENT_BIT | e_COLOR_ATTACHMENT_BLEND_BIT | e_DEPTH_STENCIL_ATTACHMENT_BIT | e_BLIT_SRC_BIT | e_BLIT_DST_BIT | e_SAMPLED_IMAGE_FILTER_LINEAR_BIT | e_TRANSFER_SRC_BIT | e_TRANSFER_DST_BIT | e_MIDPOINT_CHROMA_SAMPLES_BIT | e_SAMPLED_IMAGE_YCBCR_CONVERSION_LINEAR_FILTER_BIT | e_SAMPLED_IMAGE_YCBCR_CONVERSION_SEPARATE_RECONSTRUCTION_FILTER_BIT | e_SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_BIT | e_SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_FORCEABLE_BIT | e_DISJOINT_BIT | e_COSITED_CHROMA_SAMPLES_BIT | e_SAMPLED_IMAGE_FILTER_CUBIC_BIT_IMG | e_TRANSFER_SRC_BIT_KHR | e_TRANSFER_DST_BIT_KHR | e_SAMPLED_IMAGE_FILTER_MINMAX_BIT_EXT | e_MIDPOINT_CHROMA_SAMPLES_BIT_KHR | e_SAMPLED_IMAGE_YCBCR_CONVERSION_LINEAR_FILTER_BIT_KHR | e_SAMPLED_IMAGE_YCBCR_CONVERSION_SEPARATE_RECONSTRUCTION_FILTER_BIT_KHR | e_SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_BIT_KHR | e_SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_FORCEABLE_BIT_KHR | e_DISJOINT_BIT_KHR | e_COSITED_CHROMA_SAMPLES_BIT_KHR
};
DEFINE_ENUM_BITWISE_OPERATORS(FormatFeatureFlags)
inline std::string to_string(FormatFeatureFlags value)
{
    std::string returnString = "";
    bool addedFlags = false;
    if(static_cast<uint32_t>(value & FormatFeatureFlags::e_SAMPLED_IMAGE_BIT) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_FORMAT_FEATURE_SAMPLED_IMAGE_BIT";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & FormatFeatureFlags::e_STORAGE_IMAGE_BIT) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_FORMAT_FEATURE_STORAGE_IMAGE_BIT";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & FormatFeatureFlags::e_STORAGE_IMAGE_ATOMIC_BIT) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_FORMAT_FEATURE_STORAGE_IMAGE_ATOMIC_BIT";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & FormatFeatureFlags::e_UNIFORM_TEXEL_BUFFER_BIT) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_FORMAT_FEATURE_UNIFORM_TEXEL_BUFFER_BIT";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & FormatFeatureFlags::e_STORAGE_TEXEL_BUFFER_BIT) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_FORMAT_FEATURE_STORAGE_TEXEL_BUFFER_BIT";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & FormatFeatureFlags::e_STORAGE_TEXEL_BUFFER_ATOMIC_BIT) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_FORMAT_FEATURE_STORAGE_TEXEL_BUFFER_ATOMIC_BIT";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & FormatFeatureFlags::e_VERTEX_BUFFER_BIT) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_FORMAT_FEATURE_VERTEX_BUFFER_BIT";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & FormatFeatureFlags::e_COLOR_ATTACHMENT_BIT) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BIT";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & FormatFeatureFlags::e_COLOR_ATTACHMENT_BLEND_BIT) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BLEND_BIT";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & FormatFeatureFlags::e_DEPTH_STENCIL_ATTACHMENT_BIT) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_FORMAT_FEATURE_DEPTH_STENCIL_ATTACHMENT_BIT";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & FormatFeatureFlags::e_BLIT_SRC_BIT) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_FORMAT_FEATURE_BLIT_SRC_BIT";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & FormatFeatureFlags::e_BLIT_DST_BIT) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_FORMAT_FEATURE_BLIT_DST_BIT";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & FormatFeatureFlags::e_SAMPLED_IMAGE_FILTER_LINEAR_BIT) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_LINEAR_BIT";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & FormatFeatureFlags::e_TRANSFER_SRC_BIT) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_FORMAT_FEATURE_TRANSFER_SRC_BIT";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & FormatFeatureFlags::e_TRANSFER_DST_BIT) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_FORMAT_FEATURE_TRANSFER_DST_BIT";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & FormatFeatureFlags::e_MIDPOINT_CHROMA_SAMPLES_BIT) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_FORMAT_FEATURE_MIDPOINT_CHROMA_SAMPLES_BIT";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & FormatFeatureFlags::e_SAMPLED_IMAGE_YCBCR_CONVERSION_LINEAR_FILTER_BIT) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_LINEAR_FILTER_BIT";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & FormatFeatureFlags::e_SAMPLED_IMAGE_YCBCR_CONVERSION_SEPARATE_RECONSTRUCTION_FILTER_BIT) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_SEPARATE_RECONSTRUCTION_FILTER_BIT";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & FormatFeatureFlags::e_SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_BIT) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_BIT";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & FormatFeatureFlags::e_SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_FORCEABLE_BIT) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_FORCEABLE_BIT";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & FormatFeatureFlags::e_DISJOINT_BIT) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_FORMAT_FEATURE_DISJOINT_BIT";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & FormatFeatureFlags::e_COSITED_CHROMA_SAMPLES_BIT) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_FORMAT_FEATURE_COSITED_CHROMA_SAMPLES_BIT";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & FormatFeatureFlags::e_SAMPLED_IMAGE_FILTER_CUBIC_BIT_IMG) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_CUBIC_BIT_IMG";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & FormatFeatureFlags::e_TRANSFER_SRC_BIT_KHR) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_FORMAT_FEATURE_TRANSFER_SRC_BIT_KHR";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & FormatFeatureFlags::e_TRANSFER_DST_BIT_KHR) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_FORMAT_FEATURE_TRANSFER_DST_BIT_KHR";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & FormatFeatureFlags::e_SAMPLED_IMAGE_FILTER_MINMAX_BIT_EXT) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_MINMAX_BIT_EXT";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & FormatFeatureFlags::e_MIDPOINT_CHROMA_SAMPLES_BIT_KHR) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_FORMAT_FEATURE_MIDPOINT_CHROMA_SAMPLES_BIT_KHR";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & FormatFeatureFlags::e_SAMPLED_IMAGE_YCBCR_CONVERSION_LINEAR_FILTER_BIT_KHR) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_LINEAR_FILTER_BIT_KHR";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & FormatFeatureFlags::e_SAMPLED_IMAGE_YCBCR_CONVERSION_SEPARATE_RECONSTRUCTION_FILTER_BIT_KHR) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_SEPARATE_RECONSTRUCTION_FILTER_BIT_KHR";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & FormatFeatureFlags::e_SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_BIT_KHR) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_BIT_KHR";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & FormatFeatureFlags::e_SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_FORCEABLE_BIT_KHR) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_FORCEABLE_BIT_KHR";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & FormatFeatureFlags::e_DISJOINT_BIT_KHR) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_FORMAT_FEATURE_DISJOINT_BIT_KHR";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & FormatFeatureFlags::e_COSITED_CHROMA_SAMPLES_BIT_KHR) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_FORMAT_FEATURE_COSITED_CHROMA_SAMPLES_BIT_KHR";
        addedFlags = true;
    }
    return returnString;
}

enum class ImageType
{
    e_NONE = 0,
    e_1D = VK_IMAGE_TYPE_1D,
    e_2D = VK_IMAGE_TYPE_2D,
    e_3D = VK_IMAGE_TYPE_3D,
    e_BEGIN_RANGE = VK_IMAGE_TYPE_BEGIN_RANGE,
    e_END_RANGE = VK_IMAGE_TYPE_END_RANGE,
    e_RANGE_SIZE = VK_IMAGE_TYPE_RANGE_SIZE,
    e_MAX_ENUM = 0x7FFFFFFF

};
DEFINE_ENUM_BITWISE_OPERATORS(ImageType)
inline std::string to_string(ImageType value)
{
    switch(value)
    {
    case ImageType::e_1D: return "VK_IMAGE_TYPE_1D";
    case ImageType::e_2D: return "VK_IMAGE_TYPE_2D";
    case ImageType::e_3D: return "VK_IMAGE_TYPE_3D";
    default: return "invalid";
    }
}

enum class ImageTiling
{
    e_NONE = 0,
    e_OPTIMAL = VK_IMAGE_TILING_OPTIMAL,
    e_LINEAR = VK_IMAGE_TILING_LINEAR,
    e_BEGIN_RANGE = VK_IMAGE_TILING_BEGIN_RANGE,
    e_END_RANGE = VK_IMAGE_TILING_END_RANGE,
    e_RANGE_SIZE = VK_IMAGE_TILING_RANGE_SIZE,
    e_MAX_ENUM = 0x7FFFFFFF

};
DEFINE_ENUM_BITWISE_OPERATORS(ImageTiling)
inline std::string to_string(ImageTiling value)
{
    switch(value)
    {
    case ImageTiling::e_OPTIMAL: return "VK_IMAGE_TILING_OPTIMAL";
    case ImageTiling::e_LINEAR: return "VK_IMAGE_TILING_LINEAR";
    default: return "invalid";
    }
}

enum class ImageUsageFlags
{
    e_NONE = 0,
    e_TRANSFER_SRC_BIT = VK_IMAGE_USAGE_TRANSFER_SRC_BIT,
    e_TRANSFER_DST_BIT = VK_IMAGE_USAGE_TRANSFER_DST_BIT,
    e_SAMPLED_BIT = VK_IMAGE_USAGE_SAMPLED_BIT,
    e_STORAGE_BIT = VK_IMAGE_USAGE_STORAGE_BIT,
    e_COLOR_ATTACHMENT_BIT = VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT,
    e_DEPTH_STENCIL_ATTACHMENT_BIT = VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT,
    e_TRANSIENT_ATTACHMENT_BIT = VK_IMAGE_USAGE_TRANSIENT_ATTACHMENT_BIT,
    e_INPUT_ATTACHMENT_BIT = VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT,
    e_MAX_ENUM = 0x7FFFFFFF,
    e_ALL_BITS = e_TRANSFER_SRC_BIT | e_TRANSFER_DST_BIT | e_SAMPLED_BIT | e_STORAGE_BIT | e_COLOR_ATTACHMENT_BIT | e_DEPTH_STENCIL_ATTACHMENT_BIT | e_TRANSIENT_ATTACHMENT_BIT | e_INPUT_ATTACHMENT_BIT
};
DEFINE_ENUM_BITWISE_OPERATORS(ImageUsageFlags)
inline std::string to_string(ImageUsageFlags value)
{
    std::string returnString = "";
    bool addedFlags = false;
    if(static_cast<uint32_t>(value & ImageUsageFlags::e_TRANSFER_SRC_BIT) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_IMAGE_USAGE_TRANSFER_SRC_BIT";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & ImageUsageFlags::e_TRANSFER_DST_BIT) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_IMAGE_USAGE_TRANSFER_DST_BIT";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & ImageUsageFlags::e_SAMPLED_BIT) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_IMAGE_USAGE_SAMPLED_BIT";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & ImageUsageFlags::e_STORAGE_BIT) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_IMAGE_USAGE_STORAGE_BIT";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & ImageUsageFlags::e_COLOR_ATTACHMENT_BIT) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & ImageUsageFlags::e_DEPTH_STENCIL_ATTACHMENT_BIT) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & ImageUsageFlags::e_TRANSIENT_ATTACHMENT_BIT) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_IMAGE_USAGE_TRANSIENT_ATTACHMENT_BIT";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & ImageUsageFlags::e_INPUT_ATTACHMENT_BIT) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT";
        addedFlags = true;
    }
    return returnString;
}

enum class ImageCreateFlags
{
    e_NONE = 0,
    e_SPARSE_BINDING_BIT = VK_IMAGE_CREATE_SPARSE_BINDING_BIT,
    e_SPARSE_RESIDENCY_BIT = VK_IMAGE_CREATE_SPARSE_RESIDENCY_BIT,
    e_SPARSE_ALIASED_BIT = VK_IMAGE_CREATE_SPARSE_ALIASED_BIT,
    e_MUTABLE_FORMAT_BIT = VK_IMAGE_CREATE_MUTABLE_FORMAT_BIT,
    e_CUBE_COMPATIBLE_BIT = VK_IMAGE_CREATE_CUBE_COMPATIBLE_BIT,
    e_ALIAS_BIT = VK_IMAGE_CREATE_ALIAS_BIT,
    e_SPLIT_INSTANCE_BIND_REGIONS_BIT = VK_IMAGE_CREATE_SPLIT_INSTANCE_BIND_REGIONS_BIT,
    e_2D_ARRAY_COMPATIBLE_BIT = VK_IMAGE_CREATE_2D_ARRAY_COMPATIBLE_BIT,
    e_BLOCK_TEXEL_VIEW_COMPATIBLE_BIT = VK_IMAGE_CREATE_BLOCK_TEXEL_VIEW_COMPATIBLE_BIT,
    e_EXTENDED_USAGE_BIT = VK_IMAGE_CREATE_EXTENDED_USAGE_BIT,
    e_PROTECTED_BIT = VK_IMAGE_CREATE_PROTECTED_BIT,
    e_DISJOINT_BIT = VK_IMAGE_CREATE_DISJOINT_BIT,
    e_SPLIT_INSTANCE_BIND_REGIONS_BIT_KHR = VK_IMAGE_CREATE_SPLIT_INSTANCE_BIND_REGIONS_BIT_KHR,
    e_2D_ARRAY_COMPATIBLE_BIT_KHR = VK_IMAGE_CREATE_2D_ARRAY_COMPATIBLE_BIT_KHR,
    e_BLOCK_TEXEL_VIEW_COMPATIBLE_BIT_KHR = VK_IMAGE_CREATE_BLOCK_TEXEL_VIEW_COMPATIBLE_BIT_KHR,
    e_EXTENDED_USAGE_BIT_KHR = VK_IMAGE_CREATE_EXTENDED_USAGE_BIT_KHR,
    e_SAMPLE_LOCATIONS_COMPATIBLE_DEPTH_BIT_EXT = VK_IMAGE_CREATE_SAMPLE_LOCATIONS_COMPATIBLE_DEPTH_BIT_EXT,
    e_DISJOINT_BIT_KHR = VK_IMAGE_CREATE_DISJOINT_BIT_KHR,
    e_ALIAS_BIT_KHR = VK_IMAGE_CREATE_ALIAS_BIT_KHR,
    e_MAX_ENUM = 0x7FFFFFFF,
    e_ALL_BITS = e_SPARSE_BINDING_BIT | e_SPARSE_RESIDENCY_BIT | e_SPARSE_ALIASED_BIT | e_MUTABLE_FORMAT_BIT | e_CUBE_COMPATIBLE_BIT | e_ALIAS_BIT | e_SPLIT_INSTANCE_BIND_REGIONS_BIT | e_2D_ARRAY_COMPATIBLE_BIT | e_BLOCK_TEXEL_VIEW_COMPATIBLE_BIT | e_EXTENDED_USAGE_BIT | e_PROTECTED_BIT | e_DISJOINT_BIT | e_SPLIT_INSTANCE_BIND_REGIONS_BIT_KHR | e_2D_ARRAY_COMPATIBLE_BIT_KHR | e_BLOCK_TEXEL_VIEW_COMPATIBLE_BIT_KHR | e_EXTENDED_USAGE_BIT_KHR | e_SAMPLE_LOCATIONS_COMPATIBLE_DEPTH_BIT_EXT | e_DISJOINT_BIT_KHR | e_ALIAS_BIT_KHR
};
DEFINE_ENUM_BITWISE_OPERATORS(ImageCreateFlags)
inline std::string to_string(ImageCreateFlags value)
{
    std::string returnString = "";
    bool addedFlags = false;
    if(static_cast<uint32_t>(value & ImageCreateFlags::e_SPARSE_BINDING_BIT) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_IMAGE_CREATE_SPARSE_BINDING_BIT";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & ImageCreateFlags::e_SPARSE_RESIDENCY_BIT) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_IMAGE_CREATE_SPARSE_RESIDENCY_BIT";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & ImageCreateFlags::e_SPARSE_ALIASED_BIT) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_IMAGE_CREATE_SPARSE_ALIASED_BIT";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & ImageCreateFlags::e_MUTABLE_FORMAT_BIT) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_IMAGE_CREATE_MUTABLE_FORMAT_BIT";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & ImageCreateFlags::e_CUBE_COMPATIBLE_BIT) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_IMAGE_CREATE_CUBE_COMPATIBLE_BIT";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & ImageCreateFlags::e_ALIAS_BIT) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_IMAGE_CREATE_ALIAS_BIT";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & ImageCreateFlags::e_SPLIT_INSTANCE_BIND_REGIONS_BIT) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_IMAGE_CREATE_SPLIT_INSTANCE_BIND_REGIONS_BIT";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & ImageCreateFlags::e_2D_ARRAY_COMPATIBLE_BIT) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_IMAGE_CREATE_2D_ARRAY_COMPATIBLE_BIT";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & ImageCreateFlags::e_BLOCK_TEXEL_VIEW_COMPATIBLE_BIT) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_IMAGE_CREATE_BLOCK_TEXEL_VIEW_COMPATIBLE_BIT";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & ImageCreateFlags::e_EXTENDED_USAGE_BIT) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_IMAGE_CREATE_EXTENDED_USAGE_BIT";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & ImageCreateFlags::e_PROTECTED_BIT) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_IMAGE_CREATE_PROTECTED_BIT";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & ImageCreateFlags::e_DISJOINT_BIT) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_IMAGE_CREATE_DISJOINT_BIT";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & ImageCreateFlags::e_SPLIT_INSTANCE_BIND_REGIONS_BIT_KHR) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_IMAGE_CREATE_SPLIT_INSTANCE_BIND_REGIONS_BIT_KHR";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & ImageCreateFlags::e_2D_ARRAY_COMPATIBLE_BIT_KHR) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_IMAGE_CREATE_2D_ARRAY_COMPATIBLE_BIT_KHR";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & ImageCreateFlags::e_BLOCK_TEXEL_VIEW_COMPATIBLE_BIT_KHR) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_IMAGE_CREATE_BLOCK_TEXEL_VIEW_COMPATIBLE_BIT_KHR";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & ImageCreateFlags::e_EXTENDED_USAGE_BIT_KHR) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_IMAGE_CREATE_EXTENDED_USAGE_BIT_KHR";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & ImageCreateFlags::e_SAMPLE_LOCATIONS_COMPATIBLE_DEPTH_BIT_EXT) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_IMAGE_CREATE_SAMPLE_LOCATIONS_COMPATIBLE_DEPTH_BIT_EXT";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & ImageCreateFlags::e_DISJOINT_BIT_KHR) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_IMAGE_CREATE_DISJOINT_BIT_KHR";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & ImageCreateFlags::e_ALIAS_BIT_KHR) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_IMAGE_CREATE_ALIAS_BIT_KHR";
        addedFlags = true;
    }
    return returnString;
}

enum class SampleCountFlags
{
    e_NONE = 0,
    e_1_BIT = VK_SAMPLE_COUNT_1_BIT,
    e_2_BIT = VK_SAMPLE_COUNT_2_BIT,
    e_4_BIT = VK_SAMPLE_COUNT_4_BIT,
    e_8_BIT = VK_SAMPLE_COUNT_8_BIT,
    e_16_BIT = VK_SAMPLE_COUNT_16_BIT,
    e_32_BIT = VK_SAMPLE_COUNT_32_BIT,
    e_64_BIT = VK_SAMPLE_COUNT_64_BIT,
    e_MAX_ENUM = 0x7FFFFFFF,
    e_ALL_BITS = e_1_BIT | e_2_BIT | e_4_BIT | e_8_BIT | e_16_BIT | e_32_BIT | e_64_BIT
};
DEFINE_ENUM_BITWISE_OPERATORS(SampleCountFlags)
inline std::string to_string(SampleCountFlags value)
{
    std::string returnString = "";
    bool addedFlags = false;
    if(static_cast<uint32_t>(value & SampleCountFlags::e_1_BIT) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_SAMPLE_COUNT_1_BIT";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & SampleCountFlags::e_2_BIT) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_SAMPLE_COUNT_2_BIT";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & SampleCountFlags::e_4_BIT) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_SAMPLE_COUNT_4_BIT";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & SampleCountFlags::e_8_BIT) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_SAMPLE_COUNT_8_BIT";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & SampleCountFlags::e_16_BIT) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_SAMPLE_COUNT_16_BIT";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & SampleCountFlags::e_32_BIT) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_SAMPLE_COUNT_32_BIT";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & SampleCountFlags::e_64_BIT) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_SAMPLE_COUNT_64_BIT";
        addedFlags = true;
    }
    return returnString;
}

enum class PhysicalDeviceType
{
    e_NONE = 0,
    e_OTHER = VK_PHYSICAL_DEVICE_TYPE_OTHER,
    e_INTEGRATED_GPU = VK_PHYSICAL_DEVICE_TYPE_INTEGRATED_GPU,
    e_DISCRETE_GPU = VK_PHYSICAL_DEVICE_TYPE_DISCRETE_GPU,
    e_VIRTUAL_GPU = VK_PHYSICAL_DEVICE_TYPE_VIRTUAL_GPU,
    e_CPU = VK_PHYSICAL_DEVICE_TYPE_CPU,
    e_BEGIN_RANGE = VK_PHYSICAL_DEVICE_TYPE_BEGIN_RANGE,
    e_END_RANGE = VK_PHYSICAL_DEVICE_TYPE_END_RANGE,
    e_RANGE_SIZE = VK_PHYSICAL_DEVICE_TYPE_RANGE_SIZE,
    e_MAX_ENUM = 0x7FFFFFFF

};
DEFINE_ENUM_BITWISE_OPERATORS(PhysicalDeviceType)
inline std::string to_string(PhysicalDeviceType value)
{
    switch(value)
    {
    case PhysicalDeviceType::e_OTHER: return "VK_PHYSICAL_DEVICE_TYPE_OTHER";
    case PhysicalDeviceType::e_INTEGRATED_GPU: return "VK_PHYSICAL_DEVICE_TYPE_INTEGRATED_GPU";
    case PhysicalDeviceType::e_DISCRETE_GPU: return "VK_PHYSICAL_DEVICE_TYPE_DISCRETE_GPU";
    case PhysicalDeviceType::e_VIRTUAL_GPU: return "VK_PHYSICAL_DEVICE_TYPE_VIRTUAL_GPU";
    case PhysicalDeviceType::e_CPU: return "VK_PHYSICAL_DEVICE_TYPE_CPU";
    default: return "invalid";
    }
}

enum class QueueFlags
{
    e_NONE = 0,
    e_GRAPHICS_BIT = VK_QUEUE_GRAPHICS_BIT,
    e_COMPUTE_BIT = VK_QUEUE_COMPUTE_BIT,
    e_TRANSFER_BIT = VK_QUEUE_TRANSFER_BIT,
    e_SPARSE_BINDING_BIT = VK_QUEUE_SPARSE_BINDING_BIT,
    e_PROTECTED_BIT = VK_QUEUE_PROTECTED_BIT,
    e_MAX_ENUM = 0x7FFFFFFF,
    e_ALL_BITS = e_GRAPHICS_BIT | e_COMPUTE_BIT | e_TRANSFER_BIT | e_SPARSE_BINDING_BIT | e_PROTECTED_BIT
};
DEFINE_ENUM_BITWISE_OPERATORS(QueueFlags)
inline std::string to_string(QueueFlags value)
{
    std::string returnString = "";
    bool addedFlags = false;
    if(static_cast<uint32_t>(value & QueueFlags::e_GRAPHICS_BIT) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_QUEUE_GRAPHICS_BIT";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & QueueFlags::e_COMPUTE_BIT) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_QUEUE_COMPUTE_BIT";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & QueueFlags::e_TRANSFER_BIT) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_QUEUE_TRANSFER_BIT";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & QueueFlags::e_SPARSE_BINDING_BIT) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_QUEUE_SPARSE_BINDING_BIT";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & QueueFlags::e_PROTECTED_BIT) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_QUEUE_PROTECTED_BIT";
        addedFlags = true;
    }
    return returnString;
}

enum class MemoryPropertyFlags
{
    e_NONE = 0,
    e_DEVICE_LOCAL_BIT = VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT,
    e_HOST_VISIBLE_BIT = VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT,
    e_HOST_COHERENT_BIT = VK_MEMORY_PROPERTY_HOST_COHERENT_BIT,
    e_HOST_CACHED_BIT = VK_MEMORY_PROPERTY_HOST_CACHED_BIT,
    e_LAZILY_ALLOCATED_BIT = VK_MEMORY_PROPERTY_LAZILY_ALLOCATED_BIT,
    e_PROTECTED_BIT = VK_MEMORY_PROPERTY_PROTECTED_BIT,
    e_MAX_ENUM = 0x7FFFFFFF,
    e_ALL_BITS = e_DEVICE_LOCAL_BIT | e_HOST_VISIBLE_BIT | e_HOST_COHERENT_BIT | e_HOST_CACHED_BIT | e_LAZILY_ALLOCATED_BIT | e_PROTECTED_BIT
};
DEFINE_ENUM_BITWISE_OPERATORS(MemoryPropertyFlags)
inline std::string to_string(MemoryPropertyFlags value)
{
    std::string returnString = "";
    bool addedFlags = false;
    if(static_cast<uint32_t>(value & MemoryPropertyFlags::e_DEVICE_LOCAL_BIT) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & MemoryPropertyFlags::e_HOST_VISIBLE_BIT) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & MemoryPropertyFlags::e_HOST_COHERENT_BIT) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_MEMORY_PROPERTY_HOST_COHERENT_BIT";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & MemoryPropertyFlags::e_HOST_CACHED_BIT) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_MEMORY_PROPERTY_HOST_CACHED_BIT";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & MemoryPropertyFlags::e_LAZILY_ALLOCATED_BIT) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_MEMORY_PROPERTY_LAZILY_ALLOCATED_BIT";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & MemoryPropertyFlags::e_PROTECTED_BIT) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_MEMORY_PROPERTY_PROTECTED_BIT";
        addedFlags = true;
    }
    return returnString;
}

enum class MemoryHeapFlags
{
    e_NONE = 0,
    e_DEVICE_LOCAL_BIT = VK_MEMORY_HEAP_DEVICE_LOCAL_BIT,
    e_MULTI_INSTANCE_BIT = VK_MEMORY_HEAP_MULTI_INSTANCE_BIT,
    e_MULTI_INSTANCE_BIT_KHR = VK_MEMORY_HEAP_MULTI_INSTANCE_BIT_KHR,
    e_MAX_ENUM = 0x7FFFFFFF,
    e_ALL_BITS = e_DEVICE_LOCAL_BIT | e_MULTI_INSTANCE_BIT | e_MULTI_INSTANCE_BIT_KHR
};
DEFINE_ENUM_BITWISE_OPERATORS(MemoryHeapFlags)
inline std::string to_string(MemoryHeapFlags value)
{
    std::string returnString = "";
    bool addedFlags = false;
    if(static_cast<uint32_t>(value & MemoryHeapFlags::e_DEVICE_LOCAL_BIT) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_MEMORY_HEAP_DEVICE_LOCAL_BIT";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & MemoryHeapFlags::e_MULTI_INSTANCE_BIT) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_MEMORY_HEAP_MULTI_INSTANCE_BIT";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & MemoryHeapFlags::e_MULTI_INSTANCE_BIT_KHR) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_MEMORY_HEAP_MULTI_INSTANCE_BIT_KHR";
        addedFlags = true;
    }
    return returnString;
}

enum class DeviceQueueCreateFlags
{
    e_NONE = 0,
    e_PROTECTED_BIT = VK_DEVICE_QUEUE_CREATE_PROTECTED_BIT,
    e_MAX_ENUM = 0x7FFFFFFF,
    e_ALL_BITS = e_PROTECTED_BIT
};
DEFINE_ENUM_BITWISE_OPERATORS(DeviceQueueCreateFlags)
inline std::string to_string(DeviceQueueCreateFlags value)
{
    std::string returnString = "";
    bool addedFlags = false;
    if(static_cast<uint32_t>(value & DeviceQueueCreateFlags::e_PROTECTED_BIT) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_DEVICE_QUEUE_CREATE_PROTECTED_BIT";
        addedFlags = true;
    }
    return returnString;
}

enum class PipelineStageFlags
{
    e_NONE = 0,
    e_TOP_OF_PIPE_BIT = VK_PIPELINE_STAGE_TOP_OF_PIPE_BIT,
    e_DRAW_INDIRECT_BIT = VK_PIPELINE_STAGE_DRAW_INDIRECT_BIT,
    e_VERTEX_INPUT_BIT = VK_PIPELINE_STAGE_VERTEX_INPUT_BIT,
    e_VERTEX_SHADER_BIT = VK_PIPELINE_STAGE_VERTEX_SHADER_BIT,
    e_TESSELLATION_CONTROL_SHADER_BIT = VK_PIPELINE_STAGE_TESSELLATION_CONTROL_SHADER_BIT,
    e_TESSELLATION_EVALUATION_SHADER_BIT = VK_PIPELINE_STAGE_TESSELLATION_EVALUATION_SHADER_BIT,
    e_GEOMETRY_SHADER_BIT = VK_PIPELINE_STAGE_GEOMETRY_SHADER_BIT,
    e_FRAGMENT_SHADER_BIT = VK_PIPELINE_STAGE_FRAGMENT_SHADER_BIT,
    e_EARLY_FRAGMENT_TESTS_BIT = VK_PIPELINE_STAGE_EARLY_FRAGMENT_TESTS_BIT,
    e_LATE_FRAGMENT_TESTS_BIT = VK_PIPELINE_STAGE_LATE_FRAGMENT_TESTS_BIT,
    e_COLOR_ATTACHMENT_OUTPUT_BIT = VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT,
    e_COMPUTE_SHADER_BIT = VK_PIPELINE_STAGE_COMPUTE_SHADER_BIT,
    e_TRANSFER_BIT = VK_PIPELINE_STAGE_TRANSFER_BIT,
    e_BOTTOM_OF_PIPE_BIT = VK_PIPELINE_STAGE_BOTTOM_OF_PIPE_BIT,
    e_HOST_BIT = VK_PIPELINE_STAGE_HOST_BIT,
    e_ALL_GRAPHICS_BIT = VK_PIPELINE_STAGE_ALL_GRAPHICS_BIT,
    e_ALL_COMMANDS_BIT = VK_PIPELINE_STAGE_ALL_COMMANDS_BIT,
    e_COMMAND_PROCESS_BIT_NVX = VK_PIPELINE_STAGE_COMMAND_PROCESS_BIT_NVX,
    e_MAX_ENUM = 0x7FFFFFFF,
    e_ALL_BITS = e_TOP_OF_PIPE_BIT | e_DRAW_INDIRECT_BIT | e_VERTEX_INPUT_BIT | e_VERTEX_SHADER_BIT | e_TESSELLATION_CONTROL_SHADER_BIT | e_TESSELLATION_EVALUATION_SHADER_BIT | e_GEOMETRY_SHADER_BIT | e_FRAGMENT_SHADER_BIT | e_EARLY_FRAGMENT_TESTS_BIT | e_LATE_FRAGMENT_TESTS_BIT | e_COLOR_ATTACHMENT_OUTPUT_BIT | e_COMPUTE_SHADER_BIT | e_TRANSFER_BIT | e_BOTTOM_OF_PIPE_BIT | e_HOST_BIT | e_ALL_GRAPHICS_BIT | e_ALL_COMMANDS_BIT | e_COMMAND_PROCESS_BIT_NVX
};
DEFINE_ENUM_BITWISE_OPERATORS(PipelineStageFlags)
inline std::string to_string(PipelineStageFlags value)
{
    std::string returnString = "";
    bool addedFlags = false;
    if(static_cast<uint32_t>(value & PipelineStageFlags::e_TOP_OF_PIPE_BIT) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_PIPELINE_STAGE_TOP_OF_PIPE_BIT";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & PipelineStageFlags::e_DRAW_INDIRECT_BIT) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_PIPELINE_STAGE_DRAW_INDIRECT_BIT";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & PipelineStageFlags::e_VERTEX_INPUT_BIT) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_PIPELINE_STAGE_VERTEX_INPUT_BIT";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & PipelineStageFlags::e_VERTEX_SHADER_BIT) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_PIPELINE_STAGE_VERTEX_SHADER_BIT";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & PipelineStageFlags::e_TESSELLATION_CONTROL_SHADER_BIT) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_PIPELINE_STAGE_TESSELLATION_CONTROL_SHADER_BIT";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & PipelineStageFlags::e_TESSELLATION_EVALUATION_SHADER_BIT) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_PIPELINE_STAGE_TESSELLATION_EVALUATION_SHADER_BIT";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & PipelineStageFlags::e_GEOMETRY_SHADER_BIT) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_PIPELINE_STAGE_GEOMETRY_SHADER_BIT";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & PipelineStageFlags::e_FRAGMENT_SHADER_BIT) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_PIPELINE_STAGE_FRAGMENT_SHADER_BIT";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & PipelineStageFlags::e_EARLY_FRAGMENT_TESTS_BIT) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_PIPELINE_STAGE_EARLY_FRAGMENT_TESTS_BIT";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & PipelineStageFlags::e_LATE_FRAGMENT_TESTS_BIT) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_PIPELINE_STAGE_LATE_FRAGMENT_TESTS_BIT";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & PipelineStageFlags::e_COLOR_ATTACHMENT_OUTPUT_BIT) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & PipelineStageFlags::e_COMPUTE_SHADER_BIT) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_PIPELINE_STAGE_COMPUTE_SHADER_BIT";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & PipelineStageFlags::e_TRANSFER_BIT) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_PIPELINE_STAGE_TRANSFER_BIT";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & PipelineStageFlags::e_BOTTOM_OF_PIPE_BIT) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_PIPELINE_STAGE_BOTTOM_OF_PIPE_BIT";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & PipelineStageFlags::e_HOST_BIT) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_PIPELINE_STAGE_HOST_BIT";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & PipelineStageFlags::e_ALL_GRAPHICS_BIT) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_PIPELINE_STAGE_ALL_GRAPHICS_BIT";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & PipelineStageFlags::e_ALL_COMMANDS_BIT) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_PIPELINE_STAGE_ALL_COMMANDS_BIT";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & PipelineStageFlags::e_COMMAND_PROCESS_BIT_NVX) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_PIPELINE_STAGE_COMMAND_PROCESS_BIT_NVX";
        addedFlags = true;
    }
    return returnString;
}

enum class ImageAspectFlags
{
    e_NONE = 0,
    e_COLOR_BIT = VK_IMAGE_ASPECT_COLOR_BIT,
    e_DEPTH_BIT = VK_IMAGE_ASPECT_DEPTH_BIT,
    e_STENCIL_BIT = VK_IMAGE_ASPECT_STENCIL_BIT,
    e_METADATA_BIT = VK_IMAGE_ASPECT_METADATA_BIT,
    e_PLANE_0_BIT = VK_IMAGE_ASPECT_PLANE_0_BIT,
    e_PLANE_1_BIT = VK_IMAGE_ASPECT_PLANE_1_BIT,
    e_PLANE_2_BIT = VK_IMAGE_ASPECT_PLANE_2_BIT,
    e_PLANE_0_BIT_KHR = VK_IMAGE_ASPECT_PLANE_0_BIT_KHR,
    e_PLANE_1_BIT_KHR = VK_IMAGE_ASPECT_PLANE_1_BIT_KHR,
    e_PLANE_2_BIT_KHR = VK_IMAGE_ASPECT_PLANE_2_BIT_KHR,
    e_MAX_ENUM = 0x7FFFFFFF,
    e_ALL_BITS = e_COLOR_BIT | e_DEPTH_BIT | e_STENCIL_BIT | e_METADATA_BIT | e_PLANE_0_BIT | e_PLANE_1_BIT | e_PLANE_2_BIT | e_PLANE_0_BIT_KHR | e_PLANE_1_BIT_KHR | e_PLANE_2_BIT_KHR
};
DEFINE_ENUM_BITWISE_OPERATORS(ImageAspectFlags)
inline std::string to_string(ImageAspectFlags value)
{
    std::string returnString = "";
    bool addedFlags = false;
    if(static_cast<uint32_t>(value & ImageAspectFlags::e_COLOR_BIT) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_IMAGE_ASPECT_COLOR_BIT";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & ImageAspectFlags::e_DEPTH_BIT) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_IMAGE_ASPECT_DEPTH_BIT";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & ImageAspectFlags::e_STENCIL_BIT) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_IMAGE_ASPECT_STENCIL_BIT";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & ImageAspectFlags::e_METADATA_BIT) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_IMAGE_ASPECT_METADATA_BIT";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & ImageAspectFlags::e_PLANE_0_BIT) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_IMAGE_ASPECT_PLANE_0_BIT";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & ImageAspectFlags::e_PLANE_1_BIT) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_IMAGE_ASPECT_PLANE_1_BIT";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & ImageAspectFlags::e_PLANE_2_BIT) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_IMAGE_ASPECT_PLANE_2_BIT";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & ImageAspectFlags::e_PLANE_0_BIT_KHR) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_IMAGE_ASPECT_PLANE_0_BIT_KHR";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & ImageAspectFlags::e_PLANE_1_BIT_KHR) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_IMAGE_ASPECT_PLANE_1_BIT_KHR";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & ImageAspectFlags::e_PLANE_2_BIT_KHR) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_IMAGE_ASPECT_PLANE_2_BIT_KHR";
        addedFlags = true;
    }
    return returnString;
}

enum class SparseImageFormatFlags
{
    e_NONE = 0,
    e_SINGLE_MIPTAIL_BIT = VK_SPARSE_IMAGE_FORMAT_SINGLE_MIPTAIL_BIT,
    e_ALIGNED_MIP_SIZE_BIT = VK_SPARSE_IMAGE_FORMAT_ALIGNED_MIP_SIZE_BIT,
    e_NONSTANDARD_BLOCK_SIZE_BIT = VK_SPARSE_IMAGE_FORMAT_NONSTANDARD_BLOCK_SIZE_BIT,
    e_MAX_ENUM = 0x7FFFFFFF,
    e_ALL_BITS = e_SINGLE_MIPTAIL_BIT | e_ALIGNED_MIP_SIZE_BIT | e_NONSTANDARD_BLOCK_SIZE_BIT
};
DEFINE_ENUM_BITWISE_OPERATORS(SparseImageFormatFlags)
inline std::string to_string(SparseImageFormatFlags value)
{
    std::string returnString = "";
    bool addedFlags = false;
    if(static_cast<uint32_t>(value & SparseImageFormatFlags::e_SINGLE_MIPTAIL_BIT) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_SPARSE_IMAGE_FORMAT_SINGLE_MIPTAIL_BIT";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & SparseImageFormatFlags::e_ALIGNED_MIP_SIZE_BIT) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_SPARSE_IMAGE_FORMAT_ALIGNED_MIP_SIZE_BIT";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & SparseImageFormatFlags::e_NONSTANDARD_BLOCK_SIZE_BIT) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_SPARSE_IMAGE_FORMAT_NONSTANDARD_BLOCK_SIZE_BIT";
        addedFlags = true;
    }
    return returnString;
}

enum class SparseMemoryBindFlags
{
    e_NONE = 0,
    e_METADATA_BIT = VK_SPARSE_MEMORY_BIND_METADATA_BIT,
    e_MAX_ENUM = 0x7FFFFFFF,
    e_ALL_BITS = e_METADATA_BIT
};
DEFINE_ENUM_BITWISE_OPERATORS(SparseMemoryBindFlags)
inline std::string to_string(SparseMemoryBindFlags value)
{
    std::string returnString = "";
    bool addedFlags = false;
    if(static_cast<uint32_t>(value & SparseMemoryBindFlags::e_METADATA_BIT) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_SPARSE_MEMORY_BIND_METADATA_BIT";
        addedFlags = true;
    }
    return returnString;
}

enum class FenceCreateFlags
{
    e_NONE = 0,
    e_SIGNALED_BIT = VK_FENCE_CREATE_SIGNALED_BIT,
    e_MAX_ENUM = 0x7FFFFFFF,
    e_ALL_BITS = e_SIGNALED_BIT
};
DEFINE_ENUM_BITWISE_OPERATORS(FenceCreateFlags)
inline std::string to_string(FenceCreateFlags value)
{
    std::string returnString = "";
    bool addedFlags = false;
    if(static_cast<uint32_t>(value & FenceCreateFlags::e_SIGNALED_BIT) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_FENCE_CREATE_SIGNALED_BIT";
        addedFlags = true;
    }
    return returnString;
}

enum class QueryType
{
    e_NONE = 0,
    e_OCCLUSION = VK_QUERY_TYPE_OCCLUSION,
    e_PIPELINE_STATISTICS = VK_QUERY_TYPE_PIPELINE_STATISTICS,
    e_TIMESTAMP = VK_QUERY_TYPE_TIMESTAMP,
    e_BEGIN_RANGE = VK_QUERY_TYPE_BEGIN_RANGE,
    e_END_RANGE = VK_QUERY_TYPE_END_RANGE,
    e_RANGE_SIZE = VK_QUERY_TYPE_RANGE_SIZE,
    e_MAX_ENUM = 0x7FFFFFFF

};
DEFINE_ENUM_BITWISE_OPERATORS(QueryType)
inline std::string to_string(QueryType value)
{
    switch(value)
    {
    case QueryType::e_OCCLUSION: return "VK_QUERY_TYPE_OCCLUSION";
    case QueryType::e_PIPELINE_STATISTICS: return "VK_QUERY_TYPE_PIPELINE_STATISTICS";
    case QueryType::e_TIMESTAMP: return "VK_QUERY_TYPE_TIMESTAMP";
    default: return "invalid";
    }
}

enum class QueryPipelineStatisticFlags
{
    e_NONE = 0,
    e_INPUT_ASSEMBLY_VERTICES_BIT = VK_QUERY_PIPELINE_STATISTIC_INPUT_ASSEMBLY_VERTICES_BIT,
    e_INPUT_ASSEMBLY_PRIMITIVES_BIT = VK_QUERY_PIPELINE_STATISTIC_INPUT_ASSEMBLY_PRIMITIVES_BIT,
    e_VERTEX_SHADER_INVOCATIONS_BIT = VK_QUERY_PIPELINE_STATISTIC_VERTEX_SHADER_INVOCATIONS_BIT,
    e_GEOMETRY_SHADER_INVOCATIONS_BIT = VK_QUERY_PIPELINE_STATISTIC_GEOMETRY_SHADER_INVOCATIONS_BIT,
    e_GEOMETRY_SHADER_PRIMITIVES_BIT = VK_QUERY_PIPELINE_STATISTIC_GEOMETRY_SHADER_PRIMITIVES_BIT,
    e_CLIPPING_INVOCATIONS_BIT = VK_QUERY_PIPELINE_STATISTIC_CLIPPING_INVOCATIONS_BIT,
    e_CLIPPING_PRIMITIVES_BIT = VK_QUERY_PIPELINE_STATISTIC_CLIPPING_PRIMITIVES_BIT,
    e_FRAGMENT_SHADER_INVOCATIONS_BIT = VK_QUERY_PIPELINE_STATISTIC_FRAGMENT_SHADER_INVOCATIONS_BIT,
    e_TESSELLATION_CONTROL_SHADER_PATCHES_BIT = VK_QUERY_PIPELINE_STATISTIC_TESSELLATION_CONTROL_SHADER_PATCHES_BIT,
    e_TESSELLATION_EVALUATION_SHADER_INVOCATIONS_BIT = VK_QUERY_PIPELINE_STATISTIC_TESSELLATION_EVALUATION_SHADER_INVOCATIONS_BIT,
    e_COMPUTE_SHADER_INVOCATIONS_BIT = VK_QUERY_PIPELINE_STATISTIC_COMPUTE_SHADER_INVOCATIONS_BIT,
    e_MAX_ENUM = 0x7FFFFFFF,
    e_ALL_BITS = e_INPUT_ASSEMBLY_VERTICES_BIT | e_INPUT_ASSEMBLY_PRIMITIVES_BIT | e_VERTEX_SHADER_INVOCATIONS_BIT | e_GEOMETRY_SHADER_INVOCATIONS_BIT | e_GEOMETRY_SHADER_PRIMITIVES_BIT | e_CLIPPING_INVOCATIONS_BIT | e_CLIPPING_PRIMITIVES_BIT | e_FRAGMENT_SHADER_INVOCATIONS_BIT | e_TESSELLATION_CONTROL_SHADER_PATCHES_BIT | e_TESSELLATION_EVALUATION_SHADER_INVOCATIONS_BIT | e_COMPUTE_SHADER_INVOCATIONS_BIT
};
DEFINE_ENUM_BITWISE_OPERATORS(QueryPipelineStatisticFlags)
inline std::string to_string(QueryPipelineStatisticFlags value)
{
    std::string returnString = "";
    bool addedFlags = false;
    if(static_cast<uint32_t>(value & QueryPipelineStatisticFlags::e_INPUT_ASSEMBLY_VERTICES_BIT) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_QUERY_PIPELINE_STATISTIC_INPUT_ASSEMBLY_VERTICES_BIT";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & QueryPipelineStatisticFlags::e_INPUT_ASSEMBLY_PRIMITIVES_BIT) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_QUERY_PIPELINE_STATISTIC_INPUT_ASSEMBLY_PRIMITIVES_BIT";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & QueryPipelineStatisticFlags::e_VERTEX_SHADER_INVOCATIONS_BIT) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_QUERY_PIPELINE_STATISTIC_VERTEX_SHADER_INVOCATIONS_BIT";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & QueryPipelineStatisticFlags::e_GEOMETRY_SHADER_INVOCATIONS_BIT) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_QUERY_PIPELINE_STATISTIC_GEOMETRY_SHADER_INVOCATIONS_BIT";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & QueryPipelineStatisticFlags::e_GEOMETRY_SHADER_PRIMITIVES_BIT) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_QUERY_PIPELINE_STATISTIC_GEOMETRY_SHADER_PRIMITIVES_BIT";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & QueryPipelineStatisticFlags::e_CLIPPING_INVOCATIONS_BIT) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_QUERY_PIPELINE_STATISTIC_CLIPPING_INVOCATIONS_BIT";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & QueryPipelineStatisticFlags::e_CLIPPING_PRIMITIVES_BIT) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_QUERY_PIPELINE_STATISTIC_CLIPPING_PRIMITIVES_BIT";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & QueryPipelineStatisticFlags::e_FRAGMENT_SHADER_INVOCATIONS_BIT) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_QUERY_PIPELINE_STATISTIC_FRAGMENT_SHADER_INVOCATIONS_BIT";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & QueryPipelineStatisticFlags::e_TESSELLATION_CONTROL_SHADER_PATCHES_BIT) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_QUERY_PIPELINE_STATISTIC_TESSELLATION_CONTROL_SHADER_PATCHES_BIT";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & QueryPipelineStatisticFlags::e_TESSELLATION_EVALUATION_SHADER_INVOCATIONS_BIT) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_QUERY_PIPELINE_STATISTIC_TESSELLATION_EVALUATION_SHADER_INVOCATIONS_BIT";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & QueryPipelineStatisticFlags::e_COMPUTE_SHADER_INVOCATIONS_BIT) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_QUERY_PIPELINE_STATISTIC_COMPUTE_SHADER_INVOCATIONS_BIT";
        addedFlags = true;
    }
    return returnString;
}

enum class QueryResultFlags
{
    e_NONE = 0,
    e_64_BIT = VK_QUERY_RESULT_64_BIT,
    e_WAIT_BIT = VK_QUERY_RESULT_WAIT_BIT,
    e_WITH_AVAILABILITY_BIT = VK_QUERY_RESULT_WITH_AVAILABILITY_BIT,
    e_PARTIAL_BIT = VK_QUERY_RESULT_PARTIAL_BIT,
    e_MAX_ENUM = 0x7FFFFFFF,
    e_ALL_BITS = e_64_BIT | e_WAIT_BIT | e_WITH_AVAILABILITY_BIT | e_PARTIAL_BIT
};
DEFINE_ENUM_BITWISE_OPERATORS(QueryResultFlags)
inline std::string to_string(QueryResultFlags value)
{
    std::string returnString = "";
    bool addedFlags = false;
    if(static_cast<uint32_t>(value & QueryResultFlags::e_64_BIT) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_QUERY_RESULT_64_BIT";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & QueryResultFlags::e_WAIT_BIT) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_QUERY_RESULT_WAIT_BIT";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & QueryResultFlags::e_WITH_AVAILABILITY_BIT) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_QUERY_RESULT_WITH_AVAILABILITY_BIT";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & QueryResultFlags::e_PARTIAL_BIT) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_QUERY_RESULT_PARTIAL_BIT";
        addedFlags = true;
    }
    return returnString;
}

enum class BufferCreateFlags
{
    e_NONE = 0,
    e_SPARSE_BINDING_BIT = VK_BUFFER_CREATE_SPARSE_BINDING_BIT,
    e_SPARSE_RESIDENCY_BIT = VK_BUFFER_CREATE_SPARSE_RESIDENCY_BIT,
    e_SPARSE_ALIASED_BIT = VK_BUFFER_CREATE_SPARSE_ALIASED_BIT,
    e_PROTECTED_BIT = VK_BUFFER_CREATE_PROTECTED_BIT,
    e_MAX_ENUM = 0x7FFFFFFF,
    e_ALL_BITS = e_SPARSE_BINDING_BIT | e_SPARSE_RESIDENCY_BIT | e_SPARSE_ALIASED_BIT | e_PROTECTED_BIT
};
DEFINE_ENUM_BITWISE_OPERATORS(BufferCreateFlags)
inline std::string to_string(BufferCreateFlags value)
{
    std::string returnString = "";
    bool addedFlags = false;
    if(static_cast<uint32_t>(value & BufferCreateFlags::e_SPARSE_BINDING_BIT) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_BUFFER_CREATE_SPARSE_BINDING_BIT";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & BufferCreateFlags::e_SPARSE_RESIDENCY_BIT) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_BUFFER_CREATE_SPARSE_RESIDENCY_BIT";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & BufferCreateFlags::e_SPARSE_ALIASED_BIT) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_BUFFER_CREATE_SPARSE_ALIASED_BIT";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & BufferCreateFlags::e_PROTECTED_BIT) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_BUFFER_CREATE_PROTECTED_BIT";
        addedFlags = true;
    }
    return returnString;
}

enum class BufferUsageFlags
{
    e_NONE = 0,
    e_TRANSFER_SRC_BIT = VK_BUFFER_USAGE_TRANSFER_SRC_BIT,
    e_TRANSFER_DST_BIT = VK_BUFFER_USAGE_TRANSFER_DST_BIT,
    e_UNIFORM_TEXEL_BUFFER_BIT = VK_BUFFER_USAGE_UNIFORM_TEXEL_BUFFER_BIT,
    e_STORAGE_TEXEL_BUFFER_BIT = VK_BUFFER_USAGE_STORAGE_TEXEL_BUFFER_BIT,
    e_UNIFORM_BUFFER_BIT = VK_BUFFER_USAGE_UNIFORM_BUFFER_BIT,
    e_STORAGE_BUFFER_BIT = VK_BUFFER_USAGE_STORAGE_BUFFER_BIT,
    e_INDEX_BUFFER_BIT = VK_BUFFER_USAGE_INDEX_BUFFER_BIT,
    e_VERTEX_BUFFER_BIT = VK_BUFFER_USAGE_VERTEX_BUFFER_BIT,
    e_INDIRECT_BUFFER_BIT = VK_BUFFER_USAGE_INDIRECT_BUFFER_BIT,
    e_MAX_ENUM = 0x7FFFFFFF,
    e_ALL_BITS = e_TRANSFER_SRC_BIT | e_TRANSFER_DST_BIT | e_UNIFORM_TEXEL_BUFFER_BIT | e_STORAGE_TEXEL_BUFFER_BIT | e_UNIFORM_BUFFER_BIT | e_STORAGE_BUFFER_BIT | e_INDEX_BUFFER_BIT | e_VERTEX_BUFFER_BIT | e_INDIRECT_BUFFER_BIT
};
DEFINE_ENUM_BITWISE_OPERATORS(BufferUsageFlags)
inline std::string to_string(BufferUsageFlags value)
{
    std::string returnString = "";
    bool addedFlags = false;
    if(static_cast<uint32_t>(value & BufferUsageFlags::e_TRANSFER_SRC_BIT) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_BUFFER_USAGE_TRANSFER_SRC_BIT";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & BufferUsageFlags::e_TRANSFER_DST_BIT) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_BUFFER_USAGE_TRANSFER_DST_BIT";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & BufferUsageFlags::e_UNIFORM_TEXEL_BUFFER_BIT) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_BUFFER_USAGE_UNIFORM_TEXEL_BUFFER_BIT";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & BufferUsageFlags::e_STORAGE_TEXEL_BUFFER_BIT) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_BUFFER_USAGE_STORAGE_TEXEL_BUFFER_BIT";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & BufferUsageFlags::e_UNIFORM_BUFFER_BIT) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_BUFFER_USAGE_UNIFORM_BUFFER_BIT";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & BufferUsageFlags::e_STORAGE_BUFFER_BIT) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_BUFFER_USAGE_STORAGE_BUFFER_BIT";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & BufferUsageFlags::e_INDEX_BUFFER_BIT) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_BUFFER_USAGE_INDEX_BUFFER_BIT";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & BufferUsageFlags::e_VERTEX_BUFFER_BIT) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_BUFFER_USAGE_VERTEX_BUFFER_BIT";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & BufferUsageFlags::e_INDIRECT_BUFFER_BIT) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_BUFFER_USAGE_INDIRECT_BUFFER_BIT";
        addedFlags = true;
    }
    return returnString;
}

enum class SharingMode
{
    e_NONE = 0,
    e_EXCLUSIVE = VK_SHARING_MODE_EXCLUSIVE,
    e_CONCURRENT = VK_SHARING_MODE_CONCURRENT,
    e_BEGIN_RANGE = VK_SHARING_MODE_BEGIN_RANGE,
    e_END_RANGE = VK_SHARING_MODE_END_RANGE,
    e_RANGE_SIZE = VK_SHARING_MODE_RANGE_SIZE,
    e_MAX_ENUM = 0x7FFFFFFF

};
DEFINE_ENUM_BITWISE_OPERATORS(SharingMode)
inline std::string to_string(SharingMode value)
{
    switch(value)
    {
    case SharingMode::e_EXCLUSIVE: return "VK_SHARING_MODE_EXCLUSIVE";
    case SharingMode::e_CONCURRENT: return "VK_SHARING_MODE_CONCURRENT";
    default: return "invalid";
    }
}

enum class ImageLayout
{
    e_NONE = 0,
    e_UNDEFINED = VK_IMAGE_LAYOUT_UNDEFINED,
    e_GENERAL = VK_IMAGE_LAYOUT_GENERAL,
    e_COLOR_ATTACHMENT_OPTIMAL = VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL,
    e_DEPTH_STENCIL_ATTACHMENT_OPTIMAL = VK_IMAGE_LAYOUT_DEPTH_STENCIL_ATTACHMENT_OPTIMAL,
    e_DEPTH_STENCIL_READ_ONLY_OPTIMAL = VK_IMAGE_LAYOUT_DEPTH_STENCIL_READ_ONLY_OPTIMAL,
    e_SHADER_READ_ONLY_OPTIMAL = VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL,
    e_TRANSFER_SRC_OPTIMAL = VK_IMAGE_LAYOUT_TRANSFER_SRC_OPTIMAL,
    e_TRANSFER_DST_OPTIMAL = VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL,
    e_PREINITIALIZED = VK_IMAGE_LAYOUT_PREINITIALIZED,
    e_DEPTH_READ_ONLY_STENCIL_ATTACHMENT_OPTIMAL = VK_IMAGE_LAYOUT_DEPTH_READ_ONLY_STENCIL_ATTACHMENT_OPTIMAL,
    e_DEPTH_ATTACHMENT_STENCIL_READ_ONLY_OPTIMAL = VK_IMAGE_LAYOUT_DEPTH_ATTACHMENT_STENCIL_READ_ONLY_OPTIMAL,
    e_PRESENT_SRC_KHR = VK_IMAGE_LAYOUT_PRESENT_SRC_KHR,
    e_SHARED_PRESENT_KHR = VK_IMAGE_LAYOUT_SHARED_PRESENT_KHR,
    e_DEPTH_READ_ONLY_STENCIL_ATTACHMENT_OPTIMAL_KHR = VK_IMAGE_LAYOUT_DEPTH_READ_ONLY_STENCIL_ATTACHMENT_OPTIMAL_KHR,
    e_DEPTH_ATTACHMENT_STENCIL_READ_ONLY_OPTIMAL_KHR = VK_IMAGE_LAYOUT_DEPTH_ATTACHMENT_STENCIL_READ_ONLY_OPTIMAL_KHR,
    e_BEGIN_RANGE = VK_IMAGE_LAYOUT_BEGIN_RANGE,
    e_END_RANGE = VK_IMAGE_LAYOUT_END_RANGE,
    e_RANGE_SIZE = VK_IMAGE_LAYOUT_RANGE_SIZE,
    e_MAX_ENUM = 0x7FFFFFFF

};
DEFINE_ENUM_BITWISE_OPERATORS(ImageLayout)
inline std::string to_string(ImageLayout value)
{
    switch(value)
    {
    case ImageLayout::e_UNDEFINED: return "VK_IMAGE_LAYOUT_UNDEFINED";
    case ImageLayout::e_GENERAL: return "VK_IMAGE_LAYOUT_GENERAL";
    case ImageLayout::e_COLOR_ATTACHMENT_OPTIMAL: return "VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL";
    case ImageLayout::e_DEPTH_STENCIL_ATTACHMENT_OPTIMAL: return "VK_IMAGE_LAYOUT_DEPTH_STENCIL_ATTACHMENT_OPTIMAL";
    case ImageLayout::e_DEPTH_STENCIL_READ_ONLY_OPTIMAL: return "VK_IMAGE_LAYOUT_DEPTH_STENCIL_READ_ONLY_OPTIMAL";
    case ImageLayout::e_SHADER_READ_ONLY_OPTIMAL: return "VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL";
    case ImageLayout::e_TRANSFER_SRC_OPTIMAL: return "VK_IMAGE_LAYOUT_TRANSFER_SRC_OPTIMAL";
    case ImageLayout::e_TRANSFER_DST_OPTIMAL: return "VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL";
    case ImageLayout::e_PREINITIALIZED: return "VK_IMAGE_LAYOUT_PREINITIALIZED";
    case ImageLayout::e_DEPTH_READ_ONLY_STENCIL_ATTACHMENT_OPTIMAL: return "VK_IMAGE_LAYOUT_DEPTH_READ_ONLY_STENCIL_ATTACHMENT_OPTIMAL";
    case ImageLayout::e_DEPTH_ATTACHMENT_STENCIL_READ_ONLY_OPTIMAL: return "VK_IMAGE_LAYOUT_DEPTH_ATTACHMENT_STENCIL_READ_ONLY_OPTIMAL";
    case ImageLayout::e_PRESENT_SRC_KHR: return "VK_IMAGE_LAYOUT_PRESENT_SRC_KHR";
    case ImageLayout::e_SHARED_PRESENT_KHR: return "VK_IMAGE_LAYOUT_SHARED_PRESENT_KHR";
    default: return "invalid";
    }
}

enum class ImageViewType
{
    e_NONE = 0,
    e_1D = VK_IMAGE_VIEW_TYPE_1D,
    e_2D = VK_IMAGE_VIEW_TYPE_2D,
    e_3D = VK_IMAGE_VIEW_TYPE_3D,
    e_CUBE = VK_IMAGE_VIEW_TYPE_CUBE,
    e_1D_ARRAY = VK_IMAGE_VIEW_TYPE_1D_ARRAY,
    e_2D_ARRAY = VK_IMAGE_VIEW_TYPE_2D_ARRAY,
    e_CUBE_ARRAY = VK_IMAGE_VIEW_TYPE_CUBE_ARRAY,
    e_BEGIN_RANGE = VK_IMAGE_VIEW_TYPE_BEGIN_RANGE,
    e_END_RANGE = VK_IMAGE_VIEW_TYPE_END_RANGE,
    e_RANGE_SIZE = VK_IMAGE_VIEW_TYPE_RANGE_SIZE,
    e_MAX_ENUM = 0x7FFFFFFF

};
DEFINE_ENUM_BITWISE_OPERATORS(ImageViewType)
inline std::string to_string(ImageViewType value)
{
    switch(value)
    {
    case ImageViewType::e_1D: return "VK_IMAGE_VIEW_TYPE_1D";
    case ImageViewType::e_2D: return "VK_IMAGE_VIEW_TYPE_2D";
    case ImageViewType::e_3D: return "VK_IMAGE_VIEW_TYPE_3D";
    case ImageViewType::e_CUBE: return "VK_IMAGE_VIEW_TYPE_CUBE";
    case ImageViewType::e_1D_ARRAY: return "VK_IMAGE_VIEW_TYPE_1D_ARRAY";
    case ImageViewType::e_2D_ARRAY: return "VK_IMAGE_VIEW_TYPE_2D_ARRAY";
    case ImageViewType::e_CUBE_ARRAY: return "VK_IMAGE_VIEW_TYPE_CUBE_ARRAY";
    default: return "invalid";
    }
}

enum class ComponentSwizzle
{
    e_NONE = 0,
    e_IDENTITY = VK_COMPONENT_SWIZZLE_IDENTITY,
    e_ZERO = VK_COMPONENT_SWIZZLE_ZERO,
    e_ONE = VK_COMPONENT_SWIZZLE_ONE,
    e_R = VK_COMPONENT_SWIZZLE_R,
    e_G = VK_COMPONENT_SWIZZLE_G,
    e_B = VK_COMPONENT_SWIZZLE_B,
    e_A = VK_COMPONENT_SWIZZLE_A,
    e_BEGIN_RANGE = VK_COMPONENT_SWIZZLE_BEGIN_RANGE,
    e_END_RANGE = VK_COMPONENT_SWIZZLE_END_RANGE,
    e_RANGE_SIZE = VK_COMPONENT_SWIZZLE_RANGE_SIZE,
    e_MAX_ENUM = 0x7FFFFFFF

};
DEFINE_ENUM_BITWISE_OPERATORS(ComponentSwizzle)
inline std::string to_string(ComponentSwizzle value)
{
    switch(value)
    {
    case ComponentSwizzle::e_IDENTITY: return "VK_COMPONENT_SWIZZLE_IDENTITY";
    case ComponentSwizzle::e_ZERO: return "VK_COMPONENT_SWIZZLE_ZERO";
    case ComponentSwizzle::e_ONE: return "VK_COMPONENT_SWIZZLE_ONE";
    case ComponentSwizzle::e_R: return "VK_COMPONENT_SWIZZLE_R";
    case ComponentSwizzle::e_G: return "VK_COMPONENT_SWIZZLE_G";
    case ComponentSwizzle::e_B: return "VK_COMPONENT_SWIZZLE_B";
    case ComponentSwizzle::e_A: return "VK_COMPONENT_SWIZZLE_A";
    default: return "invalid";
    }
}

enum class PipelineCreateFlags
{
    e_NONE = 0,
    e_DISABLE_OPTIMIZATION_BIT = VK_PIPELINE_CREATE_DISABLE_OPTIMIZATION_BIT,
    e_ALLOW_DERIVATIVES_BIT = VK_PIPELINE_CREATE_ALLOW_DERIVATIVES_BIT,
    e_DERIVATIVE_BIT = VK_PIPELINE_CREATE_DERIVATIVE_BIT,
    e_VIEW_INDEX_FROM_DEVICE_INDEX_BIT = VK_PIPELINE_CREATE_VIEW_INDEX_FROM_DEVICE_INDEX_BIT,
    e_DISPATCH_BASE = VK_PIPELINE_CREATE_DISPATCH_BASE,
    e_VIEW_INDEX_FROM_DEVICE_INDEX_BIT_KHR = VK_PIPELINE_CREATE_VIEW_INDEX_FROM_DEVICE_INDEX_BIT_KHR,
    e_DISPATCH_BASE_KHR = VK_PIPELINE_CREATE_DISPATCH_BASE_KHR,
    e_MAX_ENUM = 0x7FFFFFFF,
    e_ALL_BITS = e_DISABLE_OPTIMIZATION_BIT | e_ALLOW_DERIVATIVES_BIT | e_DERIVATIVE_BIT | e_VIEW_INDEX_FROM_DEVICE_INDEX_BIT | e_DISPATCH_BASE | e_VIEW_INDEX_FROM_DEVICE_INDEX_BIT_KHR | e_DISPATCH_BASE_KHR
};
DEFINE_ENUM_BITWISE_OPERATORS(PipelineCreateFlags)
inline std::string to_string(PipelineCreateFlags value)
{
    std::string returnString = "";
    bool addedFlags = false;
    if(static_cast<uint32_t>(value & PipelineCreateFlags::e_DISABLE_OPTIMIZATION_BIT) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_PIPELINE_CREATE_DISABLE_OPTIMIZATION_BIT";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & PipelineCreateFlags::e_ALLOW_DERIVATIVES_BIT) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_PIPELINE_CREATE_ALLOW_DERIVATIVES_BIT";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & PipelineCreateFlags::e_DERIVATIVE_BIT) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_PIPELINE_CREATE_DERIVATIVE_BIT";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & PipelineCreateFlags::e_VIEW_INDEX_FROM_DEVICE_INDEX_BIT) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_PIPELINE_CREATE_VIEW_INDEX_FROM_DEVICE_INDEX_BIT";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & PipelineCreateFlags::e_DISPATCH_BASE) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_PIPELINE_CREATE_DISPATCH_BASE";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & PipelineCreateFlags::e_VIEW_INDEX_FROM_DEVICE_INDEX_BIT_KHR) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_PIPELINE_CREATE_VIEW_INDEX_FROM_DEVICE_INDEX_BIT_KHR";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & PipelineCreateFlags::e_DISPATCH_BASE_KHR) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_PIPELINE_CREATE_DISPATCH_BASE_KHR";
        addedFlags = true;
    }
    return returnString;
}

enum class ShaderStageFlags
{
    e_NONE = 0,
    e_VERTEX_BIT = VK_SHADER_STAGE_VERTEX_BIT,
    e_TESSELLATION_CONTROL_BIT = VK_SHADER_STAGE_TESSELLATION_CONTROL_BIT,
    e_TESSELLATION_EVALUATION_BIT = VK_SHADER_STAGE_TESSELLATION_EVALUATION_BIT,
    e_GEOMETRY_BIT = VK_SHADER_STAGE_GEOMETRY_BIT,
    e_FRAGMENT_BIT = VK_SHADER_STAGE_FRAGMENT_BIT,
    e_COMPUTE_BIT = VK_SHADER_STAGE_COMPUTE_BIT,
    e_ALL_GRAPHICS = VK_SHADER_STAGE_ALL_GRAPHICS,
    e_ALL = VK_SHADER_STAGE_ALL,
    e_MAX_ENUM = 0x7FFFFFFF,
    e_ALL_BITS = e_VERTEX_BIT | e_TESSELLATION_CONTROL_BIT | e_TESSELLATION_EVALUATION_BIT | e_GEOMETRY_BIT | e_FRAGMENT_BIT | e_COMPUTE_BIT | e_ALL_GRAPHICS | e_ALL
};
DEFINE_ENUM_BITWISE_OPERATORS(ShaderStageFlags)
inline std::string to_string(ShaderStageFlags value)
{
    std::string returnString = "";
    bool addedFlags = false;
    if(static_cast<uint32_t>(value & ShaderStageFlags::e_VERTEX_BIT) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_SHADER_STAGE_VERTEX_BIT";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & ShaderStageFlags::e_TESSELLATION_CONTROL_BIT) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_SHADER_STAGE_TESSELLATION_CONTROL_BIT";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & ShaderStageFlags::e_TESSELLATION_EVALUATION_BIT) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_SHADER_STAGE_TESSELLATION_EVALUATION_BIT";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & ShaderStageFlags::e_GEOMETRY_BIT) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_SHADER_STAGE_GEOMETRY_BIT";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & ShaderStageFlags::e_FRAGMENT_BIT) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_SHADER_STAGE_FRAGMENT_BIT";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & ShaderStageFlags::e_COMPUTE_BIT) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_SHADER_STAGE_COMPUTE_BIT";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & ShaderStageFlags::e_ALL_GRAPHICS) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_SHADER_STAGE_ALL_GRAPHICS";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & ShaderStageFlags::e_ALL) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_SHADER_STAGE_ALL";
        addedFlags = true;
    }
    return returnString;
}

enum class VertexInputRate
{
    e_NONE = 0,
    e_VERTEX = VK_VERTEX_INPUT_RATE_VERTEX,
    e_INSTANCE = VK_VERTEX_INPUT_RATE_INSTANCE,
    e_BEGIN_RANGE = VK_VERTEX_INPUT_RATE_BEGIN_RANGE,
    e_END_RANGE = VK_VERTEX_INPUT_RATE_END_RANGE,
    e_RANGE_SIZE = VK_VERTEX_INPUT_RATE_RANGE_SIZE,
    e_MAX_ENUM = 0x7FFFFFFF

};
DEFINE_ENUM_BITWISE_OPERATORS(VertexInputRate)
inline std::string to_string(VertexInputRate value)
{
    switch(value)
    {
    case VertexInputRate::e_VERTEX: return "VK_VERTEX_INPUT_RATE_VERTEX";
    case VertexInputRate::e_INSTANCE: return "VK_VERTEX_INPUT_RATE_INSTANCE";
    default: return "invalid";
    }
}

enum class PrimitiveTopology
{
    e_NONE = 0,
    e_POINT_LIST = VK_PRIMITIVE_TOPOLOGY_POINT_LIST,
    e_LINE_LIST = VK_PRIMITIVE_TOPOLOGY_LINE_LIST,
    e_LINE_STRIP = VK_PRIMITIVE_TOPOLOGY_LINE_STRIP,
    e_TRIANGLE_LIST = VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST,
    e_TRIANGLE_STRIP = VK_PRIMITIVE_TOPOLOGY_TRIANGLE_STRIP,
    e_TRIANGLE_FAN = VK_PRIMITIVE_TOPOLOGY_TRIANGLE_FAN,
    e_LINE_LIST_WITH_ADJACENCY = VK_PRIMITIVE_TOPOLOGY_LINE_LIST_WITH_ADJACENCY,
    e_LINE_STRIP_WITH_ADJACENCY = VK_PRIMITIVE_TOPOLOGY_LINE_STRIP_WITH_ADJACENCY,
    e_TRIANGLE_LIST_WITH_ADJACENCY = VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST_WITH_ADJACENCY,
    e_TRIANGLE_STRIP_WITH_ADJACENCY = VK_PRIMITIVE_TOPOLOGY_TRIANGLE_STRIP_WITH_ADJACENCY,
    e_PATCH_LIST = VK_PRIMITIVE_TOPOLOGY_PATCH_LIST,
    e_BEGIN_RANGE = VK_PRIMITIVE_TOPOLOGY_BEGIN_RANGE,
    e_END_RANGE = VK_PRIMITIVE_TOPOLOGY_END_RANGE,
    e_RANGE_SIZE = VK_PRIMITIVE_TOPOLOGY_RANGE_SIZE,
    e_MAX_ENUM = 0x7FFFFFFF

};
DEFINE_ENUM_BITWISE_OPERATORS(PrimitiveTopology)
inline std::string to_string(PrimitiveTopology value)
{
    switch(value)
    {
    case PrimitiveTopology::e_POINT_LIST: return "VK_PRIMITIVE_TOPOLOGY_POINT_LIST";
    case PrimitiveTopology::e_LINE_LIST: return "VK_PRIMITIVE_TOPOLOGY_LINE_LIST";
    case PrimitiveTopology::e_LINE_STRIP: return "VK_PRIMITIVE_TOPOLOGY_LINE_STRIP";
    case PrimitiveTopology::e_TRIANGLE_LIST: return "VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST";
    case PrimitiveTopology::e_TRIANGLE_STRIP: return "VK_PRIMITIVE_TOPOLOGY_TRIANGLE_STRIP";
    case PrimitiveTopology::e_TRIANGLE_FAN: return "VK_PRIMITIVE_TOPOLOGY_TRIANGLE_FAN";
    case PrimitiveTopology::e_LINE_LIST_WITH_ADJACENCY: return "VK_PRIMITIVE_TOPOLOGY_LINE_LIST_WITH_ADJACENCY";
    case PrimitiveTopology::e_LINE_STRIP_WITH_ADJACENCY: return "VK_PRIMITIVE_TOPOLOGY_LINE_STRIP_WITH_ADJACENCY";
    case PrimitiveTopology::e_TRIANGLE_LIST_WITH_ADJACENCY: return "VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST_WITH_ADJACENCY";
    case PrimitiveTopology::e_TRIANGLE_STRIP_WITH_ADJACENCY: return "VK_PRIMITIVE_TOPOLOGY_TRIANGLE_STRIP_WITH_ADJACENCY";
    case PrimitiveTopology::e_PATCH_LIST: return "VK_PRIMITIVE_TOPOLOGY_PATCH_LIST";
    default: return "invalid";
    }
}

enum class PolygonMode
{
    e_NONE = 0,
    e_FILL = VK_POLYGON_MODE_FILL,
    e_LINE = VK_POLYGON_MODE_LINE,
    e_POINT = VK_POLYGON_MODE_POINT,
    e_FILL_RECTANGLE_NV = VK_POLYGON_MODE_FILL_RECTANGLE_NV,
    e_BEGIN_RANGE = VK_POLYGON_MODE_BEGIN_RANGE,
    e_END_RANGE = VK_POLYGON_MODE_END_RANGE,
    e_RANGE_SIZE = VK_POLYGON_MODE_RANGE_SIZE,
    e_MAX_ENUM = 0x7FFFFFFF

};
DEFINE_ENUM_BITWISE_OPERATORS(PolygonMode)
inline std::string to_string(PolygonMode value)
{
    switch(value)
    {
    case PolygonMode::e_FILL: return "VK_POLYGON_MODE_FILL";
    case PolygonMode::e_LINE: return "VK_POLYGON_MODE_LINE";
    case PolygonMode::e_POINT: return "VK_POLYGON_MODE_POINT";
    case PolygonMode::e_FILL_RECTANGLE_NV: return "VK_POLYGON_MODE_FILL_RECTANGLE_NV";
    default: return "invalid";
    }
}

enum class CullModeFlags
{
    e_NONE = VK_CULL_MODE_NONE,
    e_FRONT_BIT = VK_CULL_MODE_FRONT_BIT,
    e_BACK_BIT = VK_CULL_MODE_BACK_BIT,
    e_FRONT_AND_BACK = VK_CULL_MODE_FRONT_AND_BACK,
    e_MAX_ENUM = 0x7FFFFFFF,
    e_ALL_BITS = e_NONE | e_FRONT_BIT | e_BACK_BIT | e_FRONT_AND_BACK
};
DEFINE_ENUM_BITWISE_OPERATORS(CullModeFlags)
inline std::string to_string(CullModeFlags value)
{
    std::string returnString = "";
    bool addedFlags = false;
    if(static_cast<uint32_t>(value & CullModeFlags::e_NONE) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_CULL_MODE_NONE";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & CullModeFlags::e_FRONT_BIT) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_CULL_MODE_FRONT_BIT";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & CullModeFlags::e_BACK_BIT) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_CULL_MODE_BACK_BIT";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & CullModeFlags::e_FRONT_AND_BACK) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_CULL_MODE_FRONT_AND_BACK";
        addedFlags = true;
    }
    return returnString;
}

enum class FrontFace
{
    e_NONE = 0,
    e_COUNTER_CLOCKWISE = VK_FRONT_FACE_COUNTER_CLOCKWISE,
    e_CLOCKWISE = VK_FRONT_FACE_CLOCKWISE,
    e_BEGIN_RANGE = VK_FRONT_FACE_BEGIN_RANGE,
    e_END_RANGE = VK_FRONT_FACE_END_RANGE,
    e_RANGE_SIZE = VK_FRONT_FACE_RANGE_SIZE,
    e_MAX_ENUM = 0x7FFFFFFF

};
DEFINE_ENUM_BITWISE_OPERATORS(FrontFace)
inline std::string to_string(FrontFace value)
{
    switch(value)
    {
    case FrontFace::e_COUNTER_CLOCKWISE: return "VK_FRONT_FACE_COUNTER_CLOCKWISE";
    case FrontFace::e_CLOCKWISE: return "VK_FRONT_FACE_CLOCKWISE";
    default: return "invalid";
    }
}

enum class CompareOp
{
    e_NONE = 0,
    e_NEVER = VK_COMPARE_OP_NEVER,
    e_LESS = VK_COMPARE_OP_LESS,
    e_EQUAL = VK_COMPARE_OP_EQUAL,
    e_LESS_OR_EQUAL = VK_COMPARE_OP_LESS_OR_EQUAL,
    e_GREATER = VK_COMPARE_OP_GREATER,
    e_NOT_EQUAL = VK_COMPARE_OP_NOT_EQUAL,
    e_GREATER_OR_EQUAL = VK_COMPARE_OP_GREATER_OR_EQUAL,
    e_ALWAYS = VK_COMPARE_OP_ALWAYS,
    e_BEGIN_RANGE = VK_COMPARE_OP_BEGIN_RANGE,
    e_END_RANGE = VK_COMPARE_OP_END_RANGE,
    e_RANGE_SIZE = VK_COMPARE_OP_RANGE_SIZE,
    e_MAX_ENUM = 0x7FFFFFFF

};
DEFINE_ENUM_BITWISE_OPERATORS(CompareOp)
inline std::string to_string(CompareOp value)
{
    switch(value)
    {
    case CompareOp::e_NEVER: return "VK_COMPARE_OP_NEVER";
    case CompareOp::e_LESS: return "VK_COMPARE_OP_LESS";
    case CompareOp::e_EQUAL: return "VK_COMPARE_OP_EQUAL";
    case CompareOp::e_LESS_OR_EQUAL: return "VK_COMPARE_OP_LESS_OR_EQUAL";
    case CompareOp::e_GREATER: return "VK_COMPARE_OP_GREATER";
    case CompareOp::e_NOT_EQUAL: return "VK_COMPARE_OP_NOT_EQUAL";
    case CompareOp::e_GREATER_OR_EQUAL: return "VK_COMPARE_OP_GREATER_OR_EQUAL";
    case CompareOp::e_ALWAYS: return "VK_COMPARE_OP_ALWAYS";
    default: return "invalid";
    }
}

enum class StencilOp
{
    e_NONE = 0,
    e_KEEP = VK_STENCIL_OP_KEEP,
    e_ZERO = VK_STENCIL_OP_ZERO,
    e_REPLACE = VK_STENCIL_OP_REPLACE,
    e_INCREMENT_AND_CLAMP = VK_STENCIL_OP_INCREMENT_AND_CLAMP,
    e_DECREMENT_AND_CLAMP = VK_STENCIL_OP_DECREMENT_AND_CLAMP,
    e_INVERT = VK_STENCIL_OP_INVERT,
    e_INCREMENT_AND_WRAP = VK_STENCIL_OP_INCREMENT_AND_WRAP,
    e_DECREMENT_AND_WRAP = VK_STENCIL_OP_DECREMENT_AND_WRAP,
    e_BEGIN_RANGE = VK_STENCIL_OP_BEGIN_RANGE,
    e_END_RANGE = VK_STENCIL_OP_END_RANGE,
    e_RANGE_SIZE = VK_STENCIL_OP_RANGE_SIZE,
    e_MAX_ENUM = 0x7FFFFFFF

};
DEFINE_ENUM_BITWISE_OPERATORS(StencilOp)
inline std::string to_string(StencilOp value)
{
    switch(value)
    {
    case StencilOp::e_KEEP: return "VK_STENCIL_OP_KEEP";
    case StencilOp::e_ZERO: return "VK_STENCIL_OP_ZERO";
    case StencilOp::e_REPLACE: return "VK_STENCIL_OP_REPLACE";
    case StencilOp::e_INCREMENT_AND_CLAMP: return "VK_STENCIL_OP_INCREMENT_AND_CLAMP";
    case StencilOp::e_DECREMENT_AND_CLAMP: return "VK_STENCIL_OP_DECREMENT_AND_CLAMP";
    case StencilOp::e_INVERT: return "VK_STENCIL_OP_INVERT";
    case StencilOp::e_INCREMENT_AND_WRAP: return "VK_STENCIL_OP_INCREMENT_AND_WRAP";
    case StencilOp::e_DECREMENT_AND_WRAP: return "VK_STENCIL_OP_DECREMENT_AND_WRAP";
    default: return "invalid";
    }
}

enum class LogicOp
{
    e_NONE = 0,
    e_CLEAR = VK_LOGIC_OP_CLEAR,
    e_AND = VK_LOGIC_OP_AND,
    e_AND_REVERSE = VK_LOGIC_OP_AND_REVERSE,
    e_COPY = VK_LOGIC_OP_COPY,
    e_AND_INVERTED = VK_LOGIC_OP_AND_INVERTED,
    e_NO_OP = VK_LOGIC_OP_NO_OP,
    e_XOR = VK_LOGIC_OP_XOR,
    e_OR = VK_LOGIC_OP_OR,
    e_NOR = VK_LOGIC_OP_NOR,
    e_EQUIVALENT = VK_LOGIC_OP_EQUIVALENT,
    e_INVERT = VK_LOGIC_OP_INVERT,
    e_OR_REVERSE = VK_LOGIC_OP_OR_REVERSE,
    e_COPY_INVERTED = VK_LOGIC_OP_COPY_INVERTED,
    e_OR_INVERTED = VK_LOGIC_OP_OR_INVERTED,
    e_NAND = VK_LOGIC_OP_NAND,
    e_SET = VK_LOGIC_OP_SET,
    e_BEGIN_RANGE = VK_LOGIC_OP_BEGIN_RANGE,
    e_END_RANGE = VK_LOGIC_OP_END_RANGE,
    e_RANGE_SIZE = VK_LOGIC_OP_RANGE_SIZE,
    e_MAX_ENUM = 0x7FFFFFFF

};
DEFINE_ENUM_BITWISE_OPERATORS(LogicOp)
inline std::string to_string(LogicOp value)
{
    switch(value)
    {
    case LogicOp::e_CLEAR: return "VK_LOGIC_OP_CLEAR";
    case LogicOp::e_AND: return "VK_LOGIC_OP_AND";
    case LogicOp::e_AND_REVERSE: return "VK_LOGIC_OP_AND_REVERSE";
    case LogicOp::e_COPY: return "VK_LOGIC_OP_COPY";
    case LogicOp::e_AND_INVERTED: return "VK_LOGIC_OP_AND_INVERTED";
    case LogicOp::e_NO_OP: return "VK_LOGIC_OP_NO_OP";
    case LogicOp::e_XOR: return "VK_LOGIC_OP_XOR";
    case LogicOp::e_OR: return "VK_LOGIC_OP_OR";
    case LogicOp::e_NOR: return "VK_LOGIC_OP_NOR";
    case LogicOp::e_EQUIVALENT: return "VK_LOGIC_OP_EQUIVALENT";
    case LogicOp::e_INVERT: return "VK_LOGIC_OP_INVERT";
    case LogicOp::e_OR_REVERSE: return "VK_LOGIC_OP_OR_REVERSE";
    case LogicOp::e_COPY_INVERTED: return "VK_LOGIC_OP_COPY_INVERTED";
    case LogicOp::e_OR_INVERTED: return "VK_LOGIC_OP_OR_INVERTED";
    case LogicOp::e_NAND: return "VK_LOGIC_OP_NAND";
    case LogicOp::e_SET: return "VK_LOGIC_OP_SET";
    default: return "invalid";
    }
}

enum class BlendFactor
{
    e_NONE = 0,
    e_ZERO = VK_BLEND_FACTOR_ZERO,
    e_ONE = VK_BLEND_FACTOR_ONE,
    e_SRC_COLOR = VK_BLEND_FACTOR_SRC_COLOR,
    e_ONE_MINUS_SRC_COLOR = VK_BLEND_FACTOR_ONE_MINUS_SRC_COLOR,
    e_DST_COLOR = VK_BLEND_FACTOR_DST_COLOR,
    e_ONE_MINUS_DST_COLOR = VK_BLEND_FACTOR_ONE_MINUS_DST_COLOR,
    e_SRC_ALPHA = VK_BLEND_FACTOR_SRC_ALPHA,
    e_ONE_MINUS_SRC_ALPHA = VK_BLEND_FACTOR_ONE_MINUS_SRC_ALPHA,
    e_DST_ALPHA = VK_BLEND_FACTOR_DST_ALPHA,
    e_ONE_MINUS_DST_ALPHA = VK_BLEND_FACTOR_ONE_MINUS_DST_ALPHA,
    e_CONSTANT_COLOR = VK_BLEND_FACTOR_CONSTANT_COLOR,
    e_ONE_MINUS_CONSTANT_COLOR = VK_BLEND_FACTOR_ONE_MINUS_CONSTANT_COLOR,
    e_CONSTANT_ALPHA = VK_BLEND_FACTOR_CONSTANT_ALPHA,
    e_ONE_MINUS_CONSTANT_ALPHA = VK_BLEND_FACTOR_ONE_MINUS_CONSTANT_ALPHA,
    e_SRC_ALPHA_SATURATE = VK_BLEND_FACTOR_SRC_ALPHA_SATURATE,
    e_SRC1_COLOR = VK_BLEND_FACTOR_SRC1_COLOR,
    e_ONE_MINUS_SRC1_COLOR = VK_BLEND_FACTOR_ONE_MINUS_SRC1_COLOR,
    e_SRC1_ALPHA = VK_BLEND_FACTOR_SRC1_ALPHA,
    e_ONE_MINUS_SRC1_ALPHA = VK_BLEND_FACTOR_ONE_MINUS_SRC1_ALPHA,
    e_BEGIN_RANGE = VK_BLEND_FACTOR_BEGIN_RANGE,
    e_END_RANGE = VK_BLEND_FACTOR_END_RANGE,
    e_RANGE_SIZE = VK_BLEND_FACTOR_RANGE_SIZE,
    e_MAX_ENUM = 0x7FFFFFFF

};
DEFINE_ENUM_BITWISE_OPERATORS(BlendFactor)
inline std::string to_string(BlendFactor value)
{
    switch(value)
    {
    case BlendFactor::e_ZERO: return "VK_BLEND_FACTOR_ZERO";
    case BlendFactor::e_ONE: return "VK_BLEND_FACTOR_ONE";
    case BlendFactor::e_SRC_COLOR: return "VK_BLEND_FACTOR_SRC_COLOR";
    case BlendFactor::e_ONE_MINUS_SRC_COLOR: return "VK_BLEND_FACTOR_ONE_MINUS_SRC_COLOR";
    case BlendFactor::e_DST_COLOR: return "VK_BLEND_FACTOR_DST_COLOR";
    case BlendFactor::e_ONE_MINUS_DST_COLOR: return "VK_BLEND_FACTOR_ONE_MINUS_DST_COLOR";
    case BlendFactor::e_SRC_ALPHA: return "VK_BLEND_FACTOR_SRC_ALPHA";
    case BlendFactor::e_ONE_MINUS_SRC_ALPHA: return "VK_BLEND_FACTOR_ONE_MINUS_SRC_ALPHA";
    case BlendFactor::e_DST_ALPHA: return "VK_BLEND_FACTOR_DST_ALPHA";
    case BlendFactor::e_ONE_MINUS_DST_ALPHA: return "VK_BLEND_FACTOR_ONE_MINUS_DST_ALPHA";
    case BlendFactor::e_CONSTANT_COLOR: return "VK_BLEND_FACTOR_CONSTANT_COLOR";
    case BlendFactor::e_ONE_MINUS_CONSTANT_COLOR: return "VK_BLEND_FACTOR_ONE_MINUS_CONSTANT_COLOR";
    case BlendFactor::e_CONSTANT_ALPHA: return "VK_BLEND_FACTOR_CONSTANT_ALPHA";
    case BlendFactor::e_ONE_MINUS_CONSTANT_ALPHA: return "VK_BLEND_FACTOR_ONE_MINUS_CONSTANT_ALPHA";
    case BlendFactor::e_SRC_ALPHA_SATURATE: return "VK_BLEND_FACTOR_SRC_ALPHA_SATURATE";
    case BlendFactor::e_SRC1_COLOR: return "VK_BLEND_FACTOR_SRC1_COLOR";
    case BlendFactor::e_ONE_MINUS_SRC1_COLOR: return "VK_BLEND_FACTOR_ONE_MINUS_SRC1_COLOR";
    case BlendFactor::e_SRC1_ALPHA: return "VK_BLEND_FACTOR_SRC1_ALPHA";
    case BlendFactor::e_ONE_MINUS_SRC1_ALPHA: return "VK_BLEND_FACTOR_ONE_MINUS_SRC1_ALPHA";
    default: return "invalid";
    }
}

enum class BlendOp
{
    e_NONE = 0,
    e_ADD = VK_BLEND_OP_ADD,
    e_SUBTRACT = VK_BLEND_OP_SUBTRACT,
    e_REVERSE_SUBTRACT = VK_BLEND_OP_REVERSE_SUBTRACT,
    e_MIN = VK_BLEND_OP_MIN,
    e_MAX = VK_BLEND_OP_MAX,
    e_ZERO_EXT = VK_BLEND_OP_ZERO_EXT,
    e_SRC_EXT = VK_BLEND_OP_SRC_EXT,
    e_DST_EXT = VK_BLEND_OP_DST_EXT,
    e_SRC_OVER_EXT = VK_BLEND_OP_SRC_OVER_EXT,
    e_DST_OVER_EXT = VK_BLEND_OP_DST_OVER_EXT,
    e_SRC_IN_EXT = VK_BLEND_OP_SRC_IN_EXT,
    e_DST_IN_EXT = VK_BLEND_OP_DST_IN_EXT,
    e_SRC_OUT_EXT = VK_BLEND_OP_SRC_OUT_EXT,
    e_DST_OUT_EXT = VK_BLEND_OP_DST_OUT_EXT,
    e_SRC_ATOP_EXT = VK_BLEND_OP_SRC_ATOP_EXT,
    e_DST_ATOP_EXT = VK_BLEND_OP_DST_ATOP_EXT,
    e_XOR_EXT = VK_BLEND_OP_XOR_EXT,
    e_MULTIPLY_EXT = VK_BLEND_OP_MULTIPLY_EXT,
    e_SCREEN_EXT = VK_BLEND_OP_SCREEN_EXT,
    e_OVERLAY_EXT = VK_BLEND_OP_OVERLAY_EXT,
    e_DARKEN_EXT = VK_BLEND_OP_DARKEN_EXT,
    e_LIGHTEN_EXT = VK_BLEND_OP_LIGHTEN_EXT,
    e_COLORDODGE_EXT = VK_BLEND_OP_COLORDODGE_EXT,
    e_COLORBURN_EXT = VK_BLEND_OP_COLORBURN_EXT,
    e_HARDLIGHT_EXT = VK_BLEND_OP_HARDLIGHT_EXT,
    e_SOFTLIGHT_EXT = VK_BLEND_OP_SOFTLIGHT_EXT,
    e_DIFFERENCE_EXT = VK_BLEND_OP_DIFFERENCE_EXT,
    e_EXCLUSION_EXT = VK_BLEND_OP_EXCLUSION_EXT,
    e_INVERT_EXT = VK_BLEND_OP_INVERT_EXT,
    e_INVERT_RGB_EXT = VK_BLEND_OP_INVERT_RGB_EXT,
    e_LINEARDODGE_EXT = VK_BLEND_OP_LINEARDODGE_EXT,
    e_LINEARBURN_EXT = VK_BLEND_OP_LINEARBURN_EXT,
    e_VIVIDLIGHT_EXT = VK_BLEND_OP_VIVIDLIGHT_EXT,
    e_LINEARLIGHT_EXT = VK_BLEND_OP_LINEARLIGHT_EXT,
    e_PINLIGHT_EXT = VK_BLEND_OP_PINLIGHT_EXT,
    e_HARDMIX_EXT = VK_BLEND_OP_HARDMIX_EXT,
    e_HSL_HUE_EXT = VK_BLEND_OP_HSL_HUE_EXT,
    e_HSL_SATURATION_EXT = VK_BLEND_OP_HSL_SATURATION_EXT,
    e_HSL_COLOR_EXT = VK_BLEND_OP_HSL_COLOR_EXT,
    e_HSL_LUMINOSITY_EXT = VK_BLEND_OP_HSL_LUMINOSITY_EXT,
    e_PLUS_EXT = VK_BLEND_OP_PLUS_EXT,
    e_PLUS_CLAMPED_EXT = VK_BLEND_OP_PLUS_CLAMPED_EXT,
    e_PLUS_CLAMPED_ALPHA_EXT = VK_BLEND_OP_PLUS_CLAMPED_ALPHA_EXT,
    e_PLUS_DARKER_EXT = VK_BLEND_OP_PLUS_DARKER_EXT,
    e_MINUS_EXT = VK_BLEND_OP_MINUS_EXT,
    e_MINUS_CLAMPED_EXT = VK_BLEND_OP_MINUS_CLAMPED_EXT,
    e_CONTRAST_EXT = VK_BLEND_OP_CONTRAST_EXT,
    e_INVERT_OVG_EXT = VK_BLEND_OP_INVERT_OVG_EXT,
    e_RED_EXT = VK_BLEND_OP_RED_EXT,
    e_GREEN_EXT = VK_BLEND_OP_GREEN_EXT,
    e_BLUE_EXT = VK_BLEND_OP_BLUE_EXT,
    e_BEGIN_RANGE = VK_BLEND_OP_BEGIN_RANGE,
    e_END_RANGE = VK_BLEND_OP_END_RANGE,
    e_RANGE_SIZE = VK_BLEND_OP_RANGE_SIZE,
    e_MAX_ENUM = 0x7FFFFFFF

};
DEFINE_ENUM_BITWISE_OPERATORS(BlendOp)
inline std::string to_string(BlendOp value)
{
    switch(value)
    {
    case BlendOp::e_ADD: return "VK_BLEND_OP_ADD";
    case BlendOp::e_SUBTRACT: return "VK_BLEND_OP_SUBTRACT";
    case BlendOp::e_REVERSE_SUBTRACT: return "VK_BLEND_OP_REVERSE_SUBTRACT";
    case BlendOp::e_MIN: return "VK_BLEND_OP_MIN";
    case BlendOp::e_MAX: return "VK_BLEND_OP_MAX";
    case BlendOp::e_ZERO_EXT: return "VK_BLEND_OP_ZERO_EXT";
    case BlendOp::e_SRC_EXT: return "VK_BLEND_OP_SRC_EXT";
    case BlendOp::e_DST_EXT: return "VK_BLEND_OP_DST_EXT";
    case BlendOp::e_SRC_OVER_EXT: return "VK_BLEND_OP_SRC_OVER_EXT";
    case BlendOp::e_DST_OVER_EXT: return "VK_BLEND_OP_DST_OVER_EXT";
    case BlendOp::e_SRC_IN_EXT: return "VK_BLEND_OP_SRC_IN_EXT";
    case BlendOp::e_DST_IN_EXT: return "VK_BLEND_OP_DST_IN_EXT";
    case BlendOp::e_SRC_OUT_EXT: return "VK_BLEND_OP_SRC_OUT_EXT";
    case BlendOp::e_DST_OUT_EXT: return "VK_BLEND_OP_DST_OUT_EXT";
    case BlendOp::e_SRC_ATOP_EXT: return "VK_BLEND_OP_SRC_ATOP_EXT";
    case BlendOp::e_DST_ATOP_EXT: return "VK_BLEND_OP_DST_ATOP_EXT";
    case BlendOp::e_XOR_EXT: return "VK_BLEND_OP_XOR_EXT";
    case BlendOp::e_MULTIPLY_EXT: return "VK_BLEND_OP_MULTIPLY_EXT";
    case BlendOp::e_SCREEN_EXT: return "VK_BLEND_OP_SCREEN_EXT";
    case BlendOp::e_OVERLAY_EXT: return "VK_BLEND_OP_OVERLAY_EXT";
    case BlendOp::e_DARKEN_EXT: return "VK_BLEND_OP_DARKEN_EXT";
    case BlendOp::e_LIGHTEN_EXT: return "VK_BLEND_OP_LIGHTEN_EXT";
    case BlendOp::e_COLORDODGE_EXT: return "VK_BLEND_OP_COLORDODGE_EXT";
    case BlendOp::e_COLORBURN_EXT: return "VK_BLEND_OP_COLORBURN_EXT";
    case BlendOp::e_HARDLIGHT_EXT: return "VK_BLEND_OP_HARDLIGHT_EXT";
    case BlendOp::e_SOFTLIGHT_EXT: return "VK_BLEND_OP_SOFTLIGHT_EXT";
    case BlendOp::e_DIFFERENCE_EXT: return "VK_BLEND_OP_DIFFERENCE_EXT";
    case BlendOp::e_EXCLUSION_EXT: return "VK_BLEND_OP_EXCLUSION_EXT";
    case BlendOp::e_INVERT_EXT: return "VK_BLEND_OP_INVERT_EXT";
    case BlendOp::e_INVERT_RGB_EXT: return "VK_BLEND_OP_INVERT_RGB_EXT";
    case BlendOp::e_LINEARDODGE_EXT: return "VK_BLEND_OP_LINEARDODGE_EXT";
    case BlendOp::e_LINEARBURN_EXT: return "VK_BLEND_OP_LINEARBURN_EXT";
    case BlendOp::e_VIVIDLIGHT_EXT: return "VK_BLEND_OP_VIVIDLIGHT_EXT";
    case BlendOp::e_LINEARLIGHT_EXT: return "VK_BLEND_OP_LINEARLIGHT_EXT";
    case BlendOp::e_PINLIGHT_EXT: return "VK_BLEND_OP_PINLIGHT_EXT";
    case BlendOp::e_HARDMIX_EXT: return "VK_BLEND_OP_HARDMIX_EXT";
    case BlendOp::e_HSL_HUE_EXT: return "VK_BLEND_OP_HSL_HUE_EXT";
    case BlendOp::e_HSL_SATURATION_EXT: return "VK_BLEND_OP_HSL_SATURATION_EXT";
    case BlendOp::e_HSL_COLOR_EXT: return "VK_BLEND_OP_HSL_COLOR_EXT";
    case BlendOp::e_HSL_LUMINOSITY_EXT: return "VK_BLEND_OP_HSL_LUMINOSITY_EXT";
    case BlendOp::e_PLUS_EXT: return "VK_BLEND_OP_PLUS_EXT";
    case BlendOp::e_PLUS_CLAMPED_EXT: return "VK_BLEND_OP_PLUS_CLAMPED_EXT";
    case BlendOp::e_PLUS_CLAMPED_ALPHA_EXT: return "VK_BLEND_OP_PLUS_CLAMPED_ALPHA_EXT";
    case BlendOp::e_PLUS_DARKER_EXT: return "VK_BLEND_OP_PLUS_DARKER_EXT";
    case BlendOp::e_MINUS_EXT: return "VK_BLEND_OP_MINUS_EXT";
    case BlendOp::e_MINUS_CLAMPED_EXT: return "VK_BLEND_OP_MINUS_CLAMPED_EXT";
    case BlendOp::e_CONTRAST_EXT: return "VK_BLEND_OP_CONTRAST_EXT";
    case BlendOp::e_INVERT_OVG_EXT: return "VK_BLEND_OP_INVERT_OVG_EXT";
    case BlendOp::e_RED_EXT: return "VK_BLEND_OP_RED_EXT";
    case BlendOp::e_GREEN_EXT: return "VK_BLEND_OP_GREEN_EXT";
    case BlendOp::e_BLUE_EXT: return "VK_BLEND_OP_BLUE_EXT";
    default: return "invalid";
    }
}

enum class ColorComponentFlags
{
    e_NONE = 0,
    e_R_BIT = VK_COLOR_COMPONENT_R_BIT,
    e_G_BIT = VK_COLOR_COMPONENT_G_BIT,
    e_B_BIT = VK_COLOR_COMPONENT_B_BIT,
    e_A_BIT = VK_COLOR_COMPONENT_A_BIT,
    e_MAX_ENUM = 0x7FFFFFFF,
    e_ALL_BITS = e_R_BIT | e_G_BIT | e_B_BIT | e_A_BIT
};
DEFINE_ENUM_BITWISE_OPERATORS(ColorComponentFlags)
inline std::string to_string(ColorComponentFlags value)
{
    std::string returnString = "";
    bool addedFlags = false;
    if(static_cast<uint32_t>(value & ColorComponentFlags::e_R_BIT) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_COLOR_COMPONENT_R_BIT";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & ColorComponentFlags::e_G_BIT) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_COLOR_COMPONENT_G_BIT";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & ColorComponentFlags::e_B_BIT) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_COLOR_COMPONENT_B_BIT";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & ColorComponentFlags::e_A_BIT) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_COLOR_COMPONENT_A_BIT";
        addedFlags = true;
    }
    return returnString;
}

enum class DynamicState
{
    e_NONE = 0,
    e_VIEWPORT = VK_DYNAMIC_STATE_VIEWPORT,
    e_SCISSOR = VK_DYNAMIC_STATE_SCISSOR,
    e_LINE_WIDTH = VK_DYNAMIC_STATE_LINE_WIDTH,
    e_DEPTH_BIAS = VK_DYNAMIC_STATE_DEPTH_BIAS,
    e_BLEND_CONSTANTS = VK_DYNAMIC_STATE_BLEND_CONSTANTS,
    e_DEPTH_BOUNDS = VK_DYNAMIC_STATE_DEPTH_BOUNDS,
    e_STENCIL_COMPARE_MASK = VK_DYNAMIC_STATE_STENCIL_COMPARE_MASK,
    e_STENCIL_WRITE_MASK = VK_DYNAMIC_STATE_STENCIL_WRITE_MASK,
    e_STENCIL_REFERENCE = VK_DYNAMIC_STATE_STENCIL_REFERENCE,
    e_VIEWPORT_W_SCALING_NV = VK_DYNAMIC_STATE_VIEWPORT_W_SCALING_NV,
    e_DISCARD_RECTANGLE_EXT = VK_DYNAMIC_STATE_DISCARD_RECTANGLE_EXT,
    e_SAMPLE_LOCATIONS_EXT = VK_DYNAMIC_STATE_SAMPLE_LOCATIONS_EXT,
    e_BEGIN_RANGE = VK_DYNAMIC_STATE_BEGIN_RANGE,
    e_END_RANGE = VK_DYNAMIC_STATE_END_RANGE,
    e_RANGE_SIZE = VK_DYNAMIC_STATE_RANGE_SIZE,
    e_MAX_ENUM = 0x7FFFFFFF

};
DEFINE_ENUM_BITWISE_OPERATORS(DynamicState)
inline std::string to_string(DynamicState value)
{
    switch(value)
    {
    case DynamicState::e_VIEWPORT: return "VK_DYNAMIC_STATE_VIEWPORT";
    case DynamicState::e_SCISSOR: return "VK_DYNAMIC_STATE_SCISSOR";
    case DynamicState::e_LINE_WIDTH: return "VK_DYNAMIC_STATE_LINE_WIDTH";
    case DynamicState::e_DEPTH_BIAS: return "VK_DYNAMIC_STATE_DEPTH_BIAS";
    case DynamicState::e_BLEND_CONSTANTS: return "VK_DYNAMIC_STATE_BLEND_CONSTANTS";
    case DynamicState::e_DEPTH_BOUNDS: return "VK_DYNAMIC_STATE_DEPTH_BOUNDS";
    case DynamicState::e_STENCIL_COMPARE_MASK: return "VK_DYNAMIC_STATE_STENCIL_COMPARE_MASK";
    case DynamicState::e_STENCIL_WRITE_MASK: return "VK_DYNAMIC_STATE_STENCIL_WRITE_MASK";
    case DynamicState::e_STENCIL_REFERENCE: return "VK_DYNAMIC_STATE_STENCIL_REFERENCE";
    case DynamicState::e_VIEWPORT_W_SCALING_NV: return "VK_DYNAMIC_STATE_VIEWPORT_W_SCALING_NV";
    case DynamicState::e_DISCARD_RECTANGLE_EXT: return "VK_DYNAMIC_STATE_DISCARD_RECTANGLE_EXT";
    case DynamicState::e_SAMPLE_LOCATIONS_EXT: return "VK_DYNAMIC_STATE_SAMPLE_LOCATIONS_EXT";
    default: return "invalid";
    }
}

enum class Filter
{
    e_NONE = 0,
    e_NEAREST = VK_FILTER_NEAREST,
    e_LINEAR = VK_FILTER_LINEAR,
    e_CUBIC_IMG = VK_FILTER_CUBIC_IMG,
    e_BEGIN_RANGE = VK_FILTER_BEGIN_RANGE,
    e_END_RANGE = VK_FILTER_END_RANGE,
    e_RANGE_SIZE = VK_FILTER_RANGE_SIZE,
    e_MAX_ENUM = 0x7FFFFFFF

};
DEFINE_ENUM_BITWISE_OPERATORS(Filter)
inline std::string to_string(Filter value)
{
    switch(value)
    {
    case Filter::e_NEAREST: return "VK_FILTER_NEAREST";
    case Filter::e_LINEAR: return "VK_FILTER_LINEAR";
    case Filter::e_CUBIC_IMG: return "VK_FILTER_CUBIC_IMG";
    default: return "invalid";
    }
}

enum class SamplerMipmapMode
{
    e_NONE = 0,
    e_NEAREST = VK_SAMPLER_MIPMAP_MODE_NEAREST,
    e_LINEAR = VK_SAMPLER_MIPMAP_MODE_LINEAR,
    e_BEGIN_RANGE = VK_SAMPLER_MIPMAP_MODE_BEGIN_RANGE,
    e_END_RANGE = VK_SAMPLER_MIPMAP_MODE_END_RANGE,
    e_RANGE_SIZE = VK_SAMPLER_MIPMAP_MODE_RANGE_SIZE,
    e_MAX_ENUM = 0x7FFFFFFF

};
DEFINE_ENUM_BITWISE_OPERATORS(SamplerMipmapMode)
inline std::string to_string(SamplerMipmapMode value)
{
    switch(value)
    {
    case SamplerMipmapMode::e_NEAREST: return "VK_SAMPLER_MIPMAP_MODE_NEAREST";
    case SamplerMipmapMode::e_LINEAR: return "VK_SAMPLER_MIPMAP_MODE_LINEAR";
    default: return "invalid";
    }
}

enum class SamplerAddressMode
{
    e_NONE = 0,
    e_REPEAT = VK_SAMPLER_ADDRESS_MODE_REPEAT,
    e_MIRRORED_REPEAT = VK_SAMPLER_ADDRESS_MODE_MIRRORED_REPEAT,
    e_CLAMP_TO_EDGE = VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_EDGE,
    e_CLAMP_TO_BORDER = VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_BORDER,
    e_MIRROR_CLAMP_TO_EDGE = VK_SAMPLER_ADDRESS_MODE_MIRROR_CLAMP_TO_EDGE,
    e_BEGIN_RANGE = VK_SAMPLER_ADDRESS_MODE_BEGIN_RANGE,
    e_END_RANGE = VK_SAMPLER_ADDRESS_MODE_END_RANGE,
    e_RANGE_SIZE = VK_SAMPLER_ADDRESS_MODE_RANGE_SIZE,
    e_MAX_ENUM = 0x7FFFFFFF

};
DEFINE_ENUM_BITWISE_OPERATORS(SamplerAddressMode)
inline std::string to_string(SamplerAddressMode value)
{
    switch(value)
    {
    case SamplerAddressMode::e_REPEAT: return "VK_SAMPLER_ADDRESS_MODE_REPEAT";
    case SamplerAddressMode::e_MIRRORED_REPEAT: return "VK_SAMPLER_ADDRESS_MODE_MIRRORED_REPEAT";
    case SamplerAddressMode::e_CLAMP_TO_EDGE: return "VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_EDGE";
    case SamplerAddressMode::e_CLAMP_TO_BORDER: return "VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_BORDER";
    case SamplerAddressMode::e_MIRROR_CLAMP_TO_EDGE: return "VK_SAMPLER_ADDRESS_MODE_MIRROR_CLAMP_TO_EDGE";
    default: return "invalid";
    }
}

enum class BorderColor
{
    e_NONE = 0,
    e_FLOAT_TRANSPARENT_BLACK = VK_BORDER_COLOR_FLOAT_TRANSPARENT_BLACK,
    e_INT_TRANSPARENT_BLACK = VK_BORDER_COLOR_INT_TRANSPARENT_BLACK,
    e_FLOAT_OPAQUE_BLACK = VK_BORDER_COLOR_FLOAT_OPAQUE_BLACK,
    e_INT_OPAQUE_BLACK = VK_BORDER_COLOR_INT_OPAQUE_BLACK,
    e_FLOAT_OPAQUE_WHITE = VK_BORDER_COLOR_FLOAT_OPAQUE_WHITE,
    e_INT_OPAQUE_WHITE = VK_BORDER_COLOR_INT_OPAQUE_WHITE,
    e_BEGIN_RANGE = VK_BORDER_COLOR_BEGIN_RANGE,
    e_END_RANGE = VK_BORDER_COLOR_END_RANGE,
    e_RANGE_SIZE = VK_BORDER_COLOR_RANGE_SIZE,
    e_MAX_ENUM = 0x7FFFFFFF

};
DEFINE_ENUM_BITWISE_OPERATORS(BorderColor)
inline std::string to_string(BorderColor value)
{
    switch(value)
    {
    case BorderColor::e_FLOAT_TRANSPARENT_BLACK: return "VK_BORDER_COLOR_FLOAT_TRANSPARENT_BLACK";
    case BorderColor::e_INT_TRANSPARENT_BLACK: return "VK_BORDER_COLOR_INT_TRANSPARENT_BLACK";
    case BorderColor::e_FLOAT_OPAQUE_BLACK: return "VK_BORDER_COLOR_FLOAT_OPAQUE_BLACK";
    case BorderColor::e_INT_OPAQUE_BLACK: return "VK_BORDER_COLOR_INT_OPAQUE_BLACK";
    case BorderColor::e_FLOAT_OPAQUE_WHITE: return "VK_BORDER_COLOR_FLOAT_OPAQUE_WHITE";
    case BorderColor::e_INT_OPAQUE_WHITE: return "VK_BORDER_COLOR_INT_OPAQUE_WHITE";
    default: return "invalid";
    }
}

enum class DescriptorSetLayoutCreateFlags
{
    e_NONE = 0,
    e_PUSH_DESCRIPTOR_BIT_KHR = VK_DESCRIPTOR_SET_LAYOUT_CREATE_PUSH_DESCRIPTOR_BIT_KHR,
    e_UPDATE_AFTER_BIND_POOL_BIT_EXT = VK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT_EXT,
    e_MAX_ENUM = 0x7FFFFFFF,
    e_ALL_BITS = e_PUSH_DESCRIPTOR_BIT_KHR | e_UPDATE_AFTER_BIND_POOL_BIT_EXT
};
DEFINE_ENUM_BITWISE_OPERATORS(DescriptorSetLayoutCreateFlags)
inline std::string to_string(DescriptorSetLayoutCreateFlags value)
{
    std::string returnString = "";
    bool addedFlags = false;
    if(static_cast<uint32_t>(value & DescriptorSetLayoutCreateFlags::e_PUSH_DESCRIPTOR_BIT_KHR) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_DESCRIPTOR_SET_LAYOUT_CREATE_PUSH_DESCRIPTOR_BIT_KHR";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & DescriptorSetLayoutCreateFlags::e_UPDATE_AFTER_BIND_POOL_BIT_EXT) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT_EXT";
        addedFlags = true;
    }
    return returnString;
}

enum class DescriptorType
{
    e_NONE = 0,
    e_SAMPLER = VK_DESCRIPTOR_TYPE_SAMPLER,
    e_COMBINED_IMAGE_SAMPLER = VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER,
    e_SAMPLED_IMAGE = VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE,
    e_STORAGE_IMAGE = VK_DESCRIPTOR_TYPE_STORAGE_IMAGE,
    e_UNIFORM_TEXEL_BUFFER = VK_DESCRIPTOR_TYPE_UNIFORM_TEXEL_BUFFER,
    e_STORAGE_TEXEL_BUFFER = VK_DESCRIPTOR_TYPE_STORAGE_TEXEL_BUFFER,
    e_UNIFORM_BUFFER = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER,
    e_STORAGE_BUFFER = VK_DESCRIPTOR_TYPE_STORAGE_BUFFER,
    e_UNIFORM_BUFFER_DYNAMIC = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC,
    e_STORAGE_BUFFER_DYNAMIC = VK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC,
    e_INPUT_ATTACHMENT = VK_DESCRIPTOR_TYPE_INPUT_ATTACHMENT,
    e_BEGIN_RANGE = VK_DESCRIPTOR_TYPE_BEGIN_RANGE,
    e_END_RANGE = VK_DESCRIPTOR_TYPE_END_RANGE,
    e_RANGE_SIZE = VK_DESCRIPTOR_TYPE_RANGE_SIZE,
    e_MAX_ENUM = 0x7FFFFFFF

};
DEFINE_ENUM_BITWISE_OPERATORS(DescriptorType)
inline std::string to_string(DescriptorType value)
{
    switch(value)
    {
    case DescriptorType::e_SAMPLER: return "VK_DESCRIPTOR_TYPE_SAMPLER";
    case DescriptorType::e_COMBINED_IMAGE_SAMPLER: return "VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER";
    case DescriptorType::e_SAMPLED_IMAGE: return "VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE";
    case DescriptorType::e_STORAGE_IMAGE: return "VK_DESCRIPTOR_TYPE_STORAGE_IMAGE";
    case DescriptorType::e_UNIFORM_TEXEL_BUFFER: return "VK_DESCRIPTOR_TYPE_UNIFORM_TEXEL_BUFFER";
    case DescriptorType::e_STORAGE_TEXEL_BUFFER: return "VK_DESCRIPTOR_TYPE_STORAGE_TEXEL_BUFFER";
    case DescriptorType::e_UNIFORM_BUFFER: return "VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER";
    case DescriptorType::e_STORAGE_BUFFER: return "VK_DESCRIPTOR_TYPE_STORAGE_BUFFER";
    case DescriptorType::e_UNIFORM_BUFFER_DYNAMIC: return "VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC";
    case DescriptorType::e_STORAGE_BUFFER_DYNAMIC: return "VK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC";
    case DescriptorType::e_INPUT_ATTACHMENT: return "VK_DESCRIPTOR_TYPE_INPUT_ATTACHMENT";
    default: return "invalid";
    }
}

enum class DescriptorPoolCreateFlags
{
    e_NONE = 0,
    e_FREE_DESCRIPTOR_SET_BIT = VK_DESCRIPTOR_POOL_CREATE_FREE_DESCRIPTOR_SET_BIT,
    e_UPDATE_AFTER_BIND_BIT_EXT = VK_DESCRIPTOR_POOL_CREATE_UPDATE_AFTER_BIND_BIT_EXT,
    e_MAX_ENUM = 0x7FFFFFFF,
    e_ALL_BITS = e_FREE_DESCRIPTOR_SET_BIT | e_UPDATE_AFTER_BIND_BIT_EXT
};
DEFINE_ENUM_BITWISE_OPERATORS(DescriptorPoolCreateFlags)
inline std::string to_string(DescriptorPoolCreateFlags value)
{
    std::string returnString = "";
    bool addedFlags = false;
    if(static_cast<uint32_t>(value & DescriptorPoolCreateFlags::e_FREE_DESCRIPTOR_SET_BIT) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_DESCRIPTOR_POOL_CREATE_FREE_DESCRIPTOR_SET_BIT";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & DescriptorPoolCreateFlags::e_UPDATE_AFTER_BIND_BIT_EXT) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_DESCRIPTOR_POOL_CREATE_UPDATE_AFTER_BIND_BIT_EXT";
        addedFlags = true;
    }
    return returnString;
}

enum class AttachmentDescriptionFlags
{
    e_NONE = 0,
    e_MAY_ALIAS_BIT = VK_ATTACHMENT_DESCRIPTION_MAY_ALIAS_BIT,
    e_MAX_ENUM = 0x7FFFFFFF,
    e_ALL_BITS = e_MAY_ALIAS_BIT
};
DEFINE_ENUM_BITWISE_OPERATORS(AttachmentDescriptionFlags)
inline std::string to_string(AttachmentDescriptionFlags value)
{
    std::string returnString = "";
    bool addedFlags = false;
    if(static_cast<uint32_t>(value & AttachmentDescriptionFlags::e_MAY_ALIAS_BIT) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_ATTACHMENT_DESCRIPTION_MAY_ALIAS_BIT";
        addedFlags = true;
    }
    return returnString;
}

enum class AttachmentLoadOp
{
    e_NONE = 0,
    e_LOAD = VK_ATTACHMENT_LOAD_OP_LOAD,
    e_CLEAR = VK_ATTACHMENT_LOAD_OP_CLEAR,
    e_DONT_CARE = VK_ATTACHMENT_LOAD_OP_DONT_CARE,
    e_BEGIN_RANGE = VK_ATTACHMENT_LOAD_OP_BEGIN_RANGE,
    e_END_RANGE = VK_ATTACHMENT_LOAD_OP_END_RANGE,
    e_RANGE_SIZE = VK_ATTACHMENT_LOAD_OP_RANGE_SIZE,
    e_MAX_ENUM = 0x7FFFFFFF

};
DEFINE_ENUM_BITWISE_OPERATORS(AttachmentLoadOp)
inline std::string to_string(AttachmentLoadOp value)
{
    switch(value)
    {
    case AttachmentLoadOp::e_LOAD: return "VK_ATTACHMENT_LOAD_OP_LOAD";
    case AttachmentLoadOp::e_CLEAR: return "VK_ATTACHMENT_LOAD_OP_CLEAR";
    case AttachmentLoadOp::e_DONT_CARE: return "VK_ATTACHMENT_LOAD_OP_DONT_CARE";
    default: return "invalid";
    }
}

enum class AttachmentStoreOp
{
    e_NONE = 0,
    e_STORE = VK_ATTACHMENT_STORE_OP_STORE,
    e_DONT_CARE = VK_ATTACHMENT_STORE_OP_DONT_CARE,
    e_BEGIN_RANGE = VK_ATTACHMENT_STORE_OP_BEGIN_RANGE,
    e_END_RANGE = VK_ATTACHMENT_STORE_OP_END_RANGE,
    e_RANGE_SIZE = VK_ATTACHMENT_STORE_OP_RANGE_SIZE,
    e_MAX_ENUM = 0x7FFFFFFF

};
DEFINE_ENUM_BITWISE_OPERATORS(AttachmentStoreOp)
inline std::string to_string(AttachmentStoreOp value)
{
    switch(value)
    {
    case AttachmentStoreOp::e_STORE: return "VK_ATTACHMENT_STORE_OP_STORE";
    case AttachmentStoreOp::e_DONT_CARE: return "VK_ATTACHMENT_STORE_OP_DONT_CARE";
    default: return "invalid";
    }
}

enum class SubpassDescriptionFlags
{
    e_NONE = 0,
    e_PER_VIEW_ATTRIBUTES_BIT_NVX = VK_SUBPASS_DESCRIPTION_PER_VIEW_ATTRIBUTES_BIT_NVX,
    e_PER_VIEW_POSITION_X_ONLY_BIT_NVX = VK_SUBPASS_DESCRIPTION_PER_VIEW_POSITION_X_ONLY_BIT_NVX,
    e_MAX_ENUM = 0x7FFFFFFF,
    e_ALL_BITS = e_PER_VIEW_ATTRIBUTES_BIT_NVX | e_PER_VIEW_POSITION_X_ONLY_BIT_NVX
};
DEFINE_ENUM_BITWISE_OPERATORS(SubpassDescriptionFlags)
inline std::string to_string(SubpassDescriptionFlags value)
{
    std::string returnString = "";
    bool addedFlags = false;
    if(static_cast<uint32_t>(value & SubpassDescriptionFlags::e_PER_VIEW_ATTRIBUTES_BIT_NVX) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_SUBPASS_DESCRIPTION_PER_VIEW_ATTRIBUTES_BIT_NVX";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & SubpassDescriptionFlags::e_PER_VIEW_POSITION_X_ONLY_BIT_NVX) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_SUBPASS_DESCRIPTION_PER_VIEW_POSITION_X_ONLY_BIT_NVX";
        addedFlags = true;
    }
    return returnString;
}

enum class PipelineBindPoint
{
    e_NONE = 0,
    e_GRAPHICS = VK_PIPELINE_BIND_POINT_GRAPHICS,
    e_COMPUTE = VK_PIPELINE_BIND_POINT_COMPUTE,
    e_BEGIN_RANGE = VK_PIPELINE_BIND_POINT_BEGIN_RANGE,
    e_END_RANGE = VK_PIPELINE_BIND_POINT_END_RANGE,
    e_RANGE_SIZE = VK_PIPELINE_BIND_POINT_RANGE_SIZE,
    e_MAX_ENUM = 0x7FFFFFFF

};
DEFINE_ENUM_BITWISE_OPERATORS(PipelineBindPoint)
inline std::string to_string(PipelineBindPoint value)
{
    switch(value)
    {
    case PipelineBindPoint::e_GRAPHICS: return "VK_PIPELINE_BIND_POINT_GRAPHICS";
    case PipelineBindPoint::e_COMPUTE: return "VK_PIPELINE_BIND_POINT_COMPUTE";
    default: return "invalid";
    }
}

enum class AccessFlags
{
    e_NONE = 0,
    e_INDIRECT_COMMAND_READ_BIT = VK_ACCESS_INDIRECT_COMMAND_READ_BIT,
    e_INDEX_READ_BIT = VK_ACCESS_INDEX_READ_BIT,
    e_VERTEX_ATTRIBUTE_READ_BIT = VK_ACCESS_VERTEX_ATTRIBUTE_READ_BIT,
    e_UNIFORM_READ_BIT = VK_ACCESS_UNIFORM_READ_BIT,
    e_INPUT_ATTACHMENT_READ_BIT = VK_ACCESS_INPUT_ATTACHMENT_READ_BIT,
    e_SHADER_READ_BIT = VK_ACCESS_SHADER_READ_BIT,
    e_SHADER_WRITE_BIT = VK_ACCESS_SHADER_WRITE_BIT,
    e_COLOR_ATTACHMENT_READ_BIT = VK_ACCESS_COLOR_ATTACHMENT_READ_BIT,
    e_COLOR_ATTACHMENT_WRITE_BIT = VK_ACCESS_COLOR_ATTACHMENT_WRITE_BIT,
    e_DEPTH_STENCIL_ATTACHMENT_READ_BIT = VK_ACCESS_DEPTH_STENCIL_ATTACHMENT_READ_BIT,
    e_DEPTH_STENCIL_ATTACHMENT_WRITE_BIT = VK_ACCESS_DEPTH_STENCIL_ATTACHMENT_WRITE_BIT,
    e_TRANSFER_READ_BIT = VK_ACCESS_TRANSFER_READ_BIT,
    e_TRANSFER_WRITE_BIT = VK_ACCESS_TRANSFER_WRITE_BIT,
    e_HOST_READ_BIT = VK_ACCESS_HOST_READ_BIT,
    e_HOST_WRITE_BIT = VK_ACCESS_HOST_WRITE_BIT,
    e_MEMORY_READ_BIT = VK_ACCESS_MEMORY_READ_BIT,
    e_MEMORY_WRITE_BIT = VK_ACCESS_MEMORY_WRITE_BIT,
    e_COMMAND_PROCESS_READ_BIT_NVX = VK_ACCESS_COMMAND_PROCESS_READ_BIT_NVX,
    e_COMMAND_PROCESS_WRITE_BIT_NVX = VK_ACCESS_COMMAND_PROCESS_WRITE_BIT_NVX,
    e_COLOR_ATTACHMENT_READ_NONCOHERENT_BIT_EXT = VK_ACCESS_COLOR_ATTACHMENT_READ_NONCOHERENT_BIT_EXT,
    e_MAX_ENUM = 0x7FFFFFFF,
    e_ALL_BITS = e_INDIRECT_COMMAND_READ_BIT | e_INDEX_READ_BIT | e_VERTEX_ATTRIBUTE_READ_BIT | e_UNIFORM_READ_BIT | e_INPUT_ATTACHMENT_READ_BIT | e_SHADER_READ_BIT | e_SHADER_WRITE_BIT | e_COLOR_ATTACHMENT_READ_BIT | e_COLOR_ATTACHMENT_WRITE_BIT | e_DEPTH_STENCIL_ATTACHMENT_READ_BIT | e_DEPTH_STENCIL_ATTACHMENT_WRITE_BIT | e_TRANSFER_READ_BIT | e_TRANSFER_WRITE_BIT | e_HOST_READ_BIT | e_HOST_WRITE_BIT | e_MEMORY_READ_BIT | e_MEMORY_WRITE_BIT | e_COMMAND_PROCESS_READ_BIT_NVX | e_COMMAND_PROCESS_WRITE_BIT_NVX | e_COLOR_ATTACHMENT_READ_NONCOHERENT_BIT_EXT
};
DEFINE_ENUM_BITWISE_OPERATORS(AccessFlags)
inline std::string to_string(AccessFlags value)
{
    std::string returnString = "";
    bool addedFlags = false;
    if(static_cast<uint32_t>(value & AccessFlags::e_INDIRECT_COMMAND_READ_BIT) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_ACCESS_INDIRECT_COMMAND_READ_BIT";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & AccessFlags::e_INDEX_READ_BIT) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_ACCESS_INDEX_READ_BIT";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & AccessFlags::e_VERTEX_ATTRIBUTE_READ_BIT) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_ACCESS_VERTEX_ATTRIBUTE_READ_BIT";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & AccessFlags::e_UNIFORM_READ_BIT) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_ACCESS_UNIFORM_READ_BIT";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & AccessFlags::e_INPUT_ATTACHMENT_READ_BIT) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_ACCESS_INPUT_ATTACHMENT_READ_BIT";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & AccessFlags::e_SHADER_READ_BIT) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_ACCESS_SHADER_READ_BIT";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & AccessFlags::e_SHADER_WRITE_BIT) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_ACCESS_SHADER_WRITE_BIT";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & AccessFlags::e_COLOR_ATTACHMENT_READ_BIT) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_ACCESS_COLOR_ATTACHMENT_READ_BIT";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & AccessFlags::e_COLOR_ATTACHMENT_WRITE_BIT) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_ACCESS_COLOR_ATTACHMENT_WRITE_BIT";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & AccessFlags::e_DEPTH_STENCIL_ATTACHMENT_READ_BIT) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_ACCESS_DEPTH_STENCIL_ATTACHMENT_READ_BIT";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & AccessFlags::e_DEPTH_STENCIL_ATTACHMENT_WRITE_BIT) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_ACCESS_DEPTH_STENCIL_ATTACHMENT_WRITE_BIT";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & AccessFlags::e_TRANSFER_READ_BIT) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_ACCESS_TRANSFER_READ_BIT";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & AccessFlags::e_TRANSFER_WRITE_BIT) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_ACCESS_TRANSFER_WRITE_BIT";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & AccessFlags::e_HOST_READ_BIT) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_ACCESS_HOST_READ_BIT";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & AccessFlags::e_HOST_WRITE_BIT) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_ACCESS_HOST_WRITE_BIT";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & AccessFlags::e_MEMORY_READ_BIT) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_ACCESS_MEMORY_READ_BIT";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & AccessFlags::e_MEMORY_WRITE_BIT) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_ACCESS_MEMORY_WRITE_BIT";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & AccessFlags::e_COMMAND_PROCESS_READ_BIT_NVX) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_ACCESS_COMMAND_PROCESS_READ_BIT_NVX";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & AccessFlags::e_COMMAND_PROCESS_WRITE_BIT_NVX) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_ACCESS_COMMAND_PROCESS_WRITE_BIT_NVX";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & AccessFlags::e_COLOR_ATTACHMENT_READ_NONCOHERENT_BIT_EXT) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_ACCESS_COLOR_ATTACHMENT_READ_NONCOHERENT_BIT_EXT";
        addedFlags = true;
    }
    return returnString;
}

enum class DependencyFlags
{
    e_NONE = 0,
    e_BY_REGION_BIT = VK_DEPENDENCY_BY_REGION_BIT,
    e_DEVICE_GROUP_BIT = VK_DEPENDENCY_DEVICE_GROUP_BIT,
    e_VIEW_LOCAL_BIT = VK_DEPENDENCY_VIEW_LOCAL_BIT,
    e_VIEW_LOCAL_BIT_KHR = VK_DEPENDENCY_VIEW_LOCAL_BIT_KHR,
    e_DEVICE_GROUP_BIT_KHR = VK_DEPENDENCY_DEVICE_GROUP_BIT_KHR,
    e_MAX_ENUM = 0x7FFFFFFF,
    e_ALL_BITS = e_BY_REGION_BIT | e_DEVICE_GROUP_BIT | e_VIEW_LOCAL_BIT | e_VIEW_LOCAL_BIT_KHR | e_DEVICE_GROUP_BIT_KHR
};
DEFINE_ENUM_BITWISE_OPERATORS(DependencyFlags)
inline std::string to_string(DependencyFlags value)
{
    std::string returnString = "";
    bool addedFlags = false;
    if(static_cast<uint32_t>(value & DependencyFlags::e_BY_REGION_BIT) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_DEPENDENCY_BY_REGION_BIT";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & DependencyFlags::e_DEVICE_GROUP_BIT) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_DEPENDENCY_DEVICE_GROUP_BIT";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & DependencyFlags::e_VIEW_LOCAL_BIT) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_DEPENDENCY_VIEW_LOCAL_BIT";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & DependencyFlags::e_VIEW_LOCAL_BIT_KHR) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_DEPENDENCY_VIEW_LOCAL_BIT_KHR";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & DependencyFlags::e_DEVICE_GROUP_BIT_KHR) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_DEPENDENCY_DEVICE_GROUP_BIT_KHR";
        addedFlags = true;
    }
    return returnString;
}

enum class CommandPoolCreateFlags
{
    e_NONE = 0,
    e_TRANSIENT_BIT = VK_COMMAND_POOL_CREATE_TRANSIENT_BIT,
    e_RESET_COMMAND_BUFFER_BIT = VK_COMMAND_POOL_CREATE_RESET_COMMAND_BUFFER_BIT,
    e_PROTECTED_BIT = VK_COMMAND_POOL_CREATE_PROTECTED_BIT,
    e_MAX_ENUM = 0x7FFFFFFF,
    e_ALL_BITS = e_TRANSIENT_BIT | e_RESET_COMMAND_BUFFER_BIT | e_PROTECTED_BIT
};
DEFINE_ENUM_BITWISE_OPERATORS(CommandPoolCreateFlags)
inline std::string to_string(CommandPoolCreateFlags value)
{
    std::string returnString = "";
    bool addedFlags = false;
    if(static_cast<uint32_t>(value & CommandPoolCreateFlags::e_TRANSIENT_BIT) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_COMMAND_POOL_CREATE_TRANSIENT_BIT";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & CommandPoolCreateFlags::e_RESET_COMMAND_BUFFER_BIT) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_COMMAND_POOL_CREATE_RESET_COMMAND_BUFFER_BIT";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & CommandPoolCreateFlags::e_PROTECTED_BIT) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_COMMAND_POOL_CREATE_PROTECTED_BIT";
        addedFlags = true;
    }
    return returnString;
}

enum class CommandPoolResetFlags
{
    e_NONE = 0,
    e_RELEASE_RESOURCES_BIT = VK_COMMAND_POOL_RESET_RELEASE_RESOURCES_BIT,
    e_MAX_ENUM = 0x7FFFFFFF,
    e_ALL_BITS = e_RELEASE_RESOURCES_BIT
};
DEFINE_ENUM_BITWISE_OPERATORS(CommandPoolResetFlags)
inline std::string to_string(CommandPoolResetFlags value)
{
    std::string returnString = "";
    bool addedFlags = false;
    if(static_cast<uint32_t>(value & CommandPoolResetFlags::e_RELEASE_RESOURCES_BIT) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_COMMAND_POOL_RESET_RELEASE_RESOURCES_BIT";
        addedFlags = true;
    }
    return returnString;
}

enum class CommandBufferLevel
{
    e_NONE = 0,
    e_PRIMARY = VK_COMMAND_BUFFER_LEVEL_PRIMARY,
    e_SECONDARY = VK_COMMAND_BUFFER_LEVEL_SECONDARY,
    e_BEGIN_RANGE = VK_COMMAND_BUFFER_LEVEL_BEGIN_RANGE,
    e_END_RANGE = VK_COMMAND_BUFFER_LEVEL_END_RANGE,
    e_RANGE_SIZE = VK_COMMAND_BUFFER_LEVEL_RANGE_SIZE,
    e_MAX_ENUM = 0x7FFFFFFF

};
DEFINE_ENUM_BITWISE_OPERATORS(CommandBufferLevel)
inline std::string to_string(CommandBufferLevel value)
{
    switch(value)
    {
    case CommandBufferLevel::e_PRIMARY: return "VK_COMMAND_BUFFER_LEVEL_PRIMARY";
    case CommandBufferLevel::e_SECONDARY: return "VK_COMMAND_BUFFER_LEVEL_SECONDARY";
    default: return "invalid";
    }
}

enum class CommandBufferUsageFlags
{
    e_NONE = 0,
    e_ONE_TIME_SUBMIT_BIT = VK_COMMAND_BUFFER_USAGE_ONE_TIME_SUBMIT_BIT,
    e_RENDER_PASS_CONTINUE_BIT = VK_COMMAND_BUFFER_USAGE_RENDER_PASS_CONTINUE_BIT,
    e_SIMULTANEOUS_USE_BIT = VK_COMMAND_BUFFER_USAGE_SIMULTANEOUS_USE_BIT,
    e_MAX_ENUM = 0x7FFFFFFF,
    e_ALL_BITS = e_ONE_TIME_SUBMIT_BIT | e_RENDER_PASS_CONTINUE_BIT | e_SIMULTANEOUS_USE_BIT
};
DEFINE_ENUM_BITWISE_OPERATORS(CommandBufferUsageFlags)
inline std::string to_string(CommandBufferUsageFlags value)
{
    std::string returnString = "";
    bool addedFlags = false;
    if(static_cast<uint32_t>(value & CommandBufferUsageFlags::e_ONE_TIME_SUBMIT_BIT) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_COMMAND_BUFFER_USAGE_ONE_TIME_SUBMIT_BIT";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & CommandBufferUsageFlags::e_RENDER_PASS_CONTINUE_BIT) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_COMMAND_BUFFER_USAGE_RENDER_PASS_CONTINUE_BIT";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & CommandBufferUsageFlags::e_SIMULTANEOUS_USE_BIT) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_COMMAND_BUFFER_USAGE_SIMULTANEOUS_USE_BIT";
        addedFlags = true;
    }
    return returnString;
}

enum class QueryControlFlags
{
    e_NONE = 0,
    e_PRECISE_BIT = VK_QUERY_CONTROL_PRECISE_BIT,
    e_MAX_ENUM = 0x7FFFFFFF,
    e_ALL_BITS = e_PRECISE_BIT
};
DEFINE_ENUM_BITWISE_OPERATORS(QueryControlFlags)
inline std::string to_string(QueryControlFlags value)
{
    std::string returnString = "";
    bool addedFlags = false;
    if(static_cast<uint32_t>(value & QueryControlFlags::e_PRECISE_BIT) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_QUERY_CONTROL_PRECISE_BIT";
        addedFlags = true;
    }
    return returnString;
}

enum class CommandBufferResetFlags
{
    e_NONE = 0,
    e_RELEASE_RESOURCES_BIT = VK_COMMAND_BUFFER_RESET_RELEASE_RESOURCES_BIT,
    e_MAX_ENUM = 0x7FFFFFFF,
    e_ALL_BITS = e_RELEASE_RESOURCES_BIT
};
DEFINE_ENUM_BITWISE_OPERATORS(CommandBufferResetFlags)
inline std::string to_string(CommandBufferResetFlags value)
{
    std::string returnString = "";
    bool addedFlags = false;
    if(static_cast<uint32_t>(value & CommandBufferResetFlags::e_RELEASE_RESOURCES_BIT) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_COMMAND_BUFFER_RESET_RELEASE_RESOURCES_BIT";
        addedFlags = true;
    }
    return returnString;
}

enum class StencilFaceFlags
{
    e_NONE = 0,
    e_FRONT_BIT = VK_STENCIL_FACE_FRONT_BIT,
    e_BACK_BIT = VK_STENCIL_FACE_BACK_BIT,
    e_VK_STENCIL_FRONT_AND_BACK = VK_STENCIL_FRONT_AND_BACK,
    e_MAX_ENUM = 0x7FFFFFFF,
    e_ALL_BITS = e_FRONT_BIT | e_BACK_BIT | e_VK_STENCIL_FRONT_AND_BACK
};
DEFINE_ENUM_BITWISE_OPERATORS(StencilFaceFlags)
inline std::string to_string(StencilFaceFlags value)
{
    std::string returnString = "";
    bool addedFlags = false;
    if(static_cast<uint32_t>(value & StencilFaceFlags::e_FRONT_BIT) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_STENCIL_FACE_FRONT_BIT";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & StencilFaceFlags::e_BACK_BIT) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_STENCIL_FACE_BACK_BIT";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & StencilFaceFlags::e_VK_STENCIL_FRONT_AND_BACK) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_STENCIL_FRONT_AND_BACK";
        addedFlags = true;
    }
    return returnString;
}

enum class IndexType
{
    e_NONE = 0,
    e_UINT16 = VK_INDEX_TYPE_UINT16,
    e_UINT32 = VK_INDEX_TYPE_UINT32,
    e_BEGIN_RANGE = VK_INDEX_TYPE_BEGIN_RANGE,
    e_END_RANGE = VK_INDEX_TYPE_END_RANGE,
    e_RANGE_SIZE = VK_INDEX_TYPE_RANGE_SIZE,
    e_MAX_ENUM = 0x7FFFFFFF

};
DEFINE_ENUM_BITWISE_OPERATORS(IndexType)
inline std::string to_string(IndexType value)
{
    switch(value)
    {
    case IndexType::e_UINT16: return "VK_INDEX_TYPE_UINT16";
    case IndexType::e_UINT32: return "VK_INDEX_TYPE_UINT32";
    default: return "invalid";
    }
}

enum class SubpassContents
{
    e_NONE = 0,
    e_INLINE = VK_SUBPASS_CONTENTS_INLINE,
    e_SECONDARY_COMMAND_BUFFERS = VK_SUBPASS_CONTENTS_SECONDARY_COMMAND_BUFFERS,
    e_BEGIN_RANGE = VK_SUBPASS_CONTENTS_BEGIN_RANGE,
    e_END_RANGE = VK_SUBPASS_CONTENTS_END_RANGE,
    e_RANGE_SIZE = VK_SUBPASS_CONTENTS_RANGE_SIZE,
    e_MAX_ENUM = 0x7FFFFFFF

};
DEFINE_ENUM_BITWISE_OPERATORS(SubpassContents)
inline std::string to_string(SubpassContents value)
{
    switch(value)
    {
    case SubpassContents::e_INLINE: return "VK_SUBPASS_CONTENTS_INLINE";
    case SubpassContents::e_SECONDARY_COMMAND_BUFFERS: return "VK_SUBPASS_CONTENTS_SECONDARY_COMMAND_BUFFERS";
    default: return "invalid";
    }
}

enum class ObjectType
{
    e_NONE = 0,
    e_UNKNOWN = VK_OBJECT_TYPE_UNKNOWN,
    e_INSTANCE = VK_OBJECT_TYPE_INSTANCE,
    e_PHYSICAL_DEVICE = VK_OBJECT_TYPE_PHYSICAL_DEVICE,
    e_DEVICE = VK_OBJECT_TYPE_DEVICE,
    e_QUEUE = VK_OBJECT_TYPE_QUEUE,
    e_SEMAPHORE = VK_OBJECT_TYPE_SEMAPHORE,
    e_COMMAND_BUFFER = VK_OBJECT_TYPE_COMMAND_BUFFER,
    e_FENCE = VK_OBJECT_TYPE_FENCE,
    e_DEVICE_MEMORY = VK_OBJECT_TYPE_DEVICE_MEMORY,
    e_BUFFER = VK_OBJECT_TYPE_BUFFER,
    e_IMAGE = VK_OBJECT_TYPE_IMAGE,
    e_EVENT = VK_OBJECT_TYPE_EVENT,
    e_QUERY_POOL = VK_OBJECT_TYPE_QUERY_POOL,
    e_BUFFER_VIEW = VK_OBJECT_TYPE_BUFFER_VIEW,
    e_IMAGE_VIEW = VK_OBJECT_TYPE_IMAGE_VIEW,
    e_SHADER_MODULE = VK_OBJECT_TYPE_SHADER_MODULE,
    e_PIPELINE_CACHE = VK_OBJECT_TYPE_PIPELINE_CACHE,
    e_PIPELINE_LAYOUT = VK_OBJECT_TYPE_PIPELINE_LAYOUT,
    e_RENDER_PASS = VK_OBJECT_TYPE_RENDER_PASS,
    e_PIPELINE = VK_OBJECT_TYPE_PIPELINE,
    e_DESCRIPTOR_SET_LAYOUT = VK_OBJECT_TYPE_DESCRIPTOR_SET_LAYOUT,
    e_SAMPLER = VK_OBJECT_TYPE_SAMPLER,
    e_DESCRIPTOR_POOL = VK_OBJECT_TYPE_DESCRIPTOR_POOL,
    e_DESCRIPTOR_SET = VK_OBJECT_TYPE_DESCRIPTOR_SET,
    e_FRAMEBUFFER = VK_OBJECT_TYPE_FRAMEBUFFER,
    e_COMMAND_POOL = VK_OBJECT_TYPE_COMMAND_POOL,
    e_SAMPLER_YCBCR_CONVERSION = VK_OBJECT_TYPE_SAMPLER_YCBCR_CONVERSION,
    e_DESCRIPTOR_UPDATE_TEMPLATE = VK_OBJECT_TYPE_DESCRIPTOR_UPDATE_TEMPLATE,
    e_SURFACE_KHR = VK_OBJECT_TYPE_SURFACE_KHR,
    e_SWAPCHAIN_KHR = VK_OBJECT_TYPE_SWAPCHAIN_KHR,
    e_DISPLAY_KHR = VK_OBJECT_TYPE_DISPLAY_KHR,
    e_DISPLAY_MODE_KHR = VK_OBJECT_TYPE_DISPLAY_MODE_KHR,
    e_DEBUG_REPORT_CALLBACK_EXT = VK_OBJECT_TYPE_DEBUG_REPORT_CALLBACK_EXT,
    e_DESCRIPTOR_UPDATE_TEMPLATE_KHR = VK_OBJECT_TYPE_DESCRIPTOR_UPDATE_TEMPLATE_KHR,
    e_OBJECT_TABLE_NVX = VK_OBJECT_TYPE_OBJECT_TABLE_NVX,
    e_INDIRECT_COMMANDS_LAYOUT_NVX = VK_OBJECT_TYPE_INDIRECT_COMMANDS_LAYOUT_NVX,
    e_DEBUG_UTILS_MESSENGER_EXT = VK_OBJECT_TYPE_DEBUG_UTILS_MESSENGER_EXT,
    e_SAMPLER_YCBCR_CONVERSION_KHR = VK_OBJECT_TYPE_SAMPLER_YCBCR_CONVERSION_KHR,
    e_VALIDATION_CACHE_EXT = VK_OBJECT_TYPE_VALIDATION_CACHE_EXT,
    e_BEGIN_RANGE = VK_OBJECT_TYPE_BEGIN_RANGE,
    e_END_RANGE = VK_OBJECT_TYPE_END_RANGE,
    e_RANGE_SIZE = VK_OBJECT_TYPE_RANGE_SIZE,
    e_MAX_ENUM = 0x7FFFFFFF

};
DEFINE_ENUM_BITWISE_OPERATORS(ObjectType)
inline std::string to_string(ObjectType value)
{
    switch(value)
    {
    case ObjectType::e_UNKNOWN: return "VK_OBJECT_TYPE_UNKNOWN";
    case ObjectType::e_INSTANCE: return "VK_OBJECT_TYPE_INSTANCE";
    case ObjectType::e_PHYSICAL_DEVICE: return "VK_OBJECT_TYPE_PHYSICAL_DEVICE";
    case ObjectType::e_DEVICE: return "VK_OBJECT_TYPE_DEVICE";
    case ObjectType::e_QUEUE: return "VK_OBJECT_TYPE_QUEUE";
    case ObjectType::e_SEMAPHORE: return "VK_OBJECT_TYPE_SEMAPHORE";
    case ObjectType::e_COMMAND_BUFFER: return "VK_OBJECT_TYPE_COMMAND_BUFFER";
    case ObjectType::e_FENCE: return "VK_OBJECT_TYPE_FENCE";
    case ObjectType::e_DEVICE_MEMORY: return "VK_OBJECT_TYPE_DEVICE_MEMORY";
    case ObjectType::e_BUFFER: return "VK_OBJECT_TYPE_BUFFER";
    case ObjectType::e_IMAGE: return "VK_OBJECT_TYPE_IMAGE";
    case ObjectType::e_EVENT: return "VK_OBJECT_TYPE_EVENT";
    case ObjectType::e_QUERY_POOL: return "VK_OBJECT_TYPE_QUERY_POOL";
    case ObjectType::e_BUFFER_VIEW: return "VK_OBJECT_TYPE_BUFFER_VIEW";
    case ObjectType::e_IMAGE_VIEW: return "VK_OBJECT_TYPE_IMAGE_VIEW";
    case ObjectType::e_SHADER_MODULE: return "VK_OBJECT_TYPE_SHADER_MODULE";
    case ObjectType::e_PIPELINE_CACHE: return "VK_OBJECT_TYPE_PIPELINE_CACHE";
    case ObjectType::e_PIPELINE_LAYOUT: return "VK_OBJECT_TYPE_PIPELINE_LAYOUT";
    case ObjectType::e_RENDER_PASS: return "VK_OBJECT_TYPE_RENDER_PASS";
    case ObjectType::e_PIPELINE: return "VK_OBJECT_TYPE_PIPELINE";
    case ObjectType::e_DESCRIPTOR_SET_LAYOUT: return "VK_OBJECT_TYPE_DESCRIPTOR_SET_LAYOUT";
    case ObjectType::e_SAMPLER: return "VK_OBJECT_TYPE_SAMPLER";
    case ObjectType::e_DESCRIPTOR_POOL: return "VK_OBJECT_TYPE_DESCRIPTOR_POOL";
    case ObjectType::e_DESCRIPTOR_SET: return "VK_OBJECT_TYPE_DESCRIPTOR_SET";
    case ObjectType::e_FRAMEBUFFER: return "VK_OBJECT_TYPE_FRAMEBUFFER";
    case ObjectType::e_COMMAND_POOL: return "VK_OBJECT_TYPE_COMMAND_POOL";
    case ObjectType::e_SAMPLER_YCBCR_CONVERSION: return "VK_OBJECT_TYPE_SAMPLER_YCBCR_CONVERSION";
    case ObjectType::e_DESCRIPTOR_UPDATE_TEMPLATE: return "VK_OBJECT_TYPE_DESCRIPTOR_UPDATE_TEMPLATE";
    case ObjectType::e_SURFACE_KHR: return "VK_OBJECT_TYPE_SURFACE_KHR";
    case ObjectType::e_SWAPCHAIN_KHR: return "VK_OBJECT_TYPE_SWAPCHAIN_KHR";
    case ObjectType::e_DISPLAY_KHR: return "VK_OBJECT_TYPE_DISPLAY_KHR";
    case ObjectType::e_DISPLAY_MODE_KHR: return "VK_OBJECT_TYPE_DISPLAY_MODE_KHR";
    case ObjectType::e_DEBUG_REPORT_CALLBACK_EXT: return "VK_OBJECT_TYPE_DEBUG_REPORT_CALLBACK_EXT";
    case ObjectType::e_OBJECT_TABLE_NVX: return "VK_OBJECT_TYPE_OBJECT_TABLE_NVX";
    case ObjectType::e_INDIRECT_COMMANDS_LAYOUT_NVX: return "VK_OBJECT_TYPE_INDIRECT_COMMANDS_LAYOUT_NVX";
    case ObjectType::e_DEBUG_UTILS_MESSENGER_EXT: return "VK_OBJECT_TYPE_DEBUG_UTILS_MESSENGER_EXT";
    case ObjectType::e_VALIDATION_CACHE_EXT: return "VK_OBJECT_TYPE_VALIDATION_CACHE_EXT";
    default: return "invalid";
    }
}

enum class SubgroupFeatureFlags
{
    e_NONE = 0,
    e_BASIC_BIT = VK_SUBGROUP_FEATURE_BASIC_BIT,
    e_VOTE_BIT = VK_SUBGROUP_FEATURE_VOTE_BIT,
    e_ARITHMETIC_BIT = VK_SUBGROUP_FEATURE_ARITHMETIC_BIT,
    e_BALLOT_BIT = VK_SUBGROUP_FEATURE_BALLOT_BIT,
    e_SHUFFLE_BIT = VK_SUBGROUP_FEATURE_SHUFFLE_BIT,
    e_SHUFFLE_RELATIVE_BIT = VK_SUBGROUP_FEATURE_SHUFFLE_RELATIVE_BIT,
    e_CLUSTERED_BIT = VK_SUBGROUP_FEATURE_CLUSTERED_BIT,
    e_QUAD_BIT = VK_SUBGROUP_FEATURE_QUAD_BIT,
    e_PARTITIONED_BIT_NV = VK_SUBGROUP_FEATURE_PARTITIONED_BIT_NV,
    e_MAX_ENUM = 0x7FFFFFFF,
    e_ALL_BITS = e_BASIC_BIT | e_VOTE_BIT | e_ARITHMETIC_BIT | e_BALLOT_BIT | e_SHUFFLE_BIT | e_SHUFFLE_RELATIVE_BIT | e_CLUSTERED_BIT | e_QUAD_BIT | e_PARTITIONED_BIT_NV
};
DEFINE_ENUM_BITWISE_OPERATORS(SubgroupFeatureFlags)
inline std::string to_string(SubgroupFeatureFlags value)
{
    std::string returnString = "";
    bool addedFlags = false;
    if(static_cast<uint32_t>(value & SubgroupFeatureFlags::e_BASIC_BIT) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_SUBGROUP_FEATURE_BASIC_BIT";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & SubgroupFeatureFlags::e_VOTE_BIT) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_SUBGROUP_FEATURE_VOTE_BIT";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & SubgroupFeatureFlags::e_ARITHMETIC_BIT) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_SUBGROUP_FEATURE_ARITHMETIC_BIT";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & SubgroupFeatureFlags::e_BALLOT_BIT) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_SUBGROUP_FEATURE_BALLOT_BIT";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & SubgroupFeatureFlags::e_SHUFFLE_BIT) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_SUBGROUP_FEATURE_SHUFFLE_BIT";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & SubgroupFeatureFlags::e_SHUFFLE_RELATIVE_BIT) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_SUBGROUP_FEATURE_SHUFFLE_RELATIVE_BIT";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & SubgroupFeatureFlags::e_CLUSTERED_BIT) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_SUBGROUP_FEATURE_CLUSTERED_BIT";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & SubgroupFeatureFlags::e_QUAD_BIT) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_SUBGROUP_FEATURE_QUAD_BIT";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & SubgroupFeatureFlags::e_PARTITIONED_BIT_NV) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_SUBGROUP_FEATURE_PARTITIONED_BIT_NV";
        addedFlags = true;
    }
    return returnString;
}

enum class PeerMemoryFeatureFlags
{
    e_NONE = 0,
    e_COPY_SRC_BIT = VK_PEER_MEMORY_FEATURE_COPY_SRC_BIT,
    e_COPY_DST_BIT = VK_PEER_MEMORY_FEATURE_COPY_DST_BIT,
    e_GENERIC_SRC_BIT = VK_PEER_MEMORY_FEATURE_GENERIC_SRC_BIT,
    e_GENERIC_DST_BIT = VK_PEER_MEMORY_FEATURE_GENERIC_DST_BIT,
    e_COPY_SRC_BIT_KHR = VK_PEER_MEMORY_FEATURE_COPY_SRC_BIT_KHR,
    e_COPY_DST_BIT_KHR = VK_PEER_MEMORY_FEATURE_COPY_DST_BIT_KHR,
    e_GENERIC_SRC_BIT_KHR = VK_PEER_MEMORY_FEATURE_GENERIC_SRC_BIT_KHR,
    e_GENERIC_DST_BIT_KHR = VK_PEER_MEMORY_FEATURE_GENERIC_DST_BIT_KHR,
    e_MAX_ENUM = 0x7FFFFFFF,
    e_ALL_BITS = e_COPY_SRC_BIT | e_COPY_DST_BIT | e_GENERIC_SRC_BIT | e_GENERIC_DST_BIT | e_COPY_SRC_BIT_KHR | e_COPY_DST_BIT_KHR | e_GENERIC_SRC_BIT_KHR | e_GENERIC_DST_BIT_KHR
};
DEFINE_ENUM_BITWISE_OPERATORS(PeerMemoryFeatureFlags)
inline std::string to_string(PeerMemoryFeatureFlags value)
{
    std::string returnString = "";
    bool addedFlags = false;
    if(static_cast<uint32_t>(value & PeerMemoryFeatureFlags::e_COPY_SRC_BIT) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_PEER_MEMORY_FEATURE_COPY_SRC_BIT";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & PeerMemoryFeatureFlags::e_COPY_DST_BIT) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_PEER_MEMORY_FEATURE_COPY_DST_BIT";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & PeerMemoryFeatureFlags::e_GENERIC_SRC_BIT) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_PEER_MEMORY_FEATURE_GENERIC_SRC_BIT";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & PeerMemoryFeatureFlags::e_GENERIC_DST_BIT) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_PEER_MEMORY_FEATURE_GENERIC_DST_BIT";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & PeerMemoryFeatureFlags::e_COPY_SRC_BIT_KHR) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_PEER_MEMORY_FEATURE_COPY_SRC_BIT_KHR";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & PeerMemoryFeatureFlags::e_COPY_DST_BIT_KHR) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_PEER_MEMORY_FEATURE_COPY_DST_BIT_KHR";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & PeerMemoryFeatureFlags::e_GENERIC_SRC_BIT_KHR) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_PEER_MEMORY_FEATURE_GENERIC_SRC_BIT_KHR";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & PeerMemoryFeatureFlags::e_GENERIC_DST_BIT_KHR) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_PEER_MEMORY_FEATURE_GENERIC_DST_BIT_KHR";
        addedFlags = true;
    }
    return returnString;
}

enum class MemoryAllocateFlags
{
    e_NONE = 0,
    e_DEVICE_MASK_BIT = VK_MEMORY_ALLOCATE_DEVICE_MASK_BIT,
    e_DEVICE_MASK_BIT_KHR = VK_MEMORY_ALLOCATE_DEVICE_MASK_BIT_KHR,
    e_MAX_ENUM = 0x7FFFFFFF,
    e_ALL_BITS = e_DEVICE_MASK_BIT | e_DEVICE_MASK_BIT_KHR
};
DEFINE_ENUM_BITWISE_OPERATORS(MemoryAllocateFlags)
inline std::string to_string(MemoryAllocateFlags value)
{
    std::string returnString = "";
    bool addedFlags = false;
    if(static_cast<uint32_t>(value & MemoryAllocateFlags::e_DEVICE_MASK_BIT) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_MEMORY_ALLOCATE_DEVICE_MASK_BIT";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & MemoryAllocateFlags::e_DEVICE_MASK_BIT_KHR) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_MEMORY_ALLOCATE_DEVICE_MASK_BIT_KHR";
        addedFlags = true;
    }
    return returnString;
}

enum class PointClippingBehavior
{
    e_NONE = 0,
    e_ALL_CLIP_PLANES = VK_POINT_CLIPPING_BEHAVIOR_ALL_CLIP_PLANES,
    e_USER_CLIP_PLANES_ONLY = VK_POINT_CLIPPING_BEHAVIOR_USER_CLIP_PLANES_ONLY,
    e_ALL_CLIP_PLANES_KHR = VK_POINT_CLIPPING_BEHAVIOR_ALL_CLIP_PLANES_KHR,
    e_USER_CLIP_PLANES_ONLY_KHR = VK_POINT_CLIPPING_BEHAVIOR_USER_CLIP_PLANES_ONLY_KHR,
    e_BEGIN_RANGE = VK_POINT_CLIPPING_BEHAVIOR_BEGIN_RANGE,
    e_END_RANGE = VK_POINT_CLIPPING_BEHAVIOR_END_RANGE,
    e_RANGE_SIZE = VK_POINT_CLIPPING_BEHAVIOR_RANGE_SIZE,
    e_MAX_ENUM = 0x7FFFFFFF

};
DEFINE_ENUM_BITWISE_OPERATORS(PointClippingBehavior)
inline std::string to_string(PointClippingBehavior value)
{
    switch(value)
    {
    case PointClippingBehavior::e_ALL_CLIP_PLANES: return "VK_POINT_CLIPPING_BEHAVIOR_ALL_CLIP_PLANES";
    case PointClippingBehavior::e_USER_CLIP_PLANES_ONLY: return "VK_POINT_CLIPPING_BEHAVIOR_USER_CLIP_PLANES_ONLY";
    default: return "invalid";
    }
}

enum class TessellationDomainOrigin
{
    e_NONE = 0,
    e_UPPER_LEFT = VK_TESSELLATION_DOMAIN_ORIGIN_UPPER_LEFT,
    e_LOWER_LEFT = VK_TESSELLATION_DOMAIN_ORIGIN_LOWER_LEFT,
    e_UPPER_LEFT_KHR = VK_TESSELLATION_DOMAIN_ORIGIN_UPPER_LEFT_KHR,
    e_LOWER_LEFT_KHR = VK_TESSELLATION_DOMAIN_ORIGIN_LOWER_LEFT_KHR,
    e_BEGIN_RANGE = VK_TESSELLATION_DOMAIN_ORIGIN_BEGIN_RANGE,
    e_END_RANGE = VK_TESSELLATION_DOMAIN_ORIGIN_END_RANGE,
    e_RANGE_SIZE = VK_TESSELLATION_DOMAIN_ORIGIN_RANGE_SIZE,
    e_MAX_ENUM = 0x7FFFFFFF

};
DEFINE_ENUM_BITWISE_OPERATORS(TessellationDomainOrigin)
inline std::string to_string(TessellationDomainOrigin value)
{
    switch(value)
    {
    case TessellationDomainOrigin::e_UPPER_LEFT: return "VK_TESSELLATION_DOMAIN_ORIGIN_UPPER_LEFT";
    case TessellationDomainOrigin::e_LOWER_LEFT: return "VK_TESSELLATION_DOMAIN_ORIGIN_LOWER_LEFT";
    default: return "invalid";
    }
}

enum class SamplerYcbcrModelConversion
{
    e_NONE = 0,
    e_RGB_IDENTITY = VK_SAMPLER_YCBCR_MODEL_CONVERSION_RGB_IDENTITY,
    e_YCBCR_IDENTITY = VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_IDENTITY,
    e_YCBCR_709 = VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_709,
    e_YCBCR_601 = VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_601,
    e_YCBCR_2020 = VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_2020,
    e_RGB_IDENTITY_KHR = VK_SAMPLER_YCBCR_MODEL_CONVERSION_RGB_IDENTITY_KHR,
    e_YCBCR_IDENTITY_KHR = VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_IDENTITY_KHR,
    e_YCBCR_709_KHR = VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_709_KHR,
    e_YCBCR_601_KHR = VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_601_KHR,
    e_YCBCR_2020_KHR = VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_2020_KHR,
    e_BEGIN_RANGE = VK_SAMPLER_YCBCR_MODEL_CONVERSION_BEGIN_RANGE,
    e_END_RANGE = VK_SAMPLER_YCBCR_MODEL_CONVERSION_END_RANGE,
    e_RANGE_SIZE = VK_SAMPLER_YCBCR_MODEL_CONVERSION_RANGE_SIZE,
    e_MAX_ENUM = 0x7FFFFFFF

};
DEFINE_ENUM_BITWISE_OPERATORS(SamplerYcbcrModelConversion)
inline std::string to_string(SamplerYcbcrModelConversion value)
{
    switch(value)
    {
    case SamplerYcbcrModelConversion::e_RGB_IDENTITY: return "VK_SAMPLER_YCBCR_MODEL_CONVERSION_RGB_IDENTITY";
    case SamplerYcbcrModelConversion::e_YCBCR_IDENTITY: return "VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_IDENTITY";
    case SamplerYcbcrModelConversion::e_YCBCR_709: return "VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_709";
    case SamplerYcbcrModelConversion::e_YCBCR_601: return "VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_601";
    case SamplerYcbcrModelConversion::e_YCBCR_2020: return "VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_2020";
    default: return "invalid";
    }
}

enum class SamplerYcbcrRange
{
    e_NONE = 0,
    e_ITU_FULL = VK_SAMPLER_YCBCR_RANGE_ITU_FULL,
    e_ITU_NARROW = VK_SAMPLER_YCBCR_RANGE_ITU_NARROW,
    e_ITU_FULL_KHR = VK_SAMPLER_YCBCR_RANGE_ITU_FULL_KHR,
    e_ITU_NARROW_KHR = VK_SAMPLER_YCBCR_RANGE_ITU_NARROW_KHR,
    e_BEGIN_RANGE = VK_SAMPLER_YCBCR_RANGE_BEGIN_RANGE,
    e_END_RANGE = VK_SAMPLER_YCBCR_RANGE_END_RANGE,
    e_RANGE_SIZE = VK_SAMPLER_YCBCR_RANGE_RANGE_SIZE,
    e_MAX_ENUM = 0x7FFFFFFF

};
DEFINE_ENUM_BITWISE_OPERATORS(SamplerYcbcrRange)
inline std::string to_string(SamplerYcbcrRange value)
{
    switch(value)
    {
    case SamplerYcbcrRange::e_ITU_FULL: return "VK_SAMPLER_YCBCR_RANGE_ITU_FULL";
    case SamplerYcbcrRange::e_ITU_NARROW: return "VK_SAMPLER_YCBCR_RANGE_ITU_NARROW";
    default: return "invalid";
    }
}

enum class ChromaLocation
{
    e_NONE = 0,
    e_COSITED_EVEN = VK_CHROMA_LOCATION_COSITED_EVEN,
    e_MIDPOINT = VK_CHROMA_LOCATION_MIDPOINT,
    e_COSITED_EVEN_KHR = VK_CHROMA_LOCATION_COSITED_EVEN_KHR,
    e_MIDPOINT_KHR = VK_CHROMA_LOCATION_MIDPOINT_KHR,
    e_BEGIN_RANGE = VK_CHROMA_LOCATION_BEGIN_RANGE,
    e_END_RANGE = VK_CHROMA_LOCATION_END_RANGE,
    e_RANGE_SIZE = VK_CHROMA_LOCATION_RANGE_SIZE,
    e_MAX_ENUM = 0x7FFFFFFF

};
DEFINE_ENUM_BITWISE_OPERATORS(ChromaLocation)
inline std::string to_string(ChromaLocation value)
{
    switch(value)
    {
    case ChromaLocation::e_COSITED_EVEN: return "VK_CHROMA_LOCATION_COSITED_EVEN";
    case ChromaLocation::e_MIDPOINT: return "VK_CHROMA_LOCATION_MIDPOINT";
    default: return "invalid";
    }
}

enum class DescriptorUpdateTemplateType
{
    e_NONE = 0,
    e_DESCRIPTOR_SET = VK_DESCRIPTOR_UPDATE_TEMPLATE_TYPE_DESCRIPTOR_SET,
    e_PUSH_DESCRIPTORS_KHR = VK_DESCRIPTOR_UPDATE_TEMPLATE_TYPE_PUSH_DESCRIPTORS_KHR,
    e_DESCRIPTOR_SET_KHR = VK_DESCRIPTOR_UPDATE_TEMPLATE_TYPE_DESCRIPTOR_SET_KHR,
    e_BEGIN_RANGE = VK_DESCRIPTOR_UPDATE_TEMPLATE_TYPE_BEGIN_RANGE,
    e_END_RANGE = VK_DESCRIPTOR_UPDATE_TEMPLATE_TYPE_END_RANGE,
    e_RANGE_SIZE = VK_DESCRIPTOR_UPDATE_TEMPLATE_TYPE_RANGE_SIZE,
    e_MAX_ENUM = 0x7FFFFFFF

};
DEFINE_ENUM_BITWISE_OPERATORS(DescriptorUpdateTemplateType)
inline std::string to_string(DescriptorUpdateTemplateType value)
{
    switch(value)
    {
    case DescriptorUpdateTemplateType::e_DESCRIPTOR_SET: return "VK_DESCRIPTOR_UPDATE_TEMPLATE_TYPE_DESCRIPTOR_SET";
    case DescriptorUpdateTemplateType::e_PUSH_DESCRIPTORS_KHR: return "VK_DESCRIPTOR_UPDATE_TEMPLATE_TYPE_PUSH_DESCRIPTORS_KHR";
    default: return "invalid";
    }
}

enum class ExternalMemoryHandleTypeFlags
{
    e_NONE = 0,
    e_OPAQUE_FD_BIT = VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_FD_BIT,
    e_OPAQUE_WIN32_BIT = VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_BIT,
    e_OPAQUE_WIN32_KMT_BIT = VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT,
    e_D3D11_TEXTURE_BIT = VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_TEXTURE_BIT,
    e_D3D11_TEXTURE_KMT_BIT = VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_TEXTURE_KMT_BIT,
    e_D3D12_HEAP_BIT = VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D12_HEAP_BIT,
    e_D3D12_RESOURCE_BIT = VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D12_RESOURCE_BIT,
    e_OPAQUE_FD_BIT_KHR = VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_FD_BIT_KHR,
    e_OPAQUE_WIN32_BIT_KHR = VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_BIT_KHR,
    e_OPAQUE_WIN32_KMT_BIT_KHR = VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT_KHR,
    e_D3D11_TEXTURE_BIT_KHR = VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_TEXTURE_BIT_KHR,
    e_D3D11_TEXTURE_KMT_BIT_KHR = VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_TEXTURE_KMT_BIT_KHR,
    e_D3D12_HEAP_BIT_KHR = VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D12_HEAP_BIT_KHR,
    e_D3D12_RESOURCE_BIT_KHR = VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D12_RESOURCE_BIT_KHR,
    e_DMA_BUF_BIT_EXT = VK_EXTERNAL_MEMORY_HANDLE_TYPE_DMA_BUF_BIT_EXT,
    e_ANDROID_HARDWARE_BUFFER_BIT_ANDROID = VK_EXTERNAL_MEMORY_HANDLE_TYPE_ANDROID_HARDWARE_BUFFER_BIT_ANDROID,
    e_HOST_ALLOCATION_BIT_EXT = VK_EXTERNAL_MEMORY_HANDLE_TYPE_HOST_ALLOCATION_BIT_EXT,
    e_HOST_MAPPED_FOREIGN_MEMORY_BIT_EXT = VK_EXTERNAL_MEMORY_HANDLE_TYPE_HOST_MAPPED_FOREIGN_MEMORY_BIT_EXT,
    e_MAX_ENUM = 0x7FFFFFFF,
    e_ALL_BITS = e_OPAQUE_FD_BIT | e_OPAQUE_WIN32_BIT | e_OPAQUE_WIN32_KMT_BIT | e_D3D11_TEXTURE_BIT | e_D3D11_TEXTURE_KMT_BIT | e_D3D12_HEAP_BIT | e_D3D12_RESOURCE_BIT | e_OPAQUE_FD_BIT_KHR | e_OPAQUE_WIN32_BIT_KHR | e_OPAQUE_WIN32_KMT_BIT_KHR | e_D3D11_TEXTURE_BIT_KHR | e_D3D11_TEXTURE_KMT_BIT_KHR | e_D3D12_HEAP_BIT_KHR | e_D3D12_RESOURCE_BIT_KHR | e_DMA_BUF_BIT_EXT | e_ANDROID_HARDWARE_BUFFER_BIT_ANDROID | e_HOST_ALLOCATION_BIT_EXT | e_HOST_MAPPED_FOREIGN_MEMORY_BIT_EXT
};
DEFINE_ENUM_BITWISE_OPERATORS(ExternalMemoryHandleTypeFlags)
inline std::string to_string(ExternalMemoryHandleTypeFlags value)
{
    std::string returnString = "";
    bool addedFlags = false;
    if(static_cast<uint32_t>(value & ExternalMemoryHandleTypeFlags::e_OPAQUE_FD_BIT) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_FD_BIT";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & ExternalMemoryHandleTypeFlags::e_OPAQUE_WIN32_BIT) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_BIT";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & ExternalMemoryHandleTypeFlags::e_OPAQUE_WIN32_KMT_BIT) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & ExternalMemoryHandleTypeFlags::e_D3D11_TEXTURE_BIT) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_TEXTURE_BIT";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & ExternalMemoryHandleTypeFlags::e_D3D11_TEXTURE_KMT_BIT) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_TEXTURE_KMT_BIT";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & ExternalMemoryHandleTypeFlags::e_D3D12_HEAP_BIT) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D12_HEAP_BIT";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & ExternalMemoryHandleTypeFlags::e_D3D12_RESOURCE_BIT) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D12_RESOURCE_BIT";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & ExternalMemoryHandleTypeFlags::e_OPAQUE_FD_BIT_KHR) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_FD_BIT_KHR";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & ExternalMemoryHandleTypeFlags::e_OPAQUE_WIN32_BIT_KHR) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_BIT_KHR";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & ExternalMemoryHandleTypeFlags::e_OPAQUE_WIN32_KMT_BIT_KHR) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT_KHR";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & ExternalMemoryHandleTypeFlags::e_D3D11_TEXTURE_BIT_KHR) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_TEXTURE_BIT_KHR";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & ExternalMemoryHandleTypeFlags::e_D3D11_TEXTURE_KMT_BIT_KHR) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_TEXTURE_KMT_BIT_KHR";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & ExternalMemoryHandleTypeFlags::e_D3D12_HEAP_BIT_KHR) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D12_HEAP_BIT_KHR";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & ExternalMemoryHandleTypeFlags::e_D3D12_RESOURCE_BIT_KHR) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D12_RESOURCE_BIT_KHR";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & ExternalMemoryHandleTypeFlags::e_DMA_BUF_BIT_EXT) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_EXTERNAL_MEMORY_HANDLE_TYPE_DMA_BUF_BIT_EXT";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & ExternalMemoryHandleTypeFlags::e_ANDROID_HARDWARE_BUFFER_BIT_ANDROID) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_EXTERNAL_MEMORY_HANDLE_TYPE_ANDROID_HARDWARE_BUFFER_BIT_ANDROID";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & ExternalMemoryHandleTypeFlags::e_HOST_ALLOCATION_BIT_EXT) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_EXTERNAL_MEMORY_HANDLE_TYPE_HOST_ALLOCATION_BIT_EXT";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & ExternalMemoryHandleTypeFlags::e_HOST_MAPPED_FOREIGN_MEMORY_BIT_EXT) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_EXTERNAL_MEMORY_HANDLE_TYPE_HOST_MAPPED_FOREIGN_MEMORY_BIT_EXT";
        addedFlags = true;
    }
    return returnString;
}

enum class ExternalMemoryFeatureFlags
{
    e_NONE = 0,
    e_DEDICATED_ONLY_BIT = VK_EXTERNAL_MEMORY_FEATURE_DEDICATED_ONLY_BIT,
    e_EXPORTABLE_BIT = VK_EXTERNAL_MEMORY_FEATURE_EXPORTABLE_BIT,
    e_IMPORTABLE_BIT = VK_EXTERNAL_MEMORY_FEATURE_IMPORTABLE_BIT,
    e_DEDICATED_ONLY_BIT_KHR = VK_EXTERNAL_MEMORY_FEATURE_DEDICATED_ONLY_BIT_KHR,
    e_EXPORTABLE_BIT_KHR = VK_EXTERNAL_MEMORY_FEATURE_EXPORTABLE_BIT_KHR,
    e_IMPORTABLE_BIT_KHR = VK_EXTERNAL_MEMORY_FEATURE_IMPORTABLE_BIT_KHR,
    e_MAX_ENUM = 0x7FFFFFFF,
    e_ALL_BITS = e_DEDICATED_ONLY_BIT | e_EXPORTABLE_BIT | e_IMPORTABLE_BIT | e_DEDICATED_ONLY_BIT_KHR | e_EXPORTABLE_BIT_KHR | e_IMPORTABLE_BIT_KHR
};
DEFINE_ENUM_BITWISE_OPERATORS(ExternalMemoryFeatureFlags)
inline std::string to_string(ExternalMemoryFeatureFlags value)
{
    std::string returnString = "";
    bool addedFlags = false;
    if(static_cast<uint32_t>(value & ExternalMemoryFeatureFlags::e_DEDICATED_ONLY_BIT) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_EXTERNAL_MEMORY_FEATURE_DEDICATED_ONLY_BIT";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & ExternalMemoryFeatureFlags::e_EXPORTABLE_BIT) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_EXTERNAL_MEMORY_FEATURE_EXPORTABLE_BIT";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & ExternalMemoryFeatureFlags::e_IMPORTABLE_BIT) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_EXTERNAL_MEMORY_FEATURE_IMPORTABLE_BIT";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & ExternalMemoryFeatureFlags::e_DEDICATED_ONLY_BIT_KHR) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_EXTERNAL_MEMORY_FEATURE_DEDICATED_ONLY_BIT_KHR";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & ExternalMemoryFeatureFlags::e_EXPORTABLE_BIT_KHR) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_EXTERNAL_MEMORY_FEATURE_EXPORTABLE_BIT_KHR";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & ExternalMemoryFeatureFlags::e_IMPORTABLE_BIT_KHR) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_EXTERNAL_MEMORY_FEATURE_IMPORTABLE_BIT_KHR";
        addedFlags = true;
    }
    return returnString;
}

enum class ExternalFenceHandleTypeFlags
{
    e_NONE = 0,
    e_OPAQUE_FD_BIT = VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_FD_BIT,
    e_OPAQUE_WIN32_BIT = VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_WIN32_BIT,
    e_OPAQUE_WIN32_KMT_BIT = VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT,
    e_SYNC_FD_BIT = VK_EXTERNAL_FENCE_HANDLE_TYPE_SYNC_FD_BIT,
    e_OPAQUE_FD_BIT_KHR = VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_FD_BIT_KHR,
    e_OPAQUE_WIN32_BIT_KHR = VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_WIN32_BIT_KHR,
    e_OPAQUE_WIN32_KMT_BIT_KHR = VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT_KHR,
    e_SYNC_FD_BIT_KHR = VK_EXTERNAL_FENCE_HANDLE_TYPE_SYNC_FD_BIT_KHR,
    e_MAX_ENUM = 0x7FFFFFFF,
    e_ALL_BITS = e_OPAQUE_FD_BIT | e_OPAQUE_WIN32_BIT | e_OPAQUE_WIN32_KMT_BIT | e_SYNC_FD_BIT | e_OPAQUE_FD_BIT_KHR | e_OPAQUE_WIN32_BIT_KHR | e_OPAQUE_WIN32_KMT_BIT_KHR | e_SYNC_FD_BIT_KHR
};
DEFINE_ENUM_BITWISE_OPERATORS(ExternalFenceHandleTypeFlags)
inline std::string to_string(ExternalFenceHandleTypeFlags value)
{
    std::string returnString = "";
    bool addedFlags = false;
    if(static_cast<uint32_t>(value & ExternalFenceHandleTypeFlags::e_OPAQUE_FD_BIT) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_FD_BIT";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & ExternalFenceHandleTypeFlags::e_OPAQUE_WIN32_BIT) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_WIN32_BIT";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & ExternalFenceHandleTypeFlags::e_OPAQUE_WIN32_KMT_BIT) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & ExternalFenceHandleTypeFlags::e_SYNC_FD_BIT) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_EXTERNAL_FENCE_HANDLE_TYPE_SYNC_FD_BIT";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & ExternalFenceHandleTypeFlags::e_OPAQUE_FD_BIT_KHR) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_FD_BIT_KHR";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & ExternalFenceHandleTypeFlags::e_OPAQUE_WIN32_BIT_KHR) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_WIN32_BIT_KHR";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & ExternalFenceHandleTypeFlags::e_OPAQUE_WIN32_KMT_BIT_KHR) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT_KHR";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & ExternalFenceHandleTypeFlags::e_SYNC_FD_BIT_KHR) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_EXTERNAL_FENCE_HANDLE_TYPE_SYNC_FD_BIT_KHR";
        addedFlags = true;
    }
    return returnString;
}

enum class ExternalFenceFeatureFlags
{
    e_NONE = 0,
    e_EXPORTABLE_BIT = VK_EXTERNAL_FENCE_FEATURE_EXPORTABLE_BIT,
    e_IMPORTABLE_BIT = VK_EXTERNAL_FENCE_FEATURE_IMPORTABLE_BIT,
    e_EXPORTABLE_BIT_KHR = VK_EXTERNAL_FENCE_FEATURE_EXPORTABLE_BIT_KHR,
    e_IMPORTABLE_BIT_KHR = VK_EXTERNAL_FENCE_FEATURE_IMPORTABLE_BIT_KHR,
    e_MAX_ENUM = 0x7FFFFFFF,
    e_ALL_BITS = e_EXPORTABLE_BIT | e_IMPORTABLE_BIT | e_EXPORTABLE_BIT_KHR | e_IMPORTABLE_BIT_KHR
};
DEFINE_ENUM_BITWISE_OPERATORS(ExternalFenceFeatureFlags)
inline std::string to_string(ExternalFenceFeatureFlags value)
{
    std::string returnString = "";
    bool addedFlags = false;
    if(static_cast<uint32_t>(value & ExternalFenceFeatureFlags::e_EXPORTABLE_BIT) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_EXTERNAL_FENCE_FEATURE_EXPORTABLE_BIT";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & ExternalFenceFeatureFlags::e_IMPORTABLE_BIT) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_EXTERNAL_FENCE_FEATURE_IMPORTABLE_BIT";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & ExternalFenceFeatureFlags::e_EXPORTABLE_BIT_KHR) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_EXTERNAL_FENCE_FEATURE_EXPORTABLE_BIT_KHR";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & ExternalFenceFeatureFlags::e_IMPORTABLE_BIT_KHR) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_EXTERNAL_FENCE_FEATURE_IMPORTABLE_BIT_KHR";
        addedFlags = true;
    }
    return returnString;
}

enum class FenceImportFlags
{
    e_NONE = 0,
    e_TEMPORARY_BIT = VK_FENCE_IMPORT_TEMPORARY_BIT,
    e_TEMPORARY_BIT_KHR = VK_FENCE_IMPORT_TEMPORARY_BIT_KHR,
    e_MAX_ENUM = 0x7FFFFFFF,
    e_ALL_BITS = e_TEMPORARY_BIT | e_TEMPORARY_BIT_KHR
};
DEFINE_ENUM_BITWISE_OPERATORS(FenceImportFlags)
inline std::string to_string(FenceImportFlags value)
{
    std::string returnString = "";
    bool addedFlags = false;
    if(static_cast<uint32_t>(value & FenceImportFlags::e_TEMPORARY_BIT) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_FENCE_IMPORT_TEMPORARY_BIT";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & FenceImportFlags::e_TEMPORARY_BIT_KHR) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_FENCE_IMPORT_TEMPORARY_BIT_KHR";
        addedFlags = true;
    }
    return returnString;
}

enum class SemaphoreImportFlags
{
    e_NONE = 0,
    e_TEMPORARY_BIT = VK_SEMAPHORE_IMPORT_TEMPORARY_BIT,
    e_TEMPORARY_BIT_KHR = VK_SEMAPHORE_IMPORT_TEMPORARY_BIT_KHR,
    e_MAX_ENUM = 0x7FFFFFFF,
    e_ALL_BITS = e_TEMPORARY_BIT | e_TEMPORARY_BIT_KHR
};
DEFINE_ENUM_BITWISE_OPERATORS(SemaphoreImportFlags)
inline std::string to_string(SemaphoreImportFlags value)
{
    std::string returnString = "";
    bool addedFlags = false;
    if(static_cast<uint32_t>(value & SemaphoreImportFlags::e_TEMPORARY_BIT) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_SEMAPHORE_IMPORT_TEMPORARY_BIT";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & SemaphoreImportFlags::e_TEMPORARY_BIT_KHR) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_SEMAPHORE_IMPORT_TEMPORARY_BIT_KHR";
        addedFlags = true;
    }
    return returnString;
}

enum class ExternalSemaphoreHandleTypeFlags
{
    e_NONE = 0,
    e_OPAQUE_FD_BIT = VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_FD_BIT,
    e_OPAQUE_WIN32_BIT = VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32_BIT,
    e_OPAQUE_WIN32_KMT_BIT = VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT,
    e_D3D12_FENCE_BIT = VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_D3D12_FENCE_BIT,
    e_SYNC_FD_BIT = VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_SYNC_FD_BIT,
    e_OPAQUE_FD_BIT_KHR = VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_FD_BIT_KHR,
    e_OPAQUE_WIN32_BIT_KHR = VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32_BIT_KHR,
    e_OPAQUE_WIN32_KMT_BIT_KHR = VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT_KHR,
    e_D3D12_FENCE_BIT_KHR = VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_D3D12_FENCE_BIT_KHR,
    e_SYNC_FD_BIT_KHR = VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_SYNC_FD_BIT_KHR,
    e_MAX_ENUM = 0x7FFFFFFF,
    e_ALL_BITS = e_OPAQUE_FD_BIT | e_OPAQUE_WIN32_BIT | e_OPAQUE_WIN32_KMT_BIT | e_D3D12_FENCE_BIT | e_SYNC_FD_BIT | e_OPAQUE_FD_BIT_KHR | e_OPAQUE_WIN32_BIT_KHR | e_OPAQUE_WIN32_KMT_BIT_KHR | e_D3D12_FENCE_BIT_KHR | e_SYNC_FD_BIT_KHR
};
DEFINE_ENUM_BITWISE_OPERATORS(ExternalSemaphoreHandleTypeFlags)
inline std::string to_string(ExternalSemaphoreHandleTypeFlags value)
{
    std::string returnString = "";
    bool addedFlags = false;
    if(static_cast<uint32_t>(value & ExternalSemaphoreHandleTypeFlags::e_OPAQUE_FD_BIT) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_FD_BIT";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & ExternalSemaphoreHandleTypeFlags::e_OPAQUE_WIN32_BIT) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32_BIT";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & ExternalSemaphoreHandleTypeFlags::e_OPAQUE_WIN32_KMT_BIT) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & ExternalSemaphoreHandleTypeFlags::e_D3D12_FENCE_BIT) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_D3D12_FENCE_BIT";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & ExternalSemaphoreHandleTypeFlags::e_SYNC_FD_BIT) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_SYNC_FD_BIT";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & ExternalSemaphoreHandleTypeFlags::e_OPAQUE_FD_BIT_KHR) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_FD_BIT_KHR";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & ExternalSemaphoreHandleTypeFlags::e_OPAQUE_WIN32_BIT_KHR) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32_BIT_KHR";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & ExternalSemaphoreHandleTypeFlags::e_OPAQUE_WIN32_KMT_BIT_KHR) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT_KHR";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & ExternalSemaphoreHandleTypeFlags::e_D3D12_FENCE_BIT_KHR) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_D3D12_FENCE_BIT_KHR";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & ExternalSemaphoreHandleTypeFlags::e_SYNC_FD_BIT_KHR) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_SYNC_FD_BIT_KHR";
        addedFlags = true;
    }
    return returnString;
}

enum class ExternalSemaphoreFeatureFlags
{
    e_NONE = 0,
    e_EXPORTABLE_BIT = VK_EXTERNAL_SEMAPHORE_FEATURE_EXPORTABLE_BIT,
    e_IMPORTABLE_BIT = VK_EXTERNAL_SEMAPHORE_FEATURE_IMPORTABLE_BIT,
    e_EXPORTABLE_BIT_KHR = VK_EXTERNAL_SEMAPHORE_FEATURE_EXPORTABLE_BIT_KHR,
    e_IMPORTABLE_BIT_KHR = VK_EXTERNAL_SEMAPHORE_FEATURE_IMPORTABLE_BIT_KHR,
    e_MAX_ENUM = 0x7FFFFFFF,
    e_ALL_BITS = e_EXPORTABLE_BIT | e_IMPORTABLE_BIT | e_EXPORTABLE_BIT_KHR | e_IMPORTABLE_BIT_KHR
};
DEFINE_ENUM_BITWISE_OPERATORS(ExternalSemaphoreFeatureFlags)
inline std::string to_string(ExternalSemaphoreFeatureFlags value)
{
    std::string returnString = "";
    bool addedFlags = false;
    if(static_cast<uint32_t>(value & ExternalSemaphoreFeatureFlags::e_EXPORTABLE_BIT) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_EXTERNAL_SEMAPHORE_FEATURE_EXPORTABLE_BIT";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & ExternalSemaphoreFeatureFlags::e_IMPORTABLE_BIT) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_EXTERNAL_SEMAPHORE_FEATURE_IMPORTABLE_BIT";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & ExternalSemaphoreFeatureFlags::e_EXPORTABLE_BIT_KHR) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_EXTERNAL_SEMAPHORE_FEATURE_EXPORTABLE_BIT_KHR";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & ExternalSemaphoreFeatureFlags::e_IMPORTABLE_BIT_KHR) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_EXTERNAL_SEMAPHORE_FEATURE_IMPORTABLE_BIT_KHR";
        addedFlags = true;
    }
    return returnString;
}

enum class SurfaceTransformFlagsKHR
{
    e_NONE = 0,
    e_IDENTITY_BIT_KHR = VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR,
    e_ROTATE_90_BIT_KHR = VK_SURFACE_TRANSFORM_ROTATE_90_BIT_KHR,
    e_ROTATE_180_BIT_KHR = VK_SURFACE_TRANSFORM_ROTATE_180_BIT_KHR,
    e_ROTATE_270_BIT_KHR = VK_SURFACE_TRANSFORM_ROTATE_270_BIT_KHR,
    e_HORIZONTAL_MIRROR_BIT_KHR = VK_SURFACE_TRANSFORM_HORIZONTAL_MIRROR_BIT_KHR,
    e_HORIZONTAL_MIRROR_ROTATE_90_BIT_KHR = VK_SURFACE_TRANSFORM_HORIZONTAL_MIRROR_ROTATE_90_BIT_KHR,
    e_HORIZONTAL_MIRROR_ROTATE_180_BIT_KHR = VK_SURFACE_TRANSFORM_HORIZONTAL_MIRROR_ROTATE_180_BIT_KHR,
    e_HORIZONTAL_MIRROR_ROTATE_270_BIT_KHR = VK_SURFACE_TRANSFORM_HORIZONTAL_MIRROR_ROTATE_270_BIT_KHR,
    e_INHERIT_BIT_KHR = VK_SURFACE_TRANSFORM_INHERIT_BIT_KHR,
    e_MAX_ENUM = 0x7FFFFFFF,
    e_ALL_BITS = e_IDENTITY_BIT_KHR | e_ROTATE_90_BIT_KHR | e_ROTATE_180_BIT_KHR | e_ROTATE_270_BIT_KHR | e_HORIZONTAL_MIRROR_BIT_KHR | e_HORIZONTAL_MIRROR_ROTATE_90_BIT_KHR | e_HORIZONTAL_MIRROR_ROTATE_180_BIT_KHR | e_HORIZONTAL_MIRROR_ROTATE_270_BIT_KHR | e_INHERIT_BIT_KHR
};
DEFINE_ENUM_BITWISE_OPERATORS(SurfaceTransformFlagsKHR)
inline std::string to_string(SurfaceTransformFlagsKHR value)
{
    std::string returnString = "";
    bool addedFlags = false;
    if(static_cast<uint32_t>(value & SurfaceTransformFlagsKHR::e_IDENTITY_BIT_KHR) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & SurfaceTransformFlagsKHR::e_ROTATE_90_BIT_KHR) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_SURFACE_TRANSFORM_ROTATE_90_BIT_KHR";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & SurfaceTransformFlagsKHR::e_ROTATE_180_BIT_KHR) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_SURFACE_TRANSFORM_ROTATE_180_BIT_KHR";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & SurfaceTransformFlagsKHR::e_ROTATE_270_BIT_KHR) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_SURFACE_TRANSFORM_ROTATE_270_BIT_KHR";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & SurfaceTransformFlagsKHR::e_HORIZONTAL_MIRROR_BIT_KHR) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_SURFACE_TRANSFORM_HORIZONTAL_MIRROR_BIT_KHR";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & SurfaceTransformFlagsKHR::e_HORIZONTAL_MIRROR_ROTATE_90_BIT_KHR) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_SURFACE_TRANSFORM_HORIZONTAL_MIRROR_ROTATE_90_BIT_KHR";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & SurfaceTransformFlagsKHR::e_HORIZONTAL_MIRROR_ROTATE_180_BIT_KHR) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_SURFACE_TRANSFORM_HORIZONTAL_MIRROR_ROTATE_180_BIT_KHR";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & SurfaceTransformFlagsKHR::e_HORIZONTAL_MIRROR_ROTATE_270_BIT_KHR) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_SURFACE_TRANSFORM_HORIZONTAL_MIRROR_ROTATE_270_BIT_KHR";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & SurfaceTransformFlagsKHR::e_INHERIT_BIT_KHR) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_SURFACE_TRANSFORM_INHERIT_BIT_KHR";
        addedFlags = true;
    }
    return returnString;
}

enum class CompositeAlphaFlagsKHR
{
    e_NONE = 0,
    e_OPAQUE_BIT_KHR = VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR,
    e_PRE_MULTIPLIED_BIT_KHR = VK_COMPOSITE_ALPHA_PRE_MULTIPLIED_BIT_KHR,
    e_POST_MULTIPLIED_BIT_KHR = VK_COMPOSITE_ALPHA_POST_MULTIPLIED_BIT_KHR,
    e_INHERIT_BIT_KHR = VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR,
    e_MAX_ENUM = 0x7FFFFFFF,
    e_ALL_BITS = e_OPAQUE_BIT_KHR | e_PRE_MULTIPLIED_BIT_KHR | e_POST_MULTIPLIED_BIT_KHR | e_INHERIT_BIT_KHR
};
DEFINE_ENUM_BITWISE_OPERATORS(CompositeAlphaFlagsKHR)
inline std::string to_string(CompositeAlphaFlagsKHR value)
{
    std::string returnString = "";
    bool addedFlags = false;
    if(static_cast<uint32_t>(value & CompositeAlphaFlagsKHR::e_OPAQUE_BIT_KHR) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & CompositeAlphaFlagsKHR::e_PRE_MULTIPLIED_BIT_KHR) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_COMPOSITE_ALPHA_PRE_MULTIPLIED_BIT_KHR";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & CompositeAlphaFlagsKHR::e_POST_MULTIPLIED_BIT_KHR) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_COMPOSITE_ALPHA_POST_MULTIPLIED_BIT_KHR";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & CompositeAlphaFlagsKHR::e_INHERIT_BIT_KHR) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR";
        addedFlags = true;
    }
    return returnString;
}

enum class ColorSpaceKHR
{
    e_NONE = 0,
    e_SRGB_NONLINEAR_KHR = VK_COLOR_SPACE_SRGB_NONLINEAR_KHR,
    e_DISPLAY_P3_NONLINEAR_EXT = VK_COLOR_SPACE_DISPLAY_P3_NONLINEAR_EXT,
    e_EXTENDED_SRGB_LINEAR_EXT = VK_COLOR_SPACE_EXTENDED_SRGB_LINEAR_EXT,
    e_DCI_P3_LINEAR_EXT = VK_COLOR_SPACE_DCI_P3_LINEAR_EXT,
    e_DCI_P3_NONLINEAR_EXT = VK_COLOR_SPACE_DCI_P3_NONLINEAR_EXT,
    e_BT709_LINEAR_EXT = VK_COLOR_SPACE_BT709_LINEAR_EXT,
    e_BT709_NONLINEAR_EXT = VK_COLOR_SPACE_BT709_NONLINEAR_EXT,
    e_BT2020_LINEAR_EXT = VK_COLOR_SPACE_BT2020_LINEAR_EXT,
    e_HDR10_ST2084_EXT = VK_COLOR_SPACE_HDR10_ST2084_EXT,
    e_DOLBYVISION_EXT = VK_COLOR_SPACE_DOLBYVISION_EXT,
    e_HDR10_HLG_EXT = VK_COLOR_SPACE_HDR10_HLG_EXT,
    e_ADOBERGB_LINEAR_EXT = VK_COLOR_SPACE_ADOBERGB_LINEAR_EXT,
    e_ADOBERGB_NONLINEAR_EXT = VK_COLOR_SPACE_ADOBERGB_NONLINEAR_EXT,
    e_PASS_THROUGH_EXT = VK_COLOR_SPACE_PASS_THROUGH_EXT,
    e_EXTENDED_SRGB_NONLINEAR_EXT = VK_COLOR_SPACE_EXTENDED_SRGB_NONLINEAR_EXT,
    e_BEGIN_RANGE = VK_COLOR_SPACE_BEGIN_RANGE_KHR,
    e_END_RANGE = VK_COLOR_SPACE_END_RANGE_KHR,
    e_RANGE_SIZE = VK_COLOR_SPACE_RANGE_SIZE_KHR,
    e_MAX_ENUM = 0x7FFFFFFF

};
DEFINE_ENUM_BITWISE_OPERATORS(ColorSpaceKHR)
inline std::string to_string(ColorSpaceKHR value)
{
    switch(value)
    {
    case ColorSpaceKHR::e_SRGB_NONLINEAR_KHR: return "VK_COLOR_SPACE_SRGB_NONLINEAR_KHR";
    case ColorSpaceKHR::e_DISPLAY_P3_NONLINEAR_EXT: return "VK_COLOR_SPACE_DISPLAY_P3_NONLINEAR_EXT";
    case ColorSpaceKHR::e_EXTENDED_SRGB_LINEAR_EXT: return "VK_COLOR_SPACE_EXTENDED_SRGB_LINEAR_EXT";
    case ColorSpaceKHR::e_DCI_P3_LINEAR_EXT: return "VK_COLOR_SPACE_DCI_P3_LINEAR_EXT";
    case ColorSpaceKHR::e_DCI_P3_NONLINEAR_EXT: return "VK_COLOR_SPACE_DCI_P3_NONLINEAR_EXT";
    case ColorSpaceKHR::e_BT709_LINEAR_EXT: return "VK_COLOR_SPACE_BT709_LINEAR_EXT";
    case ColorSpaceKHR::e_BT709_NONLINEAR_EXT: return "VK_COLOR_SPACE_BT709_NONLINEAR_EXT";
    case ColorSpaceKHR::e_BT2020_LINEAR_EXT: return "VK_COLOR_SPACE_BT2020_LINEAR_EXT";
    case ColorSpaceKHR::e_HDR10_ST2084_EXT: return "VK_COLOR_SPACE_HDR10_ST2084_EXT";
    case ColorSpaceKHR::e_DOLBYVISION_EXT: return "VK_COLOR_SPACE_DOLBYVISION_EXT";
    case ColorSpaceKHR::e_HDR10_HLG_EXT: return "VK_COLOR_SPACE_HDR10_HLG_EXT";
    case ColorSpaceKHR::e_ADOBERGB_LINEAR_EXT: return "VK_COLOR_SPACE_ADOBERGB_LINEAR_EXT";
    case ColorSpaceKHR::e_ADOBERGB_NONLINEAR_EXT: return "VK_COLOR_SPACE_ADOBERGB_NONLINEAR_EXT";
    case ColorSpaceKHR::e_PASS_THROUGH_EXT: return "VK_COLOR_SPACE_PASS_THROUGH_EXT";
    case ColorSpaceKHR::e_EXTENDED_SRGB_NONLINEAR_EXT: return "VK_COLOR_SPACE_EXTENDED_SRGB_NONLINEAR_EXT";
    default: return "invalid";
    }
}

enum class PresentModeKHR
{
    e_NONE = 0,
    e_IMMEDIATE_KHR = VK_PRESENT_MODE_IMMEDIATE_KHR,
    e_MAILBOX_KHR = VK_PRESENT_MODE_MAILBOX_KHR,
    e_FIFO_KHR = VK_PRESENT_MODE_FIFO_KHR,
    e_FIFO_RELAXED_KHR = VK_PRESENT_MODE_FIFO_RELAXED_KHR,
    e_SHARED_DEMAND_REFRESH_KHR = VK_PRESENT_MODE_SHARED_DEMAND_REFRESH_KHR,
    e_SHARED_CONTINUOUS_REFRESH_KHR = VK_PRESENT_MODE_SHARED_CONTINUOUS_REFRESH_KHR,
    e_BEGIN_RANGE = VK_PRESENT_MODE_BEGIN_RANGE_KHR,
    e_END_RANGE = VK_PRESENT_MODE_END_RANGE_KHR,
    e_RANGE_SIZE = VK_PRESENT_MODE_RANGE_SIZE_KHR,
    e_MAX_ENUM = 0x7FFFFFFF

};
DEFINE_ENUM_BITWISE_OPERATORS(PresentModeKHR)
inline std::string to_string(PresentModeKHR value)
{
    switch(value)
    {
    case PresentModeKHR::e_IMMEDIATE_KHR: return "VK_PRESENT_MODE_IMMEDIATE_KHR";
    case PresentModeKHR::e_MAILBOX_KHR: return "VK_PRESENT_MODE_MAILBOX_KHR";
    case PresentModeKHR::e_FIFO_KHR: return "VK_PRESENT_MODE_FIFO_KHR";
    case PresentModeKHR::e_FIFO_RELAXED_KHR: return "VK_PRESENT_MODE_FIFO_RELAXED_KHR";
    case PresentModeKHR::e_SHARED_DEMAND_REFRESH_KHR: return "VK_PRESENT_MODE_SHARED_DEMAND_REFRESH_KHR";
    case PresentModeKHR::e_SHARED_CONTINUOUS_REFRESH_KHR: return "VK_PRESENT_MODE_SHARED_CONTINUOUS_REFRESH_KHR";
    default: return "invalid";
    }
}

enum class SwapchainCreateFlagsKHR
{
    e_NONE = 0,
    e_SPLIT_INSTANCE_BIND_REGIONS_BIT_KHR = VK_SWAPCHAIN_CREATE_SPLIT_INSTANCE_BIND_REGIONS_BIT_KHR,
    e_PROTECTED_BIT_KHR = VK_SWAPCHAIN_CREATE_PROTECTED_BIT_KHR,
    e_MAX_ENUM = 0x7FFFFFFF,
    e_ALL_BITS = e_SPLIT_INSTANCE_BIND_REGIONS_BIT_KHR | e_PROTECTED_BIT_KHR
};
DEFINE_ENUM_BITWISE_OPERATORS(SwapchainCreateFlagsKHR)
inline std::string to_string(SwapchainCreateFlagsKHR value)
{
    std::string returnString = "";
    bool addedFlags = false;
    if(static_cast<uint32_t>(value & SwapchainCreateFlagsKHR::e_SPLIT_INSTANCE_BIND_REGIONS_BIT_KHR) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_SWAPCHAIN_CREATE_SPLIT_INSTANCE_BIND_REGIONS_BIT_KHR";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & SwapchainCreateFlagsKHR::e_PROTECTED_BIT_KHR) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_SWAPCHAIN_CREATE_PROTECTED_BIT_KHR";
        addedFlags = true;
    }
    return returnString;
}

enum class DeviceGroupPresentModeFlagsKHR
{
    e_NONE = 0,
    e_LOCAL_BIT_KHR = VK_DEVICE_GROUP_PRESENT_MODE_LOCAL_BIT_KHR,
    e_REMOTE_BIT_KHR = VK_DEVICE_GROUP_PRESENT_MODE_REMOTE_BIT_KHR,
    e_SUM_BIT_KHR = VK_DEVICE_GROUP_PRESENT_MODE_SUM_BIT_KHR,
    e_LOCAL_MULTI_DEVICE_BIT_KHR = VK_DEVICE_GROUP_PRESENT_MODE_LOCAL_MULTI_DEVICE_BIT_KHR,
    e_MAX_ENUM = 0x7FFFFFFF,
    e_ALL_BITS = e_LOCAL_BIT_KHR | e_REMOTE_BIT_KHR | e_SUM_BIT_KHR | e_LOCAL_MULTI_DEVICE_BIT_KHR
};
DEFINE_ENUM_BITWISE_OPERATORS(DeviceGroupPresentModeFlagsKHR)
inline std::string to_string(DeviceGroupPresentModeFlagsKHR value)
{
    std::string returnString = "";
    bool addedFlags = false;
    if(static_cast<uint32_t>(value & DeviceGroupPresentModeFlagsKHR::e_LOCAL_BIT_KHR) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_DEVICE_GROUP_PRESENT_MODE_LOCAL_BIT_KHR";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & DeviceGroupPresentModeFlagsKHR::e_REMOTE_BIT_KHR) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_DEVICE_GROUP_PRESENT_MODE_REMOTE_BIT_KHR";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & DeviceGroupPresentModeFlagsKHR::e_SUM_BIT_KHR) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_DEVICE_GROUP_PRESENT_MODE_SUM_BIT_KHR";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & DeviceGroupPresentModeFlagsKHR::e_LOCAL_MULTI_DEVICE_BIT_KHR) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_DEVICE_GROUP_PRESENT_MODE_LOCAL_MULTI_DEVICE_BIT_KHR";
        addedFlags = true;
    }
    return returnString;
}

enum class DisplayPlaneAlphaFlagsKHR
{
    e_NONE = 0,
    e_OPAQUE_BIT_KHR = VK_DISPLAY_PLANE_ALPHA_OPAQUE_BIT_KHR,
    e_GLOBAL_BIT_KHR = VK_DISPLAY_PLANE_ALPHA_GLOBAL_BIT_KHR,
    e_PER_PIXEL_BIT_KHR = VK_DISPLAY_PLANE_ALPHA_PER_PIXEL_BIT_KHR,
    e_PER_PIXEL_PREMULTIPLIED_BIT_KHR = VK_DISPLAY_PLANE_ALPHA_PER_PIXEL_PREMULTIPLIED_BIT_KHR,
    e_MAX_ENUM = 0x7FFFFFFF,
    e_ALL_BITS = e_OPAQUE_BIT_KHR | e_GLOBAL_BIT_KHR | e_PER_PIXEL_BIT_KHR | e_PER_PIXEL_PREMULTIPLIED_BIT_KHR
};
DEFINE_ENUM_BITWISE_OPERATORS(DisplayPlaneAlphaFlagsKHR)
inline std::string to_string(DisplayPlaneAlphaFlagsKHR value)
{
    std::string returnString = "";
    bool addedFlags = false;
    if(static_cast<uint32_t>(value & DisplayPlaneAlphaFlagsKHR::e_OPAQUE_BIT_KHR) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_DISPLAY_PLANE_ALPHA_OPAQUE_BIT_KHR";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & DisplayPlaneAlphaFlagsKHR::e_GLOBAL_BIT_KHR) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_DISPLAY_PLANE_ALPHA_GLOBAL_BIT_KHR";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & DisplayPlaneAlphaFlagsKHR::e_PER_PIXEL_BIT_KHR) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_DISPLAY_PLANE_ALPHA_PER_PIXEL_BIT_KHR";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & DisplayPlaneAlphaFlagsKHR::e_PER_PIXEL_PREMULTIPLIED_BIT_KHR) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_DISPLAY_PLANE_ALPHA_PER_PIXEL_PREMULTIPLIED_BIT_KHR";
        addedFlags = true;
    }
    return returnString;
}

typedef PeerMemoryFeatureFlags PeerMemoryFeatureFlagsKHR;

typedef MemoryAllocateFlags MemoryAllocateFlagsKHR;

typedef ExternalMemoryHandleTypeFlags ExternalMemoryHandleTypeFlagsKHR;

typedef ExternalMemoryFeatureFlags ExternalMemoryFeatureFlagsKHR;

typedef ExternalSemaphoreHandleTypeFlags ExternalSemaphoreHandleTypeFlagsKHR;

typedef ExternalSemaphoreFeatureFlags ExternalSemaphoreFeatureFlagsKHR;

typedef SemaphoreImportFlags SemaphoreImportFlagsKHR;

typedef DescriptorUpdateTemplateType DescriptorUpdateTemplateTypeKHR;

typedef ExternalFenceHandleTypeFlags ExternalFenceHandleTypeFlagsKHR;

typedef ExternalFenceFeatureFlags ExternalFenceFeatureFlagsKHR;

typedef FenceImportFlags FenceImportFlagsKHR;

typedef PointClippingBehavior PointClippingBehaviorKHR;

typedef TessellationDomainOrigin TessellationDomainOriginKHR;

typedef SamplerYcbcrModelConversion SamplerYcbcrModelConversionKHR;

typedef SamplerYcbcrRange SamplerYcbcrRangeKHR;

typedef ChromaLocation ChromaLocationKHR;

enum class DebugReportObjectTypeEXT
{
    e_NONE = 0,
    e_UNKNOWN_EXT = VK_DEBUG_REPORT_OBJECT_TYPE_UNKNOWN_EXT,
    e_INSTANCE_EXT = VK_DEBUG_REPORT_OBJECT_TYPE_INSTANCE_EXT,
    e_PHYSICAL_DEVICE_EXT = VK_DEBUG_REPORT_OBJECT_TYPE_PHYSICAL_DEVICE_EXT,
    e_DEVICE_EXT = VK_DEBUG_REPORT_OBJECT_TYPE_DEVICE_EXT,
    e_QUEUE_EXT = VK_DEBUG_REPORT_OBJECT_TYPE_QUEUE_EXT,
    e_SEMAPHORE_EXT = VK_DEBUG_REPORT_OBJECT_TYPE_SEMAPHORE_EXT,
    e_COMMAND_BUFFER_EXT = VK_DEBUG_REPORT_OBJECT_TYPE_COMMAND_BUFFER_EXT,
    e_FENCE_EXT = VK_DEBUG_REPORT_OBJECT_TYPE_FENCE_EXT,
    e_DEVICE_MEMORY_EXT = VK_DEBUG_REPORT_OBJECT_TYPE_DEVICE_MEMORY_EXT,
    e_BUFFER_EXT = VK_DEBUG_REPORT_OBJECT_TYPE_BUFFER_EXT,
    e_IMAGE_EXT = VK_DEBUG_REPORT_OBJECT_TYPE_IMAGE_EXT,
    e_EVENT_EXT = VK_DEBUG_REPORT_OBJECT_TYPE_EVENT_EXT,
    e_QUERY_POOL_EXT = VK_DEBUG_REPORT_OBJECT_TYPE_QUERY_POOL_EXT,
    e_BUFFER_VIEW_EXT = VK_DEBUG_REPORT_OBJECT_TYPE_BUFFER_VIEW_EXT,
    e_IMAGE_VIEW_EXT = VK_DEBUG_REPORT_OBJECT_TYPE_IMAGE_VIEW_EXT,
    e_SHADER_MODULE_EXT = VK_DEBUG_REPORT_OBJECT_TYPE_SHADER_MODULE_EXT,
    e_PIPELINE_CACHE_EXT = VK_DEBUG_REPORT_OBJECT_TYPE_PIPELINE_CACHE_EXT,
    e_PIPELINE_LAYOUT_EXT = VK_DEBUG_REPORT_OBJECT_TYPE_PIPELINE_LAYOUT_EXT,
    e_RENDER_PASS_EXT = VK_DEBUG_REPORT_OBJECT_TYPE_RENDER_PASS_EXT,
    e_PIPELINE_EXT = VK_DEBUG_REPORT_OBJECT_TYPE_PIPELINE_EXT,
    e_DESCRIPTOR_SET_LAYOUT_EXT = VK_DEBUG_REPORT_OBJECT_TYPE_DESCRIPTOR_SET_LAYOUT_EXT,
    e_SAMPLER_EXT = VK_DEBUG_REPORT_OBJECT_TYPE_SAMPLER_EXT,
    e_DESCRIPTOR_POOL_EXT = VK_DEBUG_REPORT_OBJECT_TYPE_DESCRIPTOR_POOL_EXT,
    e_DESCRIPTOR_SET_EXT = VK_DEBUG_REPORT_OBJECT_TYPE_DESCRIPTOR_SET_EXT,
    e_FRAMEBUFFER_EXT = VK_DEBUG_REPORT_OBJECT_TYPE_FRAMEBUFFER_EXT,
    e_COMMAND_POOL_EXT = VK_DEBUG_REPORT_OBJECT_TYPE_COMMAND_POOL_EXT,
    e_SURFACE_KHR_EXT = VK_DEBUG_REPORT_OBJECT_TYPE_SURFACE_KHR_EXT,
    e_SWAPCHAIN_KHR_EXT = VK_DEBUG_REPORT_OBJECT_TYPE_SWAPCHAIN_KHR_EXT,
    e_DEBUG_REPORT_CALLBACK_EXT_EXT = VK_DEBUG_REPORT_OBJECT_TYPE_DEBUG_REPORT_CALLBACK_EXT_EXT,
    e_DISPLAY_KHR_EXT = VK_DEBUG_REPORT_OBJECT_TYPE_DISPLAY_KHR_EXT,
    e_DISPLAY_MODE_KHR_EXT = VK_DEBUG_REPORT_OBJECT_TYPE_DISPLAY_MODE_KHR_EXT,
    e_OBJECT_TABLE_NVX_EXT = VK_DEBUG_REPORT_OBJECT_TYPE_OBJECT_TABLE_NVX_EXT,
    e_INDIRECT_COMMANDS_LAYOUT_NVX_EXT = VK_DEBUG_REPORT_OBJECT_TYPE_INDIRECT_COMMANDS_LAYOUT_NVX_EXT,
    e_VALIDATION_CACHE_EXT_EXT = VK_DEBUG_REPORT_OBJECT_TYPE_VALIDATION_CACHE_EXT_EXT,
    e_SAMPLER_YCBCR_CONVERSION_EXT = VK_DEBUG_REPORT_OBJECT_TYPE_SAMPLER_YCBCR_CONVERSION_EXT,
    e_DESCRIPTOR_UPDATE_TEMPLATE_EXT = VK_DEBUG_REPORT_OBJECT_TYPE_DESCRIPTOR_UPDATE_TEMPLATE_EXT,
    e_DESCRIPTOR_UPDATE_TEMPLATE_KHR_EXT = VK_DEBUG_REPORT_OBJECT_TYPE_DESCRIPTOR_UPDATE_TEMPLATE_KHR_EXT,
    e_SAMPLER_YCBCR_CONVERSION_KHR_EXT = VK_DEBUG_REPORT_OBJECT_TYPE_SAMPLER_YCBCR_CONVERSION_KHR_EXT,
    e_BEGIN_RANGE = VK_DEBUG_REPORT_OBJECT_TYPE_BEGIN_RANGE_EXT,
    e_END_RANGE = VK_DEBUG_REPORT_OBJECT_TYPE_END_RANGE_EXT,
    e_RANGE_SIZE = VK_DEBUG_REPORT_OBJECT_TYPE_RANGE_SIZE_EXT,
    e_MAX_ENUM = 0x7FFFFFFF

};
DEFINE_ENUM_BITWISE_OPERATORS(DebugReportObjectTypeEXT)
inline std::string to_string(DebugReportObjectTypeEXT value)
{
    switch(value)
    {
    case DebugReportObjectTypeEXT::e_UNKNOWN_EXT: return "VK_DEBUG_REPORT_OBJECT_TYPE_UNKNOWN_EXT";
    case DebugReportObjectTypeEXT::e_INSTANCE_EXT: return "VK_DEBUG_REPORT_OBJECT_TYPE_INSTANCE_EXT";
    case DebugReportObjectTypeEXT::e_PHYSICAL_DEVICE_EXT: return "VK_DEBUG_REPORT_OBJECT_TYPE_PHYSICAL_DEVICE_EXT";
    case DebugReportObjectTypeEXT::e_DEVICE_EXT: return "VK_DEBUG_REPORT_OBJECT_TYPE_DEVICE_EXT";
    case DebugReportObjectTypeEXT::e_QUEUE_EXT: return "VK_DEBUG_REPORT_OBJECT_TYPE_QUEUE_EXT";
    case DebugReportObjectTypeEXT::e_SEMAPHORE_EXT: return "VK_DEBUG_REPORT_OBJECT_TYPE_SEMAPHORE_EXT";
    case DebugReportObjectTypeEXT::e_COMMAND_BUFFER_EXT: return "VK_DEBUG_REPORT_OBJECT_TYPE_COMMAND_BUFFER_EXT";
    case DebugReportObjectTypeEXT::e_FENCE_EXT: return "VK_DEBUG_REPORT_OBJECT_TYPE_FENCE_EXT";
    case DebugReportObjectTypeEXT::e_DEVICE_MEMORY_EXT: return "VK_DEBUG_REPORT_OBJECT_TYPE_DEVICE_MEMORY_EXT";
    case DebugReportObjectTypeEXT::e_BUFFER_EXT: return "VK_DEBUG_REPORT_OBJECT_TYPE_BUFFER_EXT";
    case DebugReportObjectTypeEXT::e_IMAGE_EXT: return "VK_DEBUG_REPORT_OBJECT_TYPE_IMAGE_EXT";
    case DebugReportObjectTypeEXT::e_EVENT_EXT: return "VK_DEBUG_REPORT_OBJECT_TYPE_EVENT_EXT";
    case DebugReportObjectTypeEXT::e_QUERY_POOL_EXT: return "VK_DEBUG_REPORT_OBJECT_TYPE_QUERY_POOL_EXT";
    case DebugReportObjectTypeEXT::e_BUFFER_VIEW_EXT: return "VK_DEBUG_REPORT_OBJECT_TYPE_BUFFER_VIEW_EXT";
    case DebugReportObjectTypeEXT::e_IMAGE_VIEW_EXT: return "VK_DEBUG_REPORT_OBJECT_TYPE_IMAGE_VIEW_EXT";
    case DebugReportObjectTypeEXT::e_SHADER_MODULE_EXT: return "VK_DEBUG_REPORT_OBJECT_TYPE_SHADER_MODULE_EXT";
    case DebugReportObjectTypeEXT::e_PIPELINE_CACHE_EXT: return "VK_DEBUG_REPORT_OBJECT_TYPE_PIPELINE_CACHE_EXT";
    case DebugReportObjectTypeEXT::e_PIPELINE_LAYOUT_EXT: return "VK_DEBUG_REPORT_OBJECT_TYPE_PIPELINE_LAYOUT_EXT";
    case DebugReportObjectTypeEXT::e_RENDER_PASS_EXT: return "VK_DEBUG_REPORT_OBJECT_TYPE_RENDER_PASS_EXT";
    case DebugReportObjectTypeEXT::e_PIPELINE_EXT: return "VK_DEBUG_REPORT_OBJECT_TYPE_PIPELINE_EXT";
    case DebugReportObjectTypeEXT::e_DESCRIPTOR_SET_LAYOUT_EXT: return "VK_DEBUG_REPORT_OBJECT_TYPE_DESCRIPTOR_SET_LAYOUT_EXT";
    case DebugReportObjectTypeEXT::e_SAMPLER_EXT: return "VK_DEBUG_REPORT_OBJECT_TYPE_SAMPLER_EXT";
    case DebugReportObjectTypeEXT::e_DESCRIPTOR_POOL_EXT: return "VK_DEBUG_REPORT_OBJECT_TYPE_DESCRIPTOR_POOL_EXT";
    case DebugReportObjectTypeEXT::e_DESCRIPTOR_SET_EXT: return "VK_DEBUG_REPORT_OBJECT_TYPE_DESCRIPTOR_SET_EXT";
    case DebugReportObjectTypeEXT::e_FRAMEBUFFER_EXT: return "VK_DEBUG_REPORT_OBJECT_TYPE_FRAMEBUFFER_EXT";
    case DebugReportObjectTypeEXT::e_COMMAND_POOL_EXT: return "VK_DEBUG_REPORT_OBJECT_TYPE_COMMAND_POOL_EXT";
    case DebugReportObjectTypeEXT::e_SURFACE_KHR_EXT: return "VK_DEBUG_REPORT_OBJECT_TYPE_SURFACE_KHR_EXT";
    case DebugReportObjectTypeEXT::e_SWAPCHAIN_KHR_EXT: return "VK_DEBUG_REPORT_OBJECT_TYPE_SWAPCHAIN_KHR_EXT";
    case DebugReportObjectTypeEXT::e_DEBUG_REPORT_CALLBACK_EXT_EXT: return "VK_DEBUG_REPORT_OBJECT_TYPE_DEBUG_REPORT_CALLBACK_EXT_EXT";
    case DebugReportObjectTypeEXT::e_DISPLAY_KHR_EXT: return "VK_DEBUG_REPORT_OBJECT_TYPE_DISPLAY_KHR_EXT";
    case DebugReportObjectTypeEXT::e_DISPLAY_MODE_KHR_EXT: return "VK_DEBUG_REPORT_OBJECT_TYPE_DISPLAY_MODE_KHR_EXT";
    case DebugReportObjectTypeEXT::e_OBJECT_TABLE_NVX_EXT: return "VK_DEBUG_REPORT_OBJECT_TYPE_OBJECT_TABLE_NVX_EXT";
    case DebugReportObjectTypeEXT::e_INDIRECT_COMMANDS_LAYOUT_NVX_EXT: return "VK_DEBUG_REPORT_OBJECT_TYPE_INDIRECT_COMMANDS_LAYOUT_NVX_EXT";
    case DebugReportObjectTypeEXT::e_VALIDATION_CACHE_EXT_EXT: return "VK_DEBUG_REPORT_OBJECT_TYPE_VALIDATION_CACHE_EXT_EXT";
    case DebugReportObjectTypeEXT::e_SAMPLER_YCBCR_CONVERSION_EXT: return "VK_DEBUG_REPORT_OBJECT_TYPE_SAMPLER_YCBCR_CONVERSION_EXT";
    case DebugReportObjectTypeEXT::e_DESCRIPTOR_UPDATE_TEMPLATE_EXT: return "VK_DEBUG_REPORT_OBJECT_TYPE_DESCRIPTOR_UPDATE_TEMPLATE_EXT";
    default: return "invalid";
    }
}

enum class DebugReportFlagsEXT
{
    e_NONE = 0,
    e_INFORMATION_BIT_EXT = VK_DEBUG_REPORT_INFORMATION_BIT_EXT,
    e_WARNING_BIT_EXT = VK_DEBUG_REPORT_WARNING_BIT_EXT,
    e_PERFORMANCE_WARNING_BIT_EXT = VK_DEBUG_REPORT_PERFORMANCE_WARNING_BIT_EXT,
    e_ERROR_BIT_EXT = VK_DEBUG_REPORT_ERROR_BIT_EXT,
    e_DEBUG_BIT_EXT = VK_DEBUG_REPORT_DEBUG_BIT_EXT,
    e_MAX_ENUM = 0x7FFFFFFF,
    e_ALL_BITS = e_INFORMATION_BIT_EXT | e_WARNING_BIT_EXT | e_PERFORMANCE_WARNING_BIT_EXT | e_ERROR_BIT_EXT | e_DEBUG_BIT_EXT
};
DEFINE_ENUM_BITWISE_OPERATORS(DebugReportFlagsEXT)
inline std::string to_string(DebugReportFlagsEXT value)
{
    std::string returnString = "";
    bool addedFlags = false;
    if(static_cast<uint32_t>(value & DebugReportFlagsEXT::e_INFORMATION_BIT_EXT) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_DEBUG_REPORT_INFORMATION_BIT_EXT";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & DebugReportFlagsEXT::e_WARNING_BIT_EXT) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_DEBUG_REPORT_WARNING_BIT_EXT";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & DebugReportFlagsEXT::e_PERFORMANCE_WARNING_BIT_EXT) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_DEBUG_REPORT_PERFORMANCE_WARNING_BIT_EXT";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & DebugReportFlagsEXT::e_ERROR_BIT_EXT) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_DEBUG_REPORT_ERROR_BIT_EXT";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & DebugReportFlagsEXT::e_DEBUG_BIT_EXT) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_DEBUG_REPORT_DEBUG_BIT_EXT";
        addedFlags = true;
    }
    return returnString;
}

enum class RasterizationOrderAMD
{
    e_NONE = 0,
    e_STRICT_AMD = VK_RASTERIZATION_ORDER_STRICT_AMD,
    e_RELAXED_AMD = VK_RASTERIZATION_ORDER_RELAXED_AMD,
    e_BEGIN_RANGE = VK_RASTERIZATION_ORDER_BEGIN_RANGE_AMD,
    e_END_RANGE = VK_RASTERIZATION_ORDER_END_RANGE_AMD,
    e_RANGE_SIZE = VK_RASTERIZATION_ORDER_RANGE_SIZE_AMD,
    e_MAX_ENUM = 0x7FFFFFFF

};
DEFINE_ENUM_BITWISE_OPERATORS(RasterizationOrderAMD)
inline std::string to_string(RasterizationOrderAMD value)
{
    switch(value)
    {
    case RasterizationOrderAMD::e_STRICT_AMD: return "VK_RASTERIZATION_ORDER_STRICT_AMD";
    case RasterizationOrderAMD::e_RELAXED_AMD: return "VK_RASTERIZATION_ORDER_RELAXED_AMD";
    default: return "invalid";
    }
}

enum class ShaderInfoTypeAMD
{
    e_NONE = 0,
    e_STATISTICS_AMD = VK_SHADER_INFO_TYPE_STATISTICS_AMD,
    e_BINARY_AMD = VK_SHADER_INFO_TYPE_BINARY_AMD,
    e_DISASSEMBLY_AMD = VK_SHADER_INFO_TYPE_DISASSEMBLY_AMD,
    e_BEGIN_RANGE = VK_SHADER_INFO_TYPE_BEGIN_RANGE_AMD,
    e_END_RANGE = VK_SHADER_INFO_TYPE_END_RANGE_AMD,
    e_RANGE_SIZE = VK_SHADER_INFO_TYPE_RANGE_SIZE_AMD,
    e_MAX_ENUM = 0x7FFFFFFF

};
DEFINE_ENUM_BITWISE_OPERATORS(ShaderInfoTypeAMD)
inline std::string to_string(ShaderInfoTypeAMD value)
{
    switch(value)
    {
    case ShaderInfoTypeAMD::e_STATISTICS_AMD: return "VK_SHADER_INFO_TYPE_STATISTICS_AMD";
    case ShaderInfoTypeAMD::e_BINARY_AMD: return "VK_SHADER_INFO_TYPE_BINARY_AMD";
    case ShaderInfoTypeAMD::e_DISASSEMBLY_AMD: return "VK_SHADER_INFO_TYPE_DISASSEMBLY_AMD";
    default: return "invalid";
    }
}

enum class ExternalMemoryHandleTypeFlagsNV
{
    e_NONE = 0,
    e_OPAQUE_WIN32_BIT_NV = VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_BIT_NV,
    e_OPAQUE_WIN32_KMT_BIT_NV = VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT_NV,
    e_D3D11_IMAGE_BIT_NV = VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_IMAGE_BIT_NV,
    e_D3D11_IMAGE_KMT_BIT_NV = VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_IMAGE_KMT_BIT_NV,
    e_MAX_ENUM = 0x7FFFFFFF,
    e_ALL_BITS = e_OPAQUE_WIN32_BIT_NV | e_OPAQUE_WIN32_KMT_BIT_NV | e_D3D11_IMAGE_BIT_NV | e_D3D11_IMAGE_KMT_BIT_NV
};
DEFINE_ENUM_BITWISE_OPERATORS(ExternalMemoryHandleTypeFlagsNV)
inline std::string to_string(ExternalMemoryHandleTypeFlagsNV value)
{
    std::string returnString = "";
    bool addedFlags = false;
    if(static_cast<uint32_t>(value & ExternalMemoryHandleTypeFlagsNV::e_OPAQUE_WIN32_BIT_NV) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_BIT_NV";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & ExternalMemoryHandleTypeFlagsNV::e_OPAQUE_WIN32_KMT_BIT_NV) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT_NV";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & ExternalMemoryHandleTypeFlagsNV::e_D3D11_IMAGE_BIT_NV) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_IMAGE_BIT_NV";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & ExternalMemoryHandleTypeFlagsNV::e_D3D11_IMAGE_KMT_BIT_NV) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_IMAGE_KMT_BIT_NV";
        addedFlags = true;
    }
    return returnString;
}

enum class ExternalMemoryFeatureFlagsNV
{
    e_NONE = 0,
    e_DEDICATED_ONLY_BIT_NV = VK_EXTERNAL_MEMORY_FEATURE_DEDICATED_ONLY_BIT_NV,
    e_EXPORTABLE_BIT_NV = VK_EXTERNAL_MEMORY_FEATURE_EXPORTABLE_BIT_NV,
    e_IMPORTABLE_BIT_NV = VK_EXTERNAL_MEMORY_FEATURE_IMPORTABLE_BIT_NV,
    e_MAX_ENUM = 0x7FFFFFFF,
    e_ALL_BITS = e_DEDICATED_ONLY_BIT_NV | e_EXPORTABLE_BIT_NV | e_IMPORTABLE_BIT_NV
};
DEFINE_ENUM_BITWISE_OPERATORS(ExternalMemoryFeatureFlagsNV)
inline std::string to_string(ExternalMemoryFeatureFlagsNV value)
{
    std::string returnString = "";
    bool addedFlags = false;
    if(static_cast<uint32_t>(value & ExternalMemoryFeatureFlagsNV::e_DEDICATED_ONLY_BIT_NV) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_EXTERNAL_MEMORY_FEATURE_DEDICATED_ONLY_BIT_NV";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & ExternalMemoryFeatureFlagsNV::e_EXPORTABLE_BIT_NV) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_EXTERNAL_MEMORY_FEATURE_EXPORTABLE_BIT_NV";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & ExternalMemoryFeatureFlagsNV::e_IMPORTABLE_BIT_NV) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_EXTERNAL_MEMORY_FEATURE_IMPORTABLE_BIT_NV";
        addedFlags = true;
    }
    return returnString;
}

enum class ValidationCheckEXT
{
    e_NONE = 0,
    e_ALL_EXT = VK_VALIDATION_CHECK_ALL_EXT,
    e_SHADERS_EXT = VK_VALIDATION_CHECK_SHADERS_EXT,
    e_BEGIN_RANGE = VK_VALIDATION_CHECK_BEGIN_RANGE_EXT,
    e_END_RANGE = VK_VALIDATION_CHECK_END_RANGE_EXT,
    e_RANGE_SIZE = VK_VALIDATION_CHECK_RANGE_SIZE_EXT,
    e_MAX_ENUM = 0x7FFFFFFF

};
DEFINE_ENUM_BITWISE_OPERATORS(ValidationCheckEXT)
inline std::string to_string(ValidationCheckEXT value)
{
    switch(value)
    {
    case ValidationCheckEXT::e_ALL_EXT: return "VK_VALIDATION_CHECK_ALL_EXT";
    case ValidationCheckEXT::e_SHADERS_EXT: return "VK_VALIDATION_CHECK_SHADERS_EXT";
    default: return "invalid";
    }
}

enum class IndirectCommandsLayoutUsageFlagsNVX
{
    e_NONE = 0,
    e_UNORDERED_SEQUENCES_BIT_NVX = VK_INDIRECT_COMMANDS_LAYOUT_USAGE_UNORDERED_SEQUENCES_BIT_NVX,
    e_SPARSE_SEQUENCES_BIT_NVX = VK_INDIRECT_COMMANDS_LAYOUT_USAGE_SPARSE_SEQUENCES_BIT_NVX,
    e_EMPTY_EXECUTIONS_BIT_NVX = VK_INDIRECT_COMMANDS_LAYOUT_USAGE_EMPTY_EXECUTIONS_BIT_NVX,
    e_INDEXED_SEQUENCES_BIT_NVX = VK_INDIRECT_COMMANDS_LAYOUT_USAGE_INDEXED_SEQUENCES_BIT_NVX,
    e_MAX_ENUM = 0x7FFFFFFF,
    e_ALL_BITS = e_UNORDERED_SEQUENCES_BIT_NVX | e_SPARSE_SEQUENCES_BIT_NVX | e_EMPTY_EXECUTIONS_BIT_NVX | e_INDEXED_SEQUENCES_BIT_NVX
};
DEFINE_ENUM_BITWISE_OPERATORS(IndirectCommandsLayoutUsageFlagsNVX)
inline std::string to_string(IndirectCommandsLayoutUsageFlagsNVX value)
{
    std::string returnString = "";
    bool addedFlags = false;
    if(static_cast<uint32_t>(value & IndirectCommandsLayoutUsageFlagsNVX::e_UNORDERED_SEQUENCES_BIT_NVX) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_INDIRECT_COMMANDS_LAYOUT_USAGE_UNORDERED_SEQUENCES_BIT_NVX";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & IndirectCommandsLayoutUsageFlagsNVX::e_SPARSE_SEQUENCES_BIT_NVX) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_INDIRECT_COMMANDS_LAYOUT_USAGE_SPARSE_SEQUENCES_BIT_NVX";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & IndirectCommandsLayoutUsageFlagsNVX::e_EMPTY_EXECUTIONS_BIT_NVX) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_INDIRECT_COMMANDS_LAYOUT_USAGE_EMPTY_EXECUTIONS_BIT_NVX";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & IndirectCommandsLayoutUsageFlagsNVX::e_INDEXED_SEQUENCES_BIT_NVX) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_INDIRECT_COMMANDS_LAYOUT_USAGE_INDEXED_SEQUENCES_BIT_NVX";
        addedFlags = true;
    }
    return returnString;
}

enum class ObjectEntryUsageFlagsNVX
{
    e_NONE = 0,
    e_GRAPHICS_BIT_NVX = VK_OBJECT_ENTRY_USAGE_GRAPHICS_BIT_NVX,
    e_COMPUTE_BIT_NVX = VK_OBJECT_ENTRY_USAGE_COMPUTE_BIT_NVX,
    e_MAX_ENUM = 0x7FFFFFFF,
    e_ALL_BITS = e_GRAPHICS_BIT_NVX | e_COMPUTE_BIT_NVX
};
DEFINE_ENUM_BITWISE_OPERATORS(ObjectEntryUsageFlagsNVX)
inline std::string to_string(ObjectEntryUsageFlagsNVX value)
{
    std::string returnString = "";
    bool addedFlags = false;
    if(static_cast<uint32_t>(value & ObjectEntryUsageFlagsNVX::e_GRAPHICS_BIT_NVX) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_OBJECT_ENTRY_USAGE_GRAPHICS_BIT_NVX";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & ObjectEntryUsageFlagsNVX::e_COMPUTE_BIT_NVX) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_OBJECT_ENTRY_USAGE_COMPUTE_BIT_NVX";
        addedFlags = true;
    }
    return returnString;
}

enum class IndirectCommandsTokenTypeNVX
{
    e_NONE = 0,
    e_PIPELINE_NVX = VK_INDIRECT_COMMANDS_TOKEN_TYPE_PIPELINE_NVX,
    e_DESCRIPTOR_SET_NVX = VK_INDIRECT_COMMANDS_TOKEN_TYPE_DESCRIPTOR_SET_NVX,
    e_INDEX_BUFFER_NVX = VK_INDIRECT_COMMANDS_TOKEN_TYPE_INDEX_BUFFER_NVX,
    e_VERTEX_BUFFER_NVX = VK_INDIRECT_COMMANDS_TOKEN_TYPE_VERTEX_BUFFER_NVX,
    e_PUSH_CONSTANT_NVX = VK_INDIRECT_COMMANDS_TOKEN_TYPE_PUSH_CONSTANT_NVX,
    e_DRAW_INDEXED_NVX = VK_INDIRECT_COMMANDS_TOKEN_TYPE_DRAW_INDEXED_NVX,
    e_DRAW_NVX = VK_INDIRECT_COMMANDS_TOKEN_TYPE_DRAW_NVX,
    e_DISPATCH_NVX = VK_INDIRECT_COMMANDS_TOKEN_TYPE_DISPATCH_NVX,
    e_BEGIN_RANGE = VK_INDIRECT_COMMANDS_TOKEN_TYPE_BEGIN_RANGE_NVX,
    e_END_RANGE = VK_INDIRECT_COMMANDS_TOKEN_TYPE_END_RANGE_NVX,
    e_RANGE_SIZE = VK_INDIRECT_COMMANDS_TOKEN_TYPE_RANGE_SIZE_NVX,
    e_MAX_ENUM = 0x7FFFFFFF

};
DEFINE_ENUM_BITWISE_OPERATORS(IndirectCommandsTokenTypeNVX)
inline std::string to_string(IndirectCommandsTokenTypeNVX value)
{
    switch(value)
    {
    case IndirectCommandsTokenTypeNVX::e_PIPELINE_NVX: return "VK_INDIRECT_COMMANDS_TOKEN_TYPE_PIPELINE_NVX";
    case IndirectCommandsTokenTypeNVX::e_DESCRIPTOR_SET_NVX: return "VK_INDIRECT_COMMANDS_TOKEN_TYPE_DESCRIPTOR_SET_NVX";
    case IndirectCommandsTokenTypeNVX::e_INDEX_BUFFER_NVX: return "VK_INDIRECT_COMMANDS_TOKEN_TYPE_INDEX_BUFFER_NVX";
    case IndirectCommandsTokenTypeNVX::e_VERTEX_BUFFER_NVX: return "VK_INDIRECT_COMMANDS_TOKEN_TYPE_VERTEX_BUFFER_NVX";
    case IndirectCommandsTokenTypeNVX::e_PUSH_CONSTANT_NVX: return "VK_INDIRECT_COMMANDS_TOKEN_TYPE_PUSH_CONSTANT_NVX";
    case IndirectCommandsTokenTypeNVX::e_DRAW_INDEXED_NVX: return "VK_INDIRECT_COMMANDS_TOKEN_TYPE_DRAW_INDEXED_NVX";
    case IndirectCommandsTokenTypeNVX::e_DRAW_NVX: return "VK_INDIRECT_COMMANDS_TOKEN_TYPE_DRAW_NVX";
    case IndirectCommandsTokenTypeNVX::e_DISPATCH_NVX: return "VK_INDIRECT_COMMANDS_TOKEN_TYPE_DISPATCH_NVX";
    default: return "invalid";
    }
}

enum class ObjectEntryTypeNVX
{
    e_NONE = 0,
    e_DESCRIPTOR_SET_NVX = VK_OBJECT_ENTRY_TYPE_DESCRIPTOR_SET_NVX,
    e_PIPELINE_NVX = VK_OBJECT_ENTRY_TYPE_PIPELINE_NVX,
    e_INDEX_BUFFER_NVX = VK_OBJECT_ENTRY_TYPE_INDEX_BUFFER_NVX,
    e_VERTEX_BUFFER_NVX = VK_OBJECT_ENTRY_TYPE_VERTEX_BUFFER_NVX,
    e_PUSH_CONSTANT_NVX = VK_OBJECT_ENTRY_TYPE_PUSH_CONSTANT_NVX,
    e_BEGIN_RANGE = VK_OBJECT_ENTRY_TYPE_BEGIN_RANGE_NVX,
    e_END_RANGE = VK_OBJECT_ENTRY_TYPE_END_RANGE_NVX,
    e_RANGE_SIZE = VK_OBJECT_ENTRY_TYPE_RANGE_SIZE_NVX,
    e_MAX_ENUM = 0x7FFFFFFF

};
DEFINE_ENUM_BITWISE_OPERATORS(ObjectEntryTypeNVX)
inline std::string to_string(ObjectEntryTypeNVX value)
{
    switch(value)
    {
    case ObjectEntryTypeNVX::e_DESCRIPTOR_SET_NVX: return "VK_OBJECT_ENTRY_TYPE_DESCRIPTOR_SET_NVX";
    case ObjectEntryTypeNVX::e_PIPELINE_NVX: return "VK_OBJECT_ENTRY_TYPE_PIPELINE_NVX";
    case ObjectEntryTypeNVX::e_INDEX_BUFFER_NVX: return "VK_OBJECT_ENTRY_TYPE_INDEX_BUFFER_NVX";
    case ObjectEntryTypeNVX::e_VERTEX_BUFFER_NVX: return "VK_OBJECT_ENTRY_TYPE_VERTEX_BUFFER_NVX";
    case ObjectEntryTypeNVX::e_PUSH_CONSTANT_NVX: return "VK_OBJECT_ENTRY_TYPE_PUSH_CONSTANT_NVX";
    default: return "invalid";
    }
}

enum class SurfaceCounterFlagsEXT
{
    e_NONE = 0,
    e_VBLANK_EXT = VK_SURFACE_COUNTER_VBLANK_EXT,
    e_MAX_ENUM = 0x7FFFFFFF,
    e_ALL_BITS = e_VBLANK_EXT
};
DEFINE_ENUM_BITWISE_OPERATORS(SurfaceCounterFlagsEXT)
inline std::string to_string(SurfaceCounterFlagsEXT value)
{
    std::string returnString = "";
    bool addedFlags = false;
    if(static_cast<uint32_t>(value & SurfaceCounterFlagsEXT::e_VBLANK_EXT) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_SURFACE_COUNTER_VBLANK_EXT";
        addedFlags = true;
    }
    return returnString;
}

enum class DisplayPowerStateEXT
{
    e_NONE = 0,
    e_OFF_EXT = VK_DISPLAY_POWER_STATE_OFF_EXT,
    e_SUSPEND_EXT = VK_DISPLAY_POWER_STATE_SUSPEND_EXT,
    e_ON_EXT = VK_DISPLAY_POWER_STATE_ON_EXT,
    e_BEGIN_RANGE = VK_DISPLAY_POWER_STATE_BEGIN_RANGE_EXT,
    e_END_RANGE = VK_DISPLAY_POWER_STATE_END_RANGE_EXT,
    e_RANGE_SIZE = VK_DISPLAY_POWER_STATE_RANGE_SIZE_EXT,
    e_MAX_ENUM = 0x7FFFFFFF

};
DEFINE_ENUM_BITWISE_OPERATORS(DisplayPowerStateEXT)
inline std::string to_string(DisplayPowerStateEXT value)
{
    switch(value)
    {
    case DisplayPowerStateEXT::e_OFF_EXT: return "VK_DISPLAY_POWER_STATE_OFF_EXT";
    case DisplayPowerStateEXT::e_SUSPEND_EXT: return "VK_DISPLAY_POWER_STATE_SUSPEND_EXT";
    case DisplayPowerStateEXT::e_ON_EXT: return "VK_DISPLAY_POWER_STATE_ON_EXT";
    default: return "invalid";
    }
}

enum class DeviceEventTypeEXT
{
    e_NONE = 0,
    e_DISPLAY_HOTPLUG_EXT = VK_DEVICE_EVENT_TYPE_DISPLAY_HOTPLUG_EXT,
    e_BEGIN_RANGE = VK_DEVICE_EVENT_TYPE_BEGIN_RANGE_EXT,
    e_END_RANGE = VK_DEVICE_EVENT_TYPE_END_RANGE_EXT,
    e_RANGE_SIZE = VK_DEVICE_EVENT_TYPE_RANGE_SIZE_EXT,
    e_MAX_ENUM = 0x7FFFFFFF

};
DEFINE_ENUM_BITWISE_OPERATORS(DeviceEventTypeEXT)
inline std::string to_string(DeviceEventTypeEXT value)
{
    switch(value)
    {
    case DeviceEventTypeEXT::e_DISPLAY_HOTPLUG_EXT: return "VK_DEVICE_EVENT_TYPE_DISPLAY_HOTPLUG_EXT";
    default: return "invalid";
    }
}

enum class DisplayEventTypeEXT
{
    e_NONE = 0,
    e_FIRST_PIXEL_OUT_EXT = VK_DISPLAY_EVENT_TYPE_FIRST_PIXEL_OUT_EXT,
    e_BEGIN_RANGE = VK_DISPLAY_EVENT_TYPE_BEGIN_RANGE_EXT,
    e_END_RANGE = VK_DISPLAY_EVENT_TYPE_END_RANGE_EXT,
    e_RANGE_SIZE = VK_DISPLAY_EVENT_TYPE_RANGE_SIZE_EXT,
    e_MAX_ENUM = 0x7FFFFFFF

};
DEFINE_ENUM_BITWISE_OPERATORS(DisplayEventTypeEXT)
inline std::string to_string(DisplayEventTypeEXT value)
{
    switch(value)
    {
    case DisplayEventTypeEXT::e_FIRST_PIXEL_OUT_EXT: return "VK_DISPLAY_EVENT_TYPE_FIRST_PIXEL_OUT_EXT";
    default: return "invalid";
    }
}

enum class ViewportCoordinateSwizzleNV
{
    e_NONE = 0,
    e_POSITIVE_X_NV = VK_VIEWPORT_COORDINATE_SWIZZLE_POSITIVE_X_NV,
    e_NEGATIVE_X_NV = VK_VIEWPORT_COORDINATE_SWIZZLE_NEGATIVE_X_NV,
    e_POSITIVE_Y_NV = VK_VIEWPORT_COORDINATE_SWIZZLE_POSITIVE_Y_NV,
    e_NEGATIVE_Y_NV = VK_VIEWPORT_COORDINATE_SWIZZLE_NEGATIVE_Y_NV,
    e_POSITIVE_Z_NV = VK_VIEWPORT_COORDINATE_SWIZZLE_POSITIVE_Z_NV,
    e_NEGATIVE_Z_NV = VK_VIEWPORT_COORDINATE_SWIZZLE_NEGATIVE_Z_NV,
    e_POSITIVE_W_NV = VK_VIEWPORT_COORDINATE_SWIZZLE_POSITIVE_W_NV,
    e_NEGATIVE_W_NV = VK_VIEWPORT_COORDINATE_SWIZZLE_NEGATIVE_W_NV,
    e_BEGIN_RANGE = VK_VIEWPORT_COORDINATE_SWIZZLE_BEGIN_RANGE_NV,
    e_END_RANGE = VK_VIEWPORT_COORDINATE_SWIZZLE_END_RANGE_NV,
    e_RANGE_SIZE = VK_VIEWPORT_COORDINATE_SWIZZLE_RANGE_SIZE_NV,
    e_MAX_ENUM = 0x7FFFFFFF

};
DEFINE_ENUM_BITWISE_OPERATORS(ViewportCoordinateSwizzleNV)
inline std::string to_string(ViewportCoordinateSwizzleNV value)
{
    switch(value)
    {
    case ViewportCoordinateSwizzleNV::e_POSITIVE_X_NV: return "VK_VIEWPORT_COORDINATE_SWIZZLE_POSITIVE_X_NV";
    case ViewportCoordinateSwizzleNV::e_NEGATIVE_X_NV: return "VK_VIEWPORT_COORDINATE_SWIZZLE_NEGATIVE_X_NV";
    case ViewportCoordinateSwizzleNV::e_POSITIVE_Y_NV: return "VK_VIEWPORT_COORDINATE_SWIZZLE_POSITIVE_Y_NV";
    case ViewportCoordinateSwizzleNV::e_NEGATIVE_Y_NV: return "VK_VIEWPORT_COORDINATE_SWIZZLE_NEGATIVE_Y_NV";
    case ViewportCoordinateSwizzleNV::e_POSITIVE_Z_NV: return "VK_VIEWPORT_COORDINATE_SWIZZLE_POSITIVE_Z_NV";
    case ViewportCoordinateSwizzleNV::e_NEGATIVE_Z_NV: return "VK_VIEWPORT_COORDINATE_SWIZZLE_NEGATIVE_Z_NV";
    case ViewportCoordinateSwizzleNV::e_POSITIVE_W_NV: return "VK_VIEWPORT_COORDINATE_SWIZZLE_POSITIVE_W_NV";
    case ViewportCoordinateSwizzleNV::e_NEGATIVE_W_NV: return "VK_VIEWPORT_COORDINATE_SWIZZLE_NEGATIVE_W_NV";
    default: return "invalid";
    }
}

enum class DiscardRectangleModeEXT
{
    e_NONE = 0,
    e_INCLUSIVE_EXT = VK_DISCARD_RECTANGLE_MODE_INCLUSIVE_EXT,
    e_EXCLUSIVE_EXT = VK_DISCARD_RECTANGLE_MODE_EXCLUSIVE_EXT,
    e_BEGIN_RANGE = VK_DISCARD_RECTANGLE_MODE_BEGIN_RANGE_EXT,
    e_END_RANGE = VK_DISCARD_RECTANGLE_MODE_END_RANGE_EXT,
    e_RANGE_SIZE = VK_DISCARD_RECTANGLE_MODE_RANGE_SIZE_EXT,
    e_MAX_ENUM = 0x7FFFFFFF

};
DEFINE_ENUM_BITWISE_OPERATORS(DiscardRectangleModeEXT)
inline std::string to_string(DiscardRectangleModeEXT value)
{
    switch(value)
    {
    case DiscardRectangleModeEXT::e_INCLUSIVE_EXT: return "VK_DISCARD_RECTANGLE_MODE_INCLUSIVE_EXT";
    case DiscardRectangleModeEXT::e_EXCLUSIVE_EXT: return "VK_DISCARD_RECTANGLE_MODE_EXCLUSIVE_EXT";
    default: return "invalid";
    }
}

enum class ConservativeRasterizationModeEXT
{
    e_NONE = 0,
    e_DISABLED_EXT = VK_CONSERVATIVE_RASTERIZATION_MODE_DISABLED_EXT,
    e_OVERESTIMATE_EXT = VK_CONSERVATIVE_RASTERIZATION_MODE_OVERESTIMATE_EXT,
    e_UNDERESTIMATE_EXT = VK_CONSERVATIVE_RASTERIZATION_MODE_UNDERESTIMATE_EXT,
    e_BEGIN_RANGE = VK_CONSERVATIVE_RASTERIZATION_MODE_BEGIN_RANGE_EXT,
    e_END_RANGE = VK_CONSERVATIVE_RASTERIZATION_MODE_END_RANGE_EXT,
    e_RANGE_SIZE = VK_CONSERVATIVE_RASTERIZATION_MODE_RANGE_SIZE_EXT,
    e_MAX_ENUM = 0x7FFFFFFF

};
DEFINE_ENUM_BITWISE_OPERATORS(ConservativeRasterizationModeEXT)
inline std::string to_string(ConservativeRasterizationModeEXT value)
{
    switch(value)
    {
    case ConservativeRasterizationModeEXT::e_DISABLED_EXT: return "VK_CONSERVATIVE_RASTERIZATION_MODE_DISABLED_EXT";
    case ConservativeRasterizationModeEXT::e_OVERESTIMATE_EXT: return "VK_CONSERVATIVE_RASTERIZATION_MODE_OVERESTIMATE_EXT";
    case ConservativeRasterizationModeEXT::e_UNDERESTIMATE_EXT: return "VK_CONSERVATIVE_RASTERIZATION_MODE_UNDERESTIMATE_EXT";
    default: return "invalid";
    }
}

enum class DebugUtilsMessageSeverityFlagsEXT
{
    e_NONE = 0,
    e_VERBOSE_BIT_EXT = VK_DEBUG_UTILS_MESSAGE_SEVERITY_VERBOSE_BIT_EXT,
    e_INFO_BIT_EXT = VK_DEBUG_UTILS_MESSAGE_SEVERITY_INFO_BIT_EXT,
    e_WARNING_BIT_EXT = VK_DEBUG_UTILS_MESSAGE_SEVERITY_WARNING_BIT_EXT,
    e_ERROR_BIT_EXT = VK_DEBUG_UTILS_MESSAGE_SEVERITY_ERROR_BIT_EXT,
    e_MAX_ENUM = 0x7FFFFFFF,
    e_ALL_BITS = e_VERBOSE_BIT_EXT | e_INFO_BIT_EXT | e_WARNING_BIT_EXT | e_ERROR_BIT_EXT
};
DEFINE_ENUM_BITWISE_OPERATORS(DebugUtilsMessageSeverityFlagsEXT)
inline std::string to_string(DebugUtilsMessageSeverityFlagsEXT value)
{
    std::string returnString = "";
    bool addedFlags = false;
    if(static_cast<uint32_t>(value & DebugUtilsMessageSeverityFlagsEXT::e_VERBOSE_BIT_EXT) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_DEBUG_UTILS_MESSAGE_SEVERITY_VERBOSE_BIT_EXT";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & DebugUtilsMessageSeverityFlagsEXT::e_INFO_BIT_EXT) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_DEBUG_UTILS_MESSAGE_SEVERITY_INFO_BIT_EXT";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & DebugUtilsMessageSeverityFlagsEXT::e_WARNING_BIT_EXT) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_DEBUG_UTILS_MESSAGE_SEVERITY_WARNING_BIT_EXT";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & DebugUtilsMessageSeverityFlagsEXT::e_ERROR_BIT_EXT) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_DEBUG_UTILS_MESSAGE_SEVERITY_ERROR_BIT_EXT";
        addedFlags = true;
    }
    return returnString;
}

enum class DebugUtilsMessageTypeFlagsEXT
{
    e_NONE = 0,
    e_GENERAL_BIT_EXT = VK_DEBUG_UTILS_MESSAGE_TYPE_GENERAL_BIT_EXT,
    e_VALIDATION_BIT_EXT = VK_DEBUG_UTILS_MESSAGE_TYPE_VALIDATION_BIT_EXT,
    e_PERFORMANCE_BIT_EXT = VK_DEBUG_UTILS_MESSAGE_TYPE_PERFORMANCE_BIT_EXT,
    e_MAX_ENUM = 0x7FFFFFFF,
    e_ALL_BITS = e_GENERAL_BIT_EXT | e_VALIDATION_BIT_EXT | e_PERFORMANCE_BIT_EXT
};
DEFINE_ENUM_BITWISE_OPERATORS(DebugUtilsMessageTypeFlagsEXT)
inline std::string to_string(DebugUtilsMessageTypeFlagsEXT value)
{
    std::string returnString = "";
    bool addedFlags = false;
    if(static_cast<uint32_t>(value & DebugUtilsMessageTypeFlagsEXT::e_GENERAL_BIT_EXT) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_DEBUG_UTILS_MESSAGE_TYPE_GENERAL_BIT_EXT";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & DebugUtilsMessageTypeFlagsEXT::e_VALIDATION_BIT_EXT) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_DEBUG_UTILS_MESSAGE_TYPE_VALIDATION_BIT_EXT";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & DebugUtilsMessageTypeFlagsEXT::e_PERFORMANCE_BIT_EXT) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_DEBUG_UTILS_MESSAGE_TYPE_PERFORMANCE_BIT_EXT";
        addedFlags = true;
    }
    return returnString;
}

enum class SamplerReductionModeEXT
{
    e_NONE = 0,
    e_WEIGHTED_AVERAGE_EXT = VK_SAMPLER_REDUCTION_MODE_WEIGHTED_AVERAGE_EXT,
    e_MIN_EXT = VK_SAMPLER_REDUCTION_MODE_MIN_EXT,
    e_MAX_EXT = VK_SAMPLER_REDUCTION_MODE_MAX_EXT,
    e_BEGIN_RANGE = VK_SAMPLER_REDUCTION_MODE_BEGIN_RANGE_EXT,
    e_END_RANGE = VK_SAMPLER_REDUCTION_MODE_END_RANGE_EXT,
    e_RANGE_SIZE = VK_SAMPLER_REDUCTION_MODE_RANGE_SIZE_EXT,
    e_MAX_ENUM = 0x7FFFFFFF

};
DEFINE_ENUM_BITWISE_OPERATORS(SamplerReductionModeEXT)
inline std::string to_string(SamplerReductionModeEXT value)
{
    switch(value)
    {
    case SamplerReductionModeEXT::e_WEIGHTED_AVERAGE_EXT: return "VK_SAMPLER_REDUCTION_MODE_WEIGHTED_AVERAGE_EXT";
    case SamplerReductionModeEXT::e_MIN_EXT: return "VK_SAMPLER_REDUCTION_MODE_MIN_EXT";
    case SamplerReductionModeEXT::e_MAX_EXT: return "VK_SAMPLER_REDUCTION_MODE_MAX_EXT";
    default: return "invalid";
    }
}

enum class BlendOverlapEXT
{
    e_NONE = 0,
    e_UNCORRELATED_EXT = VK_BLEND_OVERLAP_UNCORRELATED_EXT,
    e_DISJOINT_EXT = VK_BLEND_OVERLAP_DISJOINT_EXT,
    e_CONJOINT_EXT = VK_BLEND_OVERLAP_CONJOINT_EXT,
    e_BEGIN_RANGE = VK_BLEND_OVERLAP_BEGIN_RANGE_EXT,
    e_END_RANGE = VK_BLEND_OVERLAP_END_RANGE_EXT,
    e_RANGE_SIZE = VK_BLEND_OVERLAP_RANGE_SIZE_EXT,
    e_MAX_ENUM = 0x7FFFFFFF

};
DEFINE_ENUM_BITWISE_OPERATORS(BlendOverlapEXT)
inline std::string to_string(BlendOverlapEXT value)
{
    switch(value)
    {
    case BlendOverlapEXT::e_UNCORRELATED_EXT: return "VK_BLEND_OVERLAP_UNCORRELATED_EXT";
    case BlendOverlapEXT::e_DISJOINT_EXT: return "VK_BLEND_OVERLAP_DISJOINT_EXT";
    case BlendOverlapEXT::e_CONJOINT_EXT: return "VK_BLEND_OVERLAP_CONJOINT_EXT";
    default: return "invalid";
    }
}

enum class CoverageModulationModeNV
{
    e_NONE = 0,
    e_NONE_NV = VK_COVERAGE_MODULATION_MODE_NONE_NV,
    e_RGB_NV = VK_COVERAGE_MODULATION_MODE_RGB_NV,
    e_ALPHA_NV = VK_COVERAGE_MODULATION_MODE_ALPHA_NV,
    e_RGBA_NV = VK_COVERAGE_MODULATION_MODE_RGBA_NV,
    e_BEGIN_RANGE = VK_COVERAGE_MODULATION_MODE_BEGIN_RANGE_NV,
    e_END_RANGE = VK_COVERAGE_MODULATION_MODE_END_RANGE_NV,
    e_RANGE_SIZE = VK_COVERAGE_MODULATION_MODE_RANGE_SIZE_NV,
    e_MAX_ENUM = 0x7FFFFFFF

};
DEFINE_ENUM_BITWISE_OPERATORS(CoverageModulationModeNV)
inline std::string to_string(CoverageModulationModeNV value)
{
    switch(value)
    {
    case CoverageModulationModeNV::e_NONE_NV: return "VK_COVERAGE_MODULATION_MODE_NONE_NV";
    case CoverageModulationModeNV::e_RGB_NV: return "VK_COVERAGE_MODULATION_MODE_RGB_NV";
    case CoverageModulationModeNV::e_ALPHA_NV: return "VK_COVERAGE_MODULATION_MODE_ALPHA_NV";
    case CoverageModulationModeNV::e_RGBA_NV: return "VK_COVERAGE_MODULATION_MODE_RGBA_NV";
    default: return "invalid";
    }
}

enum class ValidationCacheHeaderVersionEXT
{
    e_NONE = 0,
    e_ONE_EXT = VK_VALIDATION_CACHE_HEADER_VERSION_ONE_EXT,
    e_BEGIN_RANGE = VK_VALIDATION_CACHE_HEADER_VERSION_BEGIN_RANGE_EXT,
    e_END_RANGE = VK_VALIDATION_CACHE_HEADER_VERSION_END_RANGE_EXT,
    e_RANGE_SIZE = VK_VALIDATION_CACHE_HEADER_VERSION_RANGE_SIZE_EXT,
    e_MAX_ENUM = 0x7FFFFFFF

};
DEFINE_ENUM_BITWISE_OPERATORS(ValidationCacheHeaderVersionEXT)
inline std::string to_string(ValidationCacheHeaderVersionEXT value)
{
    switch(value)
    {
    case ValidationCacheHeaderVersionEXT::e_ONE_EXT: return "VK_VALIDATION_CACHE_HEADER_VERSION_ONE_EXT";
    default: return "invalid";
    }
}

enum class DescriptorBindingFlagsEXT
{
    e_NONE = 0,
    e_UPDATE_AFTER_BIND_BIT_EXT = VK_DESCRIPTOR_BINDING_UPDATE_AFTER_BIND_BIT_EXT,
    e_UPDATE_UNUSED_WHILE_PENDING_BIT_EXT = VK_DESCRIPTOR_BINDING_UPDATE_UNUSED_WHILE_PENDING_BIT_EXT,
    e_PARTIALLY_BOUND_BIT_EXT = VK_DESCRIPTOR_BINDING_PARTIALLY_BOUND_BIT_EXT,
    e_VARIABLE_DESCRIPTOR_COUNT_BIT_EXT = VK_DESCRIPTOR_BINDING_VARIABLE_DESCRIPTOR_COUNT_BIT_EXT,
    e_MAX_ENUM = 0x7FFFFFFF,
    e_ALL_BITS = e_UPDATE_AFTER_BIND_BIT_EXT | e_UPDATE_UNUSED_WHILE_PENDING_BIT_EXT | e_PARTIALLY_BOUND_BIT_EXT | e_VARIABLE_DESCRIPTOR_COUNT_BIT_EXT
};
DEFINE_ENUM_BITWISE_OPERATORS(DescriptorBindingFlagsEXT)
inline std::string to_string(DescriptorBindingFlagsEXT value)
{
    std::string returnString = "";
    bool addedFlags = false;
    if(static_cast<uint32_t>(value & DescriptorBindingFlagsEXT::e_UPDATE_AFTER_BIND_BIT_EXT) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_DESCRIPTOR_BINDING_UPDATE_AFTER_BIND_BIT_EXT";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & DescriptorBindingFlagsEXT::e_UPDATE_UNUSED_WHILE_PENDING_BIT_EXT) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_DESCRIPTOR_BINDING_UPDATE_UNUSED_WHILE_PENDING_BIT_EXT";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & DescriptorBindingFlagsEXT::e_PARTIALLY_BOUND_BIT_EXT) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_DESCRIPTOR_BINDING_PARTIALLY_BOUND_BIT_EXT";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & DescriptorBindingFlagsEXT::e_VARIABLE_DESCRIPTOR_COUNT_BIT_EXT) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_DESCRIPTOR_BINDING_VARIABLE_DESCRIPTOR_COUNT_BIT_EXT";
        addedFlags = true;
    }
    return returnString;
}

enum class QueueGlobalPriorityEXT
{
    e_NONE = 0,
    e_LOW_EXT = VK_QUEUE_GLOBAL_PRIORITY_LOW_EXT,
    e_MEDIUM_EXT = VK_QUEUE_GLOBAL_PRIORITY_MEDIUM_EXT,
    e_HIGH_EXT = VK_QUEUE_GLOBAL_PRIORITY_HIGH_EXT,
    e_REALTIME_EXT = VK_QUEUE_GLOBAL_PRIORITY_REALTIME_EXT,
    e_BEGIN_RANGE = VK_QUEUE_GLOBAL_PRIORITY_BEGIN_RANGE_EXT,
    e_END_RANGE = VK_QUEUE_GLOBAL_PRIORITY_END_RANGE_EXT,
    e_RANGE_SIZE = VK_QUEUE_GLOBAL_PRIORITY_RANGE_SIZE_EXT,
    e_MAX_ENUM = 0x7FFFFFFF

};
DEFINE_ENUM_BITWISE_OPERATORS(QueueGlobalPriorityEXT)
inline std::string to_string(QueueGlobalPriorityEXT value)
{
    switch(value)
    {
    case QueueGlobalPriorityEXT::e_LOW_EXT: return "VK_QUEUE_GLOBAL_PRIORITY_LOW_EXT";
    case QueueGlobalPriorityEXT::e_MEDIUM_EXT: return "VK_QUEUE_GLOBAL_PRIORITY_MEDIUM_EXT";
    case QueueGlobalPriorityEXT::e_HIGH_EXT: return "VK_QUEUE_GLOBAL_PRIORITY_HIGH_EXT";
    case QueueGlobalPriorityEXT::e_REALTIME_EXT: return "VK_QUEUE_GLOBAL_PRIORITY_REALTIME_EXT";
    default: return "invalid";
    }
}




// PVRVk Structures
struct AllocationCallbacks : private VkAllocationCallbacks
{
    AllocationCallbacks()
    {
        pUserData = nullptr;
        setPfnAllocation(PFN_vkAllocationFunction());
        setPfnReallocation(PFN_vkReallocationFunction());
        setPfnFree(PFN_vkFreeFunction());
        setPfnInternalAllocation(PFN_vkInternalAllocationNotification());
        setPfnInternalFree(PFN_vkInternalFreeNotification());
    }
    AllocationCallbacks(void* pUserData, const PFN_vkAllocationFunction& pfnAllocation, const PFN_vkReallocationFunction& pfnReallocation, const PFN_vkFreeFunction& pfnFree, const PFN_vkInternalAllocationNotification& pfnInternalAllocation, const PFN_vkInternalFreeNotification& pfnInternalFree)
    {
        setPUserData(pUserData);
        setPfnAllocation(pfnAllocation);
        setPfnReallocation(pfnReallocation);
        setPfnFree(pfnFree);
        setPfnInternalAllocation(pfnInternalAllocation);
        setPfnInternalFree(pfnInternalFree);
    }
    inline const void* getPUserData() const { return pUserData; }
    inline void setPUserData(void* pUserData) { this->pUserData = pUserData; }
    inline const PFN_vkAllocationFunction& getPfnAllocation() const { return pfnAllocation; }
    inline void setPfnAllocation(const PFN_vkAllocationFunction& pfnAllocation) { this->pfnAllocation = pfnAllocation; }
    inline const PFN_vkReallocationFunction& getPfnReallocation() const { return pfnReallocation; }
    inline void setPfnReallocation(const PFN_vkReallocationFunction& pfnReallocation) { this->pfnReallocation = pfnReallocation; }
    inline const PFN_vkFreeFunction& getPfnFree() const { return pfnFree; }
    inline void setPfnFree(const PFN_vkFreeFunction& pfnFree) { this->pfnFree = pfnFree; }
    inline const PFN_vkInternalAllocationNotification& getPfnInternalAllocation() const { return pfnInternalAllocation; }
    inline void setPfnInternalAllocation(const PFN_vkInternalAllocationNotification& pfnInternalAllocation) { this->pfnInternalAllocation = pfnInternalAllocation; }
    inline const PFN_vkInternalFreeNotification& getPfnInternalFree() const { return pfnInternalFree; }
    inline void setPfnInternalFree(const PFN_vkInternalFreeNotification& pfnInternalFree) { this->pfnInternalFree = pfnInternalFree; }
};

struct PhysicalDeviceFeatures : private VkPhysicalDeviceFeatures
{
    PhysicalDeviceFeatures()
    {
        setRobustBufferAccess(VkBool32());
        setFullDrawIndexUint32(VkBool32());
        setImageCubeArray(VkBool32());
        setIndependentBlend(VkBool32());
        setGeometryShader(VkBool32());
        setTessellationShader(VkBool32());
        setSampleRateShading(VkBool32());
        setDualSrcBlend(VkBool32());
        setLogicOp(VkBool32());
        setMultiDrawIndirect(VkBool32());
        setDrawIndirectFirstInstance(VkBool32());
        setDepthClamp(VkBool32());
        setDepthBiasClamp(VkBool32());
        setFillModeNonSolid(VkBool32());
        setDepthBounds(VkBool32());
        setWideLines(VkBool32());
        setLargePoints(VkBool32());
        setAlphaToOne(VkBool32());
        setMultiViewport(VkBool32());
        setSamplerAnisotropy(VkBool32());
        setTextureCompressionETC2(VkBool32());
        setTextureCompressionASTC_LDR(VkBool32());
        setTextureCompressionBC(VkBool32());
        setOcclusionQueryPrecise(VkBool32());
        setPipelineStatisticsQuery(VkBool32());
        setVertexPipelineStoresAndAtomics(VkBool32());
        setFragmentStoresAndAtomics(VkBool32());
        setShaderTessellationAndGeometryPointSize(VkBool32());
        setShaderImageGatherExtended(VkBool32());
        setShaderStorageImageExtendedFormats(VkBool32());
        setShaderStorageImageMultisample(VkBool32());
        setShaderStorageImageReadWithoutFormat(VkBool32());
        setShaderStorageImageWriteWithoutFormat(VkBool32());
        setShaderUniformBufferArrayDynamicIndexing(VkBool32());
        setShaderSampledImageArrayDynamicIndexing(VkBool32());
        setShaderStorageBufferArrayDynamicIndexing(VkBool32());
        setShaderStorageImageArrayDynamicIndexing(VkBool32());
        setShaderClipDistance(VkBool32());
        setShaderCullDistance(VkBool32());
        setShaderFloat64(VkBool32());
        setShaderInt64(VkBool32());
        setShaderInt16(VkBool32());
        setShaderResourceResidency(VkBool32());
        setShaderResourceMinLod(VkBool32());
        setSparseBinding(VkBool32());
        setSparseResidencyBuffer(VkBool32());
        setSparseResidencyImage2D(VkBool32());
        setSparseResidencyImage3D(VkBool32());
        setSparseResidency2Samples(VkBool32());
        setSparseResidency4Samples(VkBool32());
        setSparseResidency8Samples(VkBool32());
        setSparseResidency16Samples(VkBool32());
        setSparseResidencyAliased(VkBool32());
        setVariableMultisampleRate(VkBool32());
        setInheritedQueries(VkBool32());
    }
    PhysicalDeviceFeatures(VkBool32 robustBufferAccess, VkBool32 fullDrawIndexUint32, VkBool32 imageCubeArray, VkBool32 independentBlend, VkBool32 geometryShader, VkBool32 tessellationShader, VkBool32 sampleRateShading, VkBool32 dualSrcBlend, VkBool32 logicOp, VkBool32 multiDrawIndirect, VkBool32 drawIndirectFirstInstance, VkBool32 depthClamp, VkBool32 depthBiasClamp, VkBool32 fillModeNonSolid, VkBool32 depthBounds, VkBool32 wideLines, VkBool32 largePoints, VkBool32 alphaToOne, VkBool32 multiViewport, VkBool32 samplerAnisotropy, VkBool32 textureCompressionETC2, VkBool32 textureCompressionASTC_LDR, VkBool32 textureCompressionBC, VkBool32 occlusionQueryPrecise, VkBool32 pipelineStatisticsQuery, VkBool32 vertexPipelineStoresAndAtomics, VkBool32 fragmentStoresAndAtomics, VkBool32 shaderTessellationAndGeometryPointSize, VkBool32 shaderImageGatherExtended, VkBool32 shaderStorageImageExtendedFormats, VkBool32 shaderStorageImageMultisample, VkBool32 shaderStorageImageReadWithoutFormat, VkBool32 shaderStorageImageWriteWithoutFormat, VkBool32 shaderUniformBufferArrayDynamicIndexing, VkBool32 shaderSampledImageArrayDynamicIndexing, VkBool32 shaderStorageBufferArrayDynamicIndexing, VkBool32 shaderStorageImageArrayDynamicIndexing, VkBool32 shaderClipDistance, VkBool32 shaderCullDistance, VkBool32 shaderFloat64, VkBool32 shaderInt64, VkBool32 shaderInt16, VkBool32 shaderResourceResidency, VkBool32 shaderResourceMinLod, VkBool32 sparseBinding, VkBool32 sparseResidencyBuffer, VkBool32 sparseResidencyImage2D, VkBool32 sparseResidencyImage3D, VkBool32 sparseResidency2Samples, VkBool32 sparseResidency4Samples, VkBool32 sparseResidency8Samples, VkBool32 sparseResidency16Samples, VkBool32 sparseResidencyAliased, VkBool32 variableMultisampleRate, VkBool32 inheritedQueries)
    {
        setRobustBufferAccess(robustBufferAccess);
        setFullDrawIndexUint32(fullDrawIndexUint32);
        setImageCubeArray(imageCubeArray);
        setIndependentBlend(independentBlend);
        setGeometryShader(geometryShader);
        setTessellationShader(tessellationShader);
        setSampleRateShading(sampleRateShading);
        setDualSrcBlend(dualSrcBlend);
        setLogicOp(logicOp);
        setMultiDrawIndirect(multiDrawIndirect);
        setDrawIndirectFirstInstance(drawIndirectFirstInstance);
        setDepthClamp(depthClamp);
        setDepthBiasClamp(depthBiasClamp);
        setFillModeNonSolid(fillModeNonSolid);
        setDepthBounds(depthBounds);
        setWideLines(wideLines);
        setLargePoints(largePoints);
        setAlphaToOne(alphaToOne);
        setMultiViewport(multiViewport);
        setSamplerAnisotropy(samplerAnisotropy);
        setTextureCompressionETC2(textureCompressionETC2);
        setTextureCompressionASTC_LDR(textureCompressionASTC_LDR);
        setTextureCompressionBC(textureCompressionBC);
        setOcclusionQueryPrecise(occlusionQueryPrecise);
        setPipelineStatisticsQuery(pipelineStatisticsQuery);
        setVertexPipelineStoresAndAtomics(vertexPipelineStoresAndAtomics);
        setFragmentStoresAndAtomics(fragmentStoresAndAtomics);
        setShaderTessellationAndGeometryPointSize(shaderTessellationAndGeometryPointSize);
        setShaderImageGatherExtended(shaderImageGatherExtended);
        setShaderStorageImageExtendedFormats(shaderStorageImageExtendedFormats);
        setShaderStorageImageMultisample(shaderStorageImageMultisample);
        setShaderStorageImageReadWithoutFormat(shaderStorageImageReadWithoutFormat);
        setShaderStorageImageWriteWithoutFormat(shaderStorageImageWriteWithoutFormat);
        setShaderUniformBufferArrayDynamicIndexing(shaderUniformBufferArrayDynamicIndexing);
        setShaderSampledImageArrayDynamicIndexing(shaderSampledImageArrayDynamicIndexing);
        setShaderStorageBufferArrayDynamicIndexing(shaderStorageBufferArrayDynamicIndexing);
        setShaderStorageImageArrayDynamicIndexing(shaderStorageImageArrayDynamicIndexing);
        setShaderClipDistance(shaderClipDistance);
        setShaderCullDistance(shaderCullDistance);
        setShaderFloat64(shaderFloat64);
        setShaderInt64(shaderInt64);
        setShaderInt16(shaderInt16);
        setShaderResourceResidency(shaderResourceResidency);
        setShaderResourceMinLod(shaderResourceMinLod);
        setSparseBinding(sparseBinding);
        setSparseResidencyBuffer(sparseResidencyBuffer);
        setSparseResidencyImage2D(sparseResidencyImage2D);
        setSparseResidencyImage3D(sparseResidencyImage3D);
        setSparseResidency2Samples(sparseResidency2Samples);
        setSparseResidency4Samples(sparseResidency4Samples);
        setSparseResidency8Samples(sparseResidency8Samples);
        setSparseResidency16Samples(sparseResidency16Samples);
        setSparseResidencyAliased(sparseResidencyAliased);
        setVariableMultisampleRate(variableMultisampleRate);
        setInheritedQueries(inheritedQueries);
    }
    inline VkBool32 getRobustBufferAccess() const { return robustBufferAccess; }
    inline void setRobustBufferAccess(VkBool32 robustBufferAccess) { this->robustBufferAccess = robustBufferAccess; }
    inline VkBool32 getFullDrawIndexUint32() const { return fullDrawIndexUint32; }
    inline void setFullDrawIndexUint32(VkBool32 fullDrawIndexUint32) { this->fullDrawIndexUint32 = fullDrawIndexUint32; }
    inline VkBool32 getImageCubeArray() const { return imageCubeArray; }
    inline void setImageCubeArray(VkBool32 imageCubeArray) { this->imageCubeArray = imageCubeArray; }
    inline VkBool32 getIndependentBlend() const { return independentBlend; }
    inline void setIndependentBlend(VkBool32 independentBlend) { this->independentBlend = independentBlend; }
    inline VkBool32 getGeometryShader() const { return geometryShader; }
    inline void setGeometryShader(VkBool32 geometryShader) { this->geometryShader = geometryShader; }
    inline VkBool32 getTessellationShader() const { return tessellationShader; }
    inline void setTessellationShader(VkBool32 tessellationShader) { this->tessellationShader = tessellationShader; }
    inline VkBool32 getSampleRateShading() const { return sampleRateShading; }
    inline void setSampleRateShading(VkBool32 sampleRateShading) { this->sampleRateShading = sampleRateShading; }
    inline VkBool32 getDualSrcBlend() const { return dualSrcBlend; }
    inline void setDualSrcBlend(VkBool32 dualSrcBlend) { this->dualSrcBlend = dualSrcBlend; }
    inline VkBool32 getLogicOp() const { return logicOp; }
    inline void setLogicOp(VkBool32 logicOp) { this->logicOp = logicOp; }
    inline VkBool32 getMultiDrawIndirect() const { return multiDrawIndirect; }
    inline void setMultiDrawIndirect(VkBool32 multiDrawIndirect) { this->multiDrawIndirect = multiDrawIndirect; }
    inline VkBool32 getDrawIndirectFirstInstance() const { return drawIndirectFirstInstance; }
    inline void setDrawIndirectFirstInstance(VkBool32 drawIndirectFirstInstance) { this->drawIndirectFirstInstance = drawIndirectFirstInstance; }
    inline VkBool32 getDepthClamp() const { return depthClamp; }
    inline void setDepthClamp(VkBool32 depthClamp) { this->depthClamp = depthClamp; }
    inline VkBool32 getDepthBiasClamp() const { return depthBiasClamp; }
    inline void setDepthBiasClamp(VkBool32 depthBiasClamp) { this->depthBiasClamp = depthBiasClamp; }
    inline VkBool32 getFillModeNonSolid() const { return fillModeNonSolid; }
    inline void setFillModeNonSolid(VkBool32 fillModeNonSolid) { this->fillModeNonSolid = fillModeNonSolid; }
    inline VkBool32 getDepthBounds() const { return depthBounds; }
    inline void setDepthBounds(VkBool32 depthBounds) { this->depthBounds = depthBounds; }
    inline VkBool32 getWideLines() const { return wideLines; }
    inline void setWideLines(VkBool32 wideLines) { this->wideLines = wideLines; }
    inline VkBool32 getLargePoints() const { return largePoints; }
    inline void setLargePoints(VkBool32 largePoints) { this->largePoints = largePoints; }
    inline VkBool32 getAlphaToOne() const { return alphaToOne; }
    inline void setAlphaToOne(VkBool32 alphaToOne) { this->alphaToOne = alphaToOne; }
    inline VkBool32 getMultiViewport() const { return multiViewport; }
    inline void setMultiViewport(VkBool32 multiViewport) { this->multiViewport = multiViewport; }
    inline VkBool32 getSamplerAnisotropy() const { return samplerAnisotropy; }
    inline void setSamplerAnisotropy(VkBool32 samplerAnisotropy) { this->samplerAnisotropy = samplerAnisotropy; }
    inline VkBool32 getTextureCompressionETC2() const { return textureCompressionETC2; }
    inline void setTextureCompressionETC2(VkBool32 textureCompressionETC2) { this->textureCompressionETC2 = textureCompressionETC2; }
    inline VkBool32 getTextureCompressionASTC_LDR() const { return textureCompressionASTC_LDR; }
    inline void setTextureCompressionASTC_LDR(VkBool32 textureCompressionASTC_LDR) { this->textureCompressionASTC_LDR = textureCompressionASTC_LDR; }
    inline VkBool32 getTextureCompressionBC() const { return textureCompressionBC; }
    inline void setTextureCompressionBC(VkBool32 textureCompressionBC) { this->textureCompressionBC = textureCompressionBC; }
    inline VkBool32 getOcclusionQueryPrecise() const { return occlusionQueryPrecise; }
    inline void setOcclusionQueryPrecise(VkBool32 occlusionQueryPrecise) { this->occlusionQueryPrecise = occlusionQueryPrecise; }
    inline VkBool32 getPipelineStatisticsQuery() const { return pipelineStatisticsQuery; }
    inline void setPipelineStatisticsQuery(VkBool32 pipelineStatisticsQuery) { this->pipelineStatisticsQuery = pipelineStatisticsQuery; }
    inline VkBool32 getVertexPipelineStoresAndAtomics() const { return vertexPipelineStoresAndAtomics; }
    inline void setVertexPipelineStoresAndAtomics(VkBool32 vertexPipelineStoresAndAtomics) { this->vertexPipelineStoresAndAtomics = vertexPipelineStoresAndAtomics; }
    inline VkBool32 getFragmentStoresAndAtomics() const { return fragmentStoresAndAtomics; }
    inline void setFragmentStoresAndAtomics(VkBool32 fragmentStoresAndAtomics) { this->fragmentStoresAndAtomics = fragmentStoresAndAtomics; }
    inline VkBool32 getShaderTessellationAndGeometryPointSize() const { return shaderTessellationAndGeometryPointSize; }
    inline void setShaderTessellationAndGeometryPointSize(VkBool32 shaderTessellationAndGeometryPointSize) { this->shaderTessellationAndGeometryPointSize = shaderTessellationAndGeometryPointSize; }
    inline VkBool32 getShaderImageGatherExtended() const { return shaderImageGatherExtended; }
    inline void setShaderImageGatherExtended(VkBool32 shaderImageGatherExtended) { this->shaderImageGatherExtended = shaderImageGatherExtended; }
    inline VkBool32 getShaderStorageImageExtendedFormats() const { return shaderStorageImageExtendedFormats; }
    inline void setShaderStorageImageExtendedFormats(VkBool32 shaderStorageImageExtendedFormats) { this->shaderStorageImageExtendedFormats = shaderStorageImageExtendedFormats; }
    inline VkBool32 getShaderStorageImageMultisample() const { return shaderStorageImageMultisample; }
    inline void setShaderStorageImageMultisample(VkBool32 shaderStorageImageMultisample) { this->shaderStorageImageMultisample = shaderStorageImageMultisample; }
    inline VkBool32 getShaderStorageImageReadWithoutFormat() const { return shaderStorageImageReadWithoutFormat; }
    inline void setShaderStorageImageReadWithoutFormat(VkBool32 shaderStorageImageReadWithoutFormat) { this->shaderStorageImageReadWithoutFormat = shaderStorageImageReadWithoutFormat; }
    inline VkBool32 getShaderStorageImageWriteWithoutFormat() const { return shaderStorageImageWriteWithoutFormat; }
    inline void setShaderStorageImageWriteWithoutFormat(VkBool32 shaderStorageImageWriteWithoutFormat) { this->shaderStorageImageWriteWithoutFormat = shaderStorageImageWriteWithoutFormat; }
    inline VkBool32 getShaderUniformBufferArrayDynamicIndexing() const { return shaderUniformBufferArrayDynamicIndexing; }
    inline void setShaderUniformBufferArrayDynamicIndexing(VkBool32 shaderUniformBufferArrayDynamicIndexing) { this->shaderUniformBufferArrayDynamicIndexing = shaderUniformBufferArrayDynamicIndexing; }
    inline VkBool32 getShaderSampledImageArrayDynamicIndexing() const { return shaderSampledImageArrayDynamicIndexing; }
    inline void setShaderSampledImageArrayDynamicIndexing(VkBool32 shaderSampledImageArrayDynamicIndexing) { this->shaderSampledImageArrayDynamicIndexing = shaderSampledImageArrayDynamicIndexing; }
    inline VkBool32 getShaderStorageBufferArrayDynamicIndexing() const { return shaderStorageBufferArrayDynamicIndexing; }
    inline void setShaderStorageBufferArrayDynamicIndexing(VkBool32 shaderStorageBufferArrayDynamicIndexing) { this->shaderStorageBufferArrayDynamicIndexing = shaderStorageBufferArrayDynamicIndexing; }
    inline VkBool32 getShaderStorageImageArrayDynamicIndexing() const { return shaderStorageImageArrayDynamicIndexing; }
    inline void setShaderStorageImageArrayDynamicIndexing(VkBool32 shaderStorageImageArrayDynamicIndexing) { this->shaderStorageImageArrayDynamicIndexing = shaderStorageImageArrayDynamicIndexing; }
    inline VkBool32 getShaderClipDistance() const { return shaderClipDistance; }
    inline void setShaderClipDistance(VkBool32 shaderClipDistance) { this->shaderClipDistance = shaderClipDistance; }
    inline VkBool32 getShaderCullDistance() const { return shaderCullDistance; }
    inline void setShaderCullDistance(VkBool32 shaderCullDistance) { this->shaderCullDistance = shaderCullDistance; }
    inline VkBool32 getShaderFloat64() const { return shaderFloat64; }
    inline void setShaderFloat64(VkBool32 shaderFloat64) { this->shaderFloat64 = shaderFloat64; }
    inline VkBool32 getShaderInt64() const { return shaderInt64; }
    inline void setShaderInt64(VkBool32 shaderInt64) { this->shaderInt64 = shaderInt64; }
    inline VkBool32 getShaderInt16() const { return shaderInt16; }
    inline void setShaderInt16(VkBool32 shaderInt16) { this->shaderInt16 = shaderInt16; }
    inline VkBool32 getShaderResourceResidency() const { return shaderResourceResidency; }
    inline void setShaderResourceResidency(VkBool32 shaderResourceResidency) { this->shaderResourceResidency = shaderResourceResidency; }
    inline VkBool32 getShaderResourceMinLod() const { return shaderResourceMinLod; }
    inline void setShaderResourceMinLod(VkBool32 shaderResourceMinLod) { this->shaderResourceMinLod = shaderResourceMinLod; }
    inline VkBool32 getSparseBinding() const { return sparseBinding; }
    inline void setSparseBinding(VkBool32 sparseBinding) { this->sparseBinding = sparseBinding; }
    inline VkBool32 getSparseResidencyBuffer() const { return sparseResidencyBuffer; }
    inline void setSparseResidencyBuffer(VkBool32 sparseResidencyBuffer) { this->sparseResidencyBuffer = sparseResidencyBuffer; }
    inline VkBool32 getSparseResidencyImage2D() const { return sparseResidencyImage2D; }
    inline void setSparseResidencyImage2D(VkBool32 sparseResidencyImage2D) { this->sparseResidencyImage2D = sparseResidencyImage2D; }
    inline VkBool32 getSparseResidencyImage3D() const { return sparseResidencyImage3D; }
    inline void setSparseResidencyImage3D(VkBool32 sparseResidencyImage3D) { this->sparseResidencyImage3D = sparseResidencyImage3D; }
    inline VkBool32 getSparseResidency2Samples() const { return sparseResidency2Samples; }
    inline void setSparseResidency2Samples(VkBool32 sparseResidency2Samples) { this->sparseResidency2Samples = sparseResidency2Samples; }
    inline VkBool32 getSparseResidency4Samples() const { return sparseResidency4Samples; }
    inline void setSparseResidency4Samples(VkBool32 sparseResidency4Samples) { this->sparseResidency4Samples = sparseResidency4Samples; }
    inline VkBool32 getSparseResidency8Samples() const { return sparseResidency8Samples; }
    inline void setSparseResidency8Samples(VkBool32 sparseResidency8Samples) { this->sparseResidency8Samples = sparseResidency8Samples; }
    inline VkBool32 getSparseResidency16Samples() const { return sparseResidency16Samples; }
    inline void setSparseResidency16Samples(VkBool32 sparseResidency16Samples) { this->sparseResidency16Samples = sparseResidency16Samples; }
    inline VkBool32 getSparseResidencyAliased() const { return sparseResidencyAliased; }
    inline void setSparseResidencyAliased(VkBool32 sparseResidencyAliased) { this->sparseResidencyAliased = sparseResidencyAliased; }
    inline VkBool32 getVariableMultisampleRate() const { return variableMultisampleRate; }
    inline void setVariableMultisampleRate(VkBool32 variableMultisampleRate) { this->variableMultisampleRate = variableMultisampleRate; }
    inline VkBool32 getInheritedQueries() const { return inheritedQueries; }
    inline void setInheritedQueries(VkBool32 inheritedQueries) { this->inheritedQueries = inheritedQueries; }
};

// FormatProperties is a structure used only as a return type so only getters are defined
struct FormatProperties : private VkFormatProperties
{
    inline FormatFeatureFlags getLinearTilingFeatures() const { return reinterpret_cast<const FormatFeatureFlags&>(linearTilingFeatures); }
    inline FormatFeatureFlags getOptimalTilingFeatures() const { return reinterpret_cast<const FormatFeatureFlags&>(optimalTilingFeatures); }
    inline FormatFeatureFlags getBufferFeatures() const { return reinterpret_cast<const FormatFeatureFlags&>(bufferFeatures); }
};

struct Extent3D : private VkExtent3D
{
    Extent3D()
    {
        setWidth(uint32_t());
        setHeight(uint32_t());
        setDepth(uint32_t());
    }
    Extent3D(uint32_t width, uint32_t height, uint32_t depth)
    {
        setWidth(width);
        setHeight(height);
        setDepth(depth);
    }
    inline uint32_t getWidth() const { return width; }
    inline void setWidth(uint32_t width) { this->width = width; }
    inline uint32_t getHeight() const { return height; }
    inline void setHeight(uint32_t height) { this->height = height; }
    inline uint32_t getDepth() const { return depth; }
    inline void setDepth(uint32_t depth) { this->depth = depth; }
};

// ImageFormatProperties is a structure used only as a return type so only getters are defined
struct ImageFormatProperties : private VkImageFormatProperties
{
    inline const Extent3D& getMaxExtent() const { return reinterpret_cast<const Extent3D&>(maxExtent); }
    inline uint32_t getMaxMipLevels() const { return maxMipLevels; }
    inline uint32_t getMaxArrayLayers() const { return maxArrayLayers; }
    inline SampleCountFlags getSampleCounts() const { return reinterpret_cast<const SampleCountFlags&>(sampleCounts); }
    inline VkDeviceSize getMaxResourceSize() const { return maxResourceSize; }
};

// PhysicalDeviceLimits is a structure used only as a return type so only getters are defined
struct PhysicalDeviceLimits : private VkPhysicalDeviceLimits
{
    inline uint32_t getMaxImageDimension1D() const { return maxImageDimension1D; }
    inline uint32_t getMaxImageDimension2D() const { return maxImageDimension2D; }
    inline uint32_t getMaxImageDimension3D() const { return maxImageDimension3D; }
    inline uint32_t getMaxImageDimensionCube() const { return maxImageDimensionCube; }
    inline uint32_t getMaxImageArrayLayers() const { return maxImageArrayLayers; }
    inline uint32_t getMaxTexelBufferElements() const { return maxTexelBufferElements; }
    inline uint32_t getMaxUniformBufferRange() const { return maxUniformBufferRange; }
    inline uint32_t getMaxStorageBufferRange() const { return maxStorageBufferRange; }
    inline uint32_t getMaxPushConstantsSize() const { return maxPushConstantsSize; }
    inline uint32_t getMaxMemoryAllocationCount() const { return maxMemoryAllocationCount; }
    inline uint32_t getMaxSamplerAllocationCount() const { return maxSamplerAllocationCount; }
    inline VkDeviceSize getBufferImageGranularity() const { return bufferImageGranularity; }
    inline VkDeviceSize getSparseAddressSpaceSize() const { return sparseAddressSpaceSize; }
    inline uint32_t getMaxBoundDescriptorSets() const { return maxBoundDescriptorSets; }
    inline uint32_t getMaxPerStageDescriptorSamplers() const { return maxPerStageDescriptorSamplers; }
    inline uint32_t getMaxPerStageDescriptorUniformBuffers() const { return maxPerStageDescriptorUniformBuffers; }
    inline uint32_t getMaxPerStageDescriptorStorageBuffers() const { return maxPerStageDescriptorStorageBuffers; }
    inline uint32_t getMaxPerStageDescriptorSampledImages() const { return maxPerStageDescriptorSampledImages; }
    inline uint32_t getMaxPerStageDescriptorStorageImages() const { return maxPerStageDescriptorStorageImages; }
    inline uint32_t getMaxPerStageDescriptorInputAttachments() const { return maxPerStageDescriptorInputAttachments; }
    inline uint32_t getMaxPerStageResources() const { return maxPerStageResources; }
    inline uint32_t getMaxDescriptorSetSamplers() const { return maxDescriptorSetSamplers; }
    inline uint32_t getMaxDescriptorSetUniformBuffers() const { return maxDescriptorSetUniformBuffers; }
    inline uint32_t getMaxDescriptorSetUniformBuffersDynamic() const { return maxDescriptorSetUniformBuffersDynamic; }
    inline uint32_t getMaxDescriptorSetStorageBuffers() const { return maxDescriptorSetStorageBuffers; }
    inline uint32_t getMaxDescriptorSetStorageBuffersDynamic() const { return maxDescriptorSetStorageBuffersDynamic; }
    inline uint32_t getMaxDescriptorSetSampledImages() const { return maxDescriptorSetSampledImages; }
    inline uint32_t getMaxDescriptorSetStorageImages() const { return maxDescriptorSetStorageImages; }
    inline uint32_t getMaxDescriptorSetInputAttachments() const { return maxDescriptorSetInputAttachments; }
    inline uint32_t getMaxVertexInputAttributes() const { return maxVertexInputAttributes; }
    inline uint32_t getMaxVertexInputBindings() const { return maxVertexInputBindings; }
    inline uint32_t getMaxVertexInputAttributeOffset() const { return maxVertexInputAttributeOffset; }
    inline uint32_t getMaxVertexInputBindingStride() const { return maxVertexInputBindingStride; }
    inline uint32_t getMaxVertexOutputComponents() const { return maxVertexOutputComponents; }
    inline uint32_t getMaxTessellationGenerationLevel() const { return maxTessellationGenerationLevel; }
    inline uint32_t getMaxTessellationPatchSize() const { return maxTessellationPatchSize; }
    inline uint32_t getMaxTessellationControlPerVertexInputComponents() const { return maxTessellationControlPerVertexInputComponents; }
    inline uint32_t getMaxTessellationControlPerVertexOutputComponents() const { return maxTessellationControlPerVertexOutputComponents; }
    inline uint32_t getMaxTessellationControlPerPatchOutputComponents() const { return maxTessellationControlPerPatchOutputComponents; }
    inline uint32_t getMaxTessellationControlTotalOutputComponents() const { return maxTessellationControlTotalOutputComponents; }
    inline uint32_t getMaxTessellationEvaluationInputComponents() const { return maxTessellationEvaluationInputComponents; }
    inline uint32_t getMaxTessellationEvaluationOutputComponents() const { return maxTessellationEvaluationOutputComponents; }
    inline uint32_t getMaxGeometryShaderInvocations() const { return maxGeometryShaderInvocations; }
    inline uint32_t getMaxGeometryInputComponents() const { return maxGeometryInputComponents; }
    inline uint32_t getMaxGeometryOutputComponents() const { return maxGeometryOutputComponents; }
    inline uint32_t getMaxGeometryOutputVertices() const { return maxGeometryOutputVertices; }
    inline uint32_t getMaxGeometryTotalOutputComponents() const { return maxGeometryTotalOutputComponents; }
    inline uint32_t getMaxFragmentInputComponents() const { return maxFragmentInputComponents; }
    inline uint32_t getMaxFragmentOutputAttachments() const { return maxFragmentOutputAttachments; }
    inline uint32_t getMaxFragmentDualSrcAttachments() const { return maxFragmentDualSrcAttachments; }
    inline uint32_t getMaxFragmentCombinedOutputResources() const { return maxFragmentCombinedOutputResources; }
    inline uint32_t getMaxComputeSharedMemorySize() const { return maxComputeSharedMemorySize; }
    inline const uint32_t* getMaxComputeWorkGroupCount() const { return maxComputeWorkGroupCount; }
    inline uint32_t getMaxComputeWorkGroupInvocations() const { return maxComputeWorkGroupInvocations; }
    inline const uint32_t* getMaxComputeWorkGroupSize() const { return maxComputeWorkGroupSize; }
    inline uint32_t getSubPixelPrecisionBits() const { return subPixelPrecisionBits; }
    inline uint32_t getSubTexelPrecisionBits() const { return subTexelPrecisionBits; }
    inline uint32_t getMipmapPrecisionBits() const { return mipmapPrecisionBits; }
    inline uint32_t getMaxDrawIndexedIndexValue() const { return maxDrawIndexedIndexValue; }
    inline uint32_t getMaxDrawIndirectCount() const { return maxDrawIndirectCount; }
    inline float getMaxSamplerLodBias() const { return maxSamplerLodBias; }
    inline float getMaxSamplerAnisotropy() const { return maxSamplerAnisotropy; }
    inline uint32_t getMaxViewports() const { return maxViewports; }
    inline const uint32_t* getMaxViewportDimensions() const { return maxViewportDimensions; }
    inline const float* getViewportBoundsRange() const { return viewportBoundsRange; }
    inline uint32_t getViewportSubPixelBits() const { return viewportSubPixelBits; }
    inline size_t getMinMemoryMapAlignment() const { return minMemoryMapAlignment; }
    inline VkDeviceSize getMinTexelBufferOffsetAlignment() const { return minTexelBufferOffsetAlignment; }
    inline VkDeviceSize getMinUniformBufferOffsetAlignment() const { return minUniformBufferOffsetAlignment; }
    inline VkDeviceSize getMinStorageBufferOffsetAlignment() const { return minStorageBufferOffsetAlignment; }
    inline int32_t getMinTexelOffset() const { return minTexelOffset; }
    inline uint32_t getMaxTexelOffset() const { return maxTexelOffset; }
    inline int32_t getMinTexelGatherOffset() const { return minTexelGatherOffset; }
    inline uint32_t getMaxTexelGatherOffset() const { return maxTexelGatherOffset; }
    inline float getMinInterpolationOffset() const { return minInterpolationOffset; }
    inline float getMaxInterpolationOffset() const { return maxInterpolationOffset; }
    inline uint32_t getSubPixelInterpolationOffsetBits() const { return subPixelInterpolationOffsetBits; }
    inline uint32_t getMaxFramebufferWidth() const { return maxFramebufferWidth; }
    inline uint32_t getMaxFramebufferHeight() const { return maxFramebufferHeight; }
    inline uint32_t getMaxFramebufferLayers() const { return maxFramebufferLayers; }
    inline SampleCountFlags getFramebufferColorSampleCounts() const { return reinterpret_cast<const SampleCountFlags&>(framebufferColorSampleCounts); }
    inline SampleCountFlags getFramebufferDepthSampleCounts() const { return reinterpret_cast<const SampleCountFlags&>(framebufferDepthSampleCounts); }
    inline SampleCountFlags getFramebufferStencilSampleCounts() const { return reinterpret_cast<const SampleCountFlags&>(framebufferStencilSampleCounts); }
    inline SampleCountFlags getFramebufferNoAttachmentsSampleCounts() const { return reinterpret_cast<const SampleCountFlags&>(framebufferNoAttachmentsSampleCounts); }
    inline uint32_t getMaxColorAttachments() const { return maxColorAttachments; }
    inline SampleCountFlags getSampledImageColorSampleCounts() const { return reinterpret_cast<const SampleCountFlags&>(sampledImageColorSampleCounts); }
    inline SampleCountFlags getSampledImageIntegerSampleCounts() const { return reinterpret_cast<const SampleCountFlags&>(sampledImageIntegerSampleCounts); }
    inline SampleCountFlags getSampledImageDepthSampleCounts() const { return reinterpret_cast<const SampleCountFlags&>(sampledImageDepthSampleCounts); }
    inline SampleCountFlags getSampledImageStencilSampleCounts() const { return reinterpret_cast<const SampleCountFlags&>(sampledImageStencilSampleCounts); }
    inline SampleCountFlags getStorageImageSampleCounts() const { return reinterpret_cast<const SampleCountFlags&>(storageImageSampleCounts); }
    inline uint32_t getMaxSampleMaskWords() const { return maxSampleMaskWords; }
    inline VkBool32 getTimestampComputeAndGraphics() const { return timestampComputeAndGraphics; }
    inline float getTimestampPeriod() const { return timestampPeriod; }
    inline uint32_t getMaxClipDistances() const { return maxClipDistances; }
    inline uint32_t getMaxCullDistances() const { return maxCullDistances; }
    inline uint32_t getMaxCombinedClipAndCullDistances() const { return maxCombinedClipAndCullDistances; }
    inline uint32_t getDiscreteQueuePriorities() const { return discreteQueuePriorities; }
    inline const float* getPointSizeRange() const { return pointSizeRange; }
    inline const float* getLineWidthRange() const { return lineWidthRange; }
    inline float getPointSizeGranularity() const { return pointSizeGranularity; }
    inline float getLineWidthGranularity() const { return lineWidthGranularity; }
    inline VkBool32 getStrictLines() const { return strictLines; }
    inline VkBool32 getStandardSampleLocations() const { return standardSampleLocations; }
    inline VkDeviceSize getOptimalBufferCopyOffsetAlignment() const { return optimalBufferCopyOffsetAlignment; }
    inline VkDeviceSize getOptimalBufferCopyRowPitchAlignment() const { return optimalBufferCopyRowPitchAlignment; }
    inline VkDeviceSize getNonCoherentAtomSize() const { return nonCoherentAtomSize; }
};

// PhysicalDeviceSparseProperties is a structure used only as a return type so only getters are defined
struct PhysicalDeviceSparseProperties : private VkPhysicalDeviceSparseProperties
{
    inline VkBool32 getResidencyStandard2DBlockShape() const { return residencyStandard2DBlockShape; }
    inline VkBool32 getResidencyStandard2DMultisampleBlockShape() const { return residencyStandard2DMultisampleBlockShape; }
    inline VkBool32 getResidencyStandard3DBlockShape() const { return residencyStandard3DBlockShape; }
    inline VkBool32 getResidencyAlignedMipSize() const { return residencyAlignedMipSize; }
    inline VkBool32 getResidencyNonResidentStrict() const { return residencyNonResidentStrict; }
};

// PhysicalDeviceProperties is a structure used only as a return type so only getters are defined
struct PhysicalDeviceProperties : private VkPhysicalDeviceProperties
{
    inline uint32_t getApiVersion() const { return apiVersion; }
    inline uint32_t getDriverVersion() const { return driverVersion; }
    inline uint32_t getVendorID() const { return vendorID; }
    inline uint32_t getDeviceID() const { return deviceID; }
    inline PhysicalDeviceType getDeviceType() const { return reinterpret_cast<const PhysicalDeviceType&>(deviceType); }
    inline const char* getDeviceName() const { return deviceName; }
    inline const uint8_t* getPipelineCacheUUID() const { return pipelineCacheUUID; }
    inline const PhysicalDeviceLimits& getLimits() const { return reinterpret_cast<const PhysicalDeviceLimits&>(limits); }
    inline const PhysicalDeviceSparseProperties& getSparseProperties() const { return reinterpret_cast<const PhysicalDeviceSparseProperties&>(sparseProperties); }
};

// QueueFamilyProperties is a structure used only as a return type so only getters are defined
struct QueueFamilyProperties : private VkQueueFamilyProperties
{
    inline QueueFlags getQueueFlags() const { return reinterpret_cast<const QueueFlags&>(queueFlags); }
    inline uint32_t getQueueCount() const { return queueCount; }
    inline uint32_t getTimestampValidBits() const { return timestampValidBits; }
    inline const Extent3D& getMinImageTransferGranularity() const { return reinterpret_cast<const Extent3D&>(minImageTransferGranularity); }
};

// MemoryType is a structure used only as a return type so only getters are defined
struct MemoryType : private VkMemoryType
{
    inline MemoryPropertyFlags getPropertyFlags() const { return reinterpret_cast<const MemoryPropertyFlags&>(propertyFlags); }
    inline uint32_t getHeapIndex() const { return heapIndex; }
};

// MemoryHeap is a structure used only as a return type so only getters are defined
struct MemoryHeap : private VkMemoryHeap
{
    inline VkDeviceSize getSize() const { return size; }
    inline MemoryHeapFlags getFlags() const { return reinterpret_cast<const MemoryHeapFlags&>(flags); }
};

// PhysicalDeviceMemoryProperties is a structure used only as a return type so only getters are defined
struct PhysicalDeviceMemoryProperties : private VkPhysicalDeviceMemoryProperties
{
    inline uint32_t getMemoryTypeCount() const { return memoryTypeCount; }
    inline const MemoryType* getMemoryTypes() const { return reinterpret_cast<const MemoryType*>(memoryTypes); }
    inline uint32_t getMemoryHeapCount() const { return memoryHeapCount; }
    inline const MemoryHeap* getMemoryHeaps() const { return reinterpret_cast<const MemoryHeap*>(memoryHeaps); }
};

// ExtensionProperties is a structure used only as a return type so only getters are defined
struct ExtensionProperties : private VkExtensionProperties
{
    inline const char* getExtensionName() const { return extensionName; }
    inline uint32_t getSpecVersion() const { return specVersion; }
};

// LayerProperties is a structure used only as a return type so only getters are defined
struct LayerProperties : private VkLayerProperties
{
    inline const char* getLayerName() const { return layerName; }
    inline uint32_t getSpecVersion() const { return specVersion; }
    inline uint32_t getImplementationVersion() const { return implementationVersion; }
    inline const char* getDescription() const { return description; }
};

// MemoryRequirements is a structure used only as a return type so only getters are defined
struct MemoryRequirements : private VkMemoryRequirements
{
    inline VkDeviceSize getSize() const { return size; }
    inline VkDeviceSize getAlignment() const { return alignment; }
    inline uint32_t getMemoryTypeBits() const { return memoryTypeBits; }
};

// SparseImageFormatProperties is a structure used only as a return type so only getters are defined
struct SparseImageFormatProperties : private VkSparseImageFormatProperties
{
    inline ImageAspectFlags getAspectMask() const { return reinterpret_cast<const ImageAspectFlags&>(aspectMask); }
    inline const Extent3D& getImageGranularity() const { return reinterpret_cast<const Extent3D&>(imageGranularity); }
    inline SparseImageFormatFlags getFlags() const { return reinterpret_cast<const SparseImageFormatFlags&>(flags); }
};

// SparseImageMemoryRequirements is a structure used only as a return type so only getters are defined
struct SparseImageMemoryRequirements : private VkSparseImageMemoryRequirements
{
    inline const SparseImageFormatProperties& getFormatProperties() const { return reinterpret_cast<const SparseImageFormatProperties&>(formatProperties); }
    inline uint32_t getImageMipTailFirstLod() const { return imageMipTailFirstLod; }
    inline VkDeviceSize getImageMipTailSize() const { return imageMipTailSize; }
    inline VkDeviceSize getImageMipTailOffset() const { return imageMipTailOffset; }
    inline VkDeviceSize getImageMipTailStride() const { return imageMipTailStride; }
};

struct ImageSubresource : private VkImageSubresource
{
    ImageSubresource()
    {
        setAspectMask(ImageAspectFlags());
        setMipLevel(uint32_t());
        setArrayLayer(uint32_t());
    }
    ImageSubresource(const ImageAspectFlags& aspectMask, uint32_t mipLevel, uint32_t arrayLayer)
    {
        setAspectMask(aspectMask);
        setMipLevel(mipLevel);
        setArrayLayer(arrayLayer);
    }
    inline ImageAspectFlags getAspectMask() const { return reinterpret_cast<const ImageAspectFlags&>(aspectMask); }
    inline void setAspectMask(const ImageAspectFlags& aspectMask) { this->aspectMask = *reinterpret_cast<const VkImageAspectFlags*>(&aspectMask); }
    inline uint32_t getMipLevel() const { return mipLevel; }
    inline void setMipLevel(uint32_t mipLevel) { this->mipLevel = mipLevel; }
    inline uint32_t getArrayLayer() const { return arrayLayer; }
    inline void setArrayLayer(uint32_t arrayLayer) { this->arrayLayer = arrayLayer; }
};

struct Offset3D : private VkOffset3D
{
    Offset3D()
    {
        setX(int32_t());
        setY(int32_t());
        setZ(int32_t());
    }
    Offset3D(int32_t x, int32_t y, int32_t z)
    {
        setX(x);
        setY(y);
        setZ(z);
    }
    inline int32_t getX() const { return x; }
    inline void setX(int32_t x) { this->x = x; }
    inline int32_t getY() const { return y; }
    inline void setY(int32_t y) { this->y = y; }
    inline int32_t getZ() const { return z; }
    inline void setZ(int32_t z) { this->z = z; }
};

// SubresourceLayout is a structure used only as a return type so only getters are defined
struct SubresourceLayout : private VkSubresourceLayout
{
    inline VkDeviceSize getOffset() const { return offset; }
    inline VkDeviceSize getSize() const { return size; }
    inline VkDeviceSize getRowPitch() const { return rowPitch; }
    inline VkDeviceSize getArrayPitch() const { return arrayPitch; }
    inline VkDeviceSize getDepthPitch() const { return depthPitch; }
};

struct ComponentMapping : private VkComponentMapping
{
    ComponentMapping()
    {
        setR(ComponentSwizzle());
        setG(ComponentSwizzle());
        setB(ComponentSwizzle());
        setA(ComponentSwizzle());
    }
    ComponentMapping(const ComponentSwizzle& r, const ComponentSwizzle& g, const ComponentSwizzle& b, const ComponentSwizzle& a)
    {
        setR(r);
        setG(g);
        setB(b);
        setA(a);
    }
    inline ComponentSwizzle getR() const { return reinterpret_cast<const ComponentSwizzle&>(r); }
    inline void setR(const ComponentSwizzle& r) { this->r = *reinterpret_cast<const VkComponentSwizzle*>(&r); }
    inline ComponentSwizzle getG() const { return reinterpret_cast<const ComponentSwizzle&>(g); }
    inline void setG(const ComponentSwizzle& g) { this->g = *reinterpret_cast<const VkComponentSwizzle*>(&g); }
    inline ComponentSwizzle getB() const { return reinterpret_cast<const ComponentSwizzle&>(b); }
    inline void setB(const ComponentSwizzle& b) { this->b = *reinterpret_cast<const VkComponentSwizzle*>(&b); }
    inline ComponentSwizzle getA() const { return reinterpret_cast<const ComponentSwizzle&>(a); }
    inline void setA(const ComponentSwizzle& a) { this->a = *reinterpret_cast<const VkComponentSwizzle*>(&a); }
};

struct ImageSubresourceRange : private VkImageSubresourceRange
{
    ImageSubresourceRange()
    {
        setAspectMask(ImageAspectFlags::e_MAX_ENUM);
        setBaseMipLevel(0);
        setLevelCount(1);
        setBaseArrayLayer(0);
        setLayerCount(1);
    }
    ImageSubresourceRange(const ImageAspectFlags& aspectMask, uint32_t baseMipLevel = 0, uint32_t levelCount = 1, uint32_t baseArrayLayer = 0, uint32_t layerCount = 1)
    {
        setAspectMask(aspectMask);
        setBaseMipLevel(baseMipLevel);
        setLevelCount(levelCount);
        setBaseArrayLayer(baseArrayLayer);
        setLayerCount(layerCount);
    }
    inline ImageAspectFlags getAspectMask() const { return reinterpret_cast<const ImageAspectFlags&>(aspectMask); }
    inline void setAspectMask(const ImageAspectFlags& aspectMask) { this->aspectMask = *reinterpret_cast<const VkImageAspectFlags*>(&aspectMask); }
    inline uint32_t getBaseMipLevel() const { return baseMipLevel; }
    inline void setBaseMipLevel(uint32_t baseMipLevel) { this->baseMipLevel = baseMipLevel; }
    inline uint32_t getLevelCount() const { return levelCount; }
    inline void setLevelCount(uint32_t levelCount) { this->levelCount = levelCount; }
    inline uint32_t getBaseArrayLayer() const { return baseArrayLayer; }
    inline void setBaseArrayLayer(uint32_t baseArrayLayer) { this->baseArrayLayer = baseArrayLayer; }
    inline uint32_t getLayerCount() const { return layerCount; }
    inline void setLayerCount(uint32_t layerCount) { this->layerCount = layerCount; }
};

struct SpecializationMapEntry : private VkSpecializationMapEntry
{
    SpecializationMapEntry()
    {
        setConstantID(uint32_t());
        setOffset(uint32_t());
        setSize(size_t());
    }
    SpecializationMapEntry(uint32_t constantID, uint32_t offset, size_t size)
    {
        setConstantID(constantID);
        setOffset(offset);
        setSize(size);
    }
    inline uint32_t getConstantID() const { return constantID; }
    inline void setConstantID(uint32_t constantID) { this->constantID = constantID; }
    inline uint32_t getOffset() const { return offset; }
    inline void setOffset(uint32_t offset) { this->offset = offset; }
    inline size_t getSize() const { return size; }
    inline void setSize(size_t size) { this->size = size; }
};

struct SpecializationInfo : private VkSpecializationInfo
{
    SpecializationInfo()
    {
        setMapEntryCount(uint32_t());
        pMapEntries = nullptr;
        setDataSize(size_t());
        pData = nullptr;
    }
    SpecializationInfo(uint32_t mapEntryCount, SpecializationMapEntry* pMapEntries, size_t dataSize, void* pData)
    {
        setMapEntryCount(mapEntryCount);
        setPMapEntries(pMapEntries);
        setDataSize(dataSize);
        setPData(pData);
    }
    inline uint32_t getMapEntryCount() const { return mapEntryCount; }
    inline void setMapEntryCount(uint32_t mapEntryCount) { this->mapEntryCount = mapEntryCount; }
    inline const SpecializationMapEntry* getPMapEntries() const { return reinterpret_cast<const SpecializationMapEntry*>(pMapEntries); }
    inline void setPMapEntries(SpecializationMapEntry* pMapEntries) { this->pMapEntries = reinterpret_cast<const VkSpecializationMapEntry*>(pMapEntries); }
    inline size_t getDataSize() const { return dataSize; }
    inline void setDataSize(size_t dataSize) { this->dataSize = dataSize; }
    inline const void* getPData() const { return pData; }
    inline void setPData(void* pData) { this->pData = pData; }
};

struct VertexInputBindingDescription : private VkVertexInputBindingDescription
{
    VertexInputBindingDescription()
    {
        setBinding(0);
        setStride(0);
        setInputRate(VertexInputRate::e_VERTEX);
    }
    VertexInputBindingDescription(uint32_t binding, uint32_t stride, const VertexInputRate& inputRate = VertexInputRate::e_VERTEX)
    {
        setBinding(binding);
        setStride(stride);
        setInputRate(inputRate);
    }
    inline uint32_t getBinding() const { return binding; }
    inline void setBinding(uint32_t binding) { this->binding = binding; }
    inline uint32_t getStride() const { return stride; }
    inline void setStride(uint32_t stride) { this->stride = stride; }
    inline VertexInputRate getInputRate() const { return reinterpret_cast<const VertexInputRate&>(inputRate); }
    inline void setInputRate(const VertexInputRate& inputRate) { this->inputRate = *reinterpret_cast<const VkVertexInputRate*>(&inputRate); }
};

struct VertexInputAttributeDescription : private VkVertexInputAttributeDescription
{
    VertexInputAttributeDescription()
    {
        setLocation(uint32_t());
        setBinding(uint32_t());
        setFormat(Format());
        setOffset(uint32_t());
    }
    VertexInputAttributeDescription(uint32_t location, uint32_t binding, const Format& format, uint32_t offset)
    {
        setLocation(location);
        setBinding(binding);
        setFormat(format);
        setOffset(offset);
    }
    inline uint32_t getLocation() const { return location; }
    inline void setLocation(uint32_t location) { this->location = location; }
    inline uint32_t getBinding() const { return binding; }
    inline void setBinding(uint32_t binding) { this->binding = binding; }
    inline Format getFormat() const { return reinterpret_cast<const Format&>(format); }
    inline void setFormat(const Format& format) { this->format = *reinterpret_cast<const VkFormat*>(&format); }
    inline uint32_t getOffset() const { return offset; }
    inline void setOffset(uint32_t offset) { this->offset = offset; }
};

struct Viewport : private VkViewport
{
    Viewport()
    {
        setX(0);
        setY(0);
        setWidth(1);
        setHeight(1);
        setMinDepth(0.f);
        setMaxDepth(1.f);
    }
    Viewport(float x, float y, float width, float height, float minDepth = 0.f, float maxDepth = 1.f)
    {
        setX(x);
        setY(y);
        setWidth(width);
        setHeight(height);
        setMinDepth(minDepth);
        setMaxDepth(maxDepth);
    }
    inline float getX() const { return x; }
    inline void setX(float x) { this->x = x; }
    inline float getY() const { return y; }
    inline void setY(float y) { this->y = y; }
    inline float getWidth() const { return width; }
    inline void setWidth(float width) { this->width = width; }
    inline float getHeight() const { return height; }
    inline void setHeight(float height) { this->height = height; }
    inline float getMinDepth() const { return minDepth; }
    inline void setMinDepth(float minDepth) { this->minDepth = minDepth; }
    inline float getMaxDepth() const { return maxDepth; }
    inline void setMaxDepth(float maxDepth) { this->maxDepth = maxDepth; }
};

struct Offset2D : private VkOffset2D
{
    Offset2D()
    {
        setX(int32_t());
        setY(int32_t());
    }
    Offset2D(int32_t x, int32_t y)
    {
        setX(x);
        setY(y);
    }
    inline int32_t getX() const { return x; }
    inline void setX(int32_t x) { this->x = x; }
    inline int32_t getY() const { return y; }
    inline void setY(int32_t y) { this->y = y; }
};

struct Extent2D : private VkExtent2D
{
    Extent2D()
    {
        setWidth(uint32_t());
        setHeight(uint32_t());
    }
    Extent2D(uint32_t width, uint32_t height)
    {
        setWidth(width);
        setHeight(height);
    }
    inline uint32_t getWidth() const { return width; }
    inline void setWidth(uint32_t width) { this->width = width; }
    inline uint32_t getHeight() const { return height; }
    inline void setHeight(uint32_t height) { this->height = height; }
};

struct Rect2D : private VkRect2D
{
    Rect2D()
    {
        setOffset(Offset2D());
        setExtent(Extent2D());
    }
    Rect2D(const Offset2D& offset, const Extent2D& extent)
    {
        setOffset(offset);
        setExtent(extent);
    }
    Rect2D(int32_t x, int32_t y, uint32_t width, uint32_t height)
    {
        setOffset(pvrvk::Offset2D(x, y));
        setExtent(pvrvk::Extent2D(width, height));
    }
    inline const Offset2D& getOffset() const { return reinterpret_cast<const Offset2D&>(offset); }
    inline void setOffset(const Offset2D& offset) { this->offset = *reinterpret_cast<const VkOffset2D*>(&offset); }
    inline const Extent2D& getExtent() const { return reinterpret_cast<const Extent2D&>(extent); }
    inline void setExtent(const Extent2D& extent) { this->extent = *reinterpret_cast<const VkExtent2D*>(&extent); }
};

struct StencilOpState : private VkStencilOpState
{
    StencilOpState()
    {
        setFailOp(StencilOp::e_KEEP);
        setPassOp(StencilOp::e_KEEP);
        setDepthFailOp(StencilOp::e_KEEP);
        setCompareOp(CompareOp::e_ALWAYS);
        setCompareMask(0xff);
        setWriteMask(0xff);
        setReference(0);
    }
    StencilOpState(const StencilOp& failOp, const StencilOp& passOp, const StencilOp& depthFailOp, const CompareOp& compareOp, uint32_t compareMask, uint32_t writeMask, uint32_t reference)
    {
        setFailOp(failOp);
        setPassOp(passOp);
        setDepthFailOp(depthFailOp);
        setCompareOp(compareOp);
        setCompareMask(compareMask);
        setWriteMask(writeMask);
        setReference(reference);
    }
    inline StencilOp getFailOp() const { return reinterpret_cast<const StencilOp&>(failOp); }
    inline void setFailOp(const StencilOp& failOp) { this->failOp = *reinterpret_cast<const VkStencilOp*>(&failOp); }
    inline StencilOp getPassOp() const { return reinterpret_cast<const StencilOp&>(passOp); }
    inline void setPassOp(const StencilOp& passOp) { this->passOp = *reinterpret_cast<const VkStencilOp*>(&passOp); }
    inline StencilOp getDepthFailOp() const { return reinterpret_cast<const StencilOp&>(depthFailOp); }
    inline void setDepthFailOp(const StencilOp& depthFailOp) { this->depthFailOp = *reinterpret_cast<const VkStencilOp*>(&depthFailOp); }
    inline CompareOp getCompareOp() const { return reinterpret_cast<const CompareOp&>(compareOp); }
    inline void setCompareOp(const CompareOp& compareOp) { this->compareOp = *reinterpret_cast<const VkCompareOp*>(&compareOp); }
    inline uint32_t getCompareMask() const { return compareMask; }
    inline void setCompareMask(uint32_t compareMask) { this->compareMask = compareMask; }
    inline uint32_t getWriteMask() const { return writeMask; }
    inline void setWriteMask(uint32_t writeMask) { this->writeMask = writeMask; }
    inline uint32_t getReference() const { return reference; }
    inline void setReference(uint32_t reference) { this->reference = reference; }
};

struct PipelineColorBlendAttachmentState : private VkPipelineColorBlendAttachmentState
{
    PipelineColorBlendAttachmentState()
    {
        setBlendEnable(false);
        setSrcColorBlendFactor(BlendFactor::e_ONE);
        setDstColorBlendFactor(BlendFactor::e_ZERO);
        setColorBlendOp(BlendOp::e_ADD);
        setSrcAlphaBlendFactor(BlendFactor::e_ONE);
        setDstAlphaBlendFactor(BlendFactor::e_ZERO);
        setAlphaBlendOp(BlendOp::e_ADD);
        setColorWriteMask(ColorComponentFlags::e_ALL_BITS);
    }
    PipelineColorBlendAttachmentState(VkBool32 blendEnable, const BlendFactor& srcColorBlendFactor = BlendFactor::e_ONE, const BlendFactor& dstColorBlendFactor = BlendFactor::e_ZERO, const BlendOp& colorBlendOp = BlendOp::e_ADD, const BlendFactor& srcAlphaBlendFactor = BlendFactor::e_ONE, const BlendFactor& dstAlphaBlendFactor = BlendFactor::e_ZERO, const BlendOp& alphaBlendOp = BlendOp::e_ADD, const ColorComponentFlags& colorWriteMask = ColorComponentFlags::e_ALL_BITS)
    {
        setBlendEnable(blendEnable);
        setSrcColorBlendFactor(srcColorBlendFactor);
        setDstColorBlendFactor(dstColorBlendFactor);
        setColorBlendOp(colorBlendOp);
        setSrcAlphaBlendFactor(srcAlphaBlendFactor);
        setDstAlphaBlendFactor(dstAlphaBlendFactor);
        setAlphaBlendOp(alphaBlendOp);
        setColorWriteMask(colorWriteMask);
    }
    inline VkBool32 getBlendEnable() const { return blendEnable; }
    inline void setBlendEnable(VkBool32 blendEnable) { this->blendEnable = blendEnable; }
    inline BlendFactor getSrcColorBlendFactor() const { return reinterpret_cast<const BlendFactor&>(srcColorBlendFactor); }
    inline void setSrcColorBlendFactor(const BlendFactor& srcColorBlendFactor) { this->srcColorBlendFactor = *reinterpret_cast<const VkBlendFactor*>(&srcColorBlendFactor); }
    inline BlendFactor getDstColorBlendFactor() const { return reinterpret_cast<const BlendFactor&>(dstColorBlendFactor); }
    inline void setDstColorBlendFactor(const BlendFactor& dstColorBlendFactor) { this->dstColorBlendFactor = *reinterpret_cast<const VkBlendFactor*>(&dstColorBlendFactor); }
    inline BlendOp getColorBlendOp() const { return reinterpret_cast<const BlendOp&>(colorBlendOp); }
    inline void setColorBlendOp(const BlendOp& colorBlendOp) { this->colorBlendOp = *reinterpret_cast<const VkBlendOp*>(&colorBlendOp); }
    inline BlendFactor getSrcAlphaBlendFactor() const { return reinterpret_cast<const BlendFactor&>(srcAlphaBlendFactor); }
    inline void setSrcAlphaBlendFactor(const BlendFactor& srcAlphaBlendFactor) { this->srcAlphaBlendFactor = *reinterpret_cast<const VkBlendFactor*>(&srcAlphaBlendFactor); }
    inline BlendFactor getDstAlphaBlendFactor() const { return reinterpret_cast<const BlendFactor&>(dstAlphaBlendFactor); }
    inline void setDstAlphaBlendFactor(const BlendFactor& dstAlphaBlendFactor) { this->dstAlphaBlendFactor = *reinterpret_cast<const VkBlendFactor*>(&dstAlphaBlendFactor); }
    inline BlendOp getAlphaBlendOp() const { return reinterpret_cast<const BlendOp&>(alphaBlendOp); }
    inline void setAlphaBlendOp(const BlendOp& alphaBlendOp) { this->alphaBlendOp = *reinterpret_cast<const VkBlendOp*>(&alphaBlendOp); }
    inline ColorComponentFlags getColorWriteMask() const { return reinterpret_cast<const ColorComponentFlags&>(colorWriteMask); }
    inline void setColorWriteMask(const ColorComponentFlags& colorWriteMask) { this->colorWriteMask = *reinterpret_cast<const VkColorComponentFlags*>(&colorWriteMask); }
};

struct PushConstantRange : private VkPushConstantRange
{
    PushConstantRange()
    {
        setStageFlags(ShaderStageFlags::e_ALL);
        setOffset(0);
        setSize(0);
    }
    PushConstantRange(const ShaderStageFlags& stageFlags, uint32_t offset, uint32_t size)
    {
        setStageFlags(stageFlags);
        setOffset(offset);
        setSize(size);
    }
    inline ShaderStageFlags getStageFlags() const { return reinterpret_cast<const ShaderStageFlags&>(stageFlags); }
    inline void setStageFlags(const ShaderStageFlags& stageFlags) { this->stageFlags = *reinterpret_cast<const VkShaderStageFlags*>(&stageFlags); }
    inline uint32_t getOffset() const { return offset; }
    inline void setOffset(uint32_t offset) { this->offset = offset; }
    inline uint32_t getSize() const { return size; }
    inline void setSize(uint32_t size) { this->size = size; }
};

struct DescriptorPoolSize : private VkDescriptorPoolSize
{
    DescriptorPoolSize()
    {
        setType(DescriptorType());
        setDescriptorCount(uint32_t());
    }
    DescriptorPoolSize(const DescriptorType& type, uint32_t descriptorCount)
    {
        setType(type);
        setDescriptorCount(descriptorCount);
    }
    inline DescriptorType getType() const { return reinterpret_cast<const DescriptorType&>(type); }
    inline void setType(const DescriptorType& type) { this->type = *reinterpret_cast<const VkDescriptorType*>(&type); }
    inline uint32_t getDescriptorCount() const { return descriptorCount; }
    inline void setDescriptorCount(uint32_t descriptorCount) { this->descriptorCount = descriptorCount; }
};

struct AttachmentReference : private VkAttachmentReference
{
    AttachmentReference()
    {
        setAttachment(static_cast<uint32_t>(-1));
        setLayout(ImageLayout::e_UNDEFINED);
    }
    AttachmentReference(uint32_t attachment, const ImageLayout& layout)
    {
        setAttachment(attachment);
        setLayout(layout);
    }
    inline uint32_t getAttachment() const { return attachment; }
    inline void setAttachment(uint32_t attachment) { this->attachment = attachment; }
    inline ImageLayout getLayout() const { return reinterpret_cast<const ImageLayout&>(layout); }
    inline void setLayout(const ImageLayout& layout) { this->layout = *reinterpret_cast<const VkImageLayout*>(&layout); }
};

struct SubpassDependency : private VkSubpassDependency
{
    SubpassDependency()
    {
        setSrcSubpass(uint32_t());
        setDstSubpass(uint32_t());
        setSrcStageMask(PipelineStageFlags());
        setDstStageMask(PipelineStageFlags());
        setSrcAccessMask(AccessFlags());
        setDstAccessMask(AccessFlags());
        setDependencyFlags(DependencyFlags());
    }
    SubpassDependency(uint32_t srcSubpass, uint32_t dstSubpass, const PipelineStageFlags& srcStageMask, const PipelineStageFlags& dstStageMask, const AccessFlags& srcAccessMask, const AccessFlags& dstAccessMask, const DependencyFlags& dependencyFlags)
    {
        setSrcSubpass(srcSubpass);
        setDstSubpass(dstSubpass);
        setSrcStageMask(srcStageMask);
        setDstStageMask(dstStageMask);
        setSrcAccessMask(srcAccessMask);
        setDstAccessMask(dstAccessMask);
        setDependencyFlags(dependencyFlags);
    }
    inline uint32_t getSrcSubpass() const { return srcSubpass; }
    inline void setSrcSubpass(uint32_t srcSubpass) { this->srcSubpass = srcSubpass; }
    inline uint32_t getDstSubpass() const { return dstSubpass; }
    inline void setDstSubpass(uint32_t dstSubpass) { this->dstSubpass = dstSubpass; }
    inline PipelineStageFlags getSrcStageMask() const { return reinterpret_cast<const PipelineStageFlags&>(srcStageMask); }
    inline void setSrcStageMask(const PipelineStageFlags& srcStageMask) { this->srcStageMask = *reinterpret_cast<const VkPipelineStageFlags*>(&srcStageMask); }
    inline PipelineStageFlags getDstStageMask() const { return reinterpret_cast<const PipelineStageFlags&>(dstStageMask); }
    inline void setDstStageMask(const PipelineStageFlags& dstStageMask) { this->dstStageMask = *reinterpret_cast<const VkPipelineStageFlags*>(&dstStageMask); }
    inline AccessFlags getSrcAccessMask() const { return reinterpret_cast<const AccessFlags&>(srcAccessMask); }
    inline void setSrcAccessMask(const AccessFlags& srcAccessMask) { this->srcAccessMask = *reinterpret_cast<const VkAccessFlags*>(&srcAccessMask); }
    inline AccessFlags getDstAccessMask() const { return reinterpret_cast<const AccessFlags&>(dstAccessMask); }
    inline void setDstAccessMask(const AccessFlags& dstAccessMask) { this->dstAccessMask = *reinterpret_cast<const VkAccessFlags*>(&dstAccessMask); }
    inline DependencyFlags getDependencyFlags() const { return reinterpret_cast<const DependencyFlags&>(dependencyFlags); }
    inline void setDependencyFlags(const DependencyFlags& dependencyFlags) { this->dependencyFlags = *reinterpret_cast<const VkDependencyFlags*>(&dependencyFlags); }
};

struct BufferCopy : private VkBufferCopy
{
    BufferCopy()
    {
        setSrcOffset(VkDeviceSize());
        setDstOffset(VkDeviceSize());
        setSize(VkDeviceSize());
    }
    BufferCopy(VkDeviceSize srcOffset, VkDeviceSize dstOffset, VkDeviceSize size)
    {
        setSrcOffset(srcOffset);
        setDstOffset(dstOffset);
        setSize(size);
    }
    inline VkDeviceSize getSrcOffset() const { return srcOffset; }
    inline void setSrcOffset(VkDeviceSize srcOffset) { this->srcOffset = srcOffset; }
    inline VkDeviceSize getDstOffset() const { return dstOffset; }
    inline void setDstOffset(VkDeviceSize dstOffset) { this->dstOffset = dstOffset; }
    inline VkDeviceSize getSize() const { return size; }
    inline void setSize(VkDeviceSize size) { this->size = size; }
};

struct ImageSubresourceLayers : private VkImageSubresourceLayers
{
    ImageSubresourceLayers()
    {
        setAspectMask(ImageAspectFlags::e_COLOR_BIT);
        setMipLevel(0);
        setBaseArrayLayer(0);
        setLayerCount(1);
    }
    ImageSubresourceLayers(const ImageAspectFlags& aspectMask, uint32_t mipLevel, uint32_t baseArrayLayer, uint32_t layerCount)
    {
        setAspectMask(aspectMask);
        setMipLevel(mipLevel);
        setBaseArrayLayer(baseArrayLayer);
        setLayerCount(layerCount);
    }
    inline ImageAspectFlags getAspectMask() const { return reinterpret_cast<const ImageAspectFlags&>(aspectMask); }
    inline void setAspectMask(const ImageAspectFlags& aspectMask) { this->aspectMask = *reinterpret_cast<const VkImageAspectFlags*>(&aspectMask); }
    inline uint32_t getMipLevel() const { return mipLevel; }
    inline void setMipLevel(uint32_t mipLevel) { this->mipLevel = mipLevel; }
    inline uint32_t getBaseArrayLayer() const { return baseArrayLayer; }
    inline void setBaseArrayLayer(uint32_t baseArrayLayer) { this->baseArrayLayer = baseArrayLayer; }
    inline uint32_t getLayerCount() const { return layerCount; }
    inline void setLayerCount(uint32_t layerCount) { this->layerCount = layerCount; }
};

struct ImageCopy : private VkImageCopy
{
    ImageCopy()
    {
        setSrcSubresource(ImageSubresourceLayers());
        setSrcOffset(Offset3D());
        setDstSubresource(ImageSubresourceLayers());
        setDstOffset(Offset3D());
        setExtent(Extent3D());
    }
    ImageCopy(const ImageSubresourceLayers& srcSubresource, const Offset3D& srcOffset, const ImageSubresourceLayers& dstSubresource, const Offset3D& dstOffset, const Extent3D& extent)
    {
        setSrcSubresource(srcSubresource);
        setSrcOffset(srcOffset);
        setDstSubresource(dstSubresource);
        setDstOffset(dstOffset);
        setExtent(extent);
    }
    inline const ImageSubresourceLayers& getSrcSubresource() const { return reinterpret_cast<const ImageSubresourceLayers&>(srcSubresource); }
    inline void setSrcSubresource(const ImageSubresourceLayers& srcSubresource) { this->srcSubresource = *reinterpret_cast<const VkImageSubresourceLayers*>(&srcSubresource); }
    inline const Offset3D& getSrcOffset() const { return reinterpret_cast<const Offset3D&>(srcOffset); }
    inline void setSrcOffset(const Offset3D& srcOffset) { this->srcOffset = *reinterpret_cast<const VkOffset3D*>(&srcOffset); }
    inline const ImageSubresourceLayers& getDstSubresource() const { return reinterpret_cast<const ImageSubresourceLayers&>(dstSubresource); }
    inline void setDstSubresource(const ImageSubresourceLayers& dstSubresource) { this->dstSubresource = *reinterpret_cast<const VkImageSubresourceLayers*>(&dstSubresource); }
    inline const Offset3D& getDstOffset() const { return reinterpret_cast<const Offset3D&>(dstOffset); }
    inline void setDstOffset(const Offset3D& dstOffset) { this->dstOffset = *reinterpret_cast<const VkOffset3D*>(&dstOffset); }
    inline const Extent3D& getExtent() const { return reinterpret_cast<const Extent3D&>(extent); }
    inline void setExtent(const Extent3D& extent) { this->extent = *reinterpret_cast<const VkExtent3D*>(&extent); }
};

struct ImageBlit : private VkImageBlit
{
    ImageBlit()
    {
        setSrcSubresource(ImageSubresourceLayers());
        memset(srcOffsets, 0, sizeof(srcOffsets));
        setDstSubresource(ImageSubresourceLayers());
        memset(dstOffsets, 0, sizeof(dstOffsets));
    }
    ImageBlit(const ImageSubresourceLayers& srcSubresource, const Offset3D* srcOffsets, const ImageSubresourceLayers& dstSubresource, const Offset3D* dstOffsets)
    {
        setSrcSubresource(srcSubresource);
        setSrcOffsets(srcOffsets);
        setDstSubresource(dstSubresource);
        setDstOffsets(dstOffsets);
    }
    inline const ImageSubresourceLayers& getSrcSubresource() const { return reinterpret_cast<const ImageSubresourceLayers&>(srcSubresource); }
    inline void setSrcSubresource(const ImageSubresourceLayers& srcSubresource) { this->srcSubresource = *reinterpret_cast<const VkImageSubresourceLayers*>(&srcSubresource); }
    inline const Offset3D* getSrcOffsets() const { return reinterpret_cast<const Offset3D*>(srcOffsets); }
    inline void setSrcOffsets(const Offset3D* srcOffsets) { memcpy(this->srcOffsets, reinterpret_cast<const VkOffset3D*>(srcOffsets), sizeof(this->srcOffsets)); }
    inline void setSrcOffsets(const Offset3D& srcOffsets, const uint32_t index) { this->srcOffsets[index] = *reinterpret_cast<const VkOffset3D*>(&srcOffsets); }
    inline const ImageSubresourceLayers& getDstSubresource() const { return reinterpret_cast<const ImageSubresourceLayers&>(dstSubresource); }
    inline void setDstSubresource(const ImageSubresourceLayers& dstSubresource) { this->dstSubresource = *reinterpret_cast<const VkImageSubresourceLayers*>(&dstSubresource); }
    inline const Offset3D* getDstOffsets() const { return reinterpret_cast<const Offset3D*>(dstOffsets); }
    inline void setDstOffsets(const Offset3D* dstOffsets) { memcpy(this->dstOffsets, reinterpret_cast<const VkOffset3D*>(dstOffsets), sizeof(this->dstOffsets)); }
    inline void setDstOffsets(const Offset3D& dstOffsets, const uint32_t index) { this->dstOffsets[index] = *reinterpret_cast<const VkOffset3D*>(&dstOffsets); }
};

struct BufferImageCopy : private VkBufferImageCopy
{
    BufferImageCopy()
    {
        setBufferOffset(VkDeviceSize());
        setBufferRowLength(uint32_t());
        setBufferImageHeight(uint32_t());
        setImageSubresource(ImageSubresourceLayers());
        setImageOffset(Offset3D());
        setImageExtent(Extent3D());
    }
    BufferImageCopy(VkDeviceSize bufferOffset, uint32_t bufferRowLength, uint32_t bufferImageHeight, const ImageSubresourceLayers& imageSubresource, const Offset3D& imageOffset, const Extent3D& imageExtent)
    {
        setBufferOffset(bufferOffset);
        setBufferRowLength(bufferRowLength);
        setBufferImageHeight(bufferImageHeight);
        setImageSubresource(imageSubresource);
        setImageOffset(imageOffset);
        setImageExtent(imageExtent);
    }
    inline VkDeviceSize getBufferOffset() const { return bufferOffset; }
    inline void setBufferOffset(VkDeviceSize bufferOffset) { this->bufferOffset = bufferOffset; }
    inline uint32_t getBufferRowLength() const { return bufferRowLength; }
    inline void setBufferRowLength(uint32_t bufferRowLength) { this->bufferRowLength = bufferRowLength; }
    inline uint32_t getBufferImageHeight() const { return bufferImageHeight; }
    inline void setBufferImageHeight(uint32_t bufferImageHeight) { this->bufferImageHeight = bufferImageHeight; }
    inline const ImageSubresourceLayers& getImageSubresource() const { return reinterpret_cast<const ImageSubresourceLayers&>(imageSubresource); }
    inline void setImageSubresource(const ImageSubresourceLayers& imageSubresource) { this->imageSubresource = *reinterpret_cast<const VkImageSubresourceLayers*>(&imageSubresource); }
    inline const Offset3D& getImageOffset() const { return reinterpret_cast<const Offset3D&>(imageOffset); }
    inline void setImageOffset(const Offset3D& imageOffset) { this->imageOffset = *reinterpret_cast<const VkOffset3D*>(&imageOffset); }
    inline const Extent3D& getImageExtent() const { return reinterpret_cast<const Extent3D&>(imageExtent); }
    inline void setImageExtent(const Extent3D& imageExtent) { this->imageExtent = *reinterpret_cast<const VkExtent3D*>(&imageExtent); }
};

struct ClearDepthStencilValue : private VkClearDepthStencilValue
{
    ClearDepthStencilValue()
    {
        setDepth(float());
        setStencil(uint32_t());
    }
    ClearDepthStencilValue(float depth, uint32_t stencil)
    {
        setDepth(depth);
        setStencil(stencil);
    }
    inline float getDepth() const { return depth; }
    inline void setDepth(float depth) { this->depth = depth; }
    inline uint32_t getStencil() const { return stencil; }
    inline void setStencil(uint32_t stencil) { this->stencil = stencil; }
};

struct ClearRect : private VkClearRect
{
    ClearRect()
    {
        setRect(Rect2D());
        setBaseArrayLayer(0);
        setLayerCount(1);
    }
    ClearRect(const Rect2D& rect, uint32_t baseArrayLayer = 0, uint32_t layerCount = 1)
    {
        setRect(rect);
        setBaseArrayLayer(baseArrayLayer);
        setLayerCount(layerCount);
    }
    inline const Rect2D& getRect() const { return reinterpret_cast<const Rect2D&>(rect); }
    inline void setRect(const Rect2D& rect) { this->rect = *reinterpret_cast<const VkRect2D*>(&rect); }
    inline uint32_t getBaseArrayLayer() const { return baseArrayLayer; }
    inline void setBaseArrayLayer(uint32_t baseArrayLayer) { this->baseArrayLayer = baseArrayLayer; }
    inline uint32_t getLayerCount() const { return layerCount; }
    inline void setLayerCount(uint32_t layerCount) { this->layerCount = layerCount; }
};

struct ImageResolve : private VkImageResolve
{
    ImageResolve()
    {
        setSrcSubresource(ImageSubresourceLayers());
        setSrcOffset(Offset3D());
        setDstSubresource(ImageSubresourceLayers());
        setDstOffset(Offset3D());
        setExtent(Extent3D());
    }
    ImageResolve(const ImageSubresourceLayers& srcSubresource, const Offset3D& srcOffset, const ImageSubresourceLayers& dstSubresource, const Offset3D& dstOffset, const Extent3D& extent)
    {
        setSrcSubresource(srcSubresource);
        setSrcOffset(srcOffset);
        setDstSubresource(dstSubresource);
        setDstOffset(dstOffset);
        setExtent(extent);
    }
    inline const ImageSubresourceLayers& getSrcSubresource() const { return reinterpret_cast<const ImageSubresourceLayers&>(srcSubresource); }
    inline void setSrcSubresource(const ImageSubresourceLayers& srcSubresource) { this->srcSubresource = *reinterpret_cast<const VkImageSubresourceLayers*>(&srcSubresource); }
    inline const Offset3D& getSrcOffset() const { return reinterpret_cast<const Offset3D&>(srcOffset); }
    inline void setSrcOffset(const Offset3D& srcOffset) { this->srcOffset = *reinterpret_cast<const VkOffset3D*>(&srcOffset); }
    inline const ImageSubresourceLayers& getDstSubresource() const { return reinterpret_cast<const ImageSubresourceLayers&>(dstSubresource); }
    inline void setDstSubresource(const ImageSubresourceLayers& dstSubresource) { this->dstSubresource = *reinterpret_cast<const VkImageSubresourceLayers*>(&dstSubresource); }
    inline const Offset3D& getDstOffset() const { return reinterpret_cast<const Offset3D&>(dstOffset); }
    inline void setDstOffset(const Offset3D& dstOffset) { this->dstOffset = *reinterpret_cast<const VkOffset3D*>(&dstOffset); }
    inline const Extent3D& getExtent() const { return reinterpret_cast<const Extent3D&>(extent); }
    inline void setExtent(const Extent3D& extent) { this->extent = *reinterpret_cast<const VkExtent3D*>(&extent); }
};

struct DispatchIndirectCommand : private VkDispatchIndirectCommand
{
    DispatchIndirectCommand()
    {
        setX(uint32_t());
        setY(uint32_t());
        setZ(uint32_t());
    }
    DispatchIndirectCommand(uint32_t x, uint32_t y, uint32_t z)
    {
        setX(x);
        setY(y);
        setZ(z);
    }
    inline uint32_t getX() const { return x; }
    inline void setX(uint32_t x) { this->x = x; }
    inline uint32_t getY() const { return y; }
    inline void setY(uint32_t y) { this->y = y; }
    inline uint32_t getZ() const { return z; }
    inline void setZ(uint32_t z) { this->z = z; }
};

struct DrawIndexedIndirectCommand : private VkDrawIndexedIndirectCommand
{
    DrawIndexedIndirectCommand()
    {
        setIndexCount(uint32_t());
        setInstanceCount(uint32_t());
        setFirstIndex(uint32_t());
        setVertexOffset(int32_t());
        setFirstInstance(uint32_t());
    }
    DrawIndexedIndirectCommand(uint32_t indexCount, uint32_t instanceCount, uint32_t firstIndex, int32_t vertexOffset, uint32_t firstInstance)
    {
        setIndexCount(indexCount);
        setInstanceCount(instanceCount);
        setFirstIndex(firstIndex);
        setVertexOffset(vertexOffset);
        setFirstInstance(firstInstance);
    }
    inline uint32_t getIndexCount() const { return indexCount; }
    inline void setIndexCount(uint32_t indexCount) { this->indexCount = indexCount; }
    inline uint32_t getInstanceCount() const { return instanceCount; }
    inline void setInstanceCount(uint32_t instanceCount) { this->instanceCount = instanceCount; }
    inline uint32_t getFirstIndex() const { return firstIndex; }
    inline void setFirstIndex(uint32_t firstIndex) { this->firstIndex = firstIndex; }
    inline int32_t getVertexOffset() const { return vertexOffset; }
    inline void setVertexOffset(int32_t vertexOffset) { this->vertexOffset = vertexOffset; }
    inline uint32_t getFirstInstance() const { return firstInstance; }
    inline void setFirstInstance(uint32_t firstInstance) { this->firstInstance = firstInstance; }
};

struct DrawIndirectCommand : private VkDrawIndirectCommand
{
    DrawIndirectCommand()
    {
        setVertexCount(uint32_t());
        setInstanceCount(uint32_t());
        setFirstVertex(uint32_t());
        setFirstInstance(uint32_t());
    }
    DrawIndirectCommand(uint32_t vertexCount, uint32_t instanceCount, uint32_t firstVertex, uint32_t firstInstance)
    {
        setVertexCount(vertexCount);
        setInstanceCount(instanceCount);
        setFirstVertex(firstVertex);
        setFirstInstance(firstInstance);
    }
    inline uint32_t getVertexCount() const { return vertexCount; }
    inline void setVertexCount(uint32_t vertexCount) { this->vertexCount = vertexCount; }
    inline uint32_t getInstanceCount() const { return instanceCount; }
    inline void setInstanceCount(uint32_t instanceCount) { this->instanceCount = instanceCount; }
    inline uint32_t getFirstVertex() const { return firstVertex; }
    inline void setFirstVertex(uint32_t firstVertex) { this->firstVertex = firstVertex; }
    inline uint32_t getFirstInstance() const { return firstInstance; }
    inline void setFirstInstance(uint32_t firstInstance) { this->firstInstance = firstInstance; }
};

struct InputAttachmentAspectReference : private VkInputAttachmentAspectReference
{
    InputAttachmentAspectReference()
    {
        setSubpass(uint32_t());
        setInputAttachmentIndex(uint32_t());
        setAspectMask(ImageAspectFlags());
    }
    InputAttachmentAspectReference(uint32_t subpass, uint32_t inputAttachmentIndex, const ImageAspectFlags& aspectMask)
    {
        setSubpass(subpass);
        setInputAttachmentIndex(inputAttachmentIndex);
        setAspectMask(aspectMask);
    }
    inline uint32_t getSubpass() const { return subpass; }
    inline void setSubpass(uint32_t subpass) { this->subpass = subpass; }
    inline uint32_t getInputAttachmentIndex() const { return inputAttachmentIndex; }
    inline void setInputAttachmentIndex(uint32_t inputAttachmentIndex) { this->inputAttachmentIndex = inputAttachmentIndex; }
    inline ImageAspectFlags getAspectMask() const { return reinterpret_cast<const ImageAspectFlags&>(aspectMask); }
    inline void setAspectMask(const ImageAspectFlags& aspectMask) { this->aspectMask = *reinterpret_cast<const VkImageAspectFlags*>(&aspectMask); }
};

struct DescriptorUpdateTemplateEntry : private VkDescriptorUpdateTemplateEntry
{
    DescriptorUpdateTemplateEntry()
    {
        setDstBinding(uint32_t());
        setDstArrayElement(uint32_t());
        setDescriptorCount(uint32_t());
        setDescriptorType(DescriptorType());
        setOffset(size_t());
        setStride(size_t());
    }
    DescriptorUpdateTemplateEntry(uint32_t dstBinding, uint32_t dstArrayElement, uint32_t descriptorCount, const DescriptorType& descriptorType, size_t offset, size_t stride)
    {
        setDstBinding(dstBinding);
        setDstArrayElement(dstArrayElement);
        setDescriptorCount(descriptorCount);
        setDescriptorType(descriptorType);
        setOffset(offset);
        setStride(stride);
    }
    inline uint32_t getDstBinding() const { return dstBinding; }
    inline void setDstBinding(uint32_t dstBinding) { this->dstBinding = dstBinding; }
    inline uint32_t getDstArrayElement() const { return dstArrayElement; }
    inline void setDstArrayElement(uint32_t dstArrayElement) { this->dstArrayElement = dstArrayElement; }
    inline uint32_t getDescriptorCount() const { return descriptorCount; }
    inline void setDescriptorCount(uint32_t descriptorCount) { this->descriptorCount = descriptorCount; }
    inline DescriptorType getDescriptorType() const { return reinterpret_cast<const DescriptorType&>(descriptorType); }
    inline void setDescriptorType(const DescriptorType& descriptorType) { this->descriptorType = *reinterpret_cast<const VkDescriptorType*>(&descriptorType); }
    inline size_t getOffset() const { return offset; }
    inline void setOffset(size_t offset) { this->offset = offset; }
    inline size_t getStride() const { return stride; }
    inline void setStride(size_t stride) { this->stride = stride; }
};

// ExternalMemoryProperties is a structure used only as a return type so only getters are defined
struct ExternalMemoryProperties : private VkExternalMemoryProperties
{
    inline ExternalMemoryFeatureFlags getExternalMemoryFeatures() const { return reinterpret_cast<const ExternalMemoryFeatureFlags&>(externalMemoryFeatures); }
    inline ExternalMemoryHandleTypeFlags getExportFromImportedHandleTypes() const { return reinterpret_cast<const ExternalMemoryHandleTypeFlags&>(exportFromImportedHandleTypes); }
    inline ExternalMemoryHandleTypeFlags getCompatibleHandleTypes() const { return reinterpret_cast<const ExternalMemoryHandleTypeFlags&>(compatibleHandleTypes); }
};

// SurfaceCapabilitiesKHR is a structure used only as a return type so only getters are defined
struct SurfaceCapabilitiesKHR : private VkSurfaceCapabilitiesKHR
{
    inline uint32_t getMinImageCount() const { return minImageCount; }
    inline uint32_t getMaxImageCount() const { return maxImageCount; }
    inline const Extent2D& getCurrentExtent() const { return reinterpret_cast<const Extent2D&>(currentExtent); }
    inline const Extent2D& getMinImageExtent() const { return reinterpret_cast<const Extent2D&>(minImageExtent); }
    inline const Extent2D& getMaxImageExtent() const { return reinterpret_cast<const Extent2D&>(maxImageExtent); }
    inline uint32_t getMaxImageArrayLayers() const { return maxImageArrayLayers; }
    inline SurfaceTransformFlagsKHR getSupportedTransforms() const { return reinterpret_cast<const SurfaceTransformFlagsKHR&>(supportedTransforms); }
    inline SurfaceTransformFlagsKHR getCurrentTransform() const { return reinterpret_cast<const SurfaceTransformFlagsKHR&>(currentTransform); }
    inline CompositeAlphaFlagsKHR getSupportedCompositeAlpha() const { return reinterpret_cast<const CompositeAlphaFlagsKHR&>(supportedCompositeAlpha); }
    inline ImageUsageFlags getSupportedUsageFlags() const { return reinterpret_cast<const ImageUsageFlags&>(supportedUsageFlags); }
};

// SurfaceFormatKHR is a structure used only as a return type so only getters are defined
struct SurfaceFormatKHR : private VkSurfaceFormatKHR
{
    inline Format getFormat() const { return reinterpret_cast<const Format&>(format); }
    inline ColorSpaceKHR getColorSpace() const { return reinterpret_cast<const ColorSpaceKHR&>(colorSpace); }
};

// DisplayPropertiesKHR is a structure used only as a return type so only getters are defined
struct DisplayPropertiesKHR : private VkDisplayPropertiesKHR
{
    inline const VkDisplayKHR& getDisplay() const { return display; }
    inline const char* getDisplayName() const { return displayName; }
    inline const Extent2D& getPhysicalDimensions() const { return reinterpret_cast<const Extent2D&>(physicalDimensions); }
    inline const Extent2D& getPhysicalResolution() const { return reinterpret_cast<const Extent2D&>(physicalResolution); }
    inline SurfaceTransformFlagsKHR getSupportedTransforms() const { return reinterpret_cast<const SurfaceTransformFlagsKHR&>(supportedTransforms); }
    inline VkBool32 getPlaneReorderPossible() const { return planeReorderPossible; }
    inline VkBool32 getPersistentContent() const { return persistentContent; }
};

struct DisplayModeParametersKHR : private VkDisplayModeParametersKHR
{
    DisplayModeParametersKHR()
    {
        setVisibleRegion(Extent2D());
        setRefreshRate(uint32_t());
    }
    DisplayModeParametersKHR(const Extent2D& visibleRegion, uint32_t refreshRate)
    {
        setVisibleRegion(visibleRegion);
        setRefreshRate(refreshRate);
    }
    inline const Extent2D& getVisibleRegion() const { return reinterpret_cast<const Extent2D&>(visibleRegion); }
    inline void setVisibleRegion(const Extent2D& visibleRegion) { this->visibleRegion = *reinterpret_cast<const VkExtent2D*>(&visibleRegion); }
    inline uint32_t getRefreshRate() const { return refreshRate; }
    inline void setRefreshRate(uint32_t refreshRate) { this->refreshRate = refreshRate; }
};

// DisplayModePropertiesKHR is a structure used only as a return type so only getters are defined
struct DisplayModePropertiesKHR : private VkDisplayModePropertiesKHR
{
    inline const VkDisplayModeKHR& getDisplayMode() const { return displayMode; }
    inline const DisplayModeParametersKHR& getParameters() const { return reinterpret_cast<const DisplayModeParametersKHR&>(parameters); }
};

// DisplayPlaneCapabilitiesKHR is a structure used only as a return type so only getters are defined
struct DisplayPlaneCapabilitiesKHR : private VkDisplayPlaneCapabilitiesKHR
{
    inline DisplayPlaneAlphaFlagsKHR getSupportedAlpha() const { return reinterpret_cast<const DisplayPlaneAlphaFlagsKHR&>(supportedAlpha); }
    inline const Offset2D& getMinSrcPosition() const { return reinterpret_cast<const Offset2D&>(minSrcPosition); }
    inline const Offset2D& getMaxSrcPosition() const { return reinterpret_cast<const Offset2D&>(maxSrcPosition); }
    inline const Extent2D& getMinSrcExtent() const { return reinterpret_cast<const Extent2D&>(minSrcExtent); }
    inline const Extent2D& getMaxSrcExtent() const { return reinterpret_cast<const Extent2D&>(maxSrcExtent); }
    inline const Offset2D& getMinDstPosition() const { return reinterpret_cast<const Offset2D&>(minDstPosition); }
    inline const Offset2D& getMaxDstPosition() const { return reinterpret_cast<const Offset2D&>(maxDstPosition); }
    inline const Extent2D& getMinDstExtent() const { return reinterpret_cast<const Extent2D&>(minDstExtent); }
    inline const Extent2D& getMaxDstExtent() const { return reinterpret_cast<const Extent2D&>(maxDstExtent); }
};

// DisplayPlanePropertiesKHR is a structure used only as a return type so only getters are defined
struct DisplayPlanePropertiesKHR : private VkDisplayPlanePropertiesKHR
{
    inline const VkDisplayKHR& getCurrentDisplay() const { return currentDisplay; }
    inline uint32_t getCurrentStackIndex() const { return currentStackIndex; }
};

struct RectLayerKHR : private VkRectLayerKHR
{
    RectLayerKHR()
    {
        setOffset(Offset2D());
        setExtent(Extent2D());
        setLayer(uint32_t());
    }
    RectLayerKHR(const Offset2D& offset, const Extent2D& extent, uint32_t layer)
    {
        setOffset(offset);
        setExtent(extent);
        setLayer(layer);
    }
    inline const Offset2D& getOffset() const { return reinterpret_cast<const Offset2D&>(offset); }
    inline void setOffset(const Offset2D& offset) { this->offset = *reinterpret_cast<const VkOffset2D*>(&offset); }
    inline const Extent2D& getExtent() const { return reinterpret_cast<const Extent2D&>(extent); }
    inline void setExtent(const Extent2D& extent) { this->extent = *reinterpret_cast<const VkExtent2D*>(&extent); }
    inline uint32_t getLayer() const { return layer; }
    inline void setLayer(uint32_t layer) { this->layer = layer; }
};

struct PresentRegionKHR : private VkPresentRegionKHR
{
    PresentRegionKHR()
    {
        setRectangleCount(uint32_t());
        pRectangles = nullptr;
    }
    PresentRegionKHR(uint32_t rectangleCount, RectLayerKHR* pRectangles)
    {
        setRectangleCount(rectangleCount);
        setPRectangles(pRectangles);
    }
    inline uint32_t getRectangleCount() const { return rectangleCount; }
    inline void setRectangleCount(uint32_t rectangleCount) { this->rectangleCount = rectangleCount; }
    inline const RectLayerKHR* getPRectangles() const { return reinterpret_cast<const RectLayerKHR*>(pRectangles); }
    inline void setPRectangles(RectLayerKHR* pRectangles) { this->pRectangles = reinterpret_cast<const VkRectLayerKHR*>(pRectangles); }
};

// ShaderResourceUsageAMD is a structure used only as a return type so only getters are defined
struct ShaderResourceUsageAMD : private VkShaderResourceUsageAMD
{
    inline uint32_t getNumUsedVgprs() const { return numUsedVgprs; }
    inline uint32_t getNumUsedSgprs() const { return numUsedSgprs; }
    inline uint32_t getLdsSizePerLocalWorkGroup() const { return ldsSizePerLocalWorkGroup; }
    inline size_t getLdsUsageSizeInBytes() const { return ldsUsageSizeInBytes; }
    inline size_t getScratchMemUsageInBytes() const { return scratchMemUsageInBytes; }
};

// ShaderStatisticsInfoAMD is a structure used only as a return type so only getters are defined
struct ShaderStatisticsInfoAMD : private VkShaderStatisticsInfoAMD
{
    inline ShaderStageFlags getShaderStageMask() const { return reinterpret_cast<const ShaderStageFlags&>(shaderStageMask); }
    inline const ShaderResourceUsageAMD& getResourceUsage() const { return reinterpret_cast<const ShaderResourceUsageAMD&>(resourceUsage); }
    inline uint32_t getNumPhysicalVgprs() const { return numPhysicalVgprs; }
    inline uint32_t getNumPhysicalSgprs() const { return numPhysicalSgprs; }
    inline uint32_t getNumAvailableVgprs() const { return numAvailableVgprs; }
    inline uint32_t getNumAvailableSgprs() const { return numAvailableSgprs; }
    inline const uint32_t* getComputeWorkGroupSize() const { return computeWorkGroupSize; }
};

// ExternalImageFormatPropertiesNV is a structure used only as a return type so only getters are defined
struct ExternalImageFormatPropertiesNV : private VkExternalImageFormatPropertiesNV
{
    inline const ImageFormatProperties& getImageFormatProperties() const { return reinterpret_cast<const ImageFormatProperties&>(imageFormatProperties); }
    inline ExternalMemoryFeatureFlagsNV getExternalMemoryFeatures() const { return reinterpret_cast<const ExternalMemoryFeatureFlagsNV&>(externalMemoryFeatures); }
    inline ExternalMemoryHandleTypeFlagsNV getExportFromImportedHandleTypes() const { return reinterpret_cast<const ExternalMemoryHandleTypeFlagsNV&>(exportFromImportedHandleTypes); }
    inline ExternalMemoryHandleTypeFlagsNV getCompatibleHandleTypes() const { return reinterpret_cast<const ExternalMemoryHandleTypeFlagsNV&>(compatibleHandleTypes); }
};

struct IndirectCommandsTokenNVX : private VkIndirectCommandsTokenNVX
{
    IndirectCommandsTokenNVX()
    {
        setTokenType(IndirectCommandsTokenTypeNVX());
        setBuffer(VkBuffer());
        setOffset(VkDeviceSize());
    }
    IndirectCommandsTokenNVX(const IndirectCommandsTokenTypeNVX& tokenType, const VkBuffer& buffer, VkDeviceSize offset)
    {
        setTokenType(tokenType);
        setBuffer(buffer);
        setOffset(offset);
    }
    inline IndirectCommandsTokenTypeNVX getTokenType() const { return reinterpret_cast<const IndirectCommandsTokenTypeNVX&>(tokenType); }
    inline void setTokenType(const IndirectCommandsTokenTypeNVX& tokenType) { this->tokenType = *reinterpret_cast<const VkIndirectCommandsTokenTypeNVX*>(&tokenType); }
    inline const VkBuffer& getBuffer() const { return buffer; }
    inline void setBuffer(const VkBuffer& buffer) { this->buffer = buffer; }
    inline VkDeviceSize getOffset() const { return offset; }
    inline void setOffset(VkDeviceSize offset) { this->offset = offset; }
};

struct IndirectCommandsLayoutTokenNVX : private VkIndirectCommandsLayoutTokenNVX
{
    IndirectCommandsLayoutTokenNVX()
    {
        setTokenType(IndirectCommandsTokenTypeNVX());
        setBindingUnit(uint32_t());
        setDynamicCount(uint32_t());
        setDivisor(uint32_t());
    }
    IndirectCommandsLayoutTokenNVX(const IndirectCommandsTokenTypeNVX& tokenType, uint32_t bindingUnit, uint32_t dynamicCount, uint32_t divisor)
    {
        setTokenType(tokenType);
        setBindingUnit(bindingUnit);
        setDynamicCount(dynamicCount);
        setDivisor(divisor);
    }
    inline IndirectCommandsTokenTypeNVX getTokenType() const { return reinterpret_cast<const IndirectCommandsTokenTypeNVX&>(tokenType); }
    inline void setTokenType(const IndirectCommandsTokenTypeNVX& tokenType) { this->tokenType = *reinterpret_cast<const VkIndirectCommandsTokenTypeNVX*>(&tokenType); }
    inline uint32_t getBindingUnit() const { return bindingUnit; }
    inline void setBindingUnit(uint32_t bindingUnit) { this->bindingUnit = bindingUnit; }
    inline uint32_t getDynamicCount() const { return dynamicCount; }
    inline void setDynamicCount(uint32_t dynamicCount) { this->dynamicCount = dynamicCount; }
    inline uint32_t getDivisor() const { return divisor; }
    inline void setDivisor(uint32_t divisor) { this->divisor = divisor; }
};

struct ObjectTableEntryNVX : private VkObjectTableEntryNVX
{
    ObjectTableEntryNVX()
    {
        setType(ObjectEntryTypeNVX());
        setFlags(ObjectEntryUsageFlagsNVX());
    }
    ObjectTableEntryNVX(const ObjectEntryTypeNVX& type, const ObjectEntryUsageFlagsNVX& flags)
    {
        setType(type);
        setFlags(flags);
    }
    inline ObjectEntryTypeNVX getType() const { return reinterpret_cast<const ObjectEntryTypeNVX&>(type); }
    inline void setType(const ObjectEntryTypeNVX& type) { this->type = *reinterpret_cast<const VkObjectEntryTypeNVX*>(&type); }
    inline ObjectEntryUsageFlagsNVX getFlags() const { return reinterpret_cast<const ObjectEntryUsageFlagsNVX&>(flags); }
    inline void setFlags(const ObjectEntryUsageFlagsNVX& flags) { this->flags = *reinterpret_cast<const VkObjectEntryUsageFlagsNVX*>(&flags); }
};

struct ObjectTablePipelineEntryNVX : private VkObjectTablePipelineEntryNVX
{
    ObjectTablePipelineEntryNVX()
    {
        setType(ObjectEntryTypeNVX());
        setFlags(ObjectEntryUsageFlagsNVX());
        setPipeline(VkPipeline());
    }
    ObjectTablePipelineEntryNVX(const ObjectEntryTypeNVX& type, const ObjectEntryUsageFlagsNVX& flags, const VkPipeline& pipeline)
    {
        setType(type);
        setFlags(flags);
        setPipeline(pipeline);
    }
    inline ObjectEntryTypeNVX getType() const { return reinterpret_cast<const ObjectEntryTypeNVX&>(type); }
    inline void setType(const ObjectEntryTypeNVX& type) { this->type = *reinterpret_cast<const VkObjectEntryTypeNVX*>(&type); }
    inline ObjectEntryUsageFlagsNVX getFlags() const { return reinterpret_cast<const ObjectEntryUsageFlagsNVX&>(flags); }
    inline void setFlags(const ObjectEntryUsageFlagsNVX& flags) { this->flags = *reinterpret_cast<const VkObjectEntryUsageFlagsNVX*>(&flags); }
    inline const VkPipeline& getPipeline() const { return pipeline; }
    inline void setPipeline(const VkPipeline& pipeline) { this->pipeline = pipeline; }
};

struct ObjectTableDescriptorSetEntryNVX : private VkObjectTableDescriptorSetEntryNVX
{
    ObjectTableDescriptorSetEntryNVX()
    {
        setType(ObjectEntryTypeNVX());
        setFlags(ObjectEntryUsageFlagsNVX());
        setPipelineLayout(VkPipelineLayout());
        setDescriptorSet(VkDescriptorSet());
    }
    ObjectTableDescriptorSetEntryNVX(const ObjectEntryTypeNVX& type, const ObjectEntryUsageFlagsNVX& flags, const VkPipelineLayout& pipelineLayout, const VkDescriptorSet& descriptorSet)
    {
        setType(type);
        setFlags(flags);
        setPipelineLayout(pipelineLayout);
        setDescriptorSet(descriptorSet);
    }
    inline ObjectEntryTypeNVX getType() const { return reinterpret_cast<const ObjectEntryTypeNVX&>(type); }
    inline void setType(const ObjectEntryTypeNVX& type) { this->type = *reinterpret_cast<const VkObjectEntryTypeNVX*>(&type); }
    inline ObjectEntryUsageFlagsNVX getFlags() const { return reinterpret_cast<const ObjectEntryUsageFlagsNVX&>(flags); }
    inline void setFlags(const ObjectEntryUsageFlagsNVX& flags) { this->flags = *reinterpret_cast<const VkObjectEntryUsageFlagsNVX*>(&flags); }
    inline const VkPipelineLayout& getPipelineLayout() const { return pipelineLayout; }
    inline void setPipelineLayout(const VkPipelineLayout& pipelineLayout) { this->pipelineLayout = pipelineLayout; }
    inline const VkDescriptorSet& getDescriptorSet() const { return descriptorSet; }
    inline void setDescriptorSet(const VkDescriptorSet& descriptorSet) { this->descriptorSet = descriptorSet; }
};

struct ObjectTableVertexBufferEntryNVX : private VkObjectTableVertexBufferEntryNVX
{
    ObjectTableVertexBufferEntryNVX()
    {
        setType(ObjectEntryTypeNVX());
        setFlags(ObjectEntryUsageFlagsNVX());
        setBuffer(VkBuffer());
    }
    ObjectTableVertexBufferEntryNVX(const ObjectEntryTypeNVX& type, const ObjectEntryUsageFlagsNVX& flags, const VkBuffer& buffer)
    {
        setType(type);
        setFlags(flags);
        setBuffer(buffer);
    }
    inline ObjectEntryTypeNVX getType() const { return reinterpret_cast<const ObjectEntryTypeNVX&>(type); }
    inline void setType(const ObjectEntryTypeNVX& type) { this->type = *reinterpret_cast<const VkObjectEntryTypeNVX*>(&type); }
    inline ObjectEntryUsageFlagsNVX getFlags() const { return reinterpret_cast<const ObjectEntryUsageFlagsNVX&>(flags); }
    inline void setFlags(const ObjectEntryUsageFlagsNVX& flags) { this->flags = *reinterpret_cast<const VkObjectEntryUsageFlagsNVX*>(&flags); }
    inline const VkBuffer& getBuffer() const { return buffer; }
    inline void setBuffer(const VkBuffer& buffer) { this->buffer = buffer; }
};

struct ObjectTableIndexBufferEntryNVX : private VkObjectTableIndexBufferEntryNVX
{
    ObjectTableIndexBufferEntryNVX()
    {
        setType(ObjectEntryTypeNVX());
        setFlags(ObjectEntryUsageFlagsNVX());
        setBuffer(VkBuffer());
        setIndexType(IndexType());
    }
    ObjectTableIndexBufferEntryNVX(const ObjectEntryTypeNVX& type, const ObjectEntryUsageFlagsNVX& flags, const VkBuffer& buffer, const IndexType& indexType)
    {
        setType(type);
        setFlags(flags);
        setBuffer(buffer);
        setIndexType(indexType);
    }
    inline ObjectEntryTypeNVX getType() const { return reinterpret_cast<const ObjectEntryTypeNVX&>(type); }
    inline void setType(const ObjectEntryTypeNVX& type) { this->type = *reinterpret_cast<const VkObjectEntryTypeNVX*>(&type); }
    inline ObjectEntryUsageFlagsNVX getFlags() const { return reinterpret_cast<const ObjectEntryUsageFlagsNVX&>(flags); }
    inline void setFlags(const ObjectEntryUsageFlagsNVX& flags) { this->flags = *reinterpret_cast<const VkObjectEntryUsageFlagsNVX*>(&flags); }
    inline const VkBuffer& getBuffer() const { return buffer; }
    inline void setBuffer(const VkBuffer& buffer) { this->buffer = buffer; }
    inline IndexType getIndexType() const { return reinterpret_cast<const IndexType&>(indexType); }
    inline void setIndexType(const IndexType& indexType) { this->indexType = *reinterpret_cast<const VkIndexType*>(&indexType); }
};

struct ObjectTablePushConstantEntryNVX : private VkObjectTablePushConstantEntryNVX
{
    ObjectTablePushConstantEntryNVX()
    {
        setType(ObjectEntryTypeNVX());
        setFlags(ObjectEntryUsageFlagsNVX());
        setPipelineLayout(VkPipelineLayout());
        setStageFlags(ShaderStageFlags());
    }
    ObjectTablePushConstantEntryNVX(const ObjectEntryTypeNVX& type, const ObjectEntryUsageFlagsNVX& flags, const VkPipelineLayout& pipelineLayout, const ShaderStageFlags& stageFlags)
    {
        setType(type);
        setFlags(flags);
        setPipelineLayout(pipelineLayout);
        setStageFlags(stageFlags);
    }
    inline ObjectEntryTypeNVX getType() const { return reinterpret_cast<const ObjectEntryTypeNVX&>(type); }
    inline void setType(const ObjectEntryTypeNVX& type) { this->type = *reinterpret_cast<const VkObjectEntryTypeNVX*>(&type); }
    inline ObjectEntryUsageFlagsNVX getFlags() const { return reinterpret_cast<const ObjectEntryUsageFlagsNVX&>(flags); }
    inline void setFlags(const ObjectEntryUsageFlagsNVX& flags) { this->flags = *reinterpret_cast<const VkObjectEntryUsageFlagsNVX*>(&flags); }
    inline const VkPipelineLayout& getPipelineLayout() const { return pipelineLayout; }
    inline void setPipelineLayout(const VkPipelineLayout& pipelineLayout) { this->pipelineLayout = pipelineLayout; }
    inline ShaderStageFlags getStageFlags() const { return reinterpret_cast<const ShaderStageFlags&>(stageFlags); }
    inline void setStageFlags(const ShaderStageFlags& stageFlags) { this->stageFlags = *reinterpret_cast<const VkShaderStageFlags*>(&stageFlags); }
};

struct ViewportWScalingNV : private VkViewportWScalingNV
{
    ViewportWScalingNV()
    {
        setXcoeff(float());
        setYcoeff(float());
    }
    ViewportWScalingNV(float xcoeff, float ycoeff)
    {
        setXcoeff(xcoeff);
        setYcoeff(ycoeff);
    }
    inline float getXcoeff() const { return xcoeff; }
    inline void setXcoeff(float xcoeff) { this->xcoeff = xcoeff; }
    inline float getYcoeff() const { return ycoeff; }
    inline void setYcoeff(float ycoeff) { this->ycoeff = ycoeff; }
};

struct RefreshCycleDurationGOOGLE : private VkRefreshCycleDurationGOOGLE
{
    RefreshCycleDurationGOOGLE()
    {
        setRefreshDuration(uint64_t());
    }
    RefreshCycleDurationGOOGLE(uint64_t refreshDuration)
    {
        setRefreshDuration(refreshDuration);
    }
    inline uint64_t getRefreshDuration() const { return refreshDuration; }
    inline void setRefreshDuration(uint64_t refreshDuration) { this->refreshDuration = refreshDuration; }
};

struct PastPresentationTimingGOOGLE : private VkPastPresentationTimingGOOGLE
{
    PastPresentationTimingGOOGLE()
    {
        setPresentID(uint32_t());
        setDesiredPresentTime(uint64_t());
        setActualPresentTime(uint64_t());
        setEarliestPresentTime(uint64_t());
        setPresentMargin(uint64_t());
    }
    PastPresentationTimingGOOGLE(uint32_t presentID, uint64_t desiredPresentTime, uint64_t actualPresentTime, uint64_t earliestPresentTime, uint64_t presentMargin)
    {
        setPresentID(presentID);
        setDesiredPresentTime(desiredPresentTime);
        setActualPresentTime(actualPresentTime);
        setEarliestPresentTime(earliestPresentTime);
        setPresentMargin(presentMargin);
    }
    inline uint32_t getPresentID() const { return presentID; }
    inline void setPresentID(uint32_t presentID) { this->presentID = presentID; }
    inline uint64_t getDesiredPresentTime() const { return desiredPresentTime; }
    inline void setDesiredPresentTime(uint64_t desiredPresentTime) { this->desiredPresentTime = desiredPresentTime; }
    inline uint64_t getActualPresentTime() const { return actualPresentTime; }
    inline void setActualPresentTime(uint64_t actualPresentTime) { this->actualPresentTime = actualPresentTime; }
    inline uint64_t getEarliestPresentTime() const { return earliestPresentTime; }
    inline void setEarliestPresentTime(uint64_t earliestPresentTime) { this->earliestPresentTime = earliestPresentTime; }
    inline uint64_t getPresentMargin() const { return presentMargin; }
    inline void setPresentMargin(uint64_t presentMargin) { this->presentMargin = presentMargin; }
};

struct PresentTimeGOOGLE : private VkPresentTimeGOOGLE
{
    PresentTimeGOOGLE()
    {
        setPresentID(uint32_t());
        setDesiredPresentTime(uint64_t());
    }
    PresentTimeGOOGLE(uint32_t presentID, uint64_t desiredPresentTime)
    {
        setPresentID(presentID);
        setDesiredPresentTime(desiredPresentTime);
    }
    inline uint32_t getPresentID() const { return presentID; }
    inline void setPresentID(uint32_t presentID) { this->presentID = presentID; }
    inline uint64_t getDesiredPresentTime() const { return desiredPresentTime; }
    inline void setDesiredPresentTime(uint64_t desiredPresentTime) { this->desiredPresentTime = desiredPresentTime; }
};

struct ViewportSwizzleNV : private VkViewportSwizzleNV
{
    ViewportSwizzleNV()
    {
        setX(ViewportCoordinateSwizzleNV());
        setY(ViewportCoordinateSwizzleNV());
        setZ(ViewportCoordinateSwizzleNV());
        setW(ViewportCoordinateSwizzleNV());
    }
    ViewportSwizzleNV(const ViewportCoordinateSwizzleNV& x, const ViewportCoordinateSwizzleNV& y, const ViewportCoordinateSwizzleNV& z, const ViewportCoordinateSwizzleNV& w)
    {
        setX(x);
        setY(y);
        setZ(z);
        setW(w);
    }
    inline ViewportCoordinateSwizzleNV getX() const { return reinterpret_cast<const ViewportCoordinateSwizzleNV&>(x); }
    inline void setX(const ViewportCoordinateSwizzleNV& x) { this->x = *reinterpret_cast<const VkViewportCoordinateSwizzleNV*>(&x); }
    inline ViewportCoordinateSwizzleNV getY() const { return reinterpret_cast<const ViewportCoordinateSwizzleNV&>(y); }
    inline void setY(const ViewportCoordinateSwizzleNV& y) { this->y = *reinterpret_cast<const VkViewportCoordinateSwizzleNV*>(&y); }
    inline ViewportCoordinateSwizzleNV getZ() const { return reinterpret_cast<const ViewportCoordinateSwizzleNV&>(z); }
    inline void setZ(const ViewportCoordinateSwizzleNV& z) { this->z = *reinterpret_cast<const VkViewportCoordinateSwizzleNV*>(&z); }
    inline ViewportCoordinateSwizzleNV getW() const { return reinterpret_cast<const ViewportCoordinateSwizzleNV&>(w); }
    inline void setW(const ViewportCoordinateSwizzleNV& w) { this->w = *reinterpret_cast<const VkViewportCoordinateSwizzleNV*>(&w); }
};

struct XYColorEXT : private VkXYColorEXT
{
    XYColorEXT()
    {
        setX(float());
        setY(float());
    }
    XYColorEXT(float x, float y)
    {
        setX(x);
        setY(y);
    }
    inline float getX() const { return x; }
    inline void setX(float x) { this->x = x; }
    inline float getY() const { return y; }
    inline void setY(float y) { this->y = y; }
};

struct SampleLocationEXT : private VkSampleLocationEXT
{
    SampleLocationEXT()
    {
        setX(float());
        setY(float());
    }
    SampleLocationEXT(float x, float y)
    {
        setX(x);
        setY(y);
    }
    inline float getX() const { return x; }
    inline void setX(float x) { this->x = x; }
    inline float getY() const { return y; }
    inline void setY(float y) { this->y = y; }
};

struct AttachmentSampleLocationsEXT : private VkAttachmentSampleLocationsEXT
{
    AttachmentSampleLocationsEXT()
    {
        setAttachmentIndex(uint32_t());
        setSampleLocationsInfo(VkSampleLocationsInfoEXT());
    }
    AttachmentSampleLocationsEXT(uint32_t attachmentIndex, const VkSampleLocationsInfoEXT& sampleLocationsInfo)
    {
        setAttachmentIndex(attachmentIndex);
        setSampleLocationsInfo(sampleLocationsInfo);
    }
    inline uint32_t getAttachmentIndex() const { return attachmentIndex; }
    inline void setAttachmentIndex(uint32_t attachmentIndex) { this->attachmentIndex = attachmentIndex; }
    inline const VkSampleLocationsInfoEXT& getSampleLocationsInfo() const { return sampleLocationsInfo; }
    inline void setSampleLocationsInfo(const VkSampleLocationsInfoEXT& sampleLocationsInfo) { this->sampleLocationsInfo = sampleLocationsInfo; }
};

struct SubpassSampleLocationsEXT : private VkSubpassSampleLocationsEXT
{
    SubpassSampleLocationsEXT()
    {
        setSubpassIndex(uint32_t());
        setSampleLocationsInfo(VkSampleLocationsInfoEXT());
    }
    SubpassSampleLocationsEXT(uint32_t subpassIndex, const VkSampleLocationsInfoEXT& sampleLocationsInfo)
    {
        setSubpassIndex(subpassIndex);
        setSampleLocationsInfo(sampleLocationsInfo);
    }
    inline uint32_t getSubpassIndex() const { return subpassIndex; }
    inline void setSubpassIndex(uint32_t subpassIndex) { this->subpassIndex = subpassIndex; }
    inline const VkSampleLocationsInfoEXT& getSampleLocationsInfo() const { return sampleLocationsInfo; }
    inline void setSampleLocationsInfo(const VkSampleLocationsInfoEXT& sampleLocationsInfo) { this->sampleLocationsInfo = sampleLocationsInfo; }
};

struct VertexInputBindingDivisorDescriptionEXT : private VkVertexInputBindingDivisorDescriptionEXT
{
    VertexInputBindingDivisorDescriptionEXT()
    {
        setBinding(uint32_t());
        setDivisor(uint32_t());
    }
    VertexInputBindingDivisorDescriptionEXT(uint32_t binding, uint32_t divisor)
    {
        setBinding(binding);
        setDivisor(divisor);
    }
    inline uint32_t getBinding() const { return binding; }
    inline void setBinding(uint32_t binding) { this->binding = binding; }
    inline uint32_t getDivisor() const { return divisor; }
    inline void setDivisor(uint32_t divisor) { this->divisor = divisor; }
};




// PVRVk Errors
/// <summary>Convert Vulkan error code to string</summary>
/// <param name="errorCode">Vulkan error</param>
/// <returns>Error string</returns>
inline char const* vkErrorToStr(Result errorCode)
{
    switch (errorCode)
    {
    case Result::e_SUCCESS: return "VK_SUCCESS";
    case Result::e_NOT_READY: return "VK_NOT_READY";
    case Result::e_TIMEOUT: return "VK_TIMEOUT";
    case Result::e_EVENT_SET: return "VK_EVENT_SET";
    case Result::e_EVENT_RESET: return "VK_EVENT_RESET";
    case Result::e_INCOMPLETE: return "VK_INCOMPLETE";
    case Result::e_ERROR_OUT_OF_HOST_MEMORY: return "VK_ERROR_OUT_OF_HOST_MEMORY";
    case Result::e_ERROR_OUT_OF_DEVICE_MEMORY: return "VK_ERROR_OUT_OF_DEVICE_MEMORY";
    case Result::e_ERROR_INITIALIZATION_FAILED: return "VK_ERROR_INITIALIZATION_FAILED";
    case Result::e_ERROR_DEVICE_LOST: return "VK_ERROR_DEVICE_LOST";
    case Result::e_ERROR_MEMORY_MAP_FAILED: return "VK_ERROR_MEMORY_MAP_FAILED";
    case Result::e_ERROR_LAYER_NOT_PRESENT: return "VK_ERROR_LAYER_NOT_PRESENT";
    case Result::e_ERROR_EXTENSION_NOT_PRESENT: return "VK_ERROR_EXTENSION_NOT_PRESENT";
    case Result::e_ERROR_FEATURE_NOT_PRESENT: return "VK_ERROR_FEATURE_NOT_PRESENT";
    case Result::e_ERROR_INCOMPATIBLE_DRIVER: return "VK_ERROR_INCOMPATIBLE_DRIVER";
    case Result::e_ERROR_TOO_MANY_OBJECTS: return "VK_ERROR_TOO_MANY_OBJECTS";
    case Result::e_ERROR_FORMAT_NOT_SUPPORTED: return "VK_ERROR_FORMAT_NOT_SUPPORTED";
    case Result::e_ERROR_FRAGMENTED_POOL: return "VK_ERROR_FRAGMENTED_POOL";
    case Result::e_ERROR_OUT_OF_POOL_MEMORY: return "VK_ERROR_OUT_OF_POOL_MEMORY";
    case Result::e_ERROR_INVALID_EXTERNAL_HANDLE: return "VK_ERROR_INVALID_EXTERNAL_HANDLE";
    case Result::e_ERROR_SURFACE_LOST_KHR: return "VK_ERROR_SURFACE_LOST_KHR";
    case Result::e_ERROR_NATIVE_WINDOW_IN_USE_KHR: return "VK_ERROR_NATIVE_WINDOW_IN_USE_KHR";
    case Result::e_SUBOPTIMAL_KHR: return "VK_SUBOPTIMAL_KHR";
    case Result::e_ERROR_OUT_OF_DATE_KHR: return "VK_ERROR_OUT_OF_DATE_KHR";
    case Result::e_ERROR_INCOMPATIBLE_DISPLAY_KHR: return "VK_ERROR_INCOMPATIBLE_DISPLAY_KHR";
    case Result::e_ERROR_VALIDATION_FAILED_EXT: return "VK_ERROR_VALIDATION_FAILED_EXT";
    case Result::e_ERROR_INVALID_SHADER_NV: return "VK_ERROR_INVALID_SHADER_NV";
    case Result::e_ERROR_FRAGMENTATION_EXT: return "VK_ERROR_FRAGMENTATION_EXT";
    case Result::e_ERROR_NOT_PERMITTED_EXT: return "VK_ERROR_NOT_PERMITTED_EXT";
    default: return ("-- Result::UNKNOWN ERROR CODE--");
        break;
    }
}

class Error : public std::runtime_error
{
protected:
	Result _result;
public:
	virtual ~Error() {}
	Error(Result result, const std::string& errorMessage) :
		runtime_error(std::string("[") + vkErrorToStr(result) + ("] : ") + errorMessage), _result(result)
	{
#ifdef DEBUG
		Log(LogLevel::Debug, what());
		debuggerBreak();
#endif
	}
	Error(Result result, const char* errorMessage = NULL) :
		runtime_error((std::string("[") + vkErrorToStr(result) + "] : ") + (errorMessage ? errorMessage : "")), _result(result)
	{
#ifdef DEBUG
		Log(LogLevel::Debug, what());
		debuggerBreak();
#endif
	}
	const char* getErrorMessage() const { return what(); }
	Result getResult() const { return _result; }
	const char* getResultCode() const { return vkErrorToStr(_result); }
};
#define ResultUnknownError Result(-934598375)

class ErrorUnknown : public Error
{
public:
	virtual ~ErrorUnknown() {}
	ErrorUnknown(const char* errorMessage = NULL) : Error(ResultUnknownError, errorMessage) {}
	explicit ErrorUnknown(const std::string& errorMessage) : Error(ResultUnknownError, errorMessage) {}
};
class Success: public Error
{
public:
    virtual ~Success() {}
    Success(const char* errorMessage = NULL) : Error(Result::e_SUCCESS, errorMessage) {}
    explicit Success(const std::string& errorMessage) : Error(Result::e_SUCCESS, errorMessage) {}
};
class NotReady: public Error
{
public:
    virtual ~NotReady() {}
    NotReady(const char* errorMessage = NULL) : Error(Result::e_NOT_READY, errorMessage) {}
    explicit NotReady(const std::string& errorMessage) : Error(Result::e_NOT_READY, errorMessage) {}
};
class Timeout: public Error
{
public:
    virtual ~Timeout() {}
    Timeout(const char* errorMessage = NULL) : Error(Result::e_TIMEOUT, errorMessage) {}
    explicit Timeout(const std::string& errorMessage) : Error(Result::e_TIMEOUT, errorMessage) {}
};
class EventSet: public Error
{
public:
    virtual ~EventSet() {}
    EventSet(const char* errorMessage = NULL) : Error(Result::e_EVENT_SET, errorMessage) {}
    explicit EventSet(const std::string& errorMessage) : Error(Result::e_EVENT_SET, errorMessage) {}
};
class EventReset: public Error
{
public:
    virtual ~EventReset() {}
    EventReset(const char* errorMessage = NULL) : Error(Result::e_EVENT_RESET, errorMessage) {}
    explicit EventReset(const std::string& errorMessage) : Error(Result::e_EVENT_RESET, errorMessage) {}
};
class Incomplete: public Error
{
public:
    virtual ~Incomplete() {}
    Incomplete(const char* errorMessage = NULL) : Error(Result::e_INCOMPLETE, errorMessage) {}
    explicit Incomplete(const std::string& errorMessage) : Error(Result::e_INCOMPLETE, errorMessage) {}
};
class ErrorOutOfHostMemory: public Error
{
public:
    virtual ~ErrorOutOfHostMemory() {}
    ErrorOutOfHostMemory(const char* errorMessage = NULL) : Error(Result::e_ERROR_OUT_OF_HOST_MEMORY, errorMessage) {}
    explicit ErrorOutOfHostMemory(const std::string& errorMessage) : Error(Result::e_ERROR_OUT_OF_HOST_MEMORY, errorMessage) {}
};
class ErrorOutOfDeviceMemory: public Error
{
public:
    virtual ~ErrorOutOfDeviceMemory() {}
    ErrorOutOfDeviceMemory(const char* errorMessage = NULL) : Error(Result::e_ERROR_OUT_OF_DEVICE_MEMORY, errorMessage) {}
    explicit ErrorOutOfDeviceMemory(const std::string& errorMessage) : Error(Result::e_ERROR_OUT_OF_DEVICE_MEMORY, errorMessage) {}
};
class ErrorInitializationFailed: public Error
{
public:
    virtual ~ErrorInitializationFailed() {}
    ErrorInitializationFailed(const char* errorMessage = NULL) : Error(Result::e_ERROR_INITIALIZATION_FAILED, errorMessage) {}
    explicit ErrorInitializationFailed(const std::string& errorMessage) : Error(Result::e_ERROR_INITIALIZATION_FAILED, errorMessage) {}
};
class ErrorDeviceLost: public Error
{
public:
    virtual ~ErrorDeviceLost() {}
    ErrorDeviceLost(const char* errorMessage = NULL) : Error(Result::e_ERROR_DEVICE_LOST, errorMessage) {}
    explicit ErrorDeviceLost(const std::string& errorMessage) : Error(Result::e_ERROR_DEVICE_LOST, errorMessage) {}
};
class ErrorMemoryMapFailed: public Error
{
public:
    virtual ~ErrorMemoryMapFailed() {}
    ErrorMemoryMapFailed(const char* errorMessage = NULL) : Error(Result::e_ERROR_MEMORY_MAP_FAILED, errorMessage) {}
    explicit ErrorMemoryMapFailed(const std::string& errorMessage) : Error(Result::e_ERROR_MEMORY_MAP_FAILED, errorMessage) {}
};
class ErrorLayerNotPresent: public Error
{
public:
    virtual ~ErrorLayerNotPresent() {}
    ErrorLayerNotPresent(const char* errorMessage = NULL) : Error(Result::e_ERROR_LAYER_NOT_PRESENT, errorMessage) {}
    explicit ErrorLayerNotPresent(const std::string& errorMessage) : Error(Result::e_ERROR_LAYER_NOT_PRESENT, errorMessage) {}
};
class ErrorExtensionNotPresent: public Error
{
public:
    virtual ~ErrorExtensionNotPresent() {}
    ErrorExtensionNotPresent(const char* errorMessage = NULL) : Error(Result::e_ERROR_EXTENSION_NOT_PRESENT, errorMessage) {}
    explicit ErrorExtensionNotPresent(const std::string& errorMessage) : Error(Result::e_ERROR_EXTENSION_NOT_PRESENT, errorMessage) {}
};
class ErrorFeatureNotPresent: public Error
{
public:
    virtual ~ErrorFeatureNotPresent() {}
    ErrorFeatureNotPresent(const char* errorMessage = NULL) : Error(Result::e_ERROR_FEATURE_NOT_PRESENT, errorMessage) {}
    explicit ErrorFeatureNotPresent(const std::string& errorMessage) : Error(Result::e_ERROR_FEATURE_NOT_PRESENT, errorMessage) {}
};
class ErrorIncompatibleDriver: public Error
{
public:
    virtual ~ErrorIncompatibleDriver() {}
    ErrorIncompatibleDriver(const char* errorMessage = NULL) : Error(Result::e_ERROR_INCOMPATIBLE_DRIVER, errorMessage) {}
    explicit ErrorIncompatibleDriver(const std::string& errorMessage) : Error(Result::e_ERROR_INCOMPATIBLE_DRIVER, errorMessage) {}
};
class ErrorTooManyObjects: public Error
{
public:
    virtual ~ErrorTooManyObjects() {}
    ErrorTooManyObjects(const char* errorMessage = NULL) : Error(Result::e_ERROR_TOO_MANY_OBJECTS, errorMessage) {}
    explicit ErrorTooManyObjects(const std::string& errorMessage) : Error(Result::e_ERROR_TOO_MANY_OBJECTS, errorMessage) {}
};
class ErrorFormatNotSupported: public Error
{
public:
    virtual ~ErrorFormatNotSupported() {}
    ErrorFormatNotSupported(const char* errorMessage = NULL) : Error(Result::e_ERROR_FORMAT_NOT_SUPPORTED, errorMessage) {}
    explicit ErrorFormatNotSupported(const std::string& errorMessage) : Error(Result::e_ERROR_FORMAT_NOT_SUPPORTED, errorMessage) {}
};
class ErrorFragmentedPool: public Error
{
public:
    virtual ~ErrorFragmentedPool() {}
    ErrorFragmentedPool(const char* errorMessage = NULL) : Error(Result::e_ERROR_FRAGMENTED_POOL, errorMessage) {}
    explicit ErrorFragmentedPool(const std::string& errorMessage) : Error(Result::e_ERROR_FRAGMENTED_POOL, errorMessage) {}
};
class ErrorOutOfPoolMemory: public Error
{
public:
    virtual ~ErrorOutOfPoolMemory() {}
    ErrorOutOfPoolMemory(const char* errorMessage = NULL) : Error(Result::e_ERROR_OUT_OF_POOL_MEMORY, errorMessage) {}
    explicit ErrorOutOfPoolMemory(const std::string& errorMessage) : Error(Result::e_ERROR_OUT_OF_POOL_MEMORY, errorMessage) {}
};
class ErrorInvalidExternalHandle: public Error
{
public:
    virtual ~ErrorInvalidExternalHandle() {}
    ErrorInvalidExternalHandle(const char* errorMessage = NULL) : Error(Result::e_ERROR_INVALID_EXTERNAL_HANDLE, errorMessage) {}
    explicit ErrorInvalidExternalHandle(const std::string& errorMessage) : Error(Result::e_ERROR_INVALID_EXTERNAL_HANDLE, errorMessage) {}
};
class ErrorSurfaceLostKHR: public Error
{
public:
    virtual ~ErrorSurfaceLostKHR() {}
    ErrorSurfaceLostKHR(const char* errorMessage = NULL) : Error(Result::e_ERROR_SURFACE_LOST_KHR, errorMessage) {}
    explicit ErrorSurfaceLostKHR(const std::string& errorMessage) : Error(Result::e_ERROR_SURFACE_LOST_KHR, errorMessage) {}
};
class ErrorNativeWindowInUseKHR: public Error
{
public:
    virtual ~ErrorNativeWindowInUseKHR() {}
    ErrorNativeWindowInUseKHR(const char* errorMessage = NULL) : Error(Result::e_ERROR_NATIVE_WINDOW_IN_USE_KHR, errorMessage) {}
    explicit ErrorNativeWindowInUseKHR(const std::string& errorMessage) : Error(Result::e_ERROR_NATIVE_WINDOW_IN_USE_KHR, errorMessage) {}
};
class SuboptimalKHR: public Error
{
public:
    virtual ~SuboptimalKHR() {}
    SuboptimalKHR(const char* errorMessage = NULL) : Error(Result::e_SUBOPTIMAL_KHR, errorMessage) {}
    explicit SuboptimalKHR(const std::string& errorMessage) : Error(Result::e_SUBOPTIMAL_KHR, errorMessage) {}
};
class ErrorOutOfDateKHR: public Error
{
public:
    virtual ~ErrorOutOfDateKHR() {}
    ErrorOutOfDateKHR(const char* errorMessage = NULL) : Error(Result::e_ERROR_OUT_OF_DATE_KHR, errorMessage) {}
    explicit ErrorOutOfDateKHR(const std::string& errorMessage) : Error(Result::e_ERROR_OUT_OF_DATE_KHR, errorMessage) {}
};
class ErrorIncompatibleDisplayKHR: public Error
{
public:
    virtual ~ErrorIncompatibleDisplayKHR() {}
    ErrorIncompatibleDisplayKHR(const char* errorMessage = NULL) : Error(Result::e_ERROR_INCOMPATIBLE_DISPLAY_KHR, errorMessage) {}
    explicit ErrorIncompatibleDisplayKHR(const std::string& errorMessage) : Error(Result::e_ERROR_INCOMPATIBLE_DISPLAY_KHR, errorMessage) {}
};
class ErrorValidationFailedEXT: public Error
{
public:
    virtual ~ErrorValidationFailedEXT() {}
    ErrorValidationFailedEXT(const char* errorMessage = NULL) : Error(Result::e_ERROR_VALIDATION_FAILED_EXT, errorMessage) {}
    explicit ErrorValidationFailedEXT(const std::string& errorMessage) : Error(Result::e_ERROR_VALIDATION_FAILED_EXT, errorMessage) {}
};
class ErrorInvalidShaderNV: public Error
{
public:
    virtual ~ErrorInvalidShaderNV() {}
    ErrorInvalidShaderNV(const char* errorMessage = NULL) : Error(Result::e_ERROR_INVALID_SHADER_NV, errorMessage) {}
    explicit ErrorInvalidShaderNV(const std::string& errorMessage) : Error(Result::e_ERROR_INVALID_SHADER_NV, errorMessage) {}
};
class ErrorOutOfPoolMemoryKHR: public Error
{
public:
    virtual ~ErrorOutOfPoolMemoryKHR() {}
    ErrorOutOfPoolMemoryKHR(const char* errorMessage = NULL) : Error(Result::e_ERROR_OUT_OF_POOL_MEMORY_KHR, errorMessage) {}
    explicit ErrorOutOfPoolMemoryKHR(const std::string& errorMessage) : Error(Result::e_ERROR_OUT_OF_POOL_MEMORY_KHR, errorMessage) {}
};
class ErrorInvalidExternalHandleKHR: public Error
{
public:
    virtual ~ErrorInvalidExternalHandleKHR() {}
    ErrorInvalidExternalHandleKHR(const char* errorMessage = NULL) : Error(Result::e_ERROR_INVALID_EXTERNAL_HANDLE_KHR, errorMessage) {}
    explicit ErrorInvalidExternalHandleKHR(const std::string& errorMessage) : Error(Result::e_ERROR_INVALID_EXTERNAL_HANDLE_KHR, errorMessage) {}
};
class ErrorFragmentationEXT: public Error
{
public:
    virtual ~ErrorFragmentationEXT() {}
    ErrorFragmentationEXT(const char* errorMessage = NULL) : Error(Result::e_ERROR_FRAGMENTATION_EXT, errorMessage) {}
    explicit ErrorFragmentationEXT(const std::string& errorMessage) : Error(Result::e_ERROR_FRAGMENTATION_EXT, errorMessage) {}
};
class ErrorNotPermittedEXT: public Error
{
public:
    virtual ~ErrorNotPermittedEXT() {}
    ErrorNotPermittedEXT(const char* errorMessage = NULL) : Error(Result::e_ERROR_NOT_PERMITTED_EXT, errorMessage) {}
    explicit ErrorNotPermittedEXT(const std::string& errorMessage) : Error(Result::e_ERROR_NOT_PERMITTED_EXT, errorMessage) {}
};

namespace impl {
/// <summary>Throw a Vulkan exception if the result is not successful.</summary>
/// <param name="result">A vulkan result code</param>
/// <param name="msg">Throw a corresponding exception if the error code is not success</param>
inline void vkThrowIfFailed(Result result, const char* message = 0)
{
    switch (result)
    {
    case Result::e_NOT_READY: throw NotReady(message);
    case Result::e_TIMEOUT: throw Timeout(message);
    case Result::e_EVENT_SET: throw EventSet(message);
    case Result::e_EVENT_RESET: throw EventReset(message);
    case Result::e_INCOMPLETE: throw Incomplete(message);
    case Result::e_SUBOPTIMAL_KHR: throw SuboptimalKHR(message);
    case Result::e_ERROR_OUT_OF_HOST_MEMORY: throw ErrorOutOfHostMemory(message);
    case Result::e_ERROR_OUT_OF_DEVICE_MEMORY: throw ErrorOutOfDeviceMemory(message);
    case Result::e_ERROR_INITIALIZATION_FAILED: throw ErrorInitializationFailed(message);
    case Result::e_ERROR_DEVICE_LOST: throw ErrorDeviceLost(message);
    case Result::e_ERROR_MEMORY_MAP_FAILED: throw ErrorMemoryMapFailed(message);
    case Result::e_ERROR_LAYER_NOT_PRESENT: throw ErrorLayerNotPresent(message);
    case Result::e_ERROR_EXTENSION_NOT_PRESENT: throw ErrorExtensionNotPresent(message);
    case Result::e_ERROR_FEATURE_NOT_PRESENT: throw ErrorFeatureNotPresent(message);
    case Result::e_ERROR_INCOMPATIBLE_DRIVER: throw ErrorIncompatibleDriver(message);
    case Result::e_ERROR_TOO_MANY_OBJECTS: throw ErrorTooManyObjects(message);
    case Result::e_ERROR_FORMAT_NOT_SUPPORTED: throw ErrorFormatNotSupported(message);
    case Result::e_ERROR_FRAGMENTED_POOL: throw ErrorFragmentedPool(message);
    case Result::e_ERROR_OUT_OF_POOL_MEMORY: throw ErrorOutOfPoolMemory(message);
    case Result::e_ERROR_INVALID_EXTERNAL_HANDLE: throw ErrorInvalidExternalHandle(message);
    case Result::e_ERROR_SURFACE_LOST_KHR: throw ErrorSurfaceLostKHR(message);
    case Result::e_ERROR_NATIVE_WINDOW_IN_USE_KHR: throw ErrorNativeWindowInUseKHR(message);
    case Result::e_ERROR_OUT_OF_DATE_KHR: throw ErrorOutOfDateKHR(message);
    case Result::e_ERROR_INCOMPATIBLE_DISPLAY_KHR: throw ErrorIncompatibleDisplayKHR(message);
    case Result::e_ERROR_VALIDATION_FAILED_EXT: throw ErrorValidationFailedEXT(message);
    case Result::e_ERROR_INVALID_SHADER_NV: throw ErrorInvalidShaderNV(message);
    case Result::e_ERROR_FRAGMENTATION_EXT: throw ErrorFragmentationEXT(message);
    case Result::e_ERROR_NOT_PERMITTED_EXT: throw ErrorNotPermittedEXT(message);
    case Result::e_SUCCESS:
        break;
    default: throw ErrorUnknown(message);
    }
}

/// <summary>Throw a Vulkan exception if the result is not successful.</summary>
/// <param name="result">A vulkan result code</param>
/// <param name="msg">Throw a corresponding exception if the error code is not success</param>
inline void vkThrowIfFailed(VkResult result, const char* message = 0)
{
    vkThrowIfFailed(static_cast<pvrvk::Result>(result), message);
}

/// <summary>Throw a Vulkan exception if the result is not successful.</summary>
/// <param name="result">A vulkan result code</param>
/// <param name="msg">Throw a corresponding exception if the error code is an error</param>
inline void vkThrowIfError(Result result, const char* message = 0)
{
    switch (result)
    {
    case Result::e_ERROR_OUT_OF_HOST_MEMORY: throw ErrorOutOfHostMemory(message);
    case Result::e_ERROR_OUT_OF_DEVICE_MEMORY: throw ErrorOutOfDeviceMemory(message);
    case Result::e_ERROR_INITIALIZATION_FAILED: throw ErrorInitializationFailed(message);
    case Result::e_ERROR_DEVICE_LOST: throw ErrorDeviceLost(message);
    case Result::e_ERROR_MEMORY_MAP_FAILED: throw ErrorMemoryMapFailed(message);
    case Result::e_ERROR_LAYER_NOT_PRESENT: throw ErrorLayerNotPresent(message);
    case Result::e_ERROR_EXTENSION_NOT_PRESENT: throw ErrorExtensionNotPresent(message);
    case Result::e_ERROR_FEATURE_NOT_PRESENT: throw ErrorFeatureNotPresent(message);
    case Result::e_ERROR_INCOMPATIBLE_DRIVER: throw ErrorIncompatibleDriver(message);
    case Result::e_ERROR_TOO_MANY_OBJECTS: throw ErrorTooManyObjects(message);
    case Result::e_ERROR_FORMAT_NOT_SUPPORTED: throw ErrorFormatNotSupported(message);
    case Result::e_ERROR_FRAGMENTED_POOL: throw ErrorFragmentedPool(message);
    case Result::e_ERROR_OUT_OF_POOL_MEMORY: throw ErrorOutOfPoolMemory(message);
    case Result::e_ERROR_INVALID_EXTERNAL_HANDLE: throw ErrorInvalidExternalHandle(message);
    case Result::e_ERROR_SURFACE_LOST_KHR: throw ErrorSurfaceLostKHR(message);
    case Result::e_ERROR_NATIVE_WINDOW_IN_USE_KHR: throw ErrorNativeWindowInUseKHR(message);
    case Result::e_ERROR_OUT_OF_DATE_KHR: throw ErrorOutOfDateKHR(message);
    case Result::e_ERROR_INCOMPATIBLE_DISPLAY_KHR: throw ErrorIncompatibleDisplayKHR(message);
    case Result::e_ERROR_VALIDATION_FAILED_EXT: throw ErrorValidationFailedEXT(message);
    case Result::e_ERROR_INVALID_SHADER_NV: throw ErrorInvalidShaderNV(message);
    case Result::e_ERROR_FRAGMENTATION_EXT: throw ErrorFragmentationEXT(message);
    case Result::e_ERROR_NOT_PERMITTED_EXT: throw ErrorNotPermittedEXT(message);
    case Result::e_SUCCESS:
    case Result::e_NOT_READY:
    case Result::e_TIMEOUT:
    case Result::e_EVENT_SET:
    case Result::e_EVENT_RESET:
    case Result::e_INCOMPLETE:
    case Result::e_SUBOPTIMAL_KHR:
        break;
    default: throw ErrorUnknown(message);
    }
}


/// <summary>Check if the code is success, else log the error</summary>
/// <param name="result">Vulkan error</param>
/// <param name="msg">Message to log if the error code is not success</param>
/// <returns>True if no error</returns>
inline bool vkIsSuccessful(Result result, const char* msg)
{
	if (result != Result::e_SUCCESS)
	{
		Log(LogLevel::Error, "Failed: %s. Vulkan has raised an error: %s", msg, vkErrorToStr(result));
		return false;
	}
	return true;
}
}// namespace impl

} // namespace pvrvk
// clang-format on
//!\endcond
