// *** THIS FILE IS GENERATED - DO NOT EDIT ***
// See pvrvk_vulkan_wrapper_generator.py for modifications

/*
\brief vulkan.h wrapper used by PVRVk.
\file pvrvk_vulkan_wrapper.h
\author PowerVR by Imagination, Developer Technology Team
\copyright Copyright (c) Imagination Technologies Limited.
*/

//!\cond NO_DOXYGEN
// clang-format off
#pragma once
#include "vulkan/vulkan.h"

#if defined (X11)
// undef these macros from the xlib files, they are breaking the framework types.
#undef Success
#undef Enum
#undef None
#undef Always
#undef byte
#undef char8
#undef ShaderStageFlags
#undef capability
#endif

#include <algorithm>
#include <stdexcept>
#include <string>
#include <cstring>
#include <cstdio>

#if defined(_WIN32)
#ifndef WIN32_LEAN_AND_MEAN
#define WIN32_LEAN_AND_MEAN
#define NOMINMAX
#endif
#include <Windows.h>
#define vsnprintf _vsnprintf
#endif

#if defined(__linux__)
#include <sys/stat.h>
#include <unistd.h>
#include <string.h>
#include <fcntl.h>
#include <signal.h>
#endif

#define DEFINE_ENUM_BITWISE_OPERATORS(type_) \
inline type_ operator | (type_ lhs, type_ rhs) \
{ \
    return (type_)(static_cast<uint32_t>(lhs) | static_cast<uint32_t>(rhs)); \
} \
inline type_& operator |= (type_& lhs, type_ rhs) \
{ \
    return lhs = (type_)(static_cast<uint32_t>(lhs) | static_cast<uint32_t>(rhs)); \
} \
inline type_ operator & (type_ lhs, type_ rhs) \
{ \
    return (type_)(static_cast<uint32_t>(lhs) & static_cast<uint32_t>(rhs)); \
} \
inline type_& operator &= (type_& lhs, type_ rhs) \
{ \
    return lhs = (type_)(static_cast<uint32_t>(lhs) & static_cast<uint32_t>(rhs)); \
} \
inline type_ operator ^ (type_ lhs, type_ rhs) \
{ \
    return (type_)(static_cast<uint32_t>(lhs) ^ static_cast<uint32_t>(rhs)); \
} \
inline type_& operator ^= (type_& lhs, type_ rhs) \
{ \
    return lhs = (type_)(static_cast<uint32_t>(lhs) ^ static_cast<uint32_t>(rhs)); \
} \
inline type_ operator <<(type_ lhs, uint32_t rhs) \
{ \
    return (type_)(static_cast<uint32_t>(lhs) << rhs); \
} \
inline type_& operator <<=(type_& lhs, uint32_t rhs) \
{ \
    return lhs = (type_)(static_cast<uint32_t>(lhs) << rhs); \
} \
inline type_ operator >>(type_ lhs, uint32_t rhs) \
{ \
    return (type_)(static_cast<uint32_t>(lhs) >> rhs); \
} \
inline type_& operator >>=(type_& lhs, uint32_t rhs) \
{ \
    return lhs = (type_)(static_cast<uint32_t>(lhs) >> rhs); \
} \
inline bool operator ==(type_ lhs, uint32_t rhs) \
{ \
    return static_cast<uint32_t>(lhs) == rhs; \
} \
inline bool operator !=(type_ lhs, uint32_t rhs) \
{ \
    return static_cast<uint32_t>(lhs) != rhs; \
} \
inline bool operator ==(uint32_t lhs, type_ rhs) \
{ \
    return lhs == static_cast<uint32_t>(rhs); \
}\
inline bool operator !=(uint32_t lhs, type_ rhs) \
{ \
    return lhs != static_cast<uint32_t>(rhs); \
}\
inline type_ operator ~(type_ lhs) \
{ \
    return (type_)(~static_cast<uint32_t>(lhs)); \
}\
inline int operator *(uint32_t lhs, type_ rhs) \
{ \
    return (lhs * static_cast<uint32_t>(rhs)); \
}\
inline type_ operator *(type_ lhs, uint32_t rhs) \
{ \
    return (type_)(static_cast<uint32_t>(lhs) * rhs); \
}\


namespace pvrvk {


// PVRVk Structures defined in PVRVk/Types.h. These are excluded from autogeneration so we need to forward declare them here 
struct ClearValue;
struct ClearColorValue;
struct ClearAttachment;
struct AttachmentDescription;
struct SubpassDescription;



// PVRVk Basetypes
typedef VkFlags Flags;
typedef VkBool32 Bool32;
typedef VkDeviceSize DeviceSize;
typedef VkSampleMask SampleMask;



// PVRVk Bitmasks
enum class InstanceCreateFlags : uint32_t { e_NONE };
DEFINE_ENUM_BITWISE_OPERATORS(InstanceCreateFlags)
inline std::string to_string(InstanceCreateFlags value)
{
    (void)value;
    return "reserved";
}

enum class DeviceCreateFlags : uint32_t { e_NONE };
DEFINE_ENUM_BITWISE_OPERATORS(DeviceCreateFlags)
inline std::string to_string(DeviceCreateFlags value)
{
    (void)value;
    return "reserved";
}

enum class MemoryMapFlags : uint32_t { e_NONE };
DEFINE_ENUM_BITWISE_OPERATORS(MemoryMapFlags)
inline std::string to_string(MemoryMapFlags value)
{
    (void)value;
    return "reserved";
}

enum class SemaphoreCreateFlags : uint32_t { e_NONE };
DEFINE_ENUM_BITWISE_OPERATORS(SemaphoreCreateFlags)
inline std::string to_string(SemaphoreCreateFlags value)
{
    (void)value;
    return "reserved";
}

enum class EventCreateFlags : uint32_t { e_NONE };
DEFINE_ENUM_BITWISE_OPERATORS(EventCreateFlags)
inline std::string to_string(EventCreateFlags value)
{
    (void)value;
    return "reserved";
}

enum class QueryPoolCreateFlags : uint32_t { e_NONE };
DEFINE_ENUM_BITWISE_OPERATORS(QueryPoolCreateFlags)
inline std::string to_string(QueryPoolCreateFlags value)
{
    (void)value;
    return "reserved";
}

enum class BufferViewCreateFlags : uint32_t { e_NONE };
DEFINE_ENUM_BITWISE_OPERATORS(BufferViewCreateFlags)
inline std::string to_string(BufferViewCreateFlags value)
{
    (void)value;
    return "reserved";
}

enum class ImageViewCreateFlags : uint32_t { e_NONE };
DEFINE_ENUM_BITWISE_OPERATORS(ImageViewCreateFlags)
inline std::string to_string(ImageViewCreateFlags value)
{
    (void)value;
    return "reserved";
}

enum class ShaderModuleCreateFlags : uint32_t { e_NONE };
DEFINE_ENUM_BITWISE_OPERATORS(ShaderModuleCreateFlags)
inline std::string to_string(ShaderModuleCreateFlags value)
{
    (void)value;
    return "reserved";
}

enum class PipelineCacheCreateFlags : uint32_t { e_NONE };
DEFINE_ENUM_BITWISE_OPERATORS(PipelineCacheCreateFlags)
inline std::string to_string(PipelineCacheCreateFlags value)
{
    (void)value;
    return "reserved";
}

enum class PipelineShaderStageCreateFlags : uint32_t { e_NONE };
DEFINE_ENUM_BITWISE_OPERATORS(PipelineShaderStageCreateFlags)
inline std::string to_string(PipelineShaderStageCreateFlags value)
{
    (void)value;
    return "reserved";
}

enum class PipelineVertexInputStateCreateFlags : uint32_t { e_NONE };
DEFINE_ENUM_BITWISE_OPERATORS(PipelineVertexInputStateCreateFlags)
inline std::string to_string(PipelineVertexInputStateCreateFlags value)
{
    (void)value;
    return "reserved";
}

enum class PipelineInputAssemblyStateCreateFlags : uint32_t { e_NONE };
DEFINE_ENUM_BITWISE_OPERATORS(PipelineInputAssemblyStateCreateFlags)
inline std::string to_string(PipelineInputAssemblyStateCreateFlags value)
{
    (void)value;
    return "reserved";
}

enum class PipelineTessellationStateCreateFlags : uint32_t { e_NONE };
DEFINE_ENUM_BITWISE_OPERATORS(PipelineTessellationStateCreateFlags)
inline std::string to_string(PipelineTessellationStateCreateFlags value)
{
    (void)value;
    return "reserved";
}

enum class PipelineViewportStateCreateFlags : uint32_t { e_NONE };
DEFINE_ENUM_BITWISE_OPERATORS(PipelineViewportStateCreateFlags)
inline std::string to_string(PipelineViewportStateCreateFlags value)
{
    (void)value;
    return "reserved";
}

enum class PipelineRasterizationStateCreateFlags : uint32_t { e_NONE };
DEFINE_ENUM_BITWISE_OPERATORS(PipelineRasterizationStateCreateFlags)
inline std::string to_string(PipelineRasterizationStateCreateFlags value)
{
    (void)value;
    return "reserved";
}

enum class PipelineMultisampleStateCreateFlags : uint32_t { e_NONE };
DEFINE_ENUM_BITWISE_OPERATORS(PipelineMultisampleStateCreateFlags)
inline std::string to_string(PipelineMultisampleStateCreateFlags value)
{
    (void)value;
    return "reserved";
}

enum class PipelineDepthStencilStateCreateFlags : uint32_t { e_NONE };
DEFINE_ENUM_BITWISE_OPERATORS(PipelineDepthStencilStateCreateFlags)
inline std::string to_string(PipelineDepthStencilStateCreateFlags value)
{
    (void)value;
    return "reserved";
}

enum class PipelineColorBlendStateCreateFlags : uint32_t { e_NONE };
DEFINE_ENUM_BITWISE_OPERATORS(PipelineColorBlendStateCreateFlags)
inline std::string to_string(PipelineColorBlendStateCreateFlags value)
{
    (void)value;
    return "reserved";
}

enum class PipelineDynamicStateCreateFlags : uint32_t { e_NONE };
DEFINE_ENUM_BITWISE_OPERATORS(PipelineDynamicStateCreateFlags)
inline std::string to_string(PipelineDynamicStateCreateFlags value)
{
    (void)value;
    return "reserved";
}

enum class PipelineLayoutCreateFlags : uint32_t { e_NONE };
DEFINE_ENUM_BITWISE_OPERATORS(PipelineLayoutCreateFlags)
inline std::string to_string(PipelineLayoutCreateFlags value)
{
    (void)value;
    return "reserved";
}

enum class SamplerCreateFlags : uint32_t { e_NONE };
DEFINE_ENUM_BITWISE_OPERATORS(SamplerCreateFlags)
inline std::string to_string(SamplerCreateFlags value)
{
    (void)value;
    return "reserved";
}

enum class DescriptorPoolResetFlags : uint32_t { e_NONE };
DEFINE_ENUM_BITWISE_OPERATORS(DescriptorPoolResetFlags)
inline std::string to_string(DescriptorPoolResetFlags value)
{
    (void)value;
    return "reserved";
}

enum class FramebufferCreateFlags : uint32_t { e_NONE };
DEFINE_ENUM_BITWISE_OPERATORS(FramebufferCreateFlags)
inline std::string to_string(FramebufferCreateFlags value)
{
    (void)value;
    return "reserved";
}

enum class CommandPoolTrimFlags : uint32_t { e_NONE };
DEFINE_ENUM_BITWISE_OPERATORS(CommandPoolTrimFlags)
inline std::string to_string(CommandPoolTrimFlags value)
{
    (void)value;
    return "reserved";
}

enum class DescriptorUpdateTemplateCreateFlags : uint32_t { e_NONE };
DEFINE_ENUM_BITWISE_OPERATORS(DescriptorUpdateTemplateCreateFlags)
inline std::string to_string(DescriptorUpdateTemplateCreateFlags value)
{
    (void)value;
    return "reserved";
}

enum class DisplayModeCreateFlagsKHR : uint32_t { e_NONE };
DEFINE_ENUM_BITWISE_OPERATORS(DisplayModeCreateFlagsKHR)
inline std::string to_string(DisplayModeCreateFlagsKHR value)
{
    (void)value;
    return "reserved";
}

enum class DisplaySurfaceCreateFlagsKHR : uint32_t { e_NONE };
DEFINE_ENUM_BITWISE_OPERATORS(DisplaySurfaceCreateFlagsKHR)
inline std::string to_string(DisplaySurfaceCreateFlagsKHR value)
{
    (void)value;
    return "reserved";
}

#ifdef VK_USE_PLATFORM_XLIB_KHR
enum class XlibSurfaceCreateFlagsKHR : uint32_t { e_NONE };
DEFINE_ENUM_BITWISE_OPERATORS(XlibSurfaceCreateFlagsKHR)
inline std::string to_string(XlibSurfaceCreateFlagsKHR value)
{
    (void)value;
    return "reserved";
}
#endif // VK_USE_PLATFORM_XLIB_KHR

#ifdef VK_USE_PLATFORM_XCB_KHR
enum class XcbSurfaceCreateFlagsKHR : uint32_t { e_NONE };
DEFINE_ENUM_BITWISE_OPERATORS(XcbSurfaceCreateFlagsKHR)
inline std::string to_string(XcbSurfaceCreateFlagsKHR value)
{
    (void)value;
    return "reserved";
}
#endif // VK_USE_PLATFORM_XCB_KHR

#ifdef VK_USE_PLATFORM_WAYLAND_KHR
enum class WaylandSurfaceCreateFlagsKHR : uint32_t { e_NONE };
DEFINE_ENUM_BITWISE_OPERATORS(WaylandSurfaceCreateFlagsKHR)
inline std::string to_string(WaylandSurfaceCreateFlagsKHR value)
{
    (void)value;
    return "reserved";
}
#endif // VK_USE_PLATFORM_WAYLAND_KHR

#ifdef VK_USE_PLATFORM_ANDROID_KHR
enum class AndroidSurfaceCreateFlagsKHR : uint32_t { e_NONE };
DEFINE_ENUM_BITWISE_OPERATORS(AndroidSurfaceCreateFlagsKHR)
inline std::string to_string(AndroidSurfaceCreateFlagsKHR value)
{
    (void)value;
    return "reserved";
}
#endif // VK_USE_PLATFORM_ANDROID_KHR

#ifdef VK_USE_PLATFORM_WIN32_KHR
enum class Win32SurfaceCreateFlagsKHR : uint32_t { e_NONE };
DEFINE_ENUM_BITWISE_OPERATORS(Win32SurfaceCreateFlagsKHR)
inline std::string to_string(Win32SurfaceCreateFlagsKHR value)
{
    (void)value;
    return "reserved";
}
#endif // VK_USE_PLATFORM_WIN32_KHR

enum class CommandPoolTrimFlagsKHR : uint32_t { e_NONE };
DEFINE_ENUM_BITWISE_OPERATORS(CommandPoolTrimFlagsKHR)
inline std::string to_string(CommandPoolTrimFlagsKHR value)
{
    (void)value;
    return "reserved";
}

enum class DescriptorUpdateTemplateCreateFlagsKHR : uint32_t { e_NONE };
DEFINE_ENUM_BITWISE_OPERATORS(DescriptorUpdateTemplateCreateFlagsKHR)
inline std::string to_string(DescriptorUpdateTemplateCreateFlagsKHR value)
{
    (void)value;
    return "reserved";
}

enum class PipelineRasterizationStateStreamCreateFlagsEXT : uint32_t { e_NONE };
DEFINE_ENUM_BITWISE_OPERATORS(PipelineRasterizationStateStreamCreateFlagsEXT)
inline std::string to_string(PipelineRasterizationStateStreamCreateFlagsEXT value)
{
    (void)value;
    return "reserved";
}

#ifdef VK_USE_PLATFORM_VI_NN
enum class ViSurfaceCreateFlagsNN : uint32_t { e_NONE };
DEFINE_ENUM_BITWISE_OPERATORS(ViSurfaceCreateFlagsNN)
inline std::string to_string(ViSurfaceCreateFlagsNN value)
{
    (void)value;
    return "reserved";
}
#endif // VK_USE_PLATFORM_VI_NN

enum class PipelineViewportSwizzleStateCreateFlagsNV : uint32_t { e_NONE };
DEFINE_ENUM_BITWISE_OPERATORS(PipelineViewportSwizzleStateCreateFlagsNV)
inline std::string to_string(PipelineViewportSwizzleStateCreateFlagsNV value)
{
    (void)value;
    return "reserved";
}

enum class PipelineDiscardRectangleStateCreateFlagsEXT : uint32_t { e_NONE };
DEFINE_ENUM_BITWISE_OPERATORS(PipelineDiscardRectangleStateCreateFlagsEXT)
inline std::string to_string(PipelineDiscardRectangleStateCreateFlagsEXT value)
{
    (void)value;
    return "reserved";
}

enum class PipelineRasterizationConservativeStateCreateFlagsEXT : uint32_t { e_NONE };
DEFINE_ENUM_BITWISE_OPERATORS(PipelineRasterizationConservativeStateCreateFlagsEXT)
inline std::string to_string(PipelineRasterizationConservativeStateCreateFlagsEXT value)
{
    (void)value;
    return "reserved";
}

#ifdef VK_USE_PLATFORM_IOS_MVK
enum class IOSSurfaceCreateFlagsMVK : uint32_t { e_NONE };
DEFINE_ENUM_BITWISE_OPERATORS(IOSSurfaceCreateFlagsMVK)
inline std::string to_string(IOSSurfaceCreateFlagsMVK value)
{
    (void)value;
    return "reserved";
}
#endif // VK_USE_PLATFORM_IOS_MVK

#ifdef VK_USE_PLATFORM_MACOS_MVK
enum class MacOSSurfaceCreateFlagsMVK : uint32_t { e_NONE };
DEFINE_ENUM_BITWISE_OPERATORS(MacOSSurfaceCreateFlagsMVK)
inline std::string to_string(MacOSSurfaceCreateFlagsMVK value)
{
    (void)value;
    return "reserved";
}
#endif // VK_USE_PLATFORM_MACOS_MVK

enum class DebugUtilsMessengerCallbackDataFlagsEXT : uint32_t { e_NONE };
DEFINE_ENUM_BITWISE_OPERATORS(DebugUtilsMessengerCallbackDataFlagsEXT)
inline std::string to_string(DebugUtilsMessengerCallbackDataFlagsEXT value)
{
    (void)value;
    return "reserved";
}

enum class DebugUtilsMessengerCreateFlagsEXT : uint32_t { e_NONE };
DEFINE_ENUM_BITWISE_OPERATORS(DebugUtilsMessengerCreateFlagsEXT)
inline std::string to_string(DebugUtilsMessengerCreateFlagsEXT value)
{
    (void)value;
    return "reserved";
}

enum class PipelineCoverageToColorStateCreateFlagsNV : uint32_t { e_NONE };
DEFINE_ENUM_BITWISE_OPERATORS(PipelineCoverageToColorStateCreateFlagsNV)
inline std::string to_string(PipelineCoverageToColorStateCreateFlagsNV value)
{
    (void)value;
    return "reserved";
}

enum class PipelineCoverageModulationStateCreateFlagsNV : uint32_t { e_NONE };
DEFINE_ENUM_BITWISE_OPERATORS(PipelineCoverageModulationStateCreateFlagsNV)
inline std::string to_string(PipelineCoverageModulationStateCreateFlagsNV value)
{
    (void)value;
    return "reserved";
}

enum class ValidationCacheCreateFlagsEXT : uint32_t { e_NONE };
DEFINE_ENUM_BITWISE_OPERATORS(ValidationCacheCreateFlagsEXT)
inline std::string to_string(ValidationCacheCreateFlagsEXT value)
{
    (void)value;
    return "reserved";
}

#ifdef VK_USE_PLATFORM_FUCHSIA
enum class ImagePipeSurfaceCreateFlagsFUCHSIA : uint32_t { e_NONE };
DEFINE_ENUM_BITWISE_OPERATORS(ImagePipeSurfaceCreateFlagsFUCHSIA)
inline std::string to_string(ImagePipeSurfaceCreateFlagsFUCHSIA value)
{
    (void)value;
    return "reserved";
}
#endif // VK_USE_PLATFORM_FUCHSIA




// PVRVk Enums
enum class PipelineCacheHeaderVersion
{
    e_ONE = VK_PIPELINE_CACHE_HEADER_VERSION_ONE,
    e_BEGIN_RANGE = VK_PIPELINE_CACHE_HEADER_VERSION_BEGIN_RANGE,
    e_END_RANGE = VK_PIPELINE_CACHE_HEADER_VERSION_END_RANGE,
    e_RANGE_SIZE = VK_PIPELINE_CACHE_HEADER_VERSION_RANGE_SIZE,
    e_MAX_ENUM = 0x7FFFFFFF

};
DEFINE_ENUM_BITWISE_OPERATORS(PipelineCacheHeaderVersion)
inline std::string to_string(PipelineCacheHeaderVersion value)
{
    switch(value)
    {
    case PipelineCacheHeaderVersion::e_ONE: return "VK_PIPELINE_CACHE_HEADER_VERSION_ONE";
    default: return "invalid";
    }
}

enum class Result
{
    e_SUCCESS = VK_SUCCESS,
    e_NOT_READY = VK_NOT_READY,
    e_TIMEOUT = VK_TIMEOUT,
    e_EVENT_SET = VK_EVENT_SET,
    e_EVENT_RESET = VK_EVENT_RESET,
    e_INCOMPLETE = VK_INCOMPLETE,
    e_ERROR_OUT_OF_HOST_MEMORY = VK_ERROR_OUT_OF_HOST_MEMORY,
    e_ERROR_OUT_OF_DEVICE_MEMORY = VK_ERROR_OUT_OF_DEVICE_MEMORY,
    e_ERROR_INITIALIZATION_FAILED = VK_ERROR_INITIALIZATION_FAILED,
    e_ERROR_DEVICE_LOST = VK_ERROR_DEVICE_LOST,
    e_ERROR_MEMORY_MAP_FAILED = VK_ERROR_MEMORY_MAP_FAILED,
    e_ERROR_LAYER_NOT_PRESENT = VK_ERROR_LAYER_NOT_PRESENT,
    e_ERROR_EXTENSION_NOT_PRESENT = VK_ERROR_EXTENSION_NOT_PRESENT,
    e_ERROR_FEATURE_NOT_PRESENT = VK_ERROR_FEATURE_NOT_PRESENT,
    e_ERROR_INCOMPATIBLE_DRIVER = VK_ERROR_INCOMPATIBLE_DRIVER,
    e_ERROR_TOO_MANY_OBJECTS = VK_ERROR_TOO_MANY_OBJECTS,
    e_ERROR_FORMAT_NOT_SUPPORTED = VK_ERROR_FORMAT_NOT_SUPPORTED,
    e_ERROR_FRAGMENTED_POOL = VK_ERROR_FRAGMENTED_POOL,
    e_ERROR_OUT_OF_POOL_MEMORY = VK_ERROR_OUT_OF_POOL_MEMORY,
    e_ERROR_INVALID_EXTERNAL_HANDLE = VK_ERROR_INVALID_EXTERNAL_HANDLE,
    e_ERROR_SURFACE_LOST_KHR = VK_ERROR_SURFACE_LOST_KHR,
    e_ERROR_NATIVE_WINDOW_IN_USE_KHR = VK_ERROR_NATIVE_WINDOW_IN_USE_KHR,
    e_SUBOPTIMAL_KHR = VK_SUBOPTIMAL_KHR,
    e_ERROR_OUT_OF_DATE_KHR = VK_ERROR_OUT_OF_DATE_KHR,
    e_ERROR_INCOMPATIBLE_DISPLAY_KHR = VK_ERROR_INCOMPATIBLE_DISPLAY_KHR,
    e_ERROR_VALIDATION_FAILED_EXT = VK_ERROR_VALIDATION_FAILED_EXT,
    e_ERROR_INVALID_SHADER_NV = VK_ERROR_INVALID_SHADER_NV,
    e_ERROR_OUT_OF_POOL_MEMORY_KHR = VK_ERROR_OUT_OF_POOL_MEMORY_KHR,
    e_ERROR_INVALID_EXTERNAL_HANDLE_KHR = VK_ERROR_INVALID_EXTERNAL_HANDLE_KHR,
    e_ERROR_INVALID_DRM_FORMAT_MODIFIER_PLANE_LAYOUT_EXT = VK_ERROR_INVALID_DRM_FORMAT_MODIFIER_PLANE_LAYOUT_EXT,
    e_ERROR_FRAGMENTATION_EXT = VK_ERROR_FRAGMENTATION_EXT,
    e_ERROR_NOT_PERMITTED_EXT = VK_ERROR_NOT_PERMITTED_EXT,
    e_BEGIN_RANGE = VK_RESULT_BEGIN_RANGE,
    e_END_RANGE = VK_RESULT_END_RANGE,
    e_RANGE_SIZE = VK_RESULT_RANGE_SIZE,
    e_MAX_ENUM = 0x7FFFFFFF

};
DEFINE_ENUM_BITWISE_OPERATORS(Result)
inline std::string to_string(Result value)
{
    switch(value)
    {
    case Result::e_SUCCESS: return "VK_SUCCESS";
    case Result::e_NOT_READY: return "VK_NOT_READY";
    case Result::e_TIMEOUT: return "VK_TIMEOUT";
    case Result::e_EVENT_SET: return "VK_EVENT_SET";
    case Result::e_EVENT_RESET: return "VK_EVENT_RESET";
    case Result::e_INCOMPLETE: return "VK_INCOMPLETE";
    case Result::e_ERROR_OUT_OF_HOST_MEMORY: return "VK_ERROR_OUT_OF_HOST_MEMORY";
    case Result::e_ERROR_OUT_OF_DEVICE_MEMORY: return "VK_ERROR_OUT_OF_DEVICE_MEMORY";
    case Result::e_ERROR_INITIALIZATION_FAILED: return "VK_ERROR_INITIALIZATION_FAILED";
    case Result::e_ERROR_DEVICE_LOST: return "VK_ERROR_DEVICE_LOST";
    case Result::e_ERROR_MEMORY_MAP_FAILED: return "VK_ERROR_MEMORY_MAP_FAILED";
    case Result::e_ERROR_LAYER_NOT_PRESENT: return "VK_ERROR_LAYER_NOT_PRESENT";
    case Result::e_ERROR_EXTENSION_NOT_PRESENT: return "VK_ERROR_EXTENSION_NOT_PRESENT";
    case Result::e_ERROR_FEATURE_NOT_PRESENT: return "VK_ERROR_FEATURE_NOT_PRESENT";
    case Result::e_ERROR_INCOMPATIBLE_DRIVER: return "VK_ERROR_INCOMPATIBLE_DRIVER";
    case Result::e_ERROR_TOO_MANY_OBJECTS: return "VK_ERROR_TOO_MANY_OBJECTS";
    case Result::e_ERROR_FORMAT_NOT_SUPPORTED: return "VK_ERROR_FORMAT_NOT_SUPPORTED";
    case Result::e_ERROR_FRAGMENTED_POOL: return "VK_ERROR_FRAGMENTED_POOL";
    case Result::e_ERROR_OUT_OF_POOL_MEMORY: return "VK_ERROR_OUT_OF_POOL_MEMORY";
    case Result::e_ERROR_INVALID_EXTERNAL_HANDLE: return "VK_ERROR_INVALID_EXTERNAL_HANDLE";
    case Result::e_ERROR_SURFACE_LOST_KHR: return "VK_ERROR_SURFACE_LOST_KHR";
    case Result::e_ERROR_NATIVE_WINDOW_IN_USE_KHR: return "VK_ERROR_NATIVE_WINDOW_IN_USE_KHR";
    case Result::e_SUBOPTIMAL_KHR: return "VK_SUBOPTIMAL_KHR";
    case Result::e_ERROR_OUT_OF_DATE_KHR: return "VK_ERROR_OUT_OF_DATE_KHR";
    case Result::e_ERROR_INCOMPATIBLE_DISPLAY_KHR: return "VK_ERROR_INCOMPATIBLE_DISPLAY_KHR";
    case Result::e_ERROR_VALIDATION_FAILED_EXT: return "VK_ERROR_VALIDATION_FAILED_EXT";
    case Result::e_ERROR_INVALID_SHADER_NV: return "VK_ERROR_INVALID_SHADER_NV";
    case Result::e_ERROR_INVALID_DRM_FORMAT_MODIFIER_PLANE_LAYOUT_EXT: return "VK_ERROR_INVALID_DRM_FORMAT_MODIFIER_PLANE_LAYOUT_EXT";
    case Result::e_ERROR_FRAGMENTATION_EXT: return "VK_ERROR_FRAGMENTATION_EXT";
    case Result::e_ERROR_NOT_PERMITTED_EXT: return "VK_ERROR_NOT_PERMITTED_EXT";
    default: return "invalid";
    }
}

enum class StructureType
{
    e_APPLICATION_INFO = VK_STRUCTURE_TYPE_APPLICATION_INFO,
    e_INSTANCE_CREATE_INFO = VK_STRUCTURE_TYPE_INSTANCE_CREATE_INFO,
    e_DEVICE_QUEUE_CREATE_INFO = VK_STRUCTURE_TYPE_DEVICE_QUEUE_CREATE_INFO,
    e_DEVICE_CREATE_INFO = VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO,
    e_SUBMIT_INFO = VK_STRUCTURE_TYPE_SUBMIT_INFO,
    e_MEMORY_ALLOCATE_INFO = VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_INFO,
    e_MAPPED_MEMORY_RANGE = VK_STRUCTURE_TYPE_MAPPED_MEMORY_RANGE,
    e_BIND_SPARSE_INFO = VK_STRUCTURE_TYPE_BIND_SPARSE_INFO,
    e_FENCE_CREATE_INFO = VK_STRUCTURE_TYPE_FENCE_CREATE_INFO,
    e_SEMAPHORE_CREATE_INFO = VK_STRUCTURE_TYPE_SEMAPHORE_CREATE_INFO,
    e_EVENT_CREATE_INFO = VK_STRUCTURE_TYPE_EVENT_CREATE_INFO,
    e_QUERY_POOL_CREATE_INFO = VK_STRUCTURE_TYPE_QUERY_POOL_CREATE_INFO,
    e_BUFFER_CREATE_INFO = VK_STRUCTURE_TYPE_BUFFER_CREATE_INFO,
    e_BUFFER_VIEW_CREATE_INFO = VK_STRUCTURE_TYPE_BUFFER_VIEW_CREATE_INFO,
    e_IMAGE_CREATE_INFO = VK_STRUCTURE_TYPE_IMAGE_CREATE_INFO,
    e_IMAGE_VIEW_CREATE_INFO = VK_STRUCTURE_TYPE_IMAGE_VIEW_CREATE_INFO,
    e_SHADER_MODULE_CREATE_INFO = VK_STRUCTURE_TYPE_SHADER_MODULE_CREATE_INFO,
    e_PIPELINE_CACHE_CREATE_INFO = VK_STRUCTURE_TYPE_PIPELINE_CACHE_CREATE_INFO,
    e_PIPELINE_SHADER_STAGE_CREATE_INFO = VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO,
    e_PIPELINE_VERTEX_INPUT_STATE_CREATE_INFO = VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_STATE_CREATE_INFO,
    e_PIPELINE_INPUT_ASSEMBLY_STATE_CREATE_INFO = VK_STRUCTURE_TYPE_PIPELINE_INPUT_ASSEMBLY_STATE_CREATE_INFO,
    e_PIPELINE_TESSELLATION_STATE_CREATE_INFO = VK_STRUCTURE_TYPE_PIPELINE_TESSELLATION_STATE_CREATE_INFO,
    e_PIPELINE_VIEWPORT_STATE_CREATE_INFO = VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_STATE_CREATE_INFO,
    e_PIPELINE_RASTERIZATION_STATE_CREATE_INFO = VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_CREATE_INFO,
    e_PIPELINE_MULTISAMPLE_STATE_CREATE_INFO = VK_STRUCTURE_TYPE_PIPELINE_MULTISAMPLE_STATE_CREATE_INFO,
    e_PIPELINE_DEPTH_STENCIL_STATE_CREATE_INFO = VK_STRUCTURE_TYPE_PIPELINE_DEPTH_STENCIL_STATE_CREATE_INFO,
    e_PIPELINE_COLOR_BLEND_STATE_CREATE_INFO = VK_STRUCTURE_TYPE_PIPELINE_COLOR_BLEND_STATE_CREATE_INFO,
    e_PIPELINE_DYNAMIC_STATE_CREATE_INFO = VK_STRUCTURE_TYPE_PIPELINE_DYNAMIC_STATE_CREATE_INFO,
    e_GRAPHICS_PIPELINE_CREATE_INFO = VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_CREATE_INFO,
    e_COMPUTE_PIPELINE_CREATE_INFO = VK_STRUCTURE_TYPE_COMPUTE_PIPELINE_CREATE_INFO,
    e_PIPELINE_LAYOUT_CREATE_INFO = VK_STRUCTURE_TYPE_PIPELINE_LAYOUT_CREATE_INFO,
    e_SAMPLER_CREATE_INFO = VK_STRUCTURE_TYPE_SAMPLER_CREATE_INFO,
    e_DESCRIPTOR_SET_LAYOUT_CREATE_INFO = VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_CREATE_INFO,
    e_DESCRIPTOR_POOL_CREATE_INFO = VK_STRUCTURE_TYPE_DESCRIPTOR_POOL_CREATE_INFO,
    e_DESCRIPTOR_SET_ALLOCATE_INFO = VK_STRUCTURE_TYPE_DESCRIPTOR_SET_ALLOCATE_INFO,
    e_WRITE_DESCRIPTOR_SET = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET,
    e_COPY_DESCRIPTOR_SET = VK_STRUCTURE_TYPE_COPY_DESCRIPTOR_SET,
    e_FRAMEBUFFER_CREATE_INFO = VK_STRUCTURE_TYPE_FRAMEBUFFER_CREATE_INFO,
    e_RENDER_PASS_CREATE_INFO = VK_STRUCTURE_TYPE_RENDER_PASS_CREATE_INFO,
    e_COMMAND_POOL_CREATE_INFO = VK_STRUCTURE_TYPE_COMMAND_POOL_CREATE_INFO,
    e_COMMAND_BUFFER_ALLOCATE_INFO = VK_STRUCTURE_TYPE_COMMAND_BUFFER_ALLOCATE_INFO,
    e_COMMAND_BUFFER_INHERITANCE_INFO = VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_INFO,
    e_COMMAND_BUFFER_BEGIN_INFO = VK_STRUCTURE_TYPE_COMMAND_BUFFER_BEGIN_INFO,
    e_RENDER_PASS_BEGIN_INFO = VK_STRUCTURE_TYPE_RENDER_PASS_BEGIN_INFO,
    e_BUFFER_MEMORY_BARRIER = VK_STRUCTURE_TYPE_BUFFER_MEMORY_BARRIER,
    e_IMAGE_MEMORY_BARRIER = VK_STRUCTURE_TYPE_IMAGE_MEMORY_BARRIER,
    e_MEMORY_BARRIER = VK_STRUCTURE_TYPE_MEMORY_BARRIER,
    e_LOADER_INSTANCE_CREATE_INFO = VK_STRUCTURE_TYPE_LOADER_INSTANCE_CREATE_INFO,
    e_LOADER_DEVICE_CREATE_INFO = VK_STRUCTURE_TYPE_LOADER_DEVICE_CREATE_INFO,
    e_PHYSICAL_DEVICE_SUBGROUP_PROPERTIES = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBGROUP_PROPERTIES,
    e_BIND_BUFFER_MEMORY_INFO = VK_STRUCTURE_TYPE_BIND_BUFFER_MEMORY_INFO,
    e_BIND_IMAGE_MEMORY_INFO = VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_INFO,
    e_PHYSICAL_DEVICE_16BIT_STORAGE_FEATURES = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_16BIT_STORAGE_FEATURES,
    e_MEMORY_DEDICATED_REQUIREMENTS = VK_STRUCTURE_TYPE_MEMORY_DEDICATED_REQUIREMENTS,
    e_MEMORY_DEDICATED_ALLOCATE_INFO = VK_STRUCTURE_TYPE_MEMORY_DEDICATED_ALLOCATE_INFO,
    e_MEMORY_ALLOCATE_FLAGS_INFO = VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_FLAGS_INFO,
    e_DEVICE_GROUP_RENDER_PASS_BEGIN_INFO = VK_STRUCTURE_TYPE_DEVICE_GROUP_RENDER_PASS_BEGIN_INFO,
    e_DEVICE_GROUP_COMMAND_BUFFER_BEGIN_INFO = VK_STRUCTURE_TYPE_DEVICE_GROUP_COMMAND_BUFFER_BEGIN_INFO,
    e_DEVICE_GROUP_SUBMIT_INFO = VK_STRUCTURE_TYPE_DEVICE_GROUP_SUBMIT_INFO,
    e_DEVICE_GROUP_BIND_SPARSE_INFO = VK_STRUCTURE_TYPE_DEVICE_GROUP_BIND_SPARSE_INFO,
    e_BIND_BUFFER_MEMORY_DEVICE_GROUP_INFO = VK_STRUCTURE_TYPE_BIND_BUFFER_MEMORY_DEVICE_GROUP_INFO,
    e_BIND_IMAGE_MEMORY_DEVICE_GROUP_INFO = VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_DEVICE_GROUP_INFO,
    e_PHYSICAL_DEVICE_GROUP_PROPERTIES = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GROUP_PROPERTIES,
    e_DEVICE_GROUP_DEVICE_CREATE_INFO = VK_STRUCTURE_TYPE_DEVICE_GROUP_DEVICE_CREATE_INFO,
    e_BUFFER_MEMORY_REQUIREMENTS_INFO_2 = VK_STRUCTURE_TYPE_BUFFER_MEMORY_REQUIREMENTS_INFO_2,
    e_IMAGE_MEMORY_REQUIREMENTS_INFO_2 = VK_STRUCTURE_TYPE_IMAGE_MEMORY_REQUIREMENTS_INFO_2,
    e_IMAGE_SPARSE_MEMORY_REQUIREMENTS_INFO_2 = VK_STRUCTURE_TYPE_IMAGE_SPARSE_MEMORY_REQUIREMENTS_INFO_2,
    e_MEMORY_REQUIREMENTS_2 = VK_STRUCTURE_TYPE_MEMORY_REQUIREMENTS_2,
    e_SPARSE_IMAGE_MEMORY_REQUIREMENTS_2 = VK_STRUCTURE_TYPE_SPARSE_IMAGE_MEMORY_REQUIREMENTS_2,
    e_PHYSICAL_DEVICE_FEATURES_2 = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2,
    e_PHYSICAL_DEVICE_PROPERTIES_2 = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROPERTIES_2,
    e_FORMAT_PROPERTIES_2 = VK_STRUCTURE_TYPE_FORMAT_PROPERTIES_2,
    e_IMAGE_FORMAT_PROPERTIES_2 = VK_STRUCTURE_TYPE_IMAGE_FORMAT_PROPERTIES_2,
    e_PHYSICAL_DEVICE_IMAGE_FORMAT_INFO_2 = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_FORMAT_INFO_2,
    e_QUEUE_FAMILY_PROPERTIES_2 = VK_STRUCTURE_TYPE_QUEUE_FAMILY_PROPERTIES_2,
    e_PHYSICAL_DEVICE_MEMORY_PROPERTIES_2 = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_PROPERTIES_2,
    e_SPARSE_IMAGE_FORMAT_PROPERTIES_2 = VK_STRUCTURE_TYPE_SPARSE_IMAGE_FORMAT_PROPERTIES_2,
    e_PHYSICAL_DEVICE_SPARSE_IMAGE_FORMAT_INFO_2 = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SPARSE_IMAGE_FORMAT_INFO_2,
    e_PHYSICAL_DEVICE_POINT_CLIPPING_PROPERTIES = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_POINT_CLIPPING_PROPERTIES,
    e_RENDER_PASS_INPUT_ATTACHMENT_ASPECT_CREATE_INFO = VK_STRUCTURE_TYPE_RENDER_PASS_INPUT_ATTACHMENT_ASPECT_CREATE_INFO,
    e_IMAGE_VIEW_USAGE_CREATE_INFO = VK_STRUCTURE_TYPE_IMAGE_VIEW_USAGE_CREATE_INFO,
    e_PIPELINE_TESSELLATION_DOMAIN_ORIGIN_STATE_CREATE_INFO = VK_STRUCTURE_TYPE_PIPELINE_TESSELLATION_DOMAIN_ORIGIN_STATE_CREATE_INFO,
    e_RENDER_PASS_MULTIVIEW_CREATE_INFO = VK_STRUCTURE_TYPE_RENDER_PASS_MULTIVIEW_CREATE_INFO,
    e_PHYSICAL_DEVICE_MULTIVIEW_FEATURES = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_FEATURES,
    e_PHYSICAL_DEVICE_MULTIVIEW_PROPERTIES = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PROPERTIES,
    e_PHYSICAL_DEVICE_VARIABLE_POINTER_FEATURES = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VARIABLE_POINTER_FEATURES,
    e_PROTECTED_SUBMIT_INFO = VK_STRUCTURE_TYPE_PROTECTED_SUBMIT_INFO,
    e_PHYSICAL_DEVICE_PROTECTED_MEMORY_FEATURES = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROTECTED_MEMORY_FEATURES,
    e_PHYSICAL_DEVICE_PROTECTED_MEMORY_PROPERTIES = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROTECTED_MEMORY_PROPERTIES,
    e_DEVICE_QUEUE_INFO_2 = VK_STRUCTURE_TYPE_DEVICE_QUEUE_INFO_2,
    e_SAMPLER_YCBCR_CONVERSION_CREATE_INFO = VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_CREATE_INFO,
    e_SAMPLER_YCBCR_CONVERSION_INFO = VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_INFO,
    e_BIND_IMAGE_PLANE_MEMORY_INFO = VK_STRUCTURE_TYPE_BIND_IMAGE_PLANE_MEMORY_INFO,
    e_IMAGE_PLANE_MEMORY_REQUIREMENTS_INFO = VK_STRUCTURE_TYPE_IMAGE_PLANE_MEMORY_REQUIREMENTS_INFO,
    e_PHYSICAL_DEVICE_SAMPLER_YCBCR_CONVERSION_FEATURES = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLER_YCBCR_CONVERSION_FEATURES,
    e_SAMPLER_YCBCR_CONVERSION_IMAGE_FORMAT_PROPERTIES = VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_IMAGE_FORMAT_PROPERTIES,
    e_DESCRIPTOR_UPDATE_TEMPLATE_CREATE_INFO = VK_STRUCTURE_TYPE_DESCRIPTOR_UPDATE_TEMPLATE_CREATE_INFO,
    e_PHYSICAL_DEVICE_EXTERNAL_IMAGE_FORMAT_INFO = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_IMAGE_FORMAT_INFO,
    e_EXTERNAL_IMAGE_FORMAT_PROPERTIES = VK_STRUCTURE_TYPE_EXTERNAL_IMAGE_FORMAT_PROPERTIES,
    e_PHYSICAL_DEVICE_EXTERNAL_BUFFER_INFO = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_BUFFER_INFO,
    e_EXTERNAL_BUFFER_PROPERTIES = VK_STRUCTURE_TYPE_EXTERNAL_BUFFER_PROPERTIES,
    e_PHYSICAL_DEVICE_ID_PROPERTIES = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ID_PROPERTIES,
    e_EXTERNAL_MEMORY_BUFFER_CREATE_INFO = VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_BUFFER_CREATE_INFO,
    e_EXTERNAL_MEMORY_IMAGE_CREATE_INFO = VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_IMAGE_CREATE_INFO,
    e_EXPORT_MEMORY_ALLOCATE_INFO = VK_STRUCTURE_TYPE_EXPORT_MEMORY_ALLOCATE_INFO,
    e_PHYSICAL_DEVICE_EXTERNAL_FENCE_INFO = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_FENCE_INFO,
    e_EXTERNAL_FENCE_PROPERTIES = VK_STRUCTURE_TYPE_EXTERNAL_FENCE_PROPERTIES,
    e_EXPORT_FENCE_CREATE_INFO = VK_STRUCTURE_TYPE_EXPORT_FENCE_CREATE_INFO,
    e_EXPORT_SEMAPHORE_CREATE_INFO = VK_STRUCTURE_TYPE_EXPORT_SEMAPHORE_CREATE_INFO,
    e_PHYSICAL_DEVICE_EXTERNAL_SEMAPHORE_INFO = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_SEMAPHORE_INFO,
    e_EXTERNAL_SEMAPHORE_PROPERTIES = VK_STRUCTURE_TYPE_EXTERNAL_SEMAPHORE_PROPERTIES,
    e_PHYSICAL_DEVICE_MAINTENANCE_3_PROPERTIES = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_3_PROPERTIES,
    e_DESCRIPTOR_SET_LAYOUT_SUPPORT = VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_SUPPORT,
    e_PHYSICAL_DEVICE_SHADER_DRAW_PARAMETER_FEATURES = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_DRAW_PARAMETER_FEATURES,
    e_SWAPCHAIN_CREATE_INFO_KHR = VK_STRUCTURE_TYPE_SWAPCHAIN_CREATE_INFO_KHR,
    e_PRESENT_INFO_KHR = VK_STRUCTURE_TYPE_PRESENT_INFO_KHR,
    e_DEVICE_GROUP_PRESENT_CAPABILITIES_KHR = VK_STRUCTURE_TYPE_DEVICE_GROUP_PRESENT_CAPABILITIES_KHR,
    e_IMAGE_SWAPCHAIN_CREATE_INFO_KHR = VK_STRUCTURE_TYPE_IMAGE_SWAPCHAIN_CREATE_INFO_KHR,
    e_BIND_IMAGE_MEMORY_SWAPCHAIN_INFO_KHR = VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_SWAPCHAIN_INFO_KHR,
    e_ACQUIRE_NEXT_IMAGE_INFO_KHR = VK_STRUCTURE_TYPE_ACQUIRE_NEXT_IMAGE_INFO_KHR,
    e_DEVICE_GROUP_PRESENT_INFO_KHR = VK_STRUCTURE_TYPE_DEVICE_GROUP_PRESENT_INFO_KHR,
    e_DEVICE_GROUP_SWAPCHAIN_CREATE_INFO_KHR = VK_STRUCTURE_TYPE_DEVICE_GROUP_SWAPCHAIN_CREATE_INFO_KHR,
    e_DISPLAY_MODE_CREATE_INFO_KHR = VK_STRUCTURE_TYPE_DISPLAY_MODE_CREATE_INFO_KHR,
    e_DISPLAY_SURFACE_CREATE_INFO_KHR = VK_STRUCTURE_TYPE_DISPLAY_SURFACE_CREATE_INFO_KHR,
    e_DISPLAY_PRESENT_INFO_KHR = VK_STRUCTURE_TYPE_DISPLAY_PRESENT_INFO_KHR,
    e_XLIB_SURFACE_CREATE_INFO_KHR = VK_STRUCTURE_TYPE_XLIB_SURFACE_CREATE_INFO_KHR,
    e_XCB_SURFACE_CREATE_INFO_KHR = VK_STRUCTURE_TYPE_XCB_SURFACE_CREATE_INFO_KHR,
    e_WAYLAND_SURFACE_CREATE_INFO_KHR = VK_STRUCTURE_TYPE_WAYLAND_SURFACE_CREATE_INFO_KHR,
    e_ANDROID_SURFACE_CREATE_INFO_KHR = VK_STRUCTURE_TYPE_ANDROID_SURFACE_CREATE_INFO_KHR,
    e_WIN32_SURFACE_CREATE_INFO_KHR = VK_STRUCTURE_TYPE_WIN32_SURFACE_CREATE_INFO_KHR,
    e_DEBUG_REPORT_CALLBACK_CREATE_INFO_EXT = VK_STRUCTURE_TYPE_DEBUG_REPORT_CALLBACK_CREATE_INFO_EXT,
    e_DEBUG_REPORT_CREATE_INFO_EXT = VK_STRUCTURE_TYPE_DEBUG_REPORT_CREATE_INFO_EXT,
    e_PIPELINE_RASTERIZATION_STATE_RASTERIZATION_ORDER_AMD = VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_RASTERIZATION_ORDER_AMD,
    e_DEBUG_MARKER_OBJECT_NAME_INFO_EXT = VK_STRUCTURE_TYPE_DEBUG_MARKER_OBJECT_NAME_INFO_EXT,
    e_DEBUG_MARKER_OBJECT_TAG_INFO_EXT = VK_STRUCTURE_TYPE_DEBUG_MARKER_OBJECT_TAG_INFO_EXT,
    e_DEBUG_MARKER_MARKER_INFO_EXT = VK_STRUCTURE_TYPE_DEBUG_MARKER_MARKER_INFO_EXT,
    e_DEDICATED_ALLOCATION_IMAGE_CREATE_INFO_NV = VK_STRUCTURE_TYPE_DEDICATED_ALLOCATION_IMAGE_CREATE_INFO_NV,
    e_DEDICATED_ALLOCATION_BUFFER_CREATE_INFO_NV = VK_STRUCTURE_TYPE_DEDICATED_ALLOCATION_BUFFER_CREATE_INFO_NV,
    e_DEDICATED_ALLOCATION_MEMORY_ALLOCATE_INFO_NV = VK_STRUCTURE_TYPE_DEDICATED_ALLOCATION_MEMORY_ALLOCATE_INFO_NV,
    e_PHYSICAL_DEVICE_TRANSFORM_FEEDBACK_FEATURES_EXT = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TRANSFORM_FEEDBACK_FEATURES_EXT,
    e_PHYSICAL_DEVICE_TRANSFORM_FEEDBACK_PROPERTIES_EXT = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TRANSFORM_FEEDBACK_PROPERTIES_EXT,
    e_PIPELINE_RASTERIZATION_STATE_STREAM_CREATE_INFO_EXT = VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_STREAM_CREATE_INFO_EXT,
    e_TEXTURE_LOD_GATHER_FORMAT_PROPERTIES_AMD = VK_STRUCTURE_TYPE_TEXTURE_LOD_GATHER_FORMAT_PROPERTIES_AMD,
    e_PHYSICAL_DEVICE_CORNER_SAMPLED_IMAGE_FEATURES_NV = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CORNER_SAMPLED_IMAGE_FEATURES_NV,
    e_RENDER_PASS_MULTIVIEW_CREATE_INFO_KHR = VK_STRUCTURE_TYPE_RENDER_PASS_MULTIVIEW_CREATE_INFO_KHR,
    e_PHYSICAL_DEVICE_MULTIVIEW_FEATURES_KHR = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_FEATURES_KHR,
    e_PHYSICAL_DEVICE_MULTIVIEW_PROPERTIES_KHR = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PROPERTIES_KHR,
    e_EXTERNAL_MEMORY_IMAGE_CREATE_INFO_NV = VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_IMAGE_CREATE_INFO_NV,
    e_EXPORT_MEMORY_ALLOCATE_INFO_NV = VK_STRUCTURE_TYPE_EXPORT_MEMORY_ALLOCATE_INFO_NV,
    e_IMPORT_MEMORY_WIN32_HANDLE_INFO_NV = VK_STRUCTURE_TYPE_IMPORT_MEMORY_WIN32_HANDLE_INFO_NV,
    e_EXPORT_MEMORY_WIN32_HANDLE_INFO_NV = VK_STRUCTURE_TYPE_EXPORT_MEMORY_WIN32_HANDLE_INFO_NV,
    e_WIN32_KEYED_MUTEX_ACQUIRE_RELEASE_INFO_NV = VK_STRUCTURE_TYPE_WIN32_KEYED_MUTEX_ACQUIRE_RELEASE_INFO_NV,
    e_PHYSICAL_DEVICE_FEATURES_2_KHR = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2_KHR,
    e_PHYSICAL_DEVICE_PROPERTIES_2_KHR = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROPERTIES_2_KHR,
    e_FORMAT_PROPERTIES_2_KHR = VK_STRUCTURE_TYPE_FORMAT_PROPERTIES_2_KHR,
    e_IMAGE_FORMAT_PROPERTIES_2_KHR = VK_STRUCTURE_TYPE_IMAGE_FORMAT_PROPERTIES_2_KHR,
    e_PHYSICAL_DEVICE_IMAGE_FORMAT_INFO_2_KHR = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_FORMAT_INFO_2_KHR,
    e_QUEUE_FAMILY_PROPERTIES_2_KHR = VK_STRUCTURE_TYPE_QUEUE_FAMILY_PROPERTIES_2_KHR,
    e_PHYSICAL_DEVICE_MEMORY_PROPERTIES_2_KHR = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_PROPERTIES_2_KHR,
    e_SPARSE_IMAGE_FORMAT_PROPERTIES_2_KHR = VK_STRUCTURE_TYPE_SPARSE_IMAGE_FORMAT_PROPERTIES_2_KHR,
    e_PHYSICAL_DEVICE_SPARSE_IMAGE_FORMAT_INFO_2_KHR = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SPARSE_IMAGE_FORMAT_INFO_2_KHR,
    e_MEMORY_ALLOCATE_FLAGS_INFO_KHR = VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_FLAGS_INFO_KHR,
    e_DEVICE_GROUP_RENDER_PASS_BEGIN_INFO_KHR = VK_STRUCTURE_TYPE_DEVICE_GROUP_RENDER_PASS_BEGIN_INFO_KHR,
    e_DEVICE_GROUP_COMMAND_BUFFER_BEGIN_INFO_KHR = VK_STRUCTURE_TYPE_DEVICE_GROUP_COMMAND_BUFFER_BEGIN_INFO_KHR,
    e_DEVICE_GROUP_SUBMIT_INFO_KHR = VK_STRUCTURE_TYPE_DEVICE_GROUP_SUBMIT_INFO_KHR,
    e_DEVICE_GROUP_BIND_SPARSE_INFO_KHR = VK_STRUCTURE_TYPE_DEVICE_GROUP_BIND_SPARSE_INFO_KHR,
    e_BIND_BUFFER_MEMORY_DEVICE_GROUP_INFO_KHR = VK_STRUCTURE_TYPE_BIND_BUFFER_MEMORY_DEVICE_GROUP_INFO_KHR,
    e_BIND_IMAGE_MEMORY_DEVICE_GROUP_INFO_KHR = VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_DEVICE_GROUP_INFO_KHR,
    e_VALIDATION_FLAGS_EXT = VK_STRUCTURE_TYPE_VALIDATION_FLAGS_EXT,
    e_VI_SURFACE_CREATE_INFO_NN = VK_STRUCTURE_TYPE_VI_SURFACE_CREATE_INFO_NN,
    e_IMAGE_VIEW_ASTC_DECODE_MODE_EXT = VK_STRUCTURE_TYPE_IMAGE_VIEW_ASTC_DECODE_MODE_EXT,
    e_PHYSICAL_DEVICE_ASTC_DECODE_FEATURES_EXT = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ASTC_DECODE_FEATURES_EXT,
    e_PHYSICAL_DEVICE_GROUP_PROPERTIES_KHR = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GROUP_PROPERTIES_KHR,
    e_DEVICE_GROUP_DEVICE_CREATE_INFO_KHR = VK_STRUCTURE_TYPE_DEVICE_GROUP_DEVICE_CREATE_INFO_KHR,
    e_PHYSICAL_DEVICE_EXTERNAL_IMAGE_FORMAT_INFO_KHR = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_IMAGE_FORMAT_INFO_KHR,
    e_EXTERNAL_IMAGE_FORMAT_PROPERTIES_KHR = VK_STRUCTURE_TYPE_EXTERNAL_IMAGE_FORMAT_PROPERTIES_KHR,
    e_PHYSICAL_DEVICE_EXTERNAL_BUFFER_INFO_KHR = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_BUFFER_INFO_KHR,
    e_EXTERNAL_BUFFER_PROPERTIES_KHR = VK_STRUCTURE_TYPE_EXTERNAL_BUFFER_PROPERTIES_KHR,
    e_PHYSICAL_DEVICE_ID_PROPERTIES_KHR = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ID_PROPERTIES_KHR,
    e_EXTERNAL_MEMORY_BUFFER_CREATE_INFO_KHR = VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_BUFFER_CREATE_INFO_KHR,
    e_EXTERNAL_MEMORY_IMAGE_CREATE_INFO_KHR = VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_IMAGE_CREATE_INFO_KHR,
    e_EXPORT_MEMORY_ALLOCATE_INFO_KHR = VK_STRUCTURE_TYPE_EXPORT_MEMORY_ALLOCATE_INFO_KHR,
    e_IMPORT_MEMORY_WIN32_HANDLE_INFO_KHR = VK_STRUCTURE_TYPE_IMPORT_MEMORY_WIN32_HANDLE_INFO_KHR,
    e_EXPORT_MEMORY_WIN32_HANDLE_INFO_KHR = VK_STRUCTURE_TYPE_EXPORT_MEMORY_WIN32_HANDLE_INFO_KHR,
    e_MEMORY_WIN32_HANDLE_PROPERTIES_KHR = VK_STRUCTURE_TYPE_MEMORY_WIN32_HANDLE_PROPERTIES_KHR,
    e_MEMORY_GET_WIN32_HANDLE_INFO_KHR = VK_STRUCTURE_TYPE_MEMORY_GET_WIN32_HANDLE_INFO_KHR,
    e_IMPORT_MEMORY_FD_INFO_KHR = VK_STRUCTURE_TYPE_IMPORT_MEMORY_FD_INFO_KHR,
    e_MEMORY_FD_PROPERTIES_KHR = VK_STRUCTURE_TYPE_MEMORY_FD_PROPERTIES_KHR,
    e_MEMORY_GET_FD_INFO_KHR = VK_STRUCTURE_TYPE_MEMORY_GET_FD_INFO_KHR,
    e_WIN32_KEYED_MUTEX_ACQUIRE_RELEASE_INFO_KHR = VK_STRUCTURE_TYPE_WIN32_KEYED_MUTEX_ACQUIRE_RELEASE_INFO_KHR,
    e_PHYSICAL_DEVICE_EXTERNAL_SEMAPHORE_INFO_KHR = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_SEMAPHORE_INFO_KHR,
    e_EXTERNAL_SEMAPHORE_PROPERTIES_KHR = VK_STRUCTURE_TYPE_EXTERNAL_SEMAPHORE_PROPERTIES_KHR,
    e_EXPORT_SEMAPHORE_CREATE_INFO_KHR = VK_STRUCTURE_TYPE_EXPORT_SEMAPHORE_CREATE_INFO_KHR,
    e_IMPORT_SEMAPHORE_WIN32_HANDLE_INFO_KHR = VK_STRUCTURE_TYPE_IMPORT_SEMAPHORE_WIN32_HANDLE_INFO_KHR,
    e_EXPORT_SEMAPHORE_WIN32_HANDLE_INFO_KHR = VK_STRUCTURE_TYPE_EXPORT_SEMAPHORE_WIN32_HANDLE_INFO_KHR,
    e_D3D12_FENCE_SUBMIT_INFO_KHR = VK_STRUCTURE_TYPE_D3D12_FENCE_SUBMIT_INFO_KHR,
    e_SEMAPHORE_GET_WIN32_HANDLE_INFO_KHR = VK_STRUCTURE_TYPE_SEMAPHORE_GET_WIN32_HANDLE_INFO_KHR,
    e_IMPORT_SEMAPHORE_FD_INFO_KHR = VK_STRUCTURE_TYPE_IMPORT_SEMAPHORE_FD_INFO_KHR,
    e_SEMAPHORE_GET_FD_INFO_KHR = VK_STRUCTURE_TYPE_SEMAPHORE_GET_FD_INFO_KHR,
    e_PHYSICAL_DEVICE_PUSH_DESCRIPTOR_PROPERTIES_KHR = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PUSH_DESCRIPTOR_PROPERTIES_KHR,
    e_COMMAND_BUFFER_INHERITANCE_CONDITIONAL_RENDERING_INFO_EXT = VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_CONDITIONAL_RENDERING_INFO_EXT,
    e_PHYSICAL_DEVICE_CONDITIONAL_RENDERING_FEATURES_EXT = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CONDITIONAL_RENDERING_FEATURES_EXT,
    e_CONDITIONAL_RENDERING_BEGIN_INFO_EXT = VK_STRUCTURE_TYPE_CONDITIONAL_RENDERING_BEGIN_INFO_EXT,
    e_PHYSICAL_DEVICE_16BIT_STORAGE_FEATURES_KHR = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_16BIT_STORAGE_FEATURES_KHR,
    e_PRESENT_REGIONS_KHR = VK_STRUCTURE_TYPE_PRESENT_REGIONS_KHR,
    e_DESCRIPTOR_UPDATE_TEMPLATE_CREATE_INFO_KHR = VK_STRUCTURE_TYPE_DESCRIPTOR_UPDATE_TEMPLATE_CREATE_INFO_KHR,
    e_OBJECT_TABLE_CREATE_INFO_NVX = VK_STRUCTURE_TYPE_OBJECT_TABLE_CREATE_INFO_NVX,
    e_INDIRECT_COMMANDS_LAYOUT_CREATE_INFO_NVX = VK_STRUCTURE_TYPE_INDIRECT_COMMANDS_LAYOUT_CREATE_INFO_NVX,
    e_CMD_PROCESS_COMMANDS_INFO_NVX = VK_STRUCTURE_TYPE_CMD_PROCESS_COMMANDS_INFO_NVX,
    e_CMD_RESERVE_SPACE_FOR_COMMANDS_INFO_NVX = VK_STRUCTURE_TYPE_CMD_RESERVE_SPACE_FOR_COMMANDS_INFO_NVX,
    e_DEVICE_GENERATED_COMMANDS_LIMITS_NVX = VK_STRUCTURE_TYPE_DEVICE_GENERATED_COMMANDS_LIMITS_NVX,
    e_DEVICE_GENERATED_COMMANDS_FEATURES_NVX = VK_STRUCTURE_TYPE_DEVICE_GENERATED_COMMANDS_FEATURES_NVX,
    e_PIPELINE_VIEWPORT_W_SCALING_STATE_CREATE_INFO_NV = VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_W_SCALING_STATE_CREATE_INFO_NV,
    e_SURFACE_CAPABILITIES_2_EXT = VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES_2_EXT,
    e_SURFACE_CAPABILITIES2_EXT = VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES2_EXT,
    e_DISPLAY_POWER_INFO_EXT = VK_STRUCTURE_TYPE_DISPLAY_POWER_INFO_EXT,
    e_DEVICE_EVENT_INFO_EXT = VK_STRUCTURE_TYPE_DEVICE_EVENT_INFO_EXT,
    e_DISPLAY_EVENT_INFO_EXT = VK_STRUCTURE_TYPE_DISPLAY_EVENT_INFO_EXT,
    e_SWAPCHAIN_COUNTER_CREATE_INFO_EXT = VK_STRUCTURE_TYPE_SWAPCHAIN_COUNTER_CREATE_INFO_EXT,
    e_PRESENT_TIMES_INFO_GOOGLE = VK_STRUCTURE_TYPE_PRESENT_TIMES_INFO_GOOGLE,
    e_PHYSICAL_DEVICE_MULTIVIEW_PER_VIEW_ATTRIBUTES_PROPERTIES_NVX = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PER_VIEW_ATTRIBUTES_PROPERTIES_NVX,
    e_PIPELINE_VIEWPORT_SWIZZLE_STATE_CREATE_INFO_NV = VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_SWIZZLE_STATE_CREATE_INFO_NV,
    e_PHYSICAL_DEVICE_DISCARD_RECTANGLE_PROPERTIES_EXT = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DISCARD_RECTANGLE_PROPERTIES_EXT,
    e_PIPELINE_DISCARD_RECTANGLE_STATE_CREATE_INFO_EXT = VK_STRUCTURE_TYPE_PIPELINE_DISCARD_RECTANGLE_STATE_CREATE_INFO_EXT,
    e_PHYSICAL_DEVICE_CONSERVATIVE_RASTERIZATION_PROPERTIES_EXT = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CONSERVATIVE_RASTERIZATION_PROPERTIES_EXT,
    e_PIPELINE_RASTERIZATION_CONSERVATIVE_STATE_CREATE_INFO_EXT = VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_CONSERVATIVE_STATE_CREATE_INFO_EXT,
    e_HDR_METADATA_EXT = VK_STRUCTURE_TYPE_HDR_METADATA_EXT,
    e_ATTACHMENT_DESCRIPTION_2_KHR = VK_STRUCTURE_TYPE_ATTACHMENT_DESCRIPTION_2_KHR,
    e_ATTACHMENT_REFERENCE_2_KHR = VK_STRUCTURE_TYPE_ATTACHMENT_REFERENCE_2_KHR,
    e_SUBPASS_DESCRIPTION_2_KHR = VK_STRUCTURE_TYPE_SUBPASS_DESCRIPTION_2_KHR,
    e_SUBPASS_DEPENDENCY_2_KHR = VK_STRUCTURE_TYPE_SUBPASS_DEPENDENCY_2_KHR,
    e_RENDER_PASS_CREATE_INFO_2_KHR = VK_STRUCTURE_TYPE_RENDER_PASS_CREATE_INFO_2_KHR,
    e_SUBPASS_BEGIN_INFO_KHR = VK_STRUCTURE_TYPE_SUBPASS_BEGIN_INFO_KHR,
    e_SUBPASS_END_INFO_KHR = VK_STRUCTURE_TYPE_SUBPASS_END_INFO_KHR,
    e_SHARED_PRESENT_SURFACE_CAPABILITIES_KHR = VK_STRUCTURE_TYPE_SHARED_PRESENT_SURFACE_CAPABILITIES_KHR,
    e_PHYSICAL_DEVICE_EXTERNAL_FENCE_INFO_KHR = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_FENCE_INFO_KHR,
    e_EXTERNAL_FENCE_PROPERTIES_KHR = VK_STRUCTURE_TYPE_EXTERNAL_FENCE_PROPERTIES_KHR,
    e_EXPORT_FENCE_CREATE_INFO_KHR = VK_STRUCTURE_TYPE_EXPORT_FENCE_CREATE_INFO_KHR,
    e_IMPORT_FENCE_WIN32_HANDLE_INFO_KHR = VK_STRUCTURE_TYPE_IMPORT_FENCE_WIN32_HANDLE_INFO_KHR,
    e_EXPORT_FENCE_WIN32_HANDLE_INFO_KHR = VK_STRUCTURE_TYPE_EXPORT_FENCE_WIN32_HANDLE_INFO_KHR,
    e_FENCE_GET_WIN32_HANDLE_INFO_KHR = VK_STRUCTURE_TYPE_FENCE_GET_WIN32_HANDLE_INFO_KHR,
    e_IMPORT_FENCE_FD_INFO_KHR = VK_STRUCTURE_TYPE_IMPORT_FENCE_FD_INFO_KHR,
    e_FENCE_GET_FD_INFO_KHR = VK_STRUCTURE_TYPE_FENCE_GET_FD_INFO_KHR,
    e_PHYSICAL_DEVICE_POINT_CLIPPING_PROPERTIES_KHR = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_POINT_CLIPPING_PROPERTIES_KHR,
    e_RENDER_PASS_INPUT_ATTACHMENT_ASPECT_CREATE_INFO_KHR = VK_STRUCTURE_TYPE_RENDER_PASS_INPUT_ATTACHMENT_ASPECT_CREATE_INFO_KHR,
    e_IMAGE_VIEW_USAGE_CREATE_INFO_KHR = VK_STRUCTURE_TYPE_IMAGE_VIEW_USAGE_CREATE_INFO_KHR,
    e_PIPELINE_TESSELLATION_DOMAIN_ORIGIN_STATE_CREATE_INFO_KHR = VK_STRUCTURE_TYPE_PIPELINE_TESSELLATION_DOMAIN_ORIGIN_STATE_CREATE_INFO_KHR,
    e_PHYSICAL_DEVICE_SURFACE_INFO_2_KHR = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SURFACE_INFO_2_KHR,
    e_SURFACE_CAPABILITIES_2_KHR = VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES_2_KHR,
    e_SURFACE_FORMAT_2_KHR = VK_STRUCTURE_TYPE_SURFACE_FORMAT_2_KHR,
    e_PHYSICAL_DEVICE_VARIABLE_POINTER_FEATURES_KHR = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VARIABLE_POINTER_FEATURES_KHR,
    e_DISPLAY_PROPERTIES_2_KHR = VK_STRUCTURE_TYPE_DISPLAY_PROPERTIES_2_KHR,
    e_DISPLAY_PLANE_PROPERTIES_2_KHR = VK_STRUCTURE_TYPE_DISPLAY_PLANE_PROPERTIES_2_KHR,
    e_DISPLAY_MODE_PROPERTIES_2_KHR = VK_STRUCTURE_TYPE_DISPLAY_MODE_PROPERTIES_2_KHR,
    e_DISPLAY_PLANE_INFO_2_KHR = VK_STRUCTURE_TYPE_DISPLAY_PLANE_INFO_2_KHR,
    e_DISPLAY_PLANE_CAPABILITIES_2_KHR = VK_STRUCTURE_TYPE_DISPLAY_PLANE_CAPABILITIES_2_KHR,
    e_IOS_SURFACE_CREATE_INFO_MVK = VK_STRUCTURE_TYPE_IOS_SURFACE_CREATE_INFO_MVK,
    e_MACOS_SURFACE_CREATE_INFO_MVK = VK_STRUCTURE_TYPE_MACOS_SURFACE_CREATE_INFO_MVK,
    e_MEMORY_DEDICATED_REQUIREMENTS_KHR = VK_STRUCTURE_TYPE_MEMORY_DEDICATED_REQUIREMENTS_KHR,
    e_MEMORY_DEDICATED_ALLOCATE_INFO_KHR = VK_STRUCTURE_TYPE_MEMORY_DEDICATED_ALLOCATE_INFO_KHR,
    e_DEBUG_UTILS_OBJECT_NAME_INFO_EXT = VK_STRUCTURE_TYPE_DEBUG_UTILS_OBJECT_NAME_INFO_EXT,
    e_DEBUG_UTILS_OBJECT_TAG_INFO_EXT = VK_STRUCTURE_TYPE_DEBUG_UTILS_OBJECT_TAG_INFO_EXT,
    e_DEBUG_UTILS_LABEL_EXT = VK_STRUCTURE_TYPE_DEBUG_UTILS_LABEL_EXT,
    e_DEBUG_UTILS_MESSENGER_CALLBACK_DATA_EXT = VK_STRUCTURE_TYPE_DEBUG_UTILS_MESSENGER_CALLBACK_DATA_EXT,
    e_DEBUG_UTILS_MESSENGER_CREATE_INFO_EXT = VK_STRUCTURE_TYPE_DEBUG_UTILS_MESSENGER_CREATE_INFO_EXT,
    e_ANDROID_HARDWARE_BUFFER_USAGE_ANDROID = VK_STRUCTURE_TYPE_ANDROID_HARDWARE_BUFFER_USAGE_ANDROID,
    e_ANDROID_HARDWARE_BUFFER_PROPERTIES_ANDROID = VK_STRUCTURE_TYPE_ANDROID_HARDWARE_BUFFER_PROPERTIES_ANDROID,
    e_ANDROID_HARDWARE_BUFFER_FORMAT_PROPERTIES_ANDROID = VK_STRUCTURE_TYPE_ANDROID_HARDWARE_BUFFER_FORMAT_PROPERTIES_ANDROID,
    e_IMPORT_ANDROID_HARDWARE_BUFFER_INFO_ANDROID = VK_STRUCTURE_TYPE_IMPORT_ANDROID_HARDWARE_BUFFER_INFO_ANDROID,
    e_MEMORY_GET_ANDROID_HARDWARE_BUFFER_INFO_ANDROID = VK_STRUCTURE_TYPE_MEMORY_GET_ANDROID_HARDWARE_BUFFER_INFO_ANDROID,
    e_EXTERNAL_FORMAT_ANDROID = VK_STRUCTURE_TYPE_EXTERNAL_FORMAT_ANDROID,
    e_PHYSICAL_DEVICE_SAMPLER_FILTER_MINMAX_PROPERTIES_EXT = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLER_FILTER_MINMAX_PROPERTIES_EXT,
    e_SAMPLER_REDUCTION_MODE_CREATE_INFO_EXT = VK_STRUCTURE_TYPE_SAMPLER_REDUCTION_MODE_CREATE_INFO_EXT,
    e_PHYSICAL_DEVICE_INLINE_UNIFORM_BLOCK_FEATURES_EXT = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INLINE_UNIFORM_BLOCK_FEATURES_EXT,
    e_PHYSICAL_DEVICE_INLINE_UNIFORM_BLOCK_PROPERTIES_EXT = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INLINE_UNIFORM_BLOCK_PROPERTIES_EXT,
    e_WRITE_DESCRIPTOR_SET_INLINE_UNIFORM_BLOCK_EXT = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET_INLINE_UNIFORM_BLOCK_EXT,
    e_DESCRIPTOR_POOL_INLINE_UNIFORM_BLOCK_CREATE_INFO_EXT = VK_STRUCTURE_TYPE_DESCRIPTOR_POOL_INLINE_UNIFORM_BLOCK_CREATE_INFO_EXT,
    e_SAMPLE_LOCATIONS_INFO_EXT = VK_STRUCTURE_TYPE_SAMPLE_LOCATIONS_INFO_EXT,
    e_RENDER_PASS_SAMPLE_LOCATIONS_BEGIN_INFO_EXT = VK_STRUCTURE_TYPE_RENDER_PASS_SAMPLE_LOCATIONS_BEGIN_INFO_EXT,
    e_PIPELINE_SAMPLE_LOCATIONS_STATE_CREATE_INFO_EXT = VK_STRUCTURE_TYPE_PIPELINE_SAMPLE_LOCATIONS_STATE_CREATE_INFO_EXT,
    e_PHYSICAL_DEVICE_SAMPLE_LOCATIONS_PROPERTIES_EXT = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLE_LOCATIONS_PROPERTIES_EXT,
    e_MULTISAMPLE_PROPERTIES_EXT = VK_STRUCTURE_TYPE_MULTISAMPLE_PROPERTIES_EXT,
    e_BUFFER_MEMORY_REQUIREMENTS_INFO_2_KHR = VK_STRUCTURE_TYPE_BUFFER_MEMORY_REQUIREMENTS_INFO_2_KHR,
    e_IMAGE_MEMORY_REQUIREMENTS_INFO_2_KHR = VK_STRUCTURE_TYPE_IMAGE_MEMORY_REQUIREMENTS_INFO_2_KHR,
    e_IMAGE_SPARSE_MEMORY_REQUIREMENTS_INFO_2_KHR = VK_STRUCTURE_TYPE_IMAGE_SPARSE_MEMORY_REQUIREMENTS_INFO_2_KHR,
    e_MEMORY_REQUIREMENTS_2_KHR = VK_STRUCTURE_TYPE_MEMORY_REQUIREMENTS_2_KHR,
    e_SPARSE_IMAGE_MEMORY_REQUIREMENTS_2_KHR = VK_STRUCTURE_TYPE_SPARSE_IMAGE_MEMORY_REQUIREMENTS_2_KHR,
    e_IMAGE_FORMAT_LIST_CREATE_INFO_KHR = VK_STRUCTURE_TYPE_IMAGE_FORMAT_LIST_CREATE_INFO_KHR,
    e_PHYSICAL_DEVICE_BLEND_OPERATION_ADVANCED_FEATURES_EXT = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BLEND_OPERATION_ADVANCED_FEATURES_EXT,
    e_PHYSICAL_DEVICE_BLEND_OPERATION_ADVANCED_PROPERTIES_EXT = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BLEND_OPERATION_ADVANCED_PROPERTIES_EXT,
    e_PIPELINE_COLOR_BLEND_ADVANCED_STATE_CREATE_INFO_EXT = VK_STRUCTURE_TYPE_PIPELINE_COLOR_BLEND_ADVANCED_STATE_CREATE_INFO_EXT,
    e_PIPELINE_COVERAGE_TO_COLOR_STATE_CREATE_INFO_NV = VK_STRUCTURE_TYPE_PIPELINE_COVERAGE_TO_COLOR_STATE_CREATE_INFO_NV,
    e_PIPELINE_COVERAGE_MODULATION_STATE_CREATE_INFO_NV = VK_STRUCTURE_TYPE_PIPELINE_COVERAGE_MODULATION_STATE_CREATE_INFO_NV,
    e_SAMPLER_YCBCR_CONVERSION_CREATE_INFO_KHR = VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_CREATE_INFO_KHR,
    e_SAMPLER_YCBCR_CONVERSION_INFO_KHR = VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_INFO_KHR,
    e_BIND_IMAGE_PLANE_MEMORY_INFO_KHR = VK_STRUCTURE_TYPE_BIND_IMAGE_PLANE_MEMORY_INFO_KHR,
    e_IMAGE_PLANE_MEMORY_REQUIREMENTS_INFO_KHR = VK_STRUCTURE_TYPE_IMAGE_PLANE_MEMORY_REQUIREMENTS_INFO_KHR,
    e_PHYSICAL_DEVICE_SAMPLER_YCBCR_CONVERSION_FEATURES_KHR = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLER_YCBCR_CONVERSION_FEATURES_KHR,
    e_SAMPLER_YCBCR_CONVERSION_IMAGE_FORMAT_PROPERTIES_KHR = VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_IMAGE_FORMAT_PROPERTIES_KHR,
    e_BIND_BUFFER_MEMORY_INFO_KHR = VK_STRUCTURE_TYPE_BIND_BUFFER_MEMORY_INFO_KHR,
    e_BIND_IMAGE_MEMORY_INFO_KHR = VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_INFO_KHR,
    e_DRM_FORMAT_MODIFIER_PROPERTIES_LIST_EXT = VK_STRUCTURE_TYPE_DRM_FORMAT_MODIFIER_PROPERTIES_LIST_EXT,
    e_DRM_FORMAT_MODIFIER_PROPERTIES_EXT = VK_STRUCTURE_TYPE_DRM_FORMAT_MODIFIER_PROPERTIES_EXT,
    e_PHYSICAL_DEVICE_IMAGE_DRM_FORMAT_MODIFIER_INFO_EXT = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_DRM_FORMAT_MODIFIER_INFO_EXT,
    e_IMAGE_DRM_FORMAT_MODIFIER_LIST_CREATE_INFO_EXT = VK_STRUCTURE_TYPE_IMAGE_DRM_FORMAT_MODIFIER_LIST_CREATE_INFO_EXT,
    e_IMAGE_DRM_FORMAT_MODIFIER_EXPLICIT_CREATE_INFO_EXT = VK_STRUCTURE_TYPE_IMAGE_DRM_FORMAT_MODIFIER_EXPLICIT_CREATE_INFO_EXT,
    e_IMAGE_DRM_FORMAT_MODIFIER_PROPERTIES_EXT = VK_STRUCTURE_TYPE_IMAGE_DRM_FORMAT_MODIFIER_PROPERTIES_EXT,
    e_VALIDATION_CACHE_CREATE_INFO_EXT = VK_STRUCTURE_TYPE_VALIDATION_CACHE_CREATE_INFO_EXT,
    e_SHADER_MODULE_VALIDATION_CACHE_CREATE_INFO_EXT = VK_STRUCTURE_TYPE_SHADER_MODULE_VALIDATION_CACHE_CREATE_INFO_EXT,
    e_DESCRIPTOR_SET_LAYOUT_BINDING_FLAGS_CREATE_INFO_EXT = VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_BINDING_FLAGS_CREATE_INFO_EXT,
    e_PHYSICAL_DEVICE_DESCRIPTOR_INDEXING_FEATURES_EXT = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_INDEXING_FEATURES_EXT,
    e_PHYSICAL_DEVICE_DESCRIPTOR_INDEXING_PROPERTIES_EXT = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_INDEXING_PROPERTIES_EXT,
    e_DESCRIPTOR_SET_VARIABLE_DESCRIPTOR_COUNT_ALLOCATE_INFO_EXT = VK_STRUCTURE_TYPE_DESCRIPTOR_SET_VARIABLE_DESCRIPTOR_COUNT_ALLOCATE_INFO_EXT,
    e_DESCRIPTOR_SET_VARIABLE_DESCRIPTOR_COUNT_LAYOUT_SUPPORT_EXT = VK_STRUCTURE_TYPE_DESCRIPTOR_SET_VARIABLE_DESCRIPTOR_COUNT_LAYOUT_SUPPORT_EXT,
    e_PIPELINE_VIEWPORT_SHADING_RATE_IMAGE_STATE_CREATE_INFO_NV = VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_SHADING_RATE_IMAGE_STATE_CREATE_INFO_NV,
    e_PHYSICAL_DEVICE_SHADING_RATE_IMAGE_FEATURES_NV = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADING_RATE_IMAGE_FEATURES_NV,
    e_PHYSICAL_DEVICE_SHADING_RATE_IMAGE_PROPERTIES_NV = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADING_RATE_IMAGE_PROPERTIES_NV,
    e_PIPELINE_VIEWPORT_COARSE_SAMPLE_ORDER_STATE_CREATE_INFO_NV = VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_COARSE_SAMPLE_ORDER_STATE_CREATE_INFO_NV,
    e_RAY_TRACING_PIPELINE_CREATE_INFO_NV = VK_STRUCTURE_TYPE_RAY_TRACING_PIPELINE_CREATE_INFO_NV,
    e_ACCELERATION_STRUCTURE_CREATE_INFO_NV = VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_CREATE_INFO_NV,
    e_GEOMETRY_NV = VK_STRUCTURE_TYPE_GEOMETRY_NV,
    e_GEOMETRY_TRIANGLES_NV = VK_STRUCTURE_TYPE_GEOMETRY_TRIANGLES_NV,
    e_GEOMETRY_AABB_NV = VK_STRUCTURE_TYPE_GEOMETRY_AABB_NV,
    e_BIND_ACCELERATION_STRUCTURE_MEMORY_INFO_NV = VK_STRUCTURE_TYPE_BIND_ACCELERATION_STRUCTURE_MEMORY_INFO_NV,
    e_WRITE_DESCRIPTOR_SET_ACCELERATION_STRUCTURE_NV = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET_ACCELERATION_STRUCTURE_NV,
    e_ACCELERATION_STRUCTURE_MEMORY_REQUIREMENTS_INFO_NV = VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_MEMORY_REQUIREMENTS_INFO_NV,
    e_PHYSICAL_DEVICE_RAY_TRACING_PROPERTIES_NV = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_PROPERTIES_NV,
    e_RAY_TRACING_SHADER_GROUP_CREATE_INFO_NV = VK_STRUCTURE_TYPE_RAY_TRACING_SHADER_GROUP_CREATE_INFO_NV,
    e_ACCELERATION_STRUCTURE_INFO_NV = VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_INFO_NV,
    e_PHYSICAL_DEVICE_REPRESENTATIVE_FRAGMENT_TEST_FEATURES_NV = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_REPRESENTATIVE_FRAGMENT_TEST_FEATURES_NV,
    e_PIPELINE_REPRESENTATIVE_FRAGMENT_TEST_STATE_CREATE_INFO_NV = VK_STRUCTURE_TYPE_PIPELINE_REPRESENTATIVE_FRAGMENT_TEST_STATE_CREATE_INFO_NV,
    e_PHYSICAL_DEVICE_MAINTENANCE_3_PROPERTIES_KHR = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_3_PROPERTIES_KHR,
    e_DESCRIPTOR_SET_LAYOUT_SUPPORT_KHR = VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_SUPPORT_KHR,
    e_DEVICE_QUEUE_GLOBAL_PRIORITY_CREATE_INFO_EXT = VK_STRUCTURE_TYPE_DEVICE_QUEUE_GLOBAL_PRIORITY_CREATE_INFO_EXT,
    e_PHYSICAL_DEVICE_8BIT_STORAGE_FEATURES_KHR = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_8BIT_STORAGE_FEATURES_KHR,
    e_IMPORT_MEMORY_HOST_POINTER_INFO_EXT = VK_STRUCTURE_TYPE_IMPORT_MEMORY_HOST_POINTER_INFO_EXT,
    e_MEMORY_HOST_POINTER_PROPERTIES_EXT = VK_STRUCTURE_TYPE_MEMORY_HOST_POINTER_PROPERTIES_EXT,
    e_PHYSICAL_DEVICE_EXTERNAL_MEMORY_HOST_PROPERTIES_EXT = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_MEMORY_HOST_PROPERTIES_EXT,
    e_PHYSICAL_DEVICE_SHADER_ATOMIC_INT64_FEATURES_KHR = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ATOMIC_INT64_FEATURES_KHR,
    e_CALIBRATED_TIMESTAMP_INFO_EXT = VK_STRUCTURE_TYPE_CALIBRATED_TIMESTAMP_INFO_EXT,
    e_PHYSICAL_DEVICE_SHADER_CORE_PROPERTIES_AMD = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CORE_PROPERTIES_AMD,
    e_DEVICE_MEMORY_OVERALLOCATION_CREATE_INFO_AMD = VK_STRUCTURE_TYPE_DEVICE_MEMORY_OVERALLOCATION_CREATE_INFO_AMD,
    e_PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_DIVISOR_PROPERTIES_EXT = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_DIVISOR_PROPERTIES_EXT,
    e_PIPELINE_VERTEX_INPUT_DIVISOR_STATE_CREATE_INFO_EXT = VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_DIVISOR_STATE_CREATE_INFO_EXT,
    e_PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_DIVISOR_FEATURES_EXT = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_DIVISOR_FEATURES_EXT,
    e_PHYSICAL_DEVICE_DRIVER_PROPERTIES_KHR = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DRIVER_PROPERTIES_KHR,
    e_PHYSICAL_DEVICE_COMPUTE_SHADER_DERIVATIVES_FEATURES_NV = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COMPUTE_SHADER_DERIVATIVES_FEATURES_NV,
    e_PHYSICAL_DEVICE_MESH_SHADER_FEATURES_NV = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MESH_SHADER_FEATURES_NV,
    e_PHYSICAL_DEVICE_MESH_SHADER_PROPERTIES_NV = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MESH_SHADER_PROPERTIES_NV,
    e_PHYSICAL_DEVICE_FRAGMENT_SHADER_BARYCENTRIC_FEATURES_NV = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADER_BARYCENTRIC_FEATURES_NV,
    e_PHYSICAL_DEVICE_SHADER_IMAGE_FOOTPRINT_FEATURES_NV = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_IMAGE_FOOTPRINT_FEATURES_NV,
    e_PIPELINE_VIEWPORT_EXCLUSIVE_SCISSOR_STATE_CREATE_INFO_NV = VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_EXCLUSIVE_SCISSOR_STATE_CREATE_INFO_NV,
    e_PHYSICAL_DEVICE_EXCLUSIVE_SCISSOR_FEATURES_NV = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXCLUSIVE_SCISSOR_FEATURES_NV,
    e_CHECKPOINT_DATA_NV = VK_STRUCTURE_TYPE_CHECKPOINT_DATA_NV,
    e_QUEUE_FAMILY_CHECKPOINT_PROPERTIES_NV = VK_STRUCTURE_TYPE_QUEUE_FAMILY_CHECKPOINT_PROPERTIES_NV,
    e_PHYSICAL_DEVICE_VULKAN_MEMORY_MODEL_FEATURES_KHR = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_MEMORY_MODEL_FEATURES_KHR,
    e_PHYSICAL_DEVICE_PCI_BUS_INFO_PROPERTIES_EXT = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PCI_BUS_INFO_PROPERTIES_EXT,
    e_IMAGEPIPE_SURFACE_CREATE_INFO_FUCHSIA = VK_STRUCTURE_TYPE_IMAGEPIPE_SURFACE_CREATE_INFO_FUCHSIA,
    e_BEGIN_RANGE = VK_STRUCTURE_TYPE_BEGIN_RANGE,
    e_END_RANGE = VK_STRUCTURE_TYPE_END_RANGE,
    e_RANGE_SIZE = VK_STRUCTURE_TYPE_RANGE_SIZE,
    e_MAX_ENUM = 0x7FFFFFFF

};
DEFINE_ENUM_BITWISE_OPERATORS(StructureType)
inline std::string to_string(StructureType value)
{
    switch(value)
    {
    case StructureType::e_APPLICATION_INFO: return "VK_STRUCTURE_TYPE_APPLICATION_INFO";
    case StructureType::e_INSTANCE_CREATE_INFO: return "VK_STRUCTURE_TYPE_INSTANCE_CREATE_INFO";
    case StructureType::e_DEVICE_QUEUE_CREATE_INFO: return "VK_STRUCTURE_TYPE_DEVICE_QUEUE_CREATE_INFO";
    case StructureType::e_DEVICE_CREATE_INFO: return "VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO";
    case StructureType::e_SUBMIT_INFO: return "VK_STRUCTURE_TYPE_SUBMIT_INFO";
    case StructureType::e_MEMORY_ALLOCATE_INFO: return "VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_INFO";
    case StructureType::e_MAPPED_MEMORY_RANGE: return "VK_STRUCTURE_TYPE_MAPPED_MEMORY_RANGE";
    case StructureType::e_BIND_SPARSE_INFO: return "VK_STRUCTURE_TYPE_BIND_SPARSE_INFO";
    case StructureType::e_FENCE_CREATE_INFO: return "VK_STRUCTURE_TYPE_FENCE_CREATE_INFO";
    case StructureType::e_SEMAPHORE_CREATE_INFO: return "VK_STRUCTURE_TYPE_SEMAPHORE_CREATE_INFO";
    case StructureType::e_EVENT_CREATE_INFO: return "VK_STRUCTURE_TYPE_EVENT_CREATE_INFO";
    case StructureType::e_QUERY_POOL_CREATE_INFO: return "VK_STRUCTURE_TYPE_QUERY_POOL_CREATE_INFO";
    case StructureType::e_BUFFER_CREATE_INFO: return "VK_STRUCTURE_TYPE_BUFFER_CREATE_INFO";
    case StructureType::e_BUFFER_VIEW_CREATE_INFO: return "VK_STRUCTURE_TYPE_BUFFER_VIEW_CREATE_INFO";
    case StructureType::e_IMAGE_CREATE_INFO: return "VK_STRUCTURE_TYPE_IMAGE_CREATE_INFO";
    case StructureType::e_IMAGE_VIEW_CREATE_INFO: return "VK_STRUCTURE_TYPE_IMAGE_VIEW_CREATE_INFO";
    case StructureType::e_SHADER_MODULE_CREATE_INFO: return "VK_STRUCTURE_TYPE_SHADER_MODULE_CREATE_INFO";
    case StructureType::e_PIPELINE_CACHE_CREATE_INFO: return "VK_STRUCTURE_TYPE_PIPELINE_CACHE_CREATE_INFO";
    case StructureType::e_PIPELINE_SHADER_STAGE_CREATE_INFO: return "VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO";
    case StructureType::e_PIPELINE_VERTEX_INPUT_STATE_CREATE_INFO: return "VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_STATE_CREATE_INFO";
    case StructureType::e_PIPELINE_INPUT_ASSEMBLY_STATE_CREATE_INFO: return "VK_STRUCTURE_TYPE_PIPELINE_INPUT_ASSEMBLY_STATE_CREATE_INFO";
    case StructureType::e_PIPELINE_TESSELLATION_STATE_CREATE_INFO: return "VK_STRUCTURE_TYPE_PIPELINE_TESSELLATION_STATE_CREATE_INFO";
    case StructureType::e_PIPELINE_VIEWPORT_STATE_CREATE_INFO: return "VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_STATE_CREATE_INFO";
    case StructureType::e_PIPELINE_RASTERIZATION_STATE_CREATE_INFO: return "VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_CREATE_INFO";
    case StructureType::e_PIPELINE_MULTISAMPLE_STATE_CREATE_INFO: return "VK_STRUCTURE_TYPE_PIPELINE_MULTISAMPLE_STATE_CREATE_INFO";
    case StructureType::e_PIPELINE_DEPTH_STENCIL_STATE_CREATE_INFO: return "VK_STRUCTURE_TYPE_PIPELINE_DEPTH_STENCIL_STATE_CREATE_INFO";
    case StructureType::e_PIPELINE_COLOR_BLEND_STATE_CREATE_INFO: return "VK_STRUCTURE_TYPE_PIPELINE_COLOR_BLEND_STATE_CREATE_INFO";
    case StructureType::e_PIPELINE_DYNAMIC_STATE_CREATE_INFO: return "VK_STRUCTURE_TYPE_PIPELINE_DYNAMIC_STATE_CREATE_INFO";
    case StructureType::e_GRAPHICS_PIPELINE_CREATE_INFO: return "VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_CREATE_INFO";
    case StructureType::e_COMPUTE_PIPELINE_CREATE_INFO: return "VK_STRUCTURE_TYPE_COMPUTE_PIPELINE_CREATE_INFO";
    case StructureType::e_PIPELINE_LAYOUT_CREATE_INFO: return "VK_STRUCTURE_TYPE_PIPELINE_LAYOUT_CREATE_INFO";
    case StructureType::e_SAMPLER_CREATE_INFO: return "VK_STRUCTURE_TYPE_SAMPLER_CREATE_INFO";
    case StructureType::e_DESCRIPTOR_SET_LAYOUT_CREATE_INFO: return "VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_CREATE_INFO";
    case StructureType::e_DESCRIPTOR_POOL_CREATE_INFO: return "VK_STRUCTURE_TYPE_DESCRIPTOR_POOL_CREATE_INFO";
    case StructureType::e_DESCRIPTOR_SET_ALLOCATE_INFO: return "VK_STRUCTURE_TYPE_DESCRIPTOR_SET_ALLOCATE_INFO";
    case StructureType::e_WRITE_DESCRIPTOR_SET: return "VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET";
    case StructureType::e_COPY_DESCRIPTOR_SET: return "VK_STRUCTURE_TYPE_COPY_DESCRIPTOR_SET";
    case StructureType::e_FRAMEBUFFER_CREATE_INFO: return "VK_STRUCTURE_TYPE_FRAMEBUFFER_CREATE_INFO";
    case StructureType::e_RENDER_PASS_CREATE_INFO: return "VK_STRUCTURE_TYPE_RENDER_PASS_CREATE_INFO";
    case StructureType::e_COMMAND_POOL_CREATE_INFO: return "VK_STRUCTURE_TYPE_COMMAND_POOL_CREATE_INFO";
    case StructureType::e_COMMAND_BUFFER_ALLOCATE_INFO: return "VK_STRUCTURE_TYPE_COMMAND_BUFFER_ALLOCATE_INFO";
    case StructureType::e_COMMAND_BUFFER_INHERITANCE_INFO: return "VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_INFO";
    case StructureType::e_COMMAND_BUFFER_BEGIN_INFO: return "VK_STRUCTURE_TYPE_COMMAND_BUFFER_BEGIN_INFO";
    case StructureType::e_RENDER_PASS_BEGIN_INFO: return "VK_STRUCTURE_TYPE_RENDER_PASS_BEGIN_INFO";
    case StructureType::e_BUFFER_MEMORY_BARRIER: return "VK_STRUCTURE_TYPE_BUFFER_MEMORY_BARRIER";
    case StructureType::e_IMAGE_MEMORY_BARRIER: return "VK_STRUCTURE_TYPE_IMAGE_MEMORY_BARRIER";
    case StructureType::e_MEMORY_BARRIER: return "VK_STRUCTURE_TYPE_MEMORY_BARRIER";
    case StructureType::e_LOADER_INSTANCE_CREATE_INFO: return "VK_STRUCTURE_TYPE_LOADER_INSTANCE_CREATE_INFO";
    case StructureType::e_LOADER_DEVICE_CREATE_INFO: return "VK_STRUCTURE_TYPE_LOADER_DEVICE_CREATE_INFO";
    case StructureType::e_PHYSICAL_DEVICE_SUBGROUP_PROPERTIES: return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBGROUP_PROPERTIES";
    case StructureType::e_BIND_BUFFER_MEMORY_INFO: return "VK_STRUCTURE_TYPE_BIND_BUFFER_MEMORY_INFO";
    case StructureType::e_BIND_IMAGE_MEMORY_INFO: return "VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_INFO";
    case StructureType::e_PHYSICAL_DEVICE_16BIT_STORAGE_FEATURES: return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_16BIT_STORAGE_FEATURES";
    case StructureType::e_MEMORY_DEDICATED_REQUIREMENTS: return "VK_STRUCTURE_TYPE_MEMORY_DEDICATED_REQUIREMENTS";
    case StructureType::e_MEMORY_DEDICATED_ALLOCATE_INFO: return "VK_STRUCTURE_TYPE_MEMORY_DEDICATED_ALLOCATE_INFO";
    case StructureType::e_MEMORY_ALLOCATE_FLAGS_INFO: return "VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_FLAGS_INFO";
    case StructureType::e_DEVICE_GROUP_RENDER_PASS_BEGIN_INFO: return "VK_STRUCTURE_TYPE_DEVICE_GROUP_RENDER_PASS_BEGIN_INFO";
    case StructureType::e_DEVICE_GROUP_COMMAND_BUFFER_BEGIN_INFO: return "VK_STRUCTURE_TYPE_DEVICE_GROUP_COMMAND_BUFFER_BEGIN_INFO";
    case StructureType::e_DEVICE_GROUP_SUBMIT_INFO: return "VK_STRUCTURE_TYPE_DEVICE_GROUP_SUBMIT_INFO";
    case StructureType::e_DEVICE_GROUP_BIND_SPARSE_INFO: return "VK_STRUCTURE_TYPE_DEVICE_GROUP_BIND_SPARSE_INFO";
    case StructureType::e_BIND_BUFFER_MEMORY_DEVICE_GROUP_INFO: return "VK_STRUCTURE_TYPE_BIND_BUFFER_MEMORY_DEVICE_GROUP_INFO";
    case StructureType::e_BIND_IMAGE_MEMORY_DEVICE_GROUP_INFO: return "VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_DEVICE_GROUP_INFO";
    case StructureType::e_PHYSICAL_DEVICE_GROUP_PROPERTIES: return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GROUP_PROPERTIES";
    case StructureType::e_DEVICE_GROUP_DEVICE_CREATE_INFO: return "VK_STRUCTURE_TYPE_DEVICE_GROUP_DEVICE_CREATE_INFO";
    case StructureType::e_BUFFER_MEMORY_REQUIREMENTS_INFO_2: return "VK_STRUCTURE_TYPE_BUFFER_MEMORY_REQUIREMENTS_INFO_2";
    case StructureType::e_IMAGE_MEMORY_REQUIREMENTS_INFO_2: return "VK_STRUCTURE_TYPE_IMAGE_MEMORY_REQUIREMENTS_INFO_2";
    case StructureType::e_IMAGE_SPARSE_MEMORY_REQUIREMENTS_INFO_2: return "VK_STRUCTURE_TYPE_IMAGE_SPARSE_MEMORY_REQUIREMENTS_INFO_2";
    case StructureType::e_MEMORY_REQUIREMENTS_2: return "VK_STRUCTURE_TYPE_MEMORY_REQUIREMENTS_2";
    case StructureType::e_SPARSE_IMAGE_MEMORY_REQUIREMENTS_2: return "VK_STRUCTURE_TYPE_SPARSE_IMAGE_MEMORY_REQUIREMENTS_2";
    case StructureType::e_PHYSICAL_DEVICE_FEATURES_2: return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2";
    case StructureType::e_PHYSICAL_DEVICE_PROPERTIES_2: return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROPERTIES_2";
    case StructureType::e_FORMAT_PROPERTIES_2: return "VK_STRUCTURE_TYPE_FORMAT_PROPERTIES_2";
    case StructureType::e_IMAGE_FORMAT_PROPERTIES_2: return "VK_STRUCTURE_TYPE_IMAGE_FORMAT_PROPERTIES_2";
    case StructureType::e_PHYSICAL_DEVICE_IMAGE_FORMAT_INFO_2: return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_FORMAT_INFO_2";
    case StructureType::e_QUEUE_FAMILY_PROPERTIES_2: return "VK_STRUCTURE_TYPE_QUEUE_FAMILY_PROPERTIES_2";
    case StructureType::e_PHYSICAL_DEVICE_MEMORY_PROPERTIES_2: return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_PROPERTIES_2";
    case StructureType::e_SPARSE_IMAGE_FORMAT_PROPERTIES_2: return "VK_STRUCTURE_TYPE_SPARSE_IMAGE_FORMAT_PROPERTIES_2";
    case StructureType::e_PHYSICAL_DEVICE_SPARSE_IMAGE_FORMAT_INFO_2: return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SPARSE_IMAGE_FORMAT_INFO_2";
    case StructureType::e_PHYSICAL_DEVICE_POINT_CLIPPING_PROPERTIES: return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_POINT_CLIPPING_PROPERTIES";
    case StructureType::e_RENDER_PASS_INPUT_ATTACHMENT_ASPECT_CREATE_INFO: return "VK_STRUCTURE_TYPE_RENDER_PASS_INPUT_ATTACHMENT_ASPECT_CREATE_INFO";
    case StructureType::e_IMAGE_VIEW_USAGE_CREATE_INFO: return "VK_STRUCTURE_TYPE_IMAGE_VIEW_USAGE_CREATE_INFO";
    case StructureType::e_PIPELINE_TESSELLATION_DOMAIN_ORIGIN_STATE_CREATE_INFO: return "VK_STRUCTURE_TYPE_PIPELINE_TESSELLATION_DOMAIN_ORIGIN_STATE_CREATE_INFO";
    case StructureType::e_RENDER_PASS_MULTIVIEW_CREATE_INFO: return "VK_STRUCTURE_TYPE_RENDER_PASS_MULTIVIEW_CREATE_INFO";
    case StructureType::e_PHYSICAL_DEVICE_MULTIVIEW_FEATURES: return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_FEATURES";
    case StructureType::e_PHYSICAL_DEVICE_MULTIVIEW_PROPERTIES: return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PROPERTIES";
    case StructureType::e_PHYSICAL_DEVICE_VARIABLE_POINTER_FEATURES: return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VARIABLE_POINTER_FEATURES";
    case StructureType::e_PROTECTED_SUBMIT_INFO: return "VK_STRUCTURE_TYPE_PROTECTED_SUBMIT_INFO";
    case StructureType::e_PHYSICAL_DEVICE_PROTECTED_MEMORY_FEATURES: return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROTECTED_MEMORY_FEATURES";
    case StructureType::e_PHYSICAL_DEVICE_PROTECTED_MEMORY_PROPERTIES: return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROTECTED_MEMORY_PROPERTIES";
    case StructureType::e_DEVICE_QUEUE_INFO_2: return "VK_STRUCTURE_TYPE_DEVICE_QUEUE_INFO_2";
    case StructureType::e_SAMPLER_YCBCR_CONVERSION_CREATE_INFO: return "VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_CREATE_INFO";
    case StructureType::e_SAMPLER_YCBCR_CONVERSION_INFO: return "VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_INFO";
    case StructureType::e_BIND_IMAGE_PLANE_MEMORY_INFO: return "VK_STRUCTURE_TYPE_BIND_IMAGE_PLANE_MEMORY_INFO";
    case StructureType::e_IMAGE_PLANE_MEMORY_REQUIREMENTS_INFO: return "VK_STRUCTURE_TYPE_IMAGE_PLANE_MEMORY_REQUIREMENTS_INFO";
    case StructureType::e_PHYSICAL_DEVICE_SAMPLER_YCBCR_CONVERSION_FEATURES: return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLER_YCBCR_CONVERSION_FEATURES";
    case StructureType::e_SAMPLER_YCBCR_CONVERSION_IMAGE_FORMAT_PROPERTIES: return "VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_IMAGE_FORMAT_PROPERTIES";
    case StructureType::e_DESCRIPTOR_UPDATE_TEMPLATE_CREATE_INFO: return "VK_STRUCTURE_TYPE_DESCRIPTOR_UPDATE_TEMPLATE_CREATE_INFO";
    case StructureType::e_PHYSICAL_DEVICE_EXTERNAL_IMAGE_FORMAT_INFO: return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_IMAGE_FORMAT_INFO";
    case StructureType::e_EXTERNAL_IMAGE_FORMAT_PROPERTIES: return "VK_STRUCTURE_TYPE_EXTERNAL_IMAGE_FORMAT_PROPERTIES";
    case StructureType::e_PHYSICAL_DEVICE_EXTERNAL_BUFFER_INFO: return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_BUFFER_INFO";
    case StructureType::e_EXTERNAL_BUFFER_PROPERTIES: return "VK_STRUCTURE_TYPE_EXTERNAL_BUFFER_PROPERTIES";
    case StructureType::e_PHYSICAL_DEVICE_ID_PROPERTIES: return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ID_PROPERTIES";
    case StructureType::e_EXTERNAL_MEMORY_BUFFER_CREATE_INFO: return "VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_BUFFER_CREATE_INFO";
    case StructureType::e_EXTERNAL_MEMORY_IMAGE_CREATE_INFO: return "VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_IMAGE_CREATE_INFO";
    case StructureType::e_EXPORT_MEMORY_ALLOCATE_INFO: return "VK_STRUCTURE_TYPE_EXPORT_MEMORY_ALLOCATE_INFO";
    case StructureType::e_PHYSICAL_DEVICE_EXTERNAL_FENCE_INFO: return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_FENCE_INFO";
    case StructureType::e_EXTERNAL_FENCE_PROPERTIES: return "VK_STRUCTURE_TYPE_EXTERNAL_FENCE_PROPERTIES";
    case StructureType::e_EXPORT_FENCE_CREATE_INFO: return "VK_STRUCTURE_TYPE_EXPORT_FENCE_CREATE_INFO";
    case StructureType::e_EXPORT_SEMAPHORE_CREATE_INFO: return "VK_STRUCTURE_TYPE_EXPORT_SEMAPHORE_CREATE_INFO";
    case StructureType::e_PHYSICAL_DEVICE_EXTERNAL_SEMAPHORE_INFO: return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_SEMAPHORE_INFO";
    case StructureType::e_EXTERNAL_SEMAPHORE_PROPERTIES: return "VK_STRUCTURE_TYPE_EXTERNAL_SEMAPHORE_PROPERTIES";
    case StructureType::e_PHYSICAL_DEVICE_MAINTENANCE_3_PROPERTIES: return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_3_PROPERTIES";
    case StructureType::e_DESCRIPTOR_SET_LAYOUT_SUPPORT: return "VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_SUPPORT";
    case StructureType::e_PHYSICAL_DEVICE_SHADER_DRAW_PARAMETER_FEATURES: return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_DRAW_PARAMETER_FEATURES";
    case StructureType::e_SWAPCHAIN_CREATE_INFO_KHR: return "VK_STRUCTURE_TYPE_SWAPCHAIN_CREATE_INFO_KHR";
    case StructureType::e_PRESENT_INFO_KHR: return "VK_STRUCTURE_TYPE_PRESENT_INFO_KHR";
    case StructureType::e_DEVICE_GROUP_PRESENT_CAPABILITIES_KHR: return "VK_STRUCTURE_TYPE_DEVICE_GROUP_PRESENT_CAPABILITIES_KHR";
    case StructureType::e_IMAGE_SWAPCHAIN_CREATE_INFO_KHR: return "VK_STRUCTURE_TYPE_IMAGE_SWAPCHAIN_CREATE_INFO_KHR";
    case StructureType::e_BIND_IMAGE_MEMORY_SWAPCHAIN_INFO_KHR: return "VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_SWAPCHAIN_INFO_KHR";
    case StructureType::e_ACQUIRE_NEXT_IMAGE_INFO_KHR: return "VK_STRUCTURE_TYPE_ACQUIRE_NEXT_IMAGE_INFO_KHR";
    case StructureType::e_DEVICE_GROUP_PRESENT_INFO_KHR: return "VK_STRUCTURE_TYPE_DEVICE_GROUP_PRESENT_INFO_KHR";
    case StructureType::e_DEVICE_GROUP_SWAPCHAIN_CREATE_INFO_KHR: return "VK_STRUCTURE_TYPE_DEVICE_GROUP_SWAPCHAIN_CREATE_INFO_KHR";
    case StructureType::e_DISPLAY_MODE_CREATE_INFO_KHR: return "VK_STRUCTURE_TYPE_DISPLAY_MODE_CREATE_INFO_KHR";
    case StructureType::e_DISPLAY_SURFACE_CREATE_INFO_KHR: return "VK_STRUCTURE_TYPE_DISPLAY_SURFACE_CREATE_INFO_KHR";
    case StructureType::e_DISPLAY_PRESENT_INFO_KHR: return "VK_STRUCTURE_TYPE_DISPLAY_PRESENT_INFO_KHR";
    case StructureType::e_XLIB_SURFACE_CREATE_INFO_KHR: return "VK_STRUCTURE_TYPE_XLIB_SURFACE_CREATE_INFO_KHR";
    case StructureType::e_XCB_SURFACE_CREATE_INFO_KHR: return "VK_STRUCTURE_TYPE_XCB_SURFACE_CREATE_INFO_KHR";
    case StructureType::e_WAYLAND_SURFACE_CREATE_INFO_KHR: return "VK_STRUCTURE_TYPE_WAYLAND_SURFACE_CREATE_INFO_KHR";
    case StructureType::e_ANDROID_SURFACE_CREATE_INFO_KHR: return "VK_STRUCTURE_TYPE_ANDROID_SURFACE_CREATE_INFO_KHR";
    case StructureType::e_WIN32_SURFACE_CREATE_INFO_KHR: return "VK_STRUCTURE_TYPE_WIN32_SURFACE_CREATE_INFO_KHR";
    case StructureType::e_DEBUG_REPORT_CALLBACK_CREATE_INFO_EXT: return "VK_STRUCTURE_TYPE_DEBUG_REPORT_CALLBACK_CREATE_INFO_EXT";
    case StructureType::e_PIPELINE_RASTERIZATION_STATE_RASTERIZATION_ORDER_AMD: return "VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_RASTERIZATION_ORDER_AMD";
    case StructureType::e_DEBUG_MARKER_OBJECT_NAME_INFO_EXT: return "VK_STRUCTURE_TYPE_DEBUG_MARKER_OBJECT_NAME_INFO_EXT";
    case StructureType::e_DEBUG_MARKER_OBJECT_TAG_INFO_EXT: return "VK_STRUCTURE_TYPE_DEBUG_MARKER_OBJECT_TAG_INFO_EXT";
    case StructureType::e_DEBUG_MARKER_MARKER_INFO_EXT: return "VK_STRUCTURE_TYPE_DEBUG_MARKER_MARKER_INFO_EXT";
    case StructureType::e_DEDICATED_ALLOCATION_IMAGE_CREATE_INFO_NV: return "VK_STRUCTURE_TYPE_DEDICATED_ALLOCATION_IMAGE_CREATE_INFO_NV";
    case StructureType::e_DEDICATED_ALLOCATION_BUFFER_CREATE_INFO_NV: return "VK_STRUCTURE_TYPE_DEDICATED_ALLOCATION_BUFFER_CREATE_INFO_NV";
    case StructureType::e_DEDICATED_ALLOCATION_MEMORY_ALLOCATE_INFO_NV: return "VK_STRUCTURE_TYPE_DEDICATED_ALLOCATION_MEMORY_ALLOCATE_INFO_NV";
    case StructureType::e_PHYSICAL_DEVICE_TRANSFORM_FEEDBACK_FEATURES_EXT: return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TRANSFORM_FEEDBACK_FEATURES_EXT";
    case StructureType::e_PHYSICAL_DEVICE_TRANSFORM_FEEDBACK_PROPERTIES_EXT: return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TRANSFORM_FEEDBACK_PROPERTIES_EXT";
    case StructureType::e_PIPELINE_RASTERIZATION_STATE_STREAM_CREATE_INFO_EXT: return "VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_STREAM_CREATE_INFO_EXT";
    case StructureType::e_TEXTURE_LOD_GATHER_FORMAT_PROPERTIES_AMD: return "VK_STRUCTURE_TYPE_TEXTURE_LOD_GATHER_FORMAT_PROPERTIES_AMD";
    case StructureType::e_PHYSICAL_DEVICE_CORNER_SAMPLED_IMAGE_FEATURES_NV: return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CORNER_SAMPLED_IMAGE_FEATURES_NV";
    case StructureType::e_EXTERNAL_MEMORY_IMAGE_CREATE_INFO_NV: return "VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_IMAGE_CREATE_INFO_NV";
    case StructureType::e_EXPORT_MEMORY_ALLOCATE_INFO_NV: return "VK_STRUCTURE_TYPE_EXPORT_MEMORY_ALLOCATE_INFO_NV";
    case StructureType::e_IMPORT_MEMORY_WIN32_HANDLE_INFO_NV: return "VK_STRUCTURE_TYPE_IMPORT_MEMORY_WIN32_HANDLE_INFO_NV";
    case StructureType::e_EXPORT_MEMORY_WIN32_HANDLE_INFO_NV: return "VK_STRUCTURE_TYPE_EXPORT_MEMORY_WIN32_HANDLE_INFO_NV";
    case StructureType::e_WIN32_KEYED_MUTEX_ACQUIRE_RELEASE_INFO_NV: return "VK_STRUCTURE_TYPE_WIN32_KEYED_MUTEX_ACQUIRE_RELEASE_INFO_NV";
    case StructureType::e_VALIDATION_FLAGS_EXT: return "VK_STRUCTURE_TYPE_VALIDATION_FLAGS_EXT";
    case StructureType::e_VI_SURFACE_CREATE_INFO_NN: return "VK_STRUCTURE_TYPE_VI_SURFACE_CREATE_INFO_NN";
    case StructureType::e_IMAGE_VIEW_ASTC_DECODE_MODE_EXT: return "VK_STRUCTURE_TYPE_IMAGE_VIEW_ASTC_DECODE_MODE_EXT";
    case StructureType::e_PHYSICAL_DEVICE_ASTC_DECODE_FEATURES_EXT: return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ASTC_DECODE_FEATURES_EXT";
    case StructureType::e_IMPORT_MEMORY_WIN32_HANDLE_INFO_KHR: return "VK_STRUCTURE_TYPE_IMPORT_MEMORY_WIN32_HANDLE_INFO_KHR";
    case StructureType::e_EXPORT_MEMORY_WIN32_HANDLE_INFO_KHR: return "VK_STRUCTURE_TYPE_EXPORT_MEMORY_WIN32_HANDLE_INFO_KHR";
    case StructureType::e_MEMORY_WIN32_HANDLE_PROPERTIES_KHR: return "VK_STRUCTURE_TYPE_MEMORY_WIN32_HANDLE_PROPERTIES_KHR";
    case StructureType::e_MEMORY_GET_WIN32_HANDLE_INFO_KHR: return "VK_STRUCTURE_TYPE_MEMORY_GET_WIN32_HANDLE_INFO_KHR";
    case StructureType::e_IMPORT_MEMORY_FD_INFO_KHR: return "VK_STRUCTURE_TYPE_IMPORT_MEMORY_FD_INFO_KHR";
    case StructureType::e_MEMORY_FD_PROPERTIES_KHR: return "VK_STRUCTURE_TYPE_MEMORY_FD_PROPERTIES_KHR";
    case StructureType::e_MEMORY_GET_FD_INFO_KHR: return "VK_STRUCTURE_TYPE_MEMORY_GET_FD_INFO_KHR";
    case StructureType::e_WIN32_KEYED_MUTEX_ACQUIRE_RELEASE_INFO_KHR: return "VK_STRUCTURE_TYPE_WIN32_KEYED_MUTEX_ACQUIRE_RELEASE_INFO_KHR";
    case StructureType::e_IMPORT_SEMAPHORE_WIN32_HANDLE_INFO_KHR: return "VK_STRUCTURE_TYPE_IMPORT_SEMAPHORE_WIN32_HANDLE_INFO_KHR";
    case StructureType::e_EXPORT_SEMAPHORE_WIN32_HANDLE_INFO_KHR: return "VK_STRUCTURE_TYPE_EXPORT_SEMAPHORE_WIN32_HANDLE_INFO_KHR";
    case StructureType::e_D3D12_FENCE_SUBMIT_INFO_KHR: return "VK_STRUCTURE_TYPE_D3D12_FENCE_SUBMIT_INFO_KHR";
    case StructureType::e_SEMAPHORE_GET_WIN32_HANDLE_INFO_KHR: return "VK_STRUCTURE_TYPE_SEMAPHORE_GET_WIN32_HANDLE_INFO_KHR";
    case StructureType::e_IMPORT_SEMAPHORE_FD_INFO_KHR: return "VK_STRUCTURE_TYPE_IMPORT_SEMAPHORE_FD_INFO_KHR";
    case StructureType::e_SEMAPHORE_GET_FD_INFO_KHR: return "VK_STRUCTURE_TYPE_SEMAPHORE_GET_FD_INFO_KHR";
    case StructureType::e_PHYSICAL_DEVICE_PUSH_DESCRIPTOR_PROPERTIES_KHR: return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PUSH_DESCRIPTOR_PROPERTIES_KHR";
    case StructureType::e_COMMAND_BUFFER_INHERITANCE_CONDITIONAL_RENDERING_INFO_EXT: return "VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_CONDITIONAL_RENDERING_INFO_EXT";
    case StructureType::e_PHYSICAL_DEVICE_CONDITIONAL_RENDERING_FEATURES_EXT: return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CONDITIONAL_RENDERING_FEATURES_EXT";
    case StructureType::e_CONDITIONAL_RENDERING_BEGIN_INFO_EXT: return "VK_STRUCTURE_TYPE_CONDITIONAL_RENDERING_BEGIN_INFO_EXT";
    case StructureType::e_PRESENT_REGIONS_KHR: return "VK_STRUCTURE_TYPE_PRESENT_REGIONS_KHR";
    case StructureType::e_OBJECT_TABLE_CREATE_INFO_NVX: return "VK_STRUCTURE_TYPE_OBJECT_TABLE_CREATE_INFO_NVX";
    case StructureType::e_INDIRECT_COMMANDS_LAYOUT_CREATE_INFO_NVX: return "VK_STRUCTURE_TYPE_INDIRECT_COMMANDS_LAYOUT_CREATE_INFO_NVX";
    case StructureType::e_CMD_PROCESS_COMMANDS_INFO_NVX: return "VK_STRUCTURE_TYPE_CMD_PROCESS_COMMANDS_INFO_NVX";
    case StructureType::e_CMD_RESERVE_SPACE_FOR_COMMANDS_INFO_NVX: return "VK_STRUCTURE_TYPE_CMD_RESERVE_SPACE_FOR_COMMANDS_INFO_NVX";
    case StructureType::e_DEVICE_GENERATED_COMMANDS_LIMITS_NVX: return "VK_STRUCTURE_TYPE_DEVICE_GENERATED_COMMANDS_LIMITS_NVX";
    case StructureType::e_DEVICE_GENERATED_COMMANDS_FEATURES_NVX: return "VK_STRUCTURE_TYPE_DEVICE_GENERATED_COMMANDS_FEATURES_NVX";
    case StructureType::e_PIPELINE_VIEWPORT_W_SCALING_STATE_CREATE_INFO_NV: return "VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_W_SCALING_STATE_CREATE_INFO_NV";
    case StructureType::e_SURFACE_CAPABILITIES_2_EXT: return "VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES_2_EXT";
    case StructureType::e_DISPLAY_POWER_INFO_EXT: return "VK_STRUCTURE_TYPE_DISPLAY_POWER_INFO_EXT";
    case StructureType::e_DEVICE_EVENT_INFO_EXT: return "VK_STRUCTURE_TYPE_DEVICE_EVENT_INFO_EXT";
    case StructureType::e_DISPLAY_EVENT_INFO_EXT: return "VK_STRUCTURE_TYPE_DISPLAY_EVENT_INFO_EXT";
    case StructureType::e_SWAPCHAIN_COUNTER_CREATE_INFO_EXT: return "VK_STRUCTURE_TYPE_SWAPCHAIN_COUNTER_CREATE_INFO_EXT";
    case StructureType::e_PRESENT_TIMES_INFO_GOOGLE: return "VK_STRUCTURE_TYPE_PRESENT_TIMES_INFO_GOOGLE";
    case StructureType::e_PHYSICAL_DEVICE_MULTIVIEW_PER_VIEW_ATTRIBUTES_PROPERTIES_NVX: return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PER_VIEW_ATTRIBUTES_PROPERTIES_NVX";
    case StructureType::e_PIPELINE_VIEWPORT_SWIZZLE_STATE_CREATE_INFO_NV: return "VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_SWIZZLE_STATE_CREATE_INFO_NV";
    case StructureType::e_PHYSICAL_DEVICE_DISCARD_RECTANGLE_PROPERTIES_EXT: return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DISCARD_RECTANGLE_PROPERTIES_EXT";
    case StructureType::e_PIPELINE_DISCARD_RECTANGLE_STATE_CREATE_INFO_EXT: return "VK_STRUCTURE_TYPE_PIPELINE_DISCARD_RECTANGLE_STATE_CREATE_INFO_EXT";
    case StructureType::e_PHYSICAL_DEVICE_CONSERVATIVE_RASTERIZATION_PROPERTIES_EXT: return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CONSERVATIVE_RASTERIZATION_PROPERTIES_EXT";
    case StructureType::e_PIPELINE_RASTERIZATION_CONSERVATIVE_STATE_CREATE_INFO_EXT: return "VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_CONSERVATIVE_STATE_CREATE_INFO_EXT";
    case StructureType::e_HDR_METADATA_EXT: return "VK_STRUCTURE_TYPE_HDR_METADATA_EXT";
    case StructureType::e_ATTACHMENT_DESCRIPTION_2_KHR: return "VK_STRUCTURE_TYPE_ATTACHMENT_DESCRIPTION_2_KHR";
    case StructureType::e_ATTACHMENT_REFERENCE_2_KHR: return "VK_STRUCTURE_TYPE_ATTACHMENT_REFERENCE_2_KHR";
    case StructureType::e_SUBPASS_DESCRIPTION_2_KHR: return "VK_STRUCTURE_TYPE_SUBPASS_DESCRIPTION_2_KHR";
    case StructureType::e_SUBPASS_DEPENDENCY_2_KHR: return "VK_STRUCTURE_TYPE_SUBPASS_DEPENDENCY_2_KHR";
    case StructureType::e_RENDER_PASS_CREATE_INFO_2_KHR: return "VK_STRUCTURE_TYPE_RENDER_PASS_CREATE_INFO_2_KHR";
    case StructureType::e_SUBPASS_BEGIN_INFO_KHR: return "VK_STRUCTURE_TYPE_SUBPASS_BEGIN_INFO_KHR";
    case StructureType::e_SUBPASS_END_INFO_KHR: return "VK_STRUCTURE_TYPE_SUBPASS_END_INFO_KHR";
    case StructureType::e_SHARED_PRESENT_SURFACE_CAPABILITIES_KHR: return "VK_STRUCTURE_TYPE_SHARED_PRESENT_SURFACE_CAPABILITIES_KHR";
    case StructureType::e_IMPORT_FENCE_WIN32_HANDLE_INFO_KHR: return "VK_STRUCTURE_TYPE_IMPORT_FENCE_WIN32_HANDLE_INFO_KHR";
    case StructureType::e_EXPORT_FENCE_WIN32_HANDLE_INFO_KHR: return "VK_STRUCTURE_TYPE_EXPORT_FENCE_WIN32_HANDLE_INFO_KHR";
    case StructureType::e_FENCE_GET_WIN32_HANDLE_INFO_KHR: return "VK_STRUCTURE_TYPE_FENCE_GET_WIN32_HANDLE_INFO_KHR";
    case StructureType::e_IMPORT_FENCE_FD_INFO_KHR: return "VK_STRUCTURE_TYPE_IMPORT_FENCE_FD_INFO_KHR";
    case StructureType::e_FENCE_GET_FD_INFO_KHR: return "VK_STRUCTURE_TYPE_FENCE_GET_FD_INFO_KHR";
    case StructureType::e_PHYSICAL_DEVICE_SURFACE_INFO_2_KHR: return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SURFACE_INFO_2_KHR";
    case StructureType::e_SURFACE_CAPABILITIES_2_KHR: return "VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES_2_KHR";
    case StructureType::e_SURFACE_FORMAT_2_KHR: return "VK_STRUCTURE_TYPE_SURFACE_FORMAT_2_KHR";
    case StructureType::e_DISPLAY_PROPERTIES_2_KHR: return "VK_STRUCTURE_TYPE_DISPLAY_PROPERTIES_2_KHR";
    case StructureType::e_DISPLAY_PLANE_PROPERTIES_2_KHR: return "VK_STRUCTURE_TYPE_DISPLAY_PLANE_PROPERTIES_2_KHR";
    case StructureType::e_DISPLAY_MODE_PROPERTIES_2_KHR: return "VK_STRUCTURE_TYPE_DISPLAY_MODE_PROPERTIES_2_KHR";
    case StructureType::e_DISPLAY_PLANE_INFO_2_KHR: return "VK_STRUCTURE_TYPE_DISPLAY_PLANE_INFO_2_KHR";
    case StructureType::e_DISPLAY_PLANE_CAPABILITIES_2_KHR: return "VK_STRUCTURE_TYPE_DISPLAY_PLANE_CAPABILITIES_2_KHR";
    case StructureType::e_IOS_SURFACE_CREATE_INFO_MVK: return "VK_STRUCTURE_TYPE_IOS_SURFACE_CREATE_INFO_MVK";
    case StructureType::e_MACOS_SURFACE_CREATE_INFO_MVK: return "VK_STRUCTURE_TYPE_MACOS_SURFACE_CREATE_INFO_MVK";
    case StructureType::e_DEBUG_UTILS_OBJECT_NAME_INFO_EXT: return "VK_STRUCTURE_TYPE_DEBUG_UTILS_OBJECT_NAME_INFO_EXT";
    case StructureType::e_DEBUG_UTILS_OBJECT_TAG_INFO_EXT: return "VK_STRUCTURE_TYPE_DEBUG_UTILS_OBJECT_TAG_INFO_EXT";
    case StructureType::e_DEBUG_UTILS_LABEL_EXT: return "VK_STRUCTURE_TYPE_DEBUG_UTILS_LABEL_EXT";
    case StructureType::e_DEBUG_UTILS_MESSENGER_CALLBACK_DATA_EXT: return "VK_STRUCTURE_TYPE_DEBUG_UTILS_MESSENGER_CALLBACK_DATA_EXT";
    case StructureType::e_DEBUG_UTILS_MESSENGER_CREATE_INFO_EXT: return "VK_STRUCTURE_TYPE_DEBUG_UTILS_MESSENGER_CREATE_INFO_EXT";
    case StructureType::e_ANDROID_HARDWARE_BUFFER_USAGE_ANDROID: return "VK_STRUCTURE_TYPE_ANDROID_HARDWARE_BUFFER_USAGE_ANDROID";
    case StructureType::e_ANDROID_HARDWARE_BUFFER_PROPERTIES_ANDROID: return "VK_STRUCTURE_TYPE_ANDROID_HARDWARE_BUFFER_PROPERTIES_ANDROID";
    case StructureType::e_ANDROID_HARDWARE_BUFFER_FORMAT_PROPERTIES_ANDROID: return "VK_STRUCTURE_TYPE_ANDROID_HARDWARE_BUFFER_FORMAT_PROPERTIES_ANDROID";
    case StructureType::e_IMPORT_ANDROID_HARDWARE_BUFFER_INFO_ANDROID: return "VK_STRUCTURE_TYPE_IMPORT_ANDROID_HARDWARE_BUFFER_INFO_ANDROID";
    case StructureType::e_MEMORY_GET_ANDROID_HARDWARE_BUFFER_INFO_ANDROID: return "VK_STRUCTURE_TYPE_MEMORY_GET_ANDROID_HARDWARE_BUFFER_INFO_ANDROID";
    case StructureType::e_EXTERNAL_FORMAT_ANDROID: return "VK_STRUCTURE_TYPE_EXTERNAL_FORMAT_ANDROID";
    case StructureType::e_PHYSICAL_DEVICE_SAMPLER_FILTER_MINMAX_PROPERTIES_EXT: return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLER_FILTER_MINMAX_PROPERTIES_EXT";
    case StructureType::e_SAMPLER_REDUCTION_MODE_CREATE_INFO_EXT: return "VK_STRUCTURE_TYPE_SAMPLER_REDUCTION_MODE_CREATE_INFO_EXT";
    case StructureType::e_PHYSICAL_DEVICE_INLINE_UNIFORM_BLOCK_FEATURES_EXT: return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INLINE_UNIFORM_BLOCK_FEATURES_EXT";
    case StructureType::e_PHYSICAL_DEVICE_INLINE_UNIFORM_BLOCK_PROPERTIES_EXT: return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INLINE_UNIFORM_BLOCK_PROPERTIES_EXT";
    case StructureType::e_WRITE_DESCRIPTOR_SET_INLINE_UNIFORM_BLOCK_EXT: return "VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET_INLINE_UNIFORM_BLOCK_EXT";
    case StructureType::e_DESCRIPTOR_POOL_INLINE_UNIFORM_BLOCK_CREATE_INFO_EXT: return "VK_STRUCTURE_TYPE_DESCRIPTOR_POOL_INLINE_UNIFORM_BLOCK_CREATE_INFO_EXT";
    case StructureType::e_SAMPLE_LOCATIONS_INFO_EXT: return "VK_STRUCTURE_TYPE_SAMPLE_LOCATIONS_INFO_EXT";
    case StructureType::e_RENDER_PASS_SAMPLE_LOCATIONS_BEGIN_INFO_EXT: return "VK_STRUCTURE_TYPE_RENDER_PASS_SAMPLE_LOCATIONS_BEGIN_INFO_EXT";
    case StructureType::e_PIPELINE_SAMPLE_LOCATIONS_STATE_CREATE_INFO_EXT: return "VK_STRUCTURE_TYPE_PIPELINE_SAMPLE_LOCATIONS_STATE_CREATE_INFO_EXT";
    case StructureType::e_PHYSICAL_DEVICE_SAMPLE_LOCATIONS_PROPERTIES_EXT: return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLE_LOCATIONS_PROPERTIES_EXT";
    case StructureType::e_MULTISAMPLE_PROPERTIES_EXT: return "VK_STRUCTURE_TYPE_MULTISAMPLE_PROPERTIES_EXT";
    case StructureType::e_IMAGE_FORMAT_LIST_CREATE_INFO_KHR: return "VK_STRUCTURE_TYPE_IMAGE_FORMAT_LIST_CREATE_INFO_KHR";
    case StructureType::e_PHYSICAL_DEVICE_BLEND_OPERATION_ADVANCED_FEATURES_EXT: return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BLEND_OPERATION_ADVANCED_FEATURES_EXT";
    case StructureType::e_PHYSICAL_DEVICE_BLEND_OPERATION_ADVANCED_PROPERTIES_EXT: return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BLEND_OPERATION_ADVANCED_PROPERTIES_EXT";
    case StructureType::e_PIPELINE_COLOR_BLEND_ADVANCED_STATE_CREATE_INFO_EXT: return "VK_STRUCTURE_TYPE_PIPELINE_COLOR_BLEND_ADVANCED_STATE_CREATE_INFO_EXT";
    case StructureType::e_PIPELINE_COVERAGE_TO_COLOR_STATE_CREATE_INFO_NV: return "VK_STRUCTURE_TYPE_PIPELINE_COVERAGE_TO_COLOR_STATE_CREATE_INFO_NV";
    case StructureType::e_PIPELINE_COVERAGE_MODULATION_STATE_CREATE_INFO_NV: return "VK_STRUCTURE_TYPE_PIPELINE_COVERAGE_MODULATION_STATE_CREATE_INFO_NV";
    case StructureType::e_DRM_FORMAT_MODIFIER_PROPERTIES_LIST_EXT: return "VK_STRUCTURE_TYPE_DRM_FORMAT_MODIFIER_PROPERTIES_LIST_EXT";
    case StructureType::e_DRM_FORMAT_MODIFIER_PROPERTIES_EXT: return "VK_STRUCTURE_TYPE_DRM_FORMAT_MODIFIER_PROPERTIES_EXT";
    case StructureType::e_PHYSICAL_DEVICE_IMAGE_DRM_FORMAT_MODIFIER_INFO_EXT: return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_DRM_FORMAT_MODIFIER_INFO_EXT";
    case StructureType::e_IMAGE_DRM_FORMAT_MODIFIER_LIST_CREATE_INFO_EXT: return "VK_STRUCTURE_TYPE_IMAGE_DRM_FORMAT_MODIFIER_LIST_CREATE_INFO_EXT";
    case StructureType::e_IMAGE_DRM_FORMAT_MODIFIER_EXPLICIT_CREATE_INFO_EXT: return "VK_STRUCTURE_TYPE_IMAGE_DRM_FORMAT_MODIFIER_EXPLICIT_CREATE_INFO_EXT";
    case StructureType::e_IMAGE_DRM_FORMAT_MODIFIER_PROPERTIES_EXT: return "VK_STRUCTURE_TYPE_IMAGE_DRM_FORMAT_MODIFIER_PROPERTIES_EXT";
    case StructureType::e_VALIDATION_CACHE_CREATE_INFO_EXT: return "VK_STRUCTURE_TYPE_VALIDATION_CACHE_CREATE_INFO_EXT";
    case StructureType::e_SHADER_MODULE_VALIDATION_CACHE_CREATE_INFO_EXT: return "VK_STRUCTURE_TYPE_SHADER_MODULE_VALIDATION_CACHE_CREATE_INFO_EXT";
    case StructureType::e_DESCRIPTOR_SET_LAYOUT_BINDING_FLAGS_CREATE_INFO_EXT: return "VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_BINDING_FLAGS_CREATE_INFO_EXT";
    case StructureType::e_PHYSICAL_DEVICE_DESCRIPTOR_INDEXING_FEATURES_EXT: return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_INDEXING_FEATURES_EXT";
    case StructureType::e_PHYSICAL_DEVICE_DESCRIPTOR_INDEXING_PROPERTIES_EXT: return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_INDEXING_PROPERTIES_EXT";
    case StructureType::e_DESCRIPTOR_SET_VARIABLE_DESCRIPTOR_COUNT_ALLOCATE_INFO_EXT: return "VK_STRUCTURE_TYPE_DESCRIPTOR_SET_VARIABLE_DESCRIPTOR_COUNT_ALLOCATE_INFO_EXT";
    case StructureType::e_DESCRIPTOR_SET_VARIABLE_DESCRIPTOR_COUNT_LAYOUT_SUPPORT_EXT: return "VK_STRUCTURE_TYPE_DESCRIPTOR_SET_VARIABLE_DESCRIPTOR_COUNT_LAYOUT_SUPPORT_EXT";
    case StructureType::e_PIPELINE_VIEWPORT_SHADING_RATE_IMAGE_STATE_CREATE_INFO_NV: return "VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_SHADING_RATE_IMAGE_STATE_CREATE_INFO_NV";
    case StructureType::e_PHYSICAL_DEVICE_SHADING_RATE_IMAGE_FEATURES_NV: return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADING_RATE_IMAGE_FEATURES_NV";
    case StructureType::e_PHYSICAL_DEVICE_SHADING_RATE_IMAGE_PROPERTIES_NV: return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADING_RATE_IMAGE_PROPERTIES_NV";
    case StructureType::e_PIPELINE_VIEWPORT_COARSE_SAMPLE_ORDER_STATE_CREATE_INFO_NV: return "VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_COARSE_SAMPLE_ORDER_STATE_CREATE_INFO_NV";
    case StructureType::e_RAY_TRACING_PIPELINE_CREATE_INFO_NV: return "VK_STRUCTURE_TYPE_RAY_TRACING_PIPELINE_CREATE_INFO_NV";
    case StructureType::e_ACCELERATION_STRUCTURE_CREATE_INFO_NV: return "VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_CREATE_INFO_NV";
    case StructureType::e_GEOMETRY_NV: return "VK_STRUCTURE_TYPE_GEOMETRY_NV";
    case StructureType::e_GEOMETRY_TRIANGLES_NV: return "VK_STRUCTURE_TYPE_GEOMETRY_TRIANGLES_NV";
    case StructureType::e_GEOMETRY_AABB_NV: return "VK_STRUCTURE_TYPE_GEOMETRY_AABB_NV";
    case StructureType::e_BIND_ACCELERATION_STRUCTURE_MEMORY_INFO_NV: return "VK_STRUCTURE_TYPE_BIND_ACCELERATION_STRUCTURE_MEMORY_INFO_NV";
    case StructureType::e_WRITE_DESCRIPTOR_SET_ACCELERATION_STRUCTURE_NV: return "VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET_ACCELERATION_STRUCTURE_NV";
    case StructureType::e_ACCELERATION_STRUCTURE_MEMORY_REQUIREMENTS_INFO_NV: return "VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_MEMORY_REQUIREMENTS_INFO_NV";
    case StructureType::e_PHYSICAL_DEVICE_RAY_TRACING_PROPERTIES_NV: return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_PROPERTIES_NV";
    case StructureType::e_RAY_TRACING_SHADER_GROUP_CREATE_INFO_NV: return "VK_STRUCTURE_TYPE_RAY_TRACING_SHADER_GROUP_CREATE_INFO_NV";
    case StructureType::e_ACCELERATION_STRUCTURE_INFO_NV: return "VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_INFO_NV";
    case StructureType::e_PHYSICAL_DEVICE_REPRESENTATIVE_FRAGMENT_TEST_FEATURES_NV: return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_REPRESENTATIVE_FRAGMENT_TEST_FEATURES_NV";
    case StructureType::e_PIPELINE_REPRESENTATIVE_FRAGMENT_TEST_STATE_CREATE_INFO_NV: return "VK_STRUCTURE_TYPE_PIPELINE_REPRESENTATIVE_FRAGMENT_TEST_STATE_CREATE_INFO_NV";
    case StructureType::e_DEVICE_QUEUE_GLOBAL_PRIORITY_CREATE_INFO_EXT: return "VK_STRUCTURE_TYPE_DEVICE_QUEUE_GLOBAL_PRIORITY_CREATE_INFO_EXT";
    case StructureType::e_PHYSICAL_DEVICE_8BIT_STORAGE_FEATURES_KHR: return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_8BIT_STORAGE_FEATURES_KHR";
    case StructureType::e_IMPORT_MEMORY_HOST_POINTER_INFO_EXT: return "VK_STRUCTURE_TYPE_IMPORT_MEMORY_HOST_POINTER_INFO_EXT";
    case StructureType::e_MEMORY_HOST_POINTER_PROPERTIES_EXT: return "VK_STRUCTURE_TYPE_MEMORY_HOST_POINTER_PROPERTIES_EXT";
    case StructureType::e_PHYSICAL_DEVICE_EXTERNAL_MEMORY_HOST_PROPERTIES_EXT: return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_MEMORY_HOST_PROPERTIES_EXT";
    case StructureType::e_PHYSICAL_DEVICE_SHADER_ATOMIC_INT64_FEATURES_KHR: return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ATOMIC_INT64_FEATURES_KHR";
    case StructureType::e_CALIBRATED_TIMESTAMP_INFO_EXT: return "VK_STRUCTURE_TYPE_CALIBRATED_TIMESTAMP_INFO_EXT";
    case StructureType::e_PHYSICAL_DEVICE_SHADER_CORE_PROPERTIES_AMD: return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CORE_PROPERTIES_AMD";
    case StructureType::e_DEVICE_MEMORY_OVERALLOCATION_CREATE_INFO_AMD: return "VK_STRUCTURE_TYPE_DEVICE_MEMORY_OVERALLOCATION_CREATE_INFO_AMD";
    case StructureType::e_PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_DIVISOR_PROPERTIES_EXT: return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_DIVISOR_PROPERTIES_EXT";
    case StructureType::e_PIPELINE_VERTEX_INPUT_DIVISOR_STATE_CREATE_INFO_EXT: return "VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_DIVISOR_STATE_CREATE_INFO_EXT";
    case StructureType::e_PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_DIVISOR_FEATURES_EXT: return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_DIVISOR_FEATURES_EXT";
    case StructureType::e_PHYSICAL_DEVICE_DRIVER_PROPERTIES_KHR: return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DRIVER_PROPERTIES_KHR";
    case StructureType::e_PHYSICAL_DEVICE_COMPUTE_SHADER_DERIVATIVES_FEATURES_NV: return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COMPUTE_SHADER_DERIVATIVES_FEATURES_NV";
    case StructureType::e_PHYSICAL_DEVICE_MESH_SHADER_FEATURES_NV: return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MESH_SHADER_FEATURES_NV";
    case StructureType::e_PHYSICAL_DEVICE_MESH_SHADER_PROPERTIES_NV: return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MESH_SHADER_PROPERTIES_NV";
    case StructureType::e_PHYSICAL_DEVICE_FRAGMENT_SHADER_BARYCENTRIC_FEATURES_NV: return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADER_BARYCENTRIC_FEATURES_NV";
    case StructureType::e_PHYSICAL_DEVICE_SHADER_IMAGE_FOOTPRINT_FEATURES_NV: return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_IMAGE_FOOTPRINT_FEATURES_NV";
    case StructureType::e_PIPELINE_VIEWPORT_EXCLUSIVE_SCISSOR_STATE_CREATE_INFO_NV: return "VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_EXCLUSIVE_SCISSOR_STATE_CREATE_INFO_NV";
    case StructureType::e_PHYSICAL_DEVICE_EXCLUSIVE_SCISSOR_FEATURES_NV: return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXCLUSIVE_SCISSOR_FEATURES_NV";
    case StructureType::e_CHECKPOINT_DATA_NV: return "VK_STRUCTURE_TYPE_CHECKPOINT_DATA_NV";
    case StructureType::e_QUEUE_FAMILY_CHECKPOINT_PROPERTIES_NV: return "VK_STRUCTURE_TYPE_QUEUE_FAMILY_CHECKPOINT_PROPERTIES_NV";
    case StructureType::e_PHYSICAL_DEVICE_VULKAN_MEMORY_MODEL_FEATURES_KHR: return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_MEMORY_MODEL_FEATURES_KHR";
    case StructureType::e_PHYSICAL_DEVICE_PCI_BUS_INFO_PROPERTIES_EXT: return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PCI_BUS_INFO_PROPERTIES_EXT";
    case StructureType::e_IMAGEPIPE_SURFACE_CREATE_INFO_FUCHSIA: return "VK_STRUCTURE_TYPE_IMAGEPIPE_SURFACE_CREATE_INFO_FUCHSIA";
    default: return "invalid";
    }
}

enum class SystemAllocationScope
{
    e_COMMAND = VK_SYSTEM_ALLOCATION_SCOPE_COMMAND,
    e_OBJECT = VK_SYSTEM_ALLOCATION_SCOPE_OBJECT,
    e_CACHE = VK_SYSTEM_ALLOCATION_SCOPE_CACHE,
    e_DEVICE = VK_SYSTEM_ALLOCATION_SCOPE_DEVICE,
    e_INSTANCE = VK_SYSTEM_ALLOCATION_SCOPE_INSTANCE,
    e_BEGIN_RANGE = VK_SYSTEM_ALLOCATION_SCOPE_BEGIN_RANGE,
    e_END_RANGE = VK_SYSTEM_ALLOCATION_SCOPE_END_RANGE,
    e_RANGE_SIZE = VK_SYSTEM_ALLOCATION_SCOPE_RANGE_SIZE,
    e_MAX_ENUM = 0x7FFFFFFF

};
DEFINE_ENUM_BITWISE_OPERATORS(SystemAllocationScope)
inline std::string to_string(SystemAllocationScope value)
{
    switch(value)
    {
    case SystemAllocationScope::e_COMMAND: return "VK_SYSTEM_ALLOCATION_SCOPE_COMMAND";
    case SystemAllocationScope::e_OBJECT: return "VK_SYSTEM_ALLOCATION_SCOPE_OBJECT";
    case SystemAllocationScope::e_CACHE: return "VK_SYSTEM_ALLOCATION_SCOPE_CACHE";
    case SystemAllocationScope::e_DEVICE: return "VK_SYSTEM_ALLOCATION_SCOPE_DEVICE";
    case SystemAllocationScope::e_INSTANCE: return "VK_SYSTEM_ALLOCATION_SCOPE_INSTANCE";
    default: return "invalid";
    }
}

enum class InternalAllocationType
{
    e_EXECUTABLE = VK_INTERNAL_ALLOCATION_TYPE_EXECUTABLE,
    e_BEGIN_RANGE = VK_INTERNAL_ALLOCATION_TYPE_BEGIN_RANGE,
    e_END_RANGE = VK_INTERNAL_ALLOCATION_TYPE_END_RANGE,
    e_RANGE_SIZE = VK_INTERNAL_ALLOCATION_TYPE_RANGE_SIZE,
    e_MAX_ENUM = 0x7FFFFFFF

};
DEFINE_ENUM_BITWISE_OPERATORS(InternalAllocationType)
inline std::string to_string(InternalAllocationType value)
{
    switch(value)
    {
    case InternalAllocationType::e_EXECUTABLE: return "VK_INTERNAL_ALLOCATION_TYPE_EXECUTABLE";
    default: return "invalid";
    }
}

enum class Format
{
    e_UNDEFINED = VK_FORMAT_UNDEFINED,
    e_R4G4_UNORM_PACK8 = VK_FORMAT_R4G4_UNORM_PACK8,
    e_R4G4B4A4_UNORM_PACK16 = VK_FORMAT_R4G4B4A4_UNORM_PACK16,
    e_B4G4R4A4_UNORM_PACK16 = VK_FORMAT_B4G4R4A4_UNORM_PACK16,
    e_R5G6B5_UNORM_PACK16 = VK_FORMAT_R5G6B5_UNORM_PACK16,
    e_B5G6R5_UNORM_PACK16 = VK_FORMAT_B5G6R5_UNORM_PACK16,
    e_R5G5B5A1_UNORM_PACK16 = VK_FORMAT_R5G5B5A1_UNORM_PACK16,
    e_B5G5R5A1_UNORM_PACK16 = VK_FORMAT_B5G5R5A1_UNORM_PACK16,
    e_A1R5G5B5_UNORM_PACK16 = VK_FORMAT_A1R5G5B5_UNORM_PACK16,
    e_R8_UNORM = VK_FORMAT_R8_UNORM,
    e_R8_SNORM = VK_FORMAT_R8_SNORM,
    e_R8_USCALED = VK_FORMAT_R8_USCALED,
    e_R8_SSCALED = VK_FORMAT_R8_SSCALED,
    e_R8_UINT = VK_FORMAT_R8_UINT,
    e_R8_SINT = VK_FORMAT_R8_SINT,
    e_R8_SRGB = VK_FORMAT_R8_SRGB,
    e_R8G8_UNORM = VK_FORMAT_R8G8_UNORM,
    e_R8G8_SNORM = VK_FORMAT_R8G8_SNORM,
    e_R8G8_USCALED = VK_FORMAT_R8G8_USCALED,
    e_R8G8_SSCALED = VK_FORMAT_R8G8_SSCALED,
    e_R8G8_UINT = VK_FORMAT_R8G8_UINT,
    e_R8G8_SINT = VK_FORMAT_R8G8_SINT,
    e_R8G8_SRGB = VK_FORMAT_R8G8_SRGB,
    e_R8G8B8_UNORM = VK_FORMAT_R8G8B8_UNORM,
    e_R8G8B8_SNORM = VK_FORMAT_R8G8B8_SNORM,
    e_R8G8B8_USCALED = VK_FORMAT_R8G8B8_USCALED,
    e_R8G8B8_SSCALED = VK_FORMAT_R8G8B8_SSCALED,
    e_R8G8B8_UINT = VK_FORMAT_R8G8B8_UINT,
    e_R8G8B8_SINT = VK_FORMAT_R8G8B8_SINT,
    e_R8G8B8_SRGB = VK_FORMAT_R8G8B8_SRGB,
    e_B8G8R8_UNORM = VK_FORMAT_B8G8R8_UNORM,
    e_B8G8R8_SNORM = VK_FORMAT_B8G8R8_SNORM,
    e_B8G8R8_USCALED = VK_FORMAT_B8G8R8_USCALED,
    e_B8G8R8_SSCALED = VK_FORMAT_B8G8R8_SSCALED,
    e_B8G8R8_UINT = VK_FORMAT_B8G8R8_UINT,
    e_B8G8R8_SINT = VK_FORMAT_B8G8R8_SINT,
    e_B8G8R8_SRGB = VK_FORMAT_B8G8R8_SRGB,
    e_R8G8B8A8_UNORM = VK_FORMAT_R8G8B8A8_UNORM,
    e_R8G8B8A8_SNORM = VK_FORMAT_R8G8B8A8_SNORM,
    e_R8G8B8A8_USCALED = VK_FORMAT_R8G8B8A8_USCALED,
    e_R8G8B8A8_SSCALED = VK_FORMAT_R8G8B8A8_SSCALED,
    e_R8G8B8A8_UINT = VK_FORMAT_R8G8B8A8_UINT,
    e_R8G8B8A8_SINT = VK_FORMAT_R8G8B8A8_SINT,
    e_R8G8B8A8_SRGB = VK_FORMAT_R8G8B8A8_SRGB,
    e_B8G8R8A8_UNORM = VK_FORMAT_B8G8R8A8_UNORM,
    e_B8G8R8A8_SNORM = VK_FORMAT_B8G8R8A8_SNORM,
    e_B8G8R8A8_USCALED = VK_FORMAT_B8G8R8A8_USCALED,
    e_B8G8R8A8_SSCALED = VK_FORMAT_B8G8R8A8_SSCALED,
    e_B8G8R8A8_UINT = VK_FORMAT_B8G8R8A8_UINT,
    e_B8G8R8A8_SINT = VK_FORMAT_B8G8R8A8_SINT,
    e_B8G8R8A8_SRGB = VK_FORMAT_B8G8R8A8_SRGB,
    e_A8B8G8R8_UNORM_PACK32 = VK_FORMAT_A8B8G8R8_UNORM_PACK32,
    e_A8B8G8R8_SNORM_PACK32 = VK_FORMAT_A8B8G8R8_SNORM_PACK32,
    e_A8B8G8R8_USCALED_PACK32 = VK_FORMAT_A8B8G8R8_USCALED_PACK32,
    e_A8B8G8R8_SSCALED_PACK32 = VK_FORMAT_A8B8G8R8_SSCALED_PACK32,
    e_A8B8G8R8_UINT_PACK32 = VK_FORMAT_A8B8G8R8_UINT_PACK32,
    e_A8B8G8R8_SINT_PACK32 = VK_FORMAT_A8B8G8R8_SINT_PACK32,
    e_A8B8G8R8_SRGB_PACK32 = VK_FORMAT_A8B8G8R8_SRGB_PACK32,
    e_A2R10G10B10_UNORM_PACK32 = VK_FORMAT_A2R10G10B10_UNORM_PACK32,
    e_A2R10G10B10_SNORM_PACK32 = VK_FORMAT_A2R10G10B10_SNORM_PACK32,
    e_A2R10G10B10_USCALED_PACK32 = VK_FORMAT_A2R10G10B10_USCALED_PACK32,
    e_A2R10G10B10_SSCALED_PACK32 = VK_FORMAT_A2R10G10B10_SSCALED_PACK32,
    e_A2R10G10B10_UINT_PACK32 = VK_FORMAT_A2R10G10B10_UINT_PACK32,
    e_A2R10G10B10_SINT_PACK32 = VK_FORMAT_A2R10G10B10_SINT_PACK32,
    e_A2B10G10R10_UNORM_PACK32 = VK_FORMAT_A2B10G10R10_UNORM_PACK32,
    e_A2B10G10R10_SNORM_PACK32 = VK_FORMAT_A2B10G10R10_SNORM_PACK32,
    e_A2B10G10R10_USCALED_PACK32 = VK_FORMAT_A2B10G10R10_USCALED_PACK32,
    e_A2B10G10R10_SSCALED_PACK32 = VK_FORMAT_A2B10G10R10_SSCALED_PACK32,
    e_A2B10G10R10_UINT_PACK32 = VK_FORMAT_A2B10G10R10_UINT_PACK32,
    e_A2B10G10R10_SINT_PACK32 = VK_FORMAT_A2B10G10R10_SINT_PACK32,
    e_R16_UNORM = VK_FORMAT_R16_UNORM,
    e_R16_SNORM = VK_FORMAT_R16_SNORM,
    e_R16_USCALED = VK_FORMAT_R16_USCALED,
    e_R16_SSCALED = VK_FORMAT_R16_SSCALED,
    e_R16_UINT = VK_FORMAT_R16_UINT,
    e_R16_SINT = VK_FORMAT_R16_SINT,
    e_R16_SFLOAT = VK_FORMAT_R16_SFLOAT,
    e_R16G16_UNORM = VK_FORMAT_R16G16_UNORM,
    e_R16G16_SNORM = VK_FORMAT_R16G16_SNORM,
    e_R16G16_USCALED = VK_FORMAT_R16G16_USCALED,
    e_R16G16_SSCALED = VK_FORMAT_R16G16_SSCALED,
    e_R16G16_UINT = VK_FORMAT_R16G16_UINT,
    e_R16G16_SINT = VK_FORMAT_R16G16_SINT,
    e_R16G16_SFLOAT = VK_FORMAT_R16G16_SFLOAT,
    e_R16G16B16_UNORM = VK_FORMAT_R16G16B16_UNORM,
    e_R16G16B16_SNORM = VK_FORMAT_R16G16B16_SNORM,
    e_R16G16B16_USCALED = VK_FORMAT_R16G16B16_USCALED,
    e_R16G16B16_SSCALED = VK_FORMAT_R16G16B16_SSCALED,
    e_R16G16B16_UINT = VK_FORMAT_R16G16B16_UINT,
    e_R16G16B16_SINT = VK_FORMAT_R16G16B16_SINT,
    e_R16G16B16_SFLOAT = VK_FORMAT_R16G16B16_SFLOAT,
    e_R16G16B16A16_UNORM = VK_FORMAT_R16G16B16A16_UNORM,
    e_R16G16B16A16_SNORM = VK_FORMAT_R16G16B16A16_SNORM,
    e_R16G16B16A16_USCALED = VK_FORMAT_R16G16B16A16_USCALED,
    e_R16G16B16A16_SSCALED = VK_FORMAT_R16G16B16A16_SSCALED,
    e_R16G16B16A16_UINT = VK_FORMAT_R16G16B16A16_UINT,
    e_R16G16B16A16_SINT = VK_FORMAT_R16G16B16A16_SINT,
    e_R16G16B16A16_SFLOAT = VK_FORMAT_R16G16B16A16_SFLOAT,
    e_R32_UINT = VK_FORMAT_R32_UINT,
    e_R32_SINT = VK_FORMAT_R32_SINT,
    e_R32_SFLOAT = VK_FORMAT_R32_SFLOAT,
    e_R32G32_UINT = VK_FORMAT_R32G32_UINT,
    e_R32G32_SINT = VK_FORMAT_R32G32_SINT,
    e_R32G32_SFLOAT = VK_FORMAT_R32G32_SFLOAT,
    e_R32G32B32_UINT = VK_FORMAT_R32G32B32_UINT,
    e_R32G32B32_SINT = VK_FORMAT_R32G32B32_SINT,
    e_R32G32B32_SFLOAT = VK_FORMAT_R32G32B32_SFLOAT,
    e_R32G32B32A32_UINT = VK_FORMAT_R32G32B32A32_UINT,
    e_R32G32B32A32_SINT = VK_FORMAT_R32G32B32A32_SINT,
    e_R32G32B32A32_SFLOAT = VK_FORMAT_R32G32B32A32_SFLOAT,
    e_R64_UINT = VK_FORMAT_R64_UINT,
    e_R64_SINT = VK_FORMAT_R64_SINT,
    e_R64_SFLOAT = VK_FORMAT_R64_SFLOAT,
    e_R64G64_UINT = VK_FORMAT_R64G64_UINT,
    e_R64G64_SINT = VK_FORMAT_R64G64_SINT,
    e_R64G64_SFLOAT = VK_FORMAT_R64G64_SFLOAT,
    e_R64G64B64_UINT = VK_FORMAT_R64G64B64_UINT,
    e_R64G64B64_SINT = VK_FORMAT_R64G64B64_SINT,
    e_R64G64B64_SFLOAT = VK_FORMAT_R64G64B64_SFLOAT,
    e_R64G64B64A64_UINT = VK_FORMAT_R64G64B64A64_UINT,
    e_R64G64B64A64_SINT = VK_FORMAT_R64G64B64A64_SINT,
    e_R64G64B64A64_SFLOAT = VK_FORMAT_R64G64B64A64_SFLOAT,
    e_B10G11R11_UFLOAT_PACK32 = VK_FORMAT_B10G11R11_UFLOAT_PACK32,
    e_E5B9G9R9_UFLOAT_PACK32 = VK_FORMAT_E5B9G9R9_UFLOAT_PACK32,
    e_D16_UNORM = VK_FORMAT_D16_UNORM,
    e_X8_D24_UNORM_PACK32 = VK_FORMAT_X8_D24_UNORM_PACK32,
    e_D32_SFLOAT = VK_FORMAT_D32_SFLOAT,
    e_S8_UINT = VK_FORMAT_S8_UINT,
    e_D16_UNORM_S8_UINT = VK_FORMAT_D16_UNORM_S8_UINT,
    e_D24_UNORM_S8_UINT = VK_FORMAT_D24_UNORM_S8_UINT,
    e_D32_SFLOAT_S8_UINT = VK_FORMAT_D32_SFLOAT_S8_UINT,
    e_BC1_RGB_UNORM_BLOCK = VK_FORMAT_BC1_RGB_UNORM_BLOCK,
    e_BC1_RGB_SRGB_BLOCK = VK_FORMAT_BC1_RGB_SRGB_BLOCK,
    e_BC1_RGBA_UNORM_BLOCK = VK_FORMAT_BC1_RGBA_UNORM_BLOCK,
    e_BC1_RGBA_SRGB_BLOCK = VK_FORMAT_BC1_RGBA_SRGB_BLOCK,
    e_BC2_UNORM_BLOCK = VK_FORMAT_BC2_UNORM_BLOCK,
    e_BC2_SRGB_BLOCK = VK_FORMAT_BC2_SRGB_BLOCK,
    e_BC3_UNORM_BLOCK = VK_FORMAT_BC3_UNORM_BLOCK,
    e_BC3_SRGB_BLOCK = VK_FORMAT_BC3_SRGB_BLOCK,
    e_BC4_UNORM_BLOCK = VK_FORMAT_BC4_UNORM_BLOCK,
    e_BC4_SNORM_BLOCK = VK_FORMAT_BC4_SNORM_BLOCK,
    e_BC5_UNORM_BLOCK = VK_FORMAT_BC5_UNORM_BLOCK,
    e_BC5_SNORM_BLOCK = VK_FORMAT_BC5_SNORM_BLOCK,
    e_BC6H_UFLOAT_BLOCK = VK_FORMAT_BC6H_UFLOAT_BLOCK,
    e_BC6H_SFLOAT_BLOCK = VK_FORMAT_BC6H_SFLOAT_BLOCK,
    e_BC7_UNORM_BLOCK = VK_FORMAT_BC7_UNORM_BLOCK,
    e_BC7_SRGB_BLOCK = VK_FORMAT_BC7_SRGB_BLOCK,
    e_ETC2_R8G8B8_UNORM_BLOCK = VK_FORMAT_ETC2_R8G8B8_UNORM_BLOCK,
    e_ETC2_R8G8B8_SRGB_BLOCK = VK_FORMAT_ETC2_R8G8B8_SRGB_BLOCK,
    e_ETC2_R8G8B8A1_UNORM_BLOCK = VK_FORMAT_ETC2_R8G8B8A1_UNORM_BLOCK,
    e_ETC2_R8G8B8A1_SRGB_BLOCK = VK_FORMAT_ETC2_R8G8B8A1_SRGB_BLOCK,
    e_ETC2_R8G8B8A8_UNORM_BLOCK = VK_FORMAT_ETC2_R8G8B8A8_UNORM_BLOCK,
    e_ETC2_R8G8B8A8_SRGB_BLOCK = VK_FORMAT_ETC2_R8G8B8A8_SRGB_BLOCK,
    e_EAC_R11_UNORM_BLOCK = VK_FORMAT_EAC_R11_UNORM_BLOCK,
    e_EAC_R11_SNORM_BLOCK = VK_FORMAT_EAC_R11_SNORM_BLOCK,
    e_EAC_R11G11_UNORM_BLOCK = VK_FORMAT_EAC_R11G11_UNORM_BLOCK,
    e_EAC_R11G11_SNORM_BLOCK = VK_FORMAT_EAC_R11G11_SNORM_BLOCK,
    e_ASTC_4x4_UNORM_BLOCK = VK_FORMAT_ASTC_4x4_UNORM_BLOCK,
    e_ASTC_4x4_SRGB_BLOCK = VK_FORMAT_ASTC_4x4_SRGB_BLOCK,
    e_ASTC_5x4_UNORM_BLOCK = VK_FORMAT_ASTC_5x4_UNORM_BLOCK,
    e_ASTC_5x4_SRGB_BLOCK = VK_FORMAT_ASTC_5x4_SRGB_BLOCK,
    e_ASTC_5x5_UNORM_BLOCK = VK_FORMAT_ASTC_5x5_UNORM_BLOCK,
    e_ASTC_5x5_SRGB_BLOCK = VK_FORMAT_ASTC_5x5_SRGB_BLOCK,
    e_ASTC_6x5_UNORM_BLOCK = VK_FORMAT_ASTC_6x5_UNORM_BLOCK,
    e_ASTC_6x5_SRGB_BLOCK = VK_FORMAT_ASTC_6x5_SRGB_BLOCK,
    e_ASTC_6x6_UNORM_BLOCK = VK_FORMAT_ASTC_6x6_UNORM_BLOCK,
    e_ASTC_6x6_SRGB_BLOCK = VK_FORMAT_ASTC_6x6_SRGB_BLOCK,
    e_ASTC_8x5_UNORM_BLOCK = VK_FORMAT_ASTC_8x5_UNORM_BLOCK,
    e_ASTC_8x5_SRGB_BLOCK = VK_FORMAT_ASTC_8x5_SRGB_BLOCK,
    e_ASTC_8x6_UNORM_BLOCK = VK_FORMAT_ASTC_8x6_UNORM_BLOCK,
    e_ASTC_8x6_SRGB_BLOCK = VK_FORMAT_ASTC_8x6_SRGB_BLOCK,
    e_ASTC_8x8_UNORM_BLOCK = VK_FORMAT_ASTC_8x8_UNORM_BLOCK,
    e_ASTC_8x8_SRGB_BLOCK = VK_FORMAT_ASTC_8x8_SRGB_BLOCK,
    e_ASTC_10x5_UNORM_BLOCK = VK_FORMAT_ASTC_10x5_UNORM_BLOCK,
    e_ASTC_10x5_SRGB_BLOCK = VK_FORMAT_ASTC_10x5_SRGB_BLOCK,
    e_ASTC_10x6_UNORM_BLOCK = VK_FORMAT_ASTC_10x6_UNORM_BLOCK,
    e_ASTC_10x6_SRGB_BLOCK = VK_FORMAT_ASTC_10x6_SRGB_BLOCK,
    e_ASTC_10x8_UNORM_BLOCK = VK_FORMAT_ASTC_10x8_UNORM_BLOCK,
    e_ASTC_10x8_SRGB_BLOCK = VK_FORMAT_ASTC_10x8_SRGB_BLOCK,
    e_ASTC_10x10_UNORM_BLOCK = VK_FORMAT_ASTC_10x10_UNORM_BLOCK,
    e_ASTC_10x10_SRGB_BLOCK = VK_FORMAT_ASTC_10x10_SRGB_BLOCK,
    e_ASTC_12x10_UNORM_BLOCK = VK_FORMAT_ASTC_12x10_UNORM_BLOCK,
    e_ASTC_12x10_SRGB_BLOCK = VK_FORMAT_ASTC_12x10_SRGB_BLOCK,
    e_ASTC_12x12_UNORM_BLOCK = VK_FORMAT_ASTC_12x12_UNORM_BLOCK,
    e_ASTC_12x12_SRGB_BLOCK = VK_FORMAT_ASTC_12x12_SRGB_BLOCK,
    e_G8B8G8R8_422_UNORM = VK_FORMAT_G8B8G8R8_422_UNORM,
    e_B8G8R8G8_422_UNORM = VK_FORMAT_B8G8R8G8_422_UNORM,
    e_G8_B8_R8_3PLANE_420_UNORM = VK_FORMAT_G8_B8_R8_3PLANE_420_UNORM,
    e_G8_B8R8_2PLANE_420_UNORM = VK_FORMAT_G8_B8R8_2PLANE_420_UNORM,
    e_G8_B8_R8_3PLANE_422_UNORM = VK_FORMAT_G8_B8_R8_3PLANE_422_UNORM,
    e_G8_B8R8_2PLANE_422_UNORM = VK_FORMAT_G8_B8R8_2PLANE_422_UNORM,
    e_G8_B8_R8_3PLANE_444_UNORM = VK_FORMAT_G8_B8_R8_3PLANE_444_UNORM,
    e_R10X6_UNORM_PACK16 = VK_FORMAT_R10X6_UNORM_PACK16,
    e_R10X6G10X6_UNORM_2PACK16 = VK_FORMAT_R10X6G10X6_UNORM_2PACK16,
    e_R10X6G10X6B10X6A10X6_UNORM_4PACK16 = VK_FORMAT_R10X6G10X6B10X6A10X6_UNORM_4PACK16,
    e_G10X6B10X6G10X6R10X6_422_UNORM_4PACK16 = VK_FORMAT_G10X6B10X6G10X6R10X6_422_UNORM_4PACK16,
    e_B10X6G10X6R10X6G10X6_422_UNORM_4PACK16 = VK_FORMAT_B10X6G10X6R10X6G10X6_422_UNORM_4PACK16,
    e_G10X6_B10X6_R10X6_3PLANE_420_UNORM_3PACK16 = VK_FORMAT_G10X6_B10X6_R10X6_3PLANE_420_UNORM_3PACK16,
    e_G10X6_B10X6R10X6_2PLANE_420_UNORM_3PACK16 = VK_FORMAT_G10X6_B10X6R10X6_2PLANE_420_UNORM_3PACK16,
    e_G10X6_B10X6_R10X6_3PLANE_422_UNORM_3PACK16 = VK_FORMAT_G10X6_B10X6_R10X6_3PLANE_422_UNORM_3PACK16,
    e_G10X6_B10X6R10X6_2PLANE_422_UNORM_3PACK16 = VK_FORMAT_G10X6_B10X6R10X6_2PLANE_422_UNORM_3PACK16,
    e_G10X6_B10X6_R10X6_3PLANE_444_UNORM_3PACK16 = VK_FORMAT_G10X6_B10X6_R10X6_3PLANE_444_UNORM_3PACK16,
    e_R12X4_UNORM_PACK16 = VK_FORMAT_R12X4_UNORM_PACK16,
    e_R12X4G12X4_UNORM_2PACK16 = VK_FORMAT_R12X4G12X4_UNORM_2PACK16,
    e_R12X4G12X4B12X4A12X4_UNORM_4PACK16 = VK_FORMAT_R12X4G12X4B12X4A12X4_UNORM_4PACK16,
    e_G12X4B12X4G12X4R12X4_422_UNORM_4PACK16 = VK_FORMAT_G12X4B12X4G12X4R12X4_422_UNORM_4PACK16,
    e_B12X4G12X4R12X4G12X4_422_UNORM_4PACK16 = VK_FORMAT_B12X4G12X4R12X4G12X4_422_UNORM_4PACK16,
    e_G12X4_B12X4_R12X4_3PLANE_420_UNORM_3PACK16 = VK_FORMAT_G12X4_B12X4_R12X4_3PLANE_420_UNORM_3PACK16,
    e_G12X4_B12X4R12X4_2PLANE_420_UNORM_3PACK16 = VK_FORMAT_G12X4_B12X4R12X4_2PLANE_420_UNORM_3PACK16,
    e_G12X4_B12X4_R12X4_3PLANE_422_UNORM_3PACK16 = VK_FORMAT_G12X4_B12X4_R12X4_3PLANE_422_UNORM_3PACK16,
    e_G12X4_B12X4R12X4_2PLANE_422_UNORM_3PACK16 = VK_FORMAT_G12X4_B12X4R12X4_2PLANE_422_UNORM_3PACK16,
    e_G12X4_B12X4_R12X4_3PLANE_444_UNORM_3PACK16 = VK_FORMAT_G12X4_B12X4_R12X4_3PLANE_444_UNORM_3PACK16,
    e_G16B16G16R16_422_UNORM = VK_FORMAT_G16B16G16R16_422_UNORM,
    e_B16G16R16G16_422_UNORM = VK_FORMAT_B16G16R16G16_422_UNORM,
    e_G16_B16_R16_3PLANE_420_UNORM = VK_FORMAT_G16_B16_R16_3PLANE_420_UNORM,
    e_G16_B16R16_2PLANE_420_UNORM = VK_FORMAT_G16_B16R16_2PLANE_420_UNORM,
    e_G16_B16_R16_3PLANE_422_UNORM = VK_FORMAT_G16_B16_R16_3PLANE_422_UNORM,
    e_G16_B16R16_2PLANE_422_UNORM = VK_FORMAT_G16_B16R16_2PLANE_422_UNORM,
    e_G16_B16_R16_3PLANE_444_UNORM = VK_FORMAT_G16_B16_R16_3PLANE_444_UNORM,
    e_PVRTC1_2BPP_UNORM_BLOCK_IMG = VK_FORMAT_PVRTC1_2BPP_UNORM_BLOCK_IMG,
    e_PVRTC1_4BPP_UNORM_BLOCK_IMG = VK_FORMAT_PVRTC1_4BPP_UNORM_BLOCK_IMG,
    e_PVRTC2_2BPP_UNORM_BLOCK_IMG = VK_FORMAT_PVRTC2_2BPP_UNORM_BLOCK_IMG,
    e_PVRTC2_4BPP_UNORM_BLOCK_IMG = VK_FORMAT_PVRTC2_4BPP_UNORM_BLOCK_IMG,
    e_PVRTC1_2BPP_SRGB_BLOCK_IMG = VK_FORMAT_PVRTC1_2BPP_SRGB_BLOCK_IMG,
    e_PVRTC1_4BPP_SRGB_BLOCK_IMG = VK_FORMAT_PVRTC1_4BPP_SRGB_BLOCK_IMG,
    e_PVRTC2_2BPP_SRGB_BLOCK_IMG = VK_FORMAT_PVRTC2_2BPP_SRGB_BLOCK_IMG,
    e_PVRTC2_4BPP_SRGB_BLOCK_IMG = VK_FORMAT_PVRTC2_4BPP_SRGB_BLOCK_IMG,
    e_G8B8G8R8_422_UNORM_KHR = VK_FORMAT_G8B8G8R8_422_UNORM_KHR,
    e_B8G8R8G8_422_UNORM_KHR = VK_FORMAT_B8G8R8G8_422_UNORM_KHR,
    e_G8_B8_R8_3PLANE_420_UNORM_KHR = VK_FORMAT_G8_B8_R8_3PLANE_420_UNORM_KHR,
    e_G8_B8R8_2PLANE_420_UNORM_KHR = VK_FORMAT_G8_B8R8_2PLANE_420_UNORM_KHR,
    e_G8_B8_R8_3PLANE_422_UNORM_KHR = VK_FORMAT_G8_B8_R8_3PLANE_422_UNORM_KHR,
    e_G8_B8R8_2PLANE_422_UNORM_KHR = VK_FORMAT_G8_B8R8_2PLANE_422_UNORM_KHR,
    e_G8_B8_R8_3PLANE_444_UNORM_KHR = VK_FORMAT_G8_B8_R8_3PLANE_444_UNORM_KHR,
    e_R10X6_UNORM_PACK16_KHR = VK_FORMAT_R10X6_UNORM_PACK16_KHR,
    e_R10X6G10X6_UNORM_2PACK16_KHR = VK_FORMAT_R10X6G10X6_UNORM_2PACK16_KHR,
    e_R10X6G10X6B10X6A10X6_UNORM_4PACK16_KHR = VK_FORMAT_R10X6G10X6B10X6A10X6_UNORM_4PACK16_KHR,
    e_G10X6B10X6G10X6R10X6_422_UNORM_4PACK16_KHR = VK_FORMAT_G10X6B10X6G10X6R10X6_422_UNORM_4PACK16_KHR,
    e_B10X6G10X6R10X6G10X6_422_UNORM_4PACK16_KHR = VK_FORMAT_B10X6G10X6R10X6G10X6_422_UNORM_4PACK16_KHR,
    e_G10X6_B10X6_R10X6_3PLANE_420_UNORM_3PACK16_KHR = VK_FORMAT_G10X6_B10X6_R10X6_3PLANE_420_UNORM_3PACK16_KHR,
    e_G10X6_B10X6R10X6_2PLANE_420_UNORM_3PACK16_KHR = VK_FORMAT_G10X6_B10X6R10X6_2PLANE_420_UNORM_3PACK16_KHR,
    e_G10X6_B10X6_R10X6_3PLANE_422_UNORM_3PACK16_KHR = VK_FORMAT_G10X6_B10X6_R10X6_3PLANE_422_UNORM_3PACK16_KHR,
    e_G10X6_B10X6R10X6_2PLANE_422_UNORM_3PACK16_KHR = VK_FORMAT_G10X6_B10X6R10X6_2PLANE_422_UNORM_3PACK16_KHR,
    e_G10X6_B10X6_R10X6_3PLANE_444_UNORM_3PACK16_KHR = VK_FORMAT_G10X6_B10X6_R10X6_3PLANE_444_UNORM_3PACK16_KHR,
    e_R12X4_UNORM_PACK16_KHR = VK_FORMAT_R12X4_UNORM_PACK16_KHR,
    e_R12X4G12X4_UNORM_2PACK16_KHR = VK_FORMAT_R12X4G12X4_UNORM_2PACK16_KHR,
    e_R12X4G12X4B12X4A12X4_UNORM_4PACK16_KHR = VK_FORMAT_R12X4G12X4B12X4A12X4_UNORM_4PACK16_KHR,
    e_G12X4B12X4G12X4R12X4_422_UNORM_4PACK16_KHR = VK_FORMAT_G12X4B12X4G12X4R12X4_422_UNORM_4PACK16_KHR,
    e_B12X4G12X4R12X4G12X4_422_UNORM_4PACK16_KHR = VK_FORMAT_B12X4G12X4R12X4G12X4_422_UNORM_4PACK16_KHR,
    e_G12X4_B12X4_R12X4_3PLANE_420_UNORM_3PACK16_KHR = VK_FORMAT_G12X4_B12X4_R12X4_3PLANE_420_UNORM_3PACK16_KHR,
    e_G12X4_B12X4R12X4_2PLANE_420_UNORM_3PACK16_KHR = VK_FORMAT_G12X4_B12X4R12X4_2PLANE_420_UNORM_3PACK16_KHR,
    e_G12X4_B12X4_R12X4_3PLANE_422_UNORM_3PACK16_KHR = VK_FORMAT_G12X4_B12X4_R12X4_3PLANE_422_UNORM_3PACK16_KHR,
    e_G12X4_B12X4R12X4_2PLANE_422_UNORM_3PACK16_KHR = VK_FORMAT_G12X4_B12X4R12X4_2PLANE_422_UNORM_3PACK16_KHR,
    e_G12X4_B12X4_R12X4_3PLANE_444_UNORM_3PACK16_KHR = VK_FORMAT_G12X4_B12X4_R12X4_3PLANE_444_UNORM_3PACK16_KHR,
    e_G16B16G16R16_422_UNORM_KHR = VK_FORMAT_G16B16G16R16_422_UNORM_KHR,
    e_B16G16R16G16_422_UNORM_KHR = VK_FORMAT_B16G16R16G16_422_UNORM_KHR,
    e_G16_B16_R16_3PLANE_420_UNORM_KHR = VK_FORMAT_G16_B16_R16_3PLANE_420_UNORM_KHR,
    e_G16_B16R16_2PLANE_420_UNORM_KHR = VK_FORMAT_G16_B16R16_2PLANE_420_UNORM_KHR,
    e_G16_B16_R16_3PLANE_422_UNORM_KHR = VK_FORMAT_G16_B16_R16_3PLANE_422_UNORM_KHR,
    e_G16_B16R16_2PLANE_422_UNORM_KHR = VK_FORMAT_G16_B16R16_2PLANE_422_UNORM_KHR,
    e_G16_B16_R16_3PLANE_444_UNORM_KHR = VK_FORMAT_G16_B16_R16_3PLANE_444_UNORM_KHR,
    e_BEGIN_RANGE = VK_FORMAT_BEGIN_RANGE,
    e_END_RANGE = VK_FORMAT_END_RANGE,
    e_RANGE_SIZE = VK_FORMAT_RANGE_SIZE,
    e_MAX_ENUM = 0x7FFFFFFF

};
DEFINE_ENUM_BITWISE_OPERATORS(Format)
inline std::string to_string(Format value)
{
    switch(value)
    {
    case Format::e_UNDEFINED: return "VK_FORMAT_UNDEFINED";
    case Format::e_R4G4_UNORM_PACK8: return "VK_FORMAT_R4G4_UNORM_PACK8";
    case Format::e_R4G4B4A4_UNORM_PACK16: return "VK_FORMAT_R4G4B4A4_UNORM_PACK16";
    case Format::e_B4G4R4A4_UNORM_PACK16: return "VK_FORMAT_B4G4R4A4_UNORM_PACK16";
    case Format::e_R5G6B5_UNORM_PACK16: return "VK_FORMAT_R5G6B5_UNORM_PACK16";
    case Format::e_B5G6R5_UNORM_PACK16: return "VK_FORMAT_B5G6R5_UNORM_PACK16";
    case Format::e_R5G5B5A1_UNORM_PACK16: return "VK_FORMAT_R5G5B5A1_UNORM_PACK16";
    case Format::e_B5G5R5A1_UNORM_PACK16: return "VK_FORMAT_B5G5R5A1_UNORM_PACK16";
    case Format::e_A1R5G5B5_UNORM_PACK16: return "VK_FORMAT_A1R5G5B5_UNORM_PACK16";
    case Format::e_R8_UNORM: return "VK_FORMAT_R8_UNORM";
    case Format::e_R8_SNORM: return "VK_FORMAT_R8_SNORM";
    case Format::e_R8_USCALED: return "VK_FORMAT_R8_USCALED";
    case Format::e_R8_SSCALED: return "VK_FORMAT_R8_SSCALED";
    case Format::e_R8_UINT: return "VK_FORMAT_R8_UINT";
    case Format::e_R8_SINT: return "VK_FORMAT_R8_SINT";
    case Format::e_R8_SRGB: return "VK_FORMAT_R8_SRGB";
    case Format::e_R8G8_UNORM: return "VK_FORMAT_R8G8_UNORM";
    case Format::e_R8G8_SNORM: return "VK_FORMAT_R8G8_SNORM";
    case Format::e_R8G8_USCALED: return "VK_FORMAT_R8G8_USCALED";
    case Format::e_R8G8_SSCALED: return "VK_FORMAT_R8G8_SSCALED";
    case Format::e_R8G8_UINT: return "VK_FORMAT_R8G8_UINT";
    case Format::e_R8G8_SINT: return "VK_FORMAT_R8G8_SINT";
    case Format::e_R8G8_SRGB: return "VK_FORMAT_R8G8_SRGB";
    case Format::e_R8G8B8_UNORM: return "VK_FORMAT_R8G8B8_UNORM";
    case Format::e_R8G8B8_SNORM: return "VK_FORMAT_R8G8B8_SNORM";
    case Format::e_R8G8B8_USCALED: return "VK_FORMAT_R8G8B8_USCALED";
    case Format::e_R8G8B8_SSCALED: return "VK_FORMAT_R8G8B8_SSCALED";
    case Format::e_R8G8B8_UINT: return "VK_FORMAT_R8G8B8_UINT";
    case Format::e_R8G8B8_SINT: return "VK_FORMAT_R8G8B8_SINT";
    case Format::e_R8G8B8_SRGB: return "VK_FORMAT_R8G8B8_SRGB";
    case Format::e_B8G8R8_UNORM: return "VK_FORMAT_B8G8R8_UNORM";
    case Format::e_B8G8R8_SNORM: return "VK_FORMAT_B8G8R8_SNORM";
    case Format::e_B8G8R8_USCALED: return "VK_FORMAT_B8G8R8_USCALED";
    case Format::e_B8G8R8_SSCALED: return "VK_FORMAT_B8G8R8_SSCALED";
    case Format::e_B8G8R8_UINT: return "VK_FORMAT_B8G8R8_UINT";
    case Format::e_B8G8R8_SINT: return "VK_FORMAT_B8G8R8_SINT";
    case Format::e_B8G8R8_SRGB: return "VK_FORMAT_B8G8R8_SRGB";
    case Format::e_R8G8B8A8_UNORM: return "VK_FORMAT_R8G8B8A8_UNORM";
    case Format::e_R8G8B8A8_SNORM: return "VK_FORMAT_R8G8B8A8_SNORM";
    case Format::e_R8G8B8A8_USCALED: return "VK_FORMAT_R8G8B8A8_USCALED";
    case Format::e_R8G8B8A8_SSCALED: return "VK_FORMAT_R8G8B8A8_SSCALED";
    case Format::e_R8G8B8A8_UINT: return "VK_FORMAT_R8G8B8A8_UINT";
    case Format::e_R8G8B8A8_SINT: return "VK_FORMAT_R8G8B8A8_SINT";
    case Format::e_R8G8B8A8_SRGB: return "VK_FORMAT_R8G8B8A8_SRGB";
    case Format::e_B8G8R8A8_UNORM: return "VK_FORMAT_B8G8R8A8_UNORM";
    case Format::e_B8G8R8A8_SNORM: return "VK_FORMAT_B8G8R8A8_SNORM";
    case Format::e_B8G8R8A8_USCALED: return "VK_FORMAT_B8G8R8A8_USCALED";
    case Format::e_B8G8R8A8_SSCALED: return "VK_FORMAT_B8G8R8A8_SSCALED";
    case Format::e_B8G8R8A8_UINT: return "VK_FORMAT_B8G8R8A8_UINT";
    case Format::e_B8G8R8A8_SINT: return "VK_FORMAT_B8G8R8A8_SINT";
    case Format::e_B8G8R8A8_SRGB: return "VK_FORMAT_B8G8R8A8_SRGB";
    case Format::e_A8B8G8R8_UNORM_PACK32: return "VK_FORMAT_A8B8G8R8_UNORM_PACK32";
    case Format::e_A8B8G8R8_SNORM_PACK32: return "VK_FORMAT_A8B8G8R8_SNORM_PACK32";
    case Format::e_A8B8G8R8_USCALED_PACK32: return "VK_FORMAT_A8B8G8R8_USCALED_PACK32";
    case Format::e_A8B8G8R8_SSCALED_PACK32: return "VK_FORMAT_A8B8G8R8_SSCALED_PACK32";
    case Format::e_A8B8G8R8_UINT_PACK32: return "VK_FORMAT_A8B8G8R8_UINT_PACK32";
    case Format::e_A8B8G8R8_SINT_PACK32: return "VK_FORMAT_A8B8G8R8_SINT_PACK32";
    case Format::e_A8B8G8R8_SRGB_PACK32: return "VK_FORMAT_A8B8G8R8_SRGB_PACK32";
    case Format::e_A2R10G10B10_UNORM_PACK32: return "VK_FORMAT_A2R10G10B10_UNORM_PACK32";
    case Format::e_A2R10G10B10_SNORM_PACK32: return "VK_FORMAT_A2R10G10B10_SNORM_PACK32";
    case Format::e_A2R10G10B10_USCALED_PACK32: return "VK_FORMAT_A2R10G10B10_USCALED_PACK32";
    case Format::e_A2R10G10B10_SSCALED_PACK32: return "VK_FORMAT_A2R10G10B10_SSCALED_PACK32";
    case Format::e_A2R10G10B10_UINT_PACK32: return "VK_FORMAT_A2R10G10B10_UINT_PACK32";
    case Format::e_A2R10G10B10_SINT_PACK32: return "VK_FORMAT_A2R10G10B10_SINT_PACK32";
    case Format::e_A2B10G10R10_UNORM_PACK32: return "VK_FORMAT_A2B10G10R10_UNORM_PACK32";
    case Format::e_A2B10G10R10_SNORM_PACK32: return "VK_FORMAT_A2B10G10R10_SNORM_PACK32";
    case Format::e_A2B10G10R10_USCALED_PACK32: return "VK_FORMAT_A2B10G10R10_USCALED_PACK32";
    case Format::e_A2B10G10R10_SSCALED_PACK32: return "VK_FORMAT_A2B10G10R10_SSCALED_PACK32";
    case Format::e_A2B10G10R10_UINT_PACK32: return "VK_FORMAT_A2B10G10R10_UINT_PACK32";
    case Format::e_A2B10G10R10_SINT_PACK32: return "VK_FORMAT_A2B10G10R10_SINT_PACK32";
    case Format::e_R16_UNORM: return "VK_FORMAT_R16_UNORM";
    case Format::e_R16_SNORM: return "VK_FORMAT_R16_SNORM";
    case Format::e_R16_USCALED: return "VK_FORMAT_R16_USCALED";
    case Format::e_R16_SSCALED: return "VK_FORMAT_R16_SSCALED";
    case Format::e_R16_UINT: return "VK_FORMAT_R16_UINT";
    case Format::e_R16_SINT: return "VK_FORMAT_R16_SINT";
    case Format::e_R16_SFLOAT: return "VK_FORMAT_R16_SFLOAT";
    case Format::e_R16G16_UNORM: return "VK_FORMAT_R16G16_UNORM";
    case Format::e_R16G16_SNORM: return "VK_FORMAT_R16G16_SNORM";
    case Format::e_R16G16_USCALED: return "VK_FORMAT_R16G16_USCALED";
    case Format::e_R16G16_SSCALED: return "VK_FORMAT_R16G16_SSCALED";
    case Format::e_R16G16_UINT: return "VK_FORMAT_R16G16_UINT";
    case Format::e_R16G16_SINT: return "VK_FORMAT_R16G16_SINT";
    case Format::e_R16G16_SFLOAT: return "VK_FORMAT_R16G16_SFLOAT";
    case Format::e_R16G16B16_UNORM: return "VK_FORMAT_R16G16B16_UNORM";
    case Format::e_R16G16B16_SNORM: return "VK_FORMAT_R16G16B16_SNORM";
    case Format::e_R16G16B16_USCALED: return "VK_FORMAT_R16G16B16_USCALED";
    case Format::e_R16G16B16_SSCALED: return "VK_FORMAT_R16G16B16_SSCALED";
    case Format::e_R16G16B16_UINT: return "VK_FORMAT_R16G16B16_UINT";
    case Format::e_R16G16B16_SINT: return "VK_FORMAT_R16G16B16_SINT";
    case Format::e_R16G16B16_SFLOAT: return "VK_FORMAT_R16G16B16_SFLOAT";
    case Format::e_R16G16B16A16_UNORM: return "VK_FORMAT_R16G16B16A16_UNORM";
    case Format::e_R16G16B16A16_SNORM: return "VK_FORMAT_R16G16B16A16_SNORM";
    case Format::e_R16G16B16A16_USCALED: return "VK_FORMAT_R16G16B16A16_USCALED";
    case Format::e_R16G16B16A16_SSCALED: return "VK_FORMAT_R16G16B16A16_SSCALED";
    case Format::e_R16G16B16A16_UINT: return "VK_FORMAT_R16G16B16A16_UINT";
    case Format::e_R16G16B16A16_SINT: return "VK_FORMAT_R16G16B16A16_SINT";
    case Format::e_R16G16B16A16_SFLOAT: return "VK_FORMAT_R16G16B16A16_SFLOAT";
    case Format::e_R32_UINT: return "VK_FORMAT_R32_UINT";
    case Format::e_R32_SINT: return "VK_FORMAT_R32_SINT";
    case Format::e_R32_SFLOAT: return "VK_FORMAT_R32_SFLOAT";
    case Format::e_R32G32_UINT: return "VK_FORMAT_R32G32_UINT";
    case Format::e_R32G32_SINT: return "VK_FORMAT_R32G32_SINT";
    case Format::e_R32G32_SFLOAT: return "VK_FORMAT_R32G32_SFLOAT";
    case Format::e_R32G32B32_UINT: return "VK_FORMAT_R32G32B32_UINT";
    case Format::e_R32G32B32_SINT: return "VK_FORMAT_R32G32B32_SINT";
    case Format::e_R32G32B32_SFLOAT: return "VK_FORMAT_R32G32B32_SFLOAT";
    case Format::e_R32G32B32A32_UINT: return "VK_FORMAT_R32G32B32A32_UINT";
    case Format::e_R32G32B32A32_SINT: return "VK_FORMAT_R32G32B32A32_SINT";
    case Format::e_R32G32B32A32_SFLOAT: return "VK_FORMAT_R32G32B32A32_SFLOAT";
    case Format::e_R64_UINT: return "VK_FORMAT_R64_UINT";
    case Format::e_R64_SINT: return "VK_FORMAT_R64_SINT";
    case Format::e_R64_SFLOAT: return "VK_FORMAT_R64_SFLOAT";
    case Format::e_R64G64_UINT: return "VK_FORMAT_R64G64_UINT";
    case Format::e_R64G64_SINT: return "VK_FORMAT_R64G64_SINT";
    case Format::e_R64G64_SFLOAT: return "VK_FORMAT_R64G64_SFLOAT";
    case Format::e_R64G64B64_UINT: return "VK_FORMAT_R64G64B64_UINT";
    case Format::e_R64G64B64_SINT: return "VK_FORMAT_R64G64B64_SINT";
    case Format::e_R64G64B64_SFLOAT: return "VK_FORMAT_R64G64B64_SFLOAT";
    case Format::e_R64G64B64A64_UINT: return "VK_FORMAT_R64G64B64A64_UINT";
    case Format::e_R64G64B64A64_SINT: return "VK_FORMAT_R64G64B64A64_SINT";
    case Format::e_R64G64B64A64_SFLOAT: return "VK_FORMAT_R64G64B64A64_SFLOAT";
    case Format::e_B10G11R11_UFLOAT_PACK32: return "VK_FORMAT_B10G11R11_UFLOAT_PACK32";
    case Format::e_E5B9G9R9_UFLOAT_PACK32: return "VK_FORMAT_E5B9G9R9_UFLOAT_PACK32";
    case Format::e_D16_UNORM: return "VK_FORMAT_D16_UNORM";
    case Format::e_X8_D24_UNORM_PACK32: return "VK_FORMAT_X8_D24_UNORM_PACK32";
    case Format::e_D32_SFLOAT: return "VK_FORMAT_D32_SFLOAT";
    case Format::e_S8_UINT: return "VK_FORMAT_S8_UINT";
    case Format::e_D16_UNORM_S8_UINT: return "VK_FORMAT_D16_UNORM_S8_UINT";
    case Format::e_D24_UNORM_S8_UINT: return "VK_FORMAT_D24_UNORM_S8_UINT";
    case Format::e_D32_SFLOAT_S8_UINT: return "VK_FORMAT_D32_SFLOAT_S8_UINT";
    case Format::e_BC1_RGB_UNORM_BLOCK: return "VK_FORMAT_BC1_RGB_UNORM_BLOCK";
    case Format::e_BC1_RGB_SRGB_BLOCK: return "VK_FORMAT_BC1_RGB_SRGB_BLOCK";
    case Format::e_BC1_RGBA_UNORM_BLOCK: return "VK_FORMAT_BC1_RGBA_UNORM_BLOCK";
    case Format::e_BC1_RGBA_SRGB_BLOCK: return "VK_FORMAT_BC1_RGBA_SRGB_BLOCK";
    case Format::e_BC2_UNORM_BLOCK: return "VK_FORMAT_BC2_UNORM_BLOCK";
    case Format::e_BC2_SRGB_BLOCK: return "VK_FORMAT_BC2_SRGB_BLOCK";
    case Format::e_BC3_UNORM_BLOCK: return "VK_FORMAT_BC3_UNORM_BLOCK";
    case Format::e_BC3_SRGB_BLOCK: return "VK_FORMAT_BC3_SRGB_BLOCK";
    case Format::e_BC4_UNORM_BLOCK: return "VK_FORMAT_BC4_UNORM_BLOCK";
    case Format::e_BC4_SNORM_BLOCK: return "VK_FORMAT_BC4_SNORM_BLOCK";
    case Format::e_BC5_UNORM_BLOCK: return "VK_FORMAT_BC5_UNORM_BLOCK";
    case Format::e_BC5_SNORM_BLOCK: return "VK_FORMAT_BC5_SNORM_BLOCK";
    case Format::e_BC6H_UFLOAT_BLOCK: return "VK_FORMAT_BC6H_UFLOAT_BLOCK";
    case Format::e_BC6H_SFLOAT_BLOCK: return "VK_FORMAT_BC6H_SFLOAT_BLOCK";
    case Format::e_BC7_UNORM_BLOCK: return "VK_FORMAT_BC7_UNORM_BLOCK";
    case Format::e_BC7_SRGB_BLOCK: return "VK_FORMAT_BC7_SRGB_BLOCK";
    case Format::e_ETC2_R8G8B8_UNORM_BLOCK: return "VK_FORMAT_ETC2_R8G8B8_UNORM_BLOCK";
    case Format::e_ETC2_R8G8B8_SRGB_BLOCK: return "VK_FORMAT_ETC2_R8G8B8_SRGB_BLOCK";
    case Format::e_ETC2_R8G8B8A1_UNORM_BLOCK: return "VK_FORMAT_ETC2_R8G8B8A1_UNORM_BLOCK";
    case Format::e_ETC2_R8G8B8A1_SRGB_BLOCK: return "VK_FORMAT_ETC2_R8G8B8A1_SRGB_BLOCK";
    case Format::e_ETC2_R8G8B8A8_UNORM_BLOCK: return "VK_FORMAT_ETC2_R8G8B8A8_UNORM_BLOCK";
    case Format::e_ETC2_R8G8B8A8_SRGB_BLOCK: return "VK_FORMAT_ETC2_R8G8B8A8_SRGB_BLOCK";
    case Format::e_EAC_R11_UNORM_BLOCK: return "VK_FORMAT_EAC_R11_UNORM_BLOCK";
    case Format::e_EAC_R11_SNORM_BLOCK: return "VK_FORMAT_EAC_R11_SNORM_BLOCK";
    case Format::e_EAC_R11G11_UNORM_BLOCK: return "VK_FORMAT_EAC_R11G11_UNORM_BLOCK";
    case Format::e_EAC_R11G11_SNORM_BLOCK: return "VK_FORMAT_EAC_R11G11_SNORM_BLOCK";
    case Format::e_ASTC_4x4_UNORM_BLOCK: return "VK_FORMAT_ASTC_4x4_UNORM_BLOCK";
    case Format::e_ASTC_4x4_SRGB_BLOCK: return "VK_FORMAT_ASTC_4x4_SRGB_BLOCK";
    case Format::e_ASTC_5x4_UNORM_BLOCK: return "VK_FORMAT_ASTC_5x4_UNORM_BLOCK";
    case Format::e_ASTC_5x4_SRGB_BLOCK: return "VK_FORMAT_ASTC_5x4_SRGB_BLOCK";
    case Format::e_ASTC_5x5_UNORM_BLOCK: return "VK_FORMAT_ASTC_5x5_UNORM_BLOCK";
    case Format::e_ASTC_5x5_SRGB_BLOCK: return "VK_FORMAT_ASTC_5x5_SRGB_BLOCK";
    case Format::e_ASTC_6x5_UNORM_BLOCK: return "VK_FORMAT_ASTC_6x5_UNORM_BLOCK";
    case Format::e_ASTC_6x5_SRGB_BLOCK: return "VK_FORMAT_ASTC_6x5_SRGB_BLOCK";
    case Format::e_ASTC_6x6_UNORM_BLOCK: return "VK_FORMAT_ASTC_6x6_UNORM_BLOCK";
    case Format::e_ASTC_6x6_SRGB_BLOCK: return "VK_FORMAT_ASTC_6x6_SRGB_BLOCK";
    case Format::e_ASTC_8x5_UNORM_BLOCK: return "VK_FORMAT_ASTC_8x5_UNORM_BLOCK";
    case Format::e_ASTC_8x5_SRGB_BLOCK: return "VK_FORMAT_ASTC_8x5_SRGB_BLOCK";
    case Format::e_ASTC_8x6_UNORM_BLOCK: return "VK_FORMAT_ASTC_8x6_UNORM_BLOCK";
    case Format::e_ASTC_8x6_SRGB_BLOCK: return "VK_FORMAT_ASTC_8x6_SRGB_BLOCK";
    case Format::e_ASTC_8x8_UNORM_BLOCK: return "VK_FORMAT_ASTC_8x8_UNORM_BLOCK";
    case Format::e_ASTC_8x8_SRGB_BLOCK: return "VK_FORMAT_ASTC_8x8_SRGB_BLOCK";
    case Format::e_ASTC_10x5_UNORM_BLOCK: return "VK_FORMAT_ASTC_10x5_UNORM_BLOCK";
    case Format::e_ASTC_10x5_SRGB_BLOCK: return "VK_FORMAT_ASTC_10x5_SRGB_BLOCK";
    case Format::e_ASTC_10x6_UNORM_BLOCK: return "VK_FORMAT_ASTC_10x6_UNORM_BLOCK";
    case Format::e_ASTC_10x6_SRGB_BLOCK: return "VK_FORMAT_ASTC_10x6_SRGB_BLOCK";
    case Format::e_ASTC_10x8_UNORM_BLOCK: return "VK_FORMAT_ASTC_10x8_UNORM_BLOCK";
    case Format::e_ASTC_10x8_SRGB_BLOCK: return "VK_FORMAT_ASTC_10x8_SRGB_BLOCK";
    case Format::e_ASTC_10x10_UNORM_BLOCK: return "VK_FORMAT_ASTC_10x10_UNORM_BLOCK";
    case Format::e_ASTC_10x10_SRGB_BLOCK: return "VK_FORMAT_ASTC_10x10_SRGB_BLOCK";
    case Format::e_ASTC_12x10_UNORM_BLOCK: return "VK_FORMAT_ASTC_12x10_UNORM_BLOCK";
    case Format::e_ASTC_12x10_SRGB_BLOCK: return "VK_FORMAT_ASTC_12x10_SRGB_BLOCK";
    case Format::e_ASTC_12x12_UNORM_BLOCK: return "VK_FORMAT_ASTC_12x12_UNORM_BLOCK";
    case Format::e_ASTC_12x12_SRGB_BLOCK: return "VK_FORMAT_ASTC_12x12_SRGB_BLOCK";
    case Format::e_G8B8G8R8_422_UNORM: return "VK_FORMAT_G8B8G8R8_422_UNORM";
    case Format::e_B8G8R8G8_422_UNORM: return "VK_FORMAT_B8G8R8G8_422_UNORM";
    case Format::e_G8_B8_R8_3PLANE_420_UNORM: return "VK_FORMAT_G8_B8_R8_3PLANE_420_UNORM";
    case Format::e_G8_B8R8_2PLANE_420_UNORM: return "VK_FORMAT_G8_B8R8_2PLANE_420_UNORM";
    case Format::e_G8_B8_R8_3PLANE_422_UNORM: return "VK_FORMAT_G8_B8_R8_3PLANE_422_UNORM";
    case Format::e_G8_B8R8_2PLANE_422_UNORM: return "VK_FORMAT_G8_B8R8_2PLANE_422_UNORM";
    case Format::e_G8_B8_R8_3PLANE_444_UNORM: return "VK_FORMAT_G8_B8_R8_3PLANE_444_UNORM";
    case Format::e_R10X6_UNORM_PACK16: return "VK_FORMAT_R10X6_UNORM_PACK16";
    case Format::e_R10X6G10X6_UNORM_2PACK16: return "VK_FORMAT_R10X6G10X6_UNORM_2PACK16";
    case Format::e_R10X6G10X6B10X6A10X6_UNORM_4PACK16: return "VK_FORMAT_R10X6G10X6B10X6A10X6_UNORM_4PACK16";
    case Format::e_G10X6B10X6G10X6R10X6_422_UNORM_4PACK16: return "VK_FORMAT_G10X6B10X6G10X6R10X6_422_UNORM_4PACK16";
    case Format::e_B10X6G10X6R10X6G10X6_422_UNORM_4PACK16: return "VK_FORMAT_B10X6G10X6R10X6G10X6_422_UNORM_4PACK16";
    case Format::e_G10X6_B10X6_R10X6_3PLANE_420_UNORM_3PACK16: return "VK_FORMAT_G10X6_B10X6_R10X6_3PLANE_420_UNORM_3PACK16";
    case Format::e_G10X6_B10X6R10X6_2PLANE_420_UNORM_3PACK16: return "VK_FORMAT_G10X6_B10X6R10X6_2PLANE_420_UNORM_3PACK16";
    case Format::e_G10X6_B10X6_R10X6_3PLANE_422_UNORM_3PACK16: return "VK_FORMAT_G10X6_B10X6_R10X6_3PLANE_422_UNORM_3PACK16";
    case Format::e_G10X6_B10X6R10X6_2PLANE_422_UNORM_3PACK16: return "VK_FORMAT_G10X6_B10X6R10X6_2PLANE_422_UNORM_3PACK16";
    case Format::e_G10X6_B10X6_R10X6_3PLANE_444_UNORM_3PACK16: return "VK_FORMAT_G10X6_B10X6_R10X6_3PLANE_444_UNORM_3PACK16";
    case Format::e_R12X4_UNORM_PACK16: return "VK_FORMAT_R12X4_UNORM_PACK16";
    case Format::e_R12X4G12X4_UNORM_2PACK16: return "VK_FORMAT_R12X4G12X4_UNORM_2PACK16";
    case Format::e_R12X4G12X4B12X4A12X4_UNORM_4PACK16: return "VK_FORMAT_R12X4G12X4B12X4A12X4_UNORM_4PACK16";
    case Format::e_G12X4B12X4G12X4R12X4_422_UNORM_4PACK16: return "VK_FORMAT_G12X4B12X4G12X4R12X4_422_UNORM_4PACK16";
    case Format::e_B12X4G12X4R12X4G12X4_422_UNORM_4PACK16: return "VK_FORMAT_B12X4G12X4R12X4G12X4_422_UNORM_4PACK16";
    case Format::e_G12X4_B12X4_R12X4_3PLANE_420_UNORM_3PACK16: return "VK_FORMAT_G12X4_B12X4_R12X4_3PLANE_420_UNORM_3PACK16";
    case Format::e_G12X4_B12X4R12X4_2PLANE_420_UNORM_3PACK16: return "VK_FORMAT_G12X4_B12X4R12X4_2PLANE_420_UNORM_3PACK16";
    case Format::e_G12X4_B12X4_R12X4_3PLANE_422_UNORM_3PACK16: return "VK_FORMAT_G12X4_B12X4_R12X4_3PLANE_422_UNORM_3PACK16";
    case Format::e_G12X4_B12X4R12X4_2PLANE_422_UNORM_3PACK16: return "VK_FORMAT_G12X4_B12X4R12X4_2PLANE_422_UNORM_3PACK16";
    case Format::e_G12X4_B12X4_R12X4_3PLANE_444_UNORM_3PACK16: return "VK_FORMAT_G12X4_B12X4_R12X4_3PLANE_444_UNORM_3PACK16";
    case Format::e_G16B16G16R16_422_UNORM: return "VK_FORMAT_G16B16G16R16_422_UNORM";
    case Format::e_B16G16R16G16_422_UNORM: return "VK_FORMAT_B16G16R16G16_422_UNORM";
    case Format::e_G16_B16_R16_3PLANE_420_UNORM: return "VK_FORMAT_G16_B16_R16_3PLANE_420_UNORM";
    case Format::e_G16_B16R16_2PLANE_420_UNORM: return "VK_FORMAT_G16_B16R16_2PLANE_420_UNORM";
    case Format::e_G16_B16_R16_3PLANE_422_UNORM: return "VK_FORMAT_G16_B16_R16_3PLANE_422_UNORM";
    case Format::e_G16_B16R16_2PLANE_422_UNORM: return "VK_FORMAT_G16_B16R16_2PLANE_422_UNORM";
    case Format::e_G16_B16_R16_3PLANE_444_UNORM: return "VK_FORMAT_G16_B16_R16_3PLANE_444_UNORM";
    case Format::e_PVRTC1_2BPP_UNORM_BLOCK_IMG: return "VK_FORMAT_PVRTC1_2BPP_UNORM_BLOCK_IMG";
    case Format::e_PVRTC1_4BPP_UNORM_BLOCK_IMG: return "VK_FORMAT_PVRTC1_4BPP_UNORM_BLOCK_IMG";
    case Format::e_PVRTC2_2BPP_UNORM_BLOCK_IMG: return "VK_FORMAT_PVRTC2_2BPP_UNORM_BLOCK_IMG";
    case Format::e_PVRTC2_4BPP_UNORM_BLOCK_IMG: return "VK_FORMAT_PVRTC2_4BPP_UNORM_BLOCK_IMG";
    case Format::e_PVRTC1_2BPP_SRGB_BLOCK_IMG: return "VK_FORMAT_PVRTC1_2BPP_SRGB_BLOCK_IMG";
    case Format::e_PVRTC1_4BPP_SRGB_BLOCK_IMG: return "VK_FORMAT_PVRTC1_4BPP_SRGB_BLOCK_IMG";
    case Format::e_PVRTC2_2BPP_SRGB_BLOCK_IMG: return "VK_FORMAT_PVRTC2_2BPP_SRGB_BLOCK_IMG";
    case Format::e_PVRTC2_4BPP_SRGB_BLOCK_IMG: return "VK_FORMAT_PVRTC2_4BPP_SRGB_BLOCK_IMG";
    default: return "invalid";
    }
}

enum class FormatFeatureFlags
{
    e_NONE = 0,
    e_SAMPLED_IMAGE_BIT = VK_FORMAT_FEATURE_SAMPLED_IMAGE_BIT,
    e_STORAGE_IMAGE_BIT = VK_FORMAT_FEATURE_STORAGE_IMAGE_BIT,
    e_STORAGE_IMAGE_ATOMIC_BIT = VK_FORMAT_FEATURE_STORAGE_IMAGE_ATOMIC_BIT,
    e_UNIFORM_TEXEL_BUFFER_BIT = VK_FORMAT_FEATURE_UNIFORM_TEXEL_BUFFER_BIT,
    e_STORAGE_TEXEL_BUFFER_BIT = VK_FORMAT_FEATURE_STORAGE_TEXEL_BUFFER_BIT,
    e_STORAGE_TEXEL_BUFFER_ATOMIC_BIT = VK_FORMAT_FEATURE_STORAGE_TEXEL_BUFFER_ATOMIC_BIT,
    e_VERTEX_BUFFER_BIT = VK_FORMAT_FEATURE_VERTEX_BUFFER_BIT,
    e_COLOR_ATTACHMENT_BIT = VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BIT,
    e_COLOR_ATTACHMENT_BLEND_BIT = VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BLEND_BIT,
    e_DEPTH_STENCIL_ATTACHMENT_BIT = VK_FORMAT_FEATURE_DEPTH_STENCIL_ATTACHMENT_BIT,
    e_BLIT_SRC_BIT = VK_FORMAT_FEATURE_BLIT_SRC_BIT,
    e_BLIT_DST_BIT = VK_FORMAT_FEATURE_BLIT_DST_BIT,
    e_SAMPLED_IMAGE_FILTER_LINEAR_BIT = VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_LINEAR_BIT,
    e_TRANSFER_SRC_BIT = VK_FORMAT_FEATURE_TRANSFER_SRC_BIT,
    e_TRANSFER_DST_BIT = VK_FORMAT_FEATURE_TRANSFER_DST_BIT,
    e_MIDPOINT_CHROMA_SAMPLES_BIT = VK_FORMAT_FEATURE_MIDPOINT_CHROMA_SAMPLES_BIT,
    e_SAMPLED_IMAGE_YCBCR_CONVERSION_LINEAR_FILTER_BIT = VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_LINEAR_FILTER_BIT,
    e_SAMPLED_IMAGE_YCBCR_CONVERSION_SEPARATE_RECONSTRUCTION_FILTER_BIT = VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_SEPARATE_RECONSTRUCTION_FILTER_BIT,
    e_SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_BIT = VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_BIT,
    e_SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_FORCEABLE_BIT = VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_FORCEABLE_BIT,
    e_DISJOINT_BIT = VK_FORMAT_FEATURE_DISJOINT_BIT,
    e_COSITED_CHROMA_SAMPLES_BIT = VK_FORMAT_FEATURE_COSITED_CHROMA_SAMPLES_BIT,
    e_SAMPLED_IMAGE_FILTER_CUBIC_BIT_IMG = VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_CUBIC_BIT_IMG,
    e_TRANSFER_SRC_BIT_KHR = VK_FORMAT_FEATURE_TRANSFER_SRC_BIT_KHR,
    e_TRANSFER_DST_BIT_KHR = VK_FORMAT_FEATURE_TRANSFER_DST_BIT_KHR,
    e_SAMPLED_IMAGE_FILTER_MINMAX_BIT_EXT = VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_MINMAX_BIT_EXT,
    e_MIDPOINT_CHROMA_SAMPLES_BIT_KHR = VK_FORMAT_FEATURE_MIDPOINT_CHROMA_SAMPLES_BIT_KHR,
    e_SAMPLED_IMAGE_YCBCR_CONVERSION_LINEAR_FILTER_BIT_KHR = VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_LINEAR_FILTER_BIT_KHR,
    e_SAMPLED_IMAGE_YCBCR_CONVERSION_SEPARATE_RECONSTRUCTION_FILTER_BIT_KHR = VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_SEPARATE_RECONSTRUCTION_FILTER_BIT_KHR,
    e_SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_BIT_KHR = VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_BIT_KHR,
    e_SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_FORCEABLE_BIT_KHR = VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_FORCEABLE_BIT_KHR,
    e_DISJOINT_BIT_KHR = VK_FORMAT_FEATURE_DISJOINT_BIT_KHR,
    e_COSITED_CHROMA_SAMPLES_BIT_KHR = VK_FORMAT_FEATURE_COSITED_CHROMA_SAMPLES_BIT_KHR,
    e_MAX_ENUM = 0x7FFFFFFF,
    e_ALL_BITS = e_SAMPLED_IMAGE_BIT | e_STORAGE_IMAGE_BIT | e_STORAGE_IMAGE_ATOMIC_BIT | e_UNIFORM_TEXEL_BUFFER_BIT | e_STORAGE_TEXEL_BUFFER_BIT | e_STORAGE_TEXEL_BUFFER_ATOMIC_BIT | e_VERTEX_BUFFER_BIT | e_COLOR_ATTACHMENT_BIT | e_COLOR_ATTACHMENT_BLEND_BIT | e_DEPTH_STENCIL_ATTACHMENT_BIT | e_BLIT_SRC_BIT | e_BLIT_DST_BIT | e_SAMPLED_IMAGE_FILTER_LINEAR_BIT | e_TRANSFER_SRC_BIT | e_TRANSFER_DST_BIT | e_MIDPOINT_CHROMA_SAMPLES_BIT | e_SAMPLED_IMAGE_YCBCR_CONVERSION_LINEAR_FILTER_BIT | e_SAMPLED_IMAGE_YCBCR_CONVERSION_SEPARATE_RECONSTRUCTION_FILTER_BIT | e_SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_BIT | e_SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_FORCEABLE_BIT | e_DISJOINT_BIT | e_COSITED_CHROMA_SAMPLES_BIT | e_SAMPLED_IMAGE_FILTER_CUBIC_BIT_IMG | e_TRANSFER_SRC_BIT_KHR | e_TRANSFER_DST_BIT_KHR | e_SAMPLED_IMAGE_FILTER_MINMAX_BIT_EXT | e_MIDPOINT_CHROMA_SAMPLES_BIT_KHR | e_SAMPLED_IMAGE_YCBCR_CONVERSION_LINEAR_FILTER_BIT_KHR | e_SAMPLED_IMAGE_YCBCR_CONVERSION_SEPARATE_RECONSTRUCTION_FILTER_BIT_KHR | e_SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_BIT_KHR | e_SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_FORCEABLE_BIT_KHR | e_DISJOINT_BIT_KHR | e_COSITED_CHROMA_SAMPLES_BIT_KHR
};
DEFINE_ENUM_BITWISE_OPERATORS(FormatFeatureFlags)
inline std::string to_string(FormatFeatureFlags value)
{
    std::string returnString = "";
    bool addedFlags = false;
    if(static_cast<uint32_t>(value & FormatFeatureFlags::e_SAMPLED_IMAGE_BIT) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_FORMAT_FEATURE_SAMPLED_IMAGE_BIT";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & FormatFeatureFlags::e_STORAGE_IMAGE_BIT) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_FORMAT_FEATURE_STORAGE_IMAGE_BIT";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & FormatFeatureFlags::e_STORAGE_IMAGE_ATOMIC_BIT) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_FORMAT_FEATURE_STORAGE_IMAGE_ATOMIC_BIT";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & FormatFeatureFlags::e_UNIFORM_TEXEL_BUFFER_BIT) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_FORMAT_FEATURE_UNIFORM_TEXEL_BUFFER_BIT";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & FormatFeatureFlags::e_STORAGE_TEXEL_BUFFER_BIT) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_FORMAT_FEATURE_STORAGE_TEXEL_BUFFER_BIT";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & FormatFeatureFlags::e_STORAGE_TEXEL_BUFFER_ATOMIC_BIT) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_FORMAT_FEATURE_STORAGE_TEXEL_BUFFER_ATOMIC_BIT";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & FormatFeatureFlags::e_VERTEX_BUFFER_BIT) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_FORMAT_FEATURE_VERTEX_BUFFER_BIT";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & FormatFeatureFlags::e_COLOR_ATTACHMENT_BIT) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BIT";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & FormatFeatureFlags::e_COLOR_ATTACHMENT_BLEND_BIT) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BLEND_BIT";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & FormatFeatureFlags::e_DEPTH_STENCIL_ATTACHMENT_BIT) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_FORMAT_FEATURE_DEPTH_STENCIL_ATTACHMENT_BIT";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & FormatFeatureFlags::e_BLIT_SRC_BIT) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_FORMAT_FEATURE_BLIT_SRC_BIT";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & FormatFeatureFlags::e_BLIT_DST_BIT) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_FORMAT_FEATURE_BLIT_DST_BIT";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & FormatFeatureFlags::e_SAMPLED_IMAGE_FILTER_LINEAR_BIT) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_LINEAR_BIT";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & FormatFeatureFlags::e_TRANSFER_SRC_BIT) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_FORMAT_FEATURE_TRANSFER_SRC_BIT";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & FormatFeatureFlags::e_TRANSFER_DST_BIT) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_FORMAT_FEATURE_TRANSFER_DST_BIT";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & FormatFeatureFlags::e_MIDPOINT_CHROMA_SAMPLES_BIT) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_FORMAT_FEATURE_MIDPOINT_CHROMA_SAMPLES_BIT";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & FormatFeatureFlags::e_SAMPLED_IMAGE_YCBCR_CONVERSION_LINEAR_FILTER_BIT) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_LINEAR_FILTER_BIT";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & FormatFeatureFlags::e_SAMPLED_IMAGE_YCBCR_CONVERSION_SEPARATE_RECONSTRUCTION_FILTER_BIT) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_SEPARATE_RECONSTRUCTION_FILTER_BIT";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & FormatFeatureFlags::e_SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_BIT) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_BIT";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & FormatFeatureFlags::e_SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_FORCEABLE_BIT) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_FORCEABLE_BIT";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & FormatFeatureFlags::e_DISJOINT_BIT) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_FORMAT_FEATURE_DISJOINT_BIT";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & FormatFeatureFlags::e_COSITED_CHROMA_SAMPLES_BIT) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_FORMAT_FEATURE_COSITED_CHROMA_SAMPLES_BIT";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & FormatFeatureFlags::e_SAMPLED_IMAGE_FILTER_CUBIC_BIT_IMG) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_CUBIC_BIT_IMG";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & FormatFeatureFlags::e_TRANSFER_SRC_BIT_KHR) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_FORMAT_FEATURE_TRANSFER_SRC_BIT_KHR";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & FormatFeatureFlags::e_TRANSFER_DST_BIT_KHR) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_FORMAT_FEATURE_TRANSFER_DST_BIT_KHR";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & FormatFeatureFlags::e_SAMPLED_IMAGE_FILTER_MINMAX_BIT_EXT) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_MINMAX_BIT_EXT";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & FormatFeatureFlags::e_MIDPOINT_CHROMA_SAMPLES_BIT_KHR) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_FORMAT_FEATURE_MIDPOINT_CHROMA_SAMPLES_BIT_KHR";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & FormatFeatureFlags::e_SAMPLED_IMAGE_YCBCR_CONVERSION_LINEAR_FILTER_BIT_KHR) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_LINEAR_FILTER_BIT_KHR";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & FormatFeatureFlags::e_SAMPLED_IMAGE_YCBCR_CONVERSION_SEPARATE_RECONSTRUCTION_FILTER_BIT_KHR) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_SEPARATE_RECONSTRUCTION_FILTER_BIT_KHR";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & FormatFeatureFlags::e_SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_BIT_KHR) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_BIT_KHR";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & FormatFeatureFlags::e_SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_FORCEABLE_BIT_KHR) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_FORCEABLE_BIT_KHR";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & FormatFeatureFlags::e_DISJOINT_BIT_KHR) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_FORMAT_FEATURE_DISJOINT_BIT_KHR";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & FormatFeatureFlags::e_COSITED_CHROMA_SAMPLES_BIT_KHR) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_FORMAT_FEATURE_COSITED_CHROMA_SAMPLES_BIT_KHR";
        addedFlags = true;
    }
    return returnString;
}

enum class ImageType
{
    e_1D = VK_IMAGE_TYPE_1D,
    e_2D = VK_IMAGE_TYPE_2D,
    e_3D = VK_IMAGE_TYPE_3D,
    e_BEGIN_RANGE = VK_IMAGE_TYPE_BEGIN_RANGE,
    e_END_RANGE = VK_IMAGE_TYPE_END_RANGE,
    e_RANGE_SIZE = VK_IMAGE_TYPE_RANGE_SIZE,
    e_MAX_ENUM = 0x7FFFFFFF

};
DEFINE_ENUM_BITWISE_OPERATORS(ImageType)
inline std::string to_string(ImageType value)
{
    switch(value)
    {
    case ImageType::e_1D: return "VK_IMAGE_TYPE_1D";
    case ImageType::e_2D: return "VK_IMAGE_TYPE_2D";
    case ImageType::e_3D: return "VK_IMAGE_TYPE_3D";
    default: return "invalid";
    }
}

enum class ImageTiling
{
    e_OPTIMAL = VK_IMAGE_TILING_OPTIMAL,
    e_LINEAR = VK_IMAGE_TILING_LINEAR,
    e_DRM_FORMAT_MODIFIER_EXT = VK_IMAGE_TILING_DRM_FORMAT_MODIFIER_EXT,
    e_BEGIN_RANGE = VK_IMAGE_TILING_BEGIN_RANGE,
    e_END_RANGE = VK_IMAGE_TILING_END_RANGE,
    e_RANGE_SIZE = VK_IMAGE_TILING_RANGE_SIZE,
    e_MAX_ENUM = 0x7FFFFFFF

};
DEFINE_ENUM_BITWISE_OPERATORS(ImageTiling)
inline std::string to_string(ImageTiling value)
{
    switch(value)
    {
    case ImageTiling::e_OPTIMAL: return "VK_IMAGE_TILING_OPTIMAL";
    case ImageTiling::e_LINEAR: return "VK_IMAGE_TILING_LINEAR";
    case ImageTiling::e_DRM_FORMAT_MODIFIER_EXT: return "VK_IMAGE_TILING_DRM_FORMAT_MODIFIER_EXT";
    default: return "invalid";
    }
}

enum class ImageUsageFlags
{
    e_NONE = 0,
    e_TRANSFER_SRC_BIT = VK_IMAGE_USAGE_TRANSFER_SRC_BIT,
    e_TRANSFER_DST_BIT = VK_IMAGE_USAGE_TRANSFER_DST_BIT,
    e_SAMPLED_BIT = VK_IMAGE_USAGE_SAMPLED_BIT,
    e_STORAGE_BIT = VK_IMAGE_USAGE_STORAGE_BIT,
    e_COLOR_ATTACHMENT_BIT = VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT,
    e_DEPTH_STENCIL_ATTACHMENT_BIT = VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT,
    e_TRANSIENT_ATTACHMENT_BIT = VK_IMAGE_USAGE_TRANSIENT_ATTACHMENT_BIT,
    e_INPUT_ATTACHMENT_BIT = VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT,
    e_SHADING_RATE_IMAGE_BIT_NV = VK_IMAGE_USAGE_SHADING_RATE_IMAGE_BIT_NV,
    e_MAX_ENUM = 0x7FFFFFFF,
    e_ALL_BITS = e_TRANSFER_SRC_BIT | e_TRANSFER_DST_BIT | e_SAMPLED_BIT | e_STORAGE_BIT | e_COLOR_ATTACHMENT_BIT | e_DEPTH_STENCIL_ATTACHMENT_BIT | e_TRANSIENT_ATTACHMENT_BIT | e_INPUT_ATTACHMENT_BIT | e_SHADING_RATE_IMAGE_BIT_NV
};
DEFINE_ENUM_BITWISE_OPERATORS(ImageUsageFlags)
inline std::string to_string(ImageUsageFlags value)
{
    std::string returnString = "";
    bool addedFlags = false;
    if(static_cast<uint32_t>(value & ImageUsageFlags::e_TRANSFER_SRC_BIT) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_IMAGE_USAGE_TRANSFER_SRC_BIT";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & ImageUsageFlags::e_TRANSFER_DST_BIT) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_IMAGE_USAGE_TRANSFER_DST_BIT";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & ImageUsageFlags::e_SAMPLED_BIT) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_IMAGE_USAGE_SAMPLED_BIT";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & ImageUsageFlags::e_STORAGE_BIT) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_IMAGE_USAGE_STORAGE_BIT";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & ImageUsageFlags::e_COLOR_ATTACHMENT_BIT) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & ImageUsageFlags::e_DEPTH_STENCIL_ATTACHMENT_BIT) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & ImageUsageFlags::e_TRANSIENT_ATTACHMENT_BIT) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_IMAGE_USAGE_TRANSIENT_ATTACHMENT_BIT";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & ImageUsageFlags::e_INPUT_ATTACHMENT_BIT) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & ImageUsageFlags::e_SHADING_RATE_IMAGE_BIT_NV) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_IMAGE_USAGE_SHADING_RATE_IMAGE_BIT_NV";
        addedFlags = true;
    }
    return returnString;
}

enum class ImageCreateFlags
{
    e_NONE = 0,
    e_SPARSE_BINDING_BIT = VK_IMAGE_CREATE_SPARSE_BINDING_BIT,
    e_SPARSE_RESIDENCY_BIT = VK_IMAGE_CREATE_SPARSE_RESIDENCY_BIT,
    e_SPARSE_ALIASED_BIT = VK_IMAGE_CREATE_SPARSE_ALIASED_BIT,
    e_MUTABLE_FORMAT_BIT = VK_IMAGE_CREATE_MUTABLE_FORMAT_BIT,
    e_CUBE_COMPATIBLE_BIT = VK_IMAGE_CREATE_CUBE_COMPATIBLE_BIT,
    e_ALIAS_BIT = VK_IMAGE_CREATE_ALIAS_BIT,
    e_SPLIT_INSTANCE_BIND_REGIONS_BIT = VK_IMAGE_CREATE_SPLIT_INSTANCE_BIND_REGIONS_BIT,
    e_2D_ARRAY_COMPATIBLE_BIT = VK_IMAGE_CREATE_2D_ARRAY_COMPATIBLE_BIT,
    e_BLOCK_TEXEL_VIEW_COMPATIBLE_BIT = VK_IMAGE_CREATE_BLOCK_TEXEL_VIEW_COMPATIBLE_BIT,
    e_EXTENDED_USAGE_BIT = VK_IMAGE_CREATE_EXTENDED_USAGE_BIT,
    e_PROTECTED_BIT = VK_IMAGE_CREATE_PROTECTED_BIT,
    e_DISJOINT_BIT = VK_IMAGE_CREATE_DISJOINT_BIT,
    e_CORNER_SAMPLED_BIT_NV = VK_IMAGE_CREATE_CORNER_SAMPLED_BIT_NV,
    e_SPLIT_INSTANCE_BIND_REGIONS_BIT_KHR = VK_IMAGE_CREATE_SPLIT_INSTANCE_BIND_REGIONS_BIT_KHR,
    e_2D_ARRAY_COMPATIBLE_BIT_KHR = VK_IMAGE_CREATE_2D_ARRAY_COMPATIBLE_BIT_KHR,
    e_BLOCK_TEXEL_VIEW_COMPATIBLE_BIT_KHR = VK_IMAGE_CREATE_BLOCK_TEXEL_VIEW_COMPATIBLE_BIT_KHR,
    e_EXTENDED_USAGE_BIT_KHR = VK_IMAGE_CREATE_EXTENDED_USAGE_BIT_KHR,
    e_SAMPLE_LOCATIONS_COMPATIBLE_DEPTH_BIT_EXT = VK_IMAGE_CREATE_SAMPLE_LOCATIONS_COMPATIBLE_DEPTH_BIT_EXT,
    e_DISJOINT_BIT_KHR = VK_IMAGE_CREATE_DISJOINT_BIT_KHR,
    e_ALIAS_BIT_KHR = VK_IMAGE_CREATE_ALIAS_BIT_KHR,
    e_MAX_ENUM = 0x7FFFFFFF,
    e_ALL_BITS = e_SPARSE_BINDING_BIT | e_SPARSE_RESIDENCY_BIT | e_SPARSE_ALIASED_BIT | e_MUTABLE_FORMAT_BIT | e_CUBE_COMPATIBLE_BIT | e_ALIAS_BIT | e_SPLIT_INSTANCE_BIND_REGIONS_BIT | e_2D_ARRAY_COMPATIBLE_BIT | e_BLOCK_TEXEL_VIEW_COMPATIBLE_BIT | e_EXTENDED_USAGE_BIT | e_PROTECTED_BIT | e_DISJOINT_BIT | e_CORNER_SAMPLED_BIT_NV | e_SPLIT_INSTANCE_BIND_REGIONS_BIT_KHR | e_2D_ARRAY_COMPATIBLE_BIT_KHR | e_BLOCK_TEXEL_VIEW_COMPATIBLE_BIT_KHR | e_EXTENDED_USAGE_BIT_KHR | e_SAMPLE_LOCATIONS_COMPATIBLE_DEPTH_BIT_EXT | e_DISJOINT_BIT_KHR | e_ALIAS_BIT_KHR
};
DEFINE_ENUM_BITWISE_OPERATORS(ImageCreateFlags)
inline std::string to_string(ImageCreateFlags value)
{
    std::string returnString = "";
    bool addedFlags = false;
    if(static_cast<uint32_t>(value & ImageCreateFlags::e_SPARSE_BINDING_BIT) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_IMAGE_CREATE_SPARSE_BINDING_BIT";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & ImageCreateFlags::e_SPARSE_RESIDENCY_BIT) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_IMAGE_CREATE_SPARSE_RESIDENCY_BIT";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & ImageCreateFlags::e_SPARSE_ALIASED_BIT) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_IMAGE_CREATE_SPARSE_ALIASED_BIT";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & ImageCreateFlags::e_MUTABLE_FORMAT_BIT) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_IMAGE_CREATE_MUTABLE_FORMAT_BIT";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & ImageCreateFlags::e_CUBE_COMPATIBLE_BIT) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_IMAGE_CREATE_CUBE_COMPATIBLE_BIT";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & ImageCreateFlags::e_ALIAS_BIT) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_IMAGE_CREATE_ALIAS_BIT";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & ImageCreateFlags::e_SPLIT_INSTANCE_BIND_REGIONS_BIT) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_IMAGE_CREATE_SPLIT_INSTANCE_BIND_REGIONS_BIT";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & ImageCreateFlags::e_2D_ARRAY_COMPATIBLE_BIT) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_IMAGE_CREATE_2D_ARRAY_COMPATIBLE_BIT";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & ImageCreateFlags::e_BLOCK_TEXEL_VIEW_COMPATIBLE_BIT) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_IMAGE_CREATE_BLOCK_TEXEL_VIEW_COMPATIBLE_BIT";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & ImageCreateFlags::e_EXTENDED_USAGE_BIT) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_IMAGE_CREATE_EXTENDED_USAGE_BIT";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & ImageCreateFlags::e_PROTECTED_BIT) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_IMAGE_CREATE_PROTECTED_BIT";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & ImageCreateFlags::e_DISJOINT_BIT) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_IMAGE_CREATE_DISJOINT_BIT";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & ImageCreateFlags::e_CORNER_SAMPLED_BIT_NV) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_IMAGE_CREATE_CORNER_SAMPLED_BIT_NV";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & ImageCreateFlags::e_SPLIT_INSTANCE_BIND_REGIONS_BIT_KHR) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_IMAGE_CREATE_SPLIT_INSTANCE_BIND_REGIONS_BIT_KHR";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & ImageCreateFlags::e_2D_ARRAY_COMPATIBLE_BIT_KHR) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_IMAGE_CREATE_2D_ARRAY_COMPATIBLE_BIT_KHR";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & ImageCreateFlags::e_BLOCK_TEXEL_VIEW_COMPATIBLE_BIT_KHR) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_IMAGE_CREATE_BLOCK_TEXEL_VIEW_COMPATIBLE_BIT_KHR";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & ImageCreateFlags::e_EXTENDED_USAGE_BIT_KHR) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_IMAGE_CREATE_EXTENDED_USAGE_BIT_KHR";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & ImageCreateFlags::e_SAMPLE_LOCATIONS_COMPATIBLE_DEPTH_BIT_EXT) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_IMAGE_CREATE_SAMPLE_LOCATIONS_COMPATIBLE_DEPTH_BIT_EXT";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & ImageCreateFlags::e_DISJOINT_BIT_KHR) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_IMAGE_CREATE_DISJOINT_BIT_KHR";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & ImageCreateFlags::e_ALIAS_BIT_KHR) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_IMAGE_CREATE_ALIAS_BIT_KHR";
        addedFlags = true;
    }
    return returnString;
}

enum class SampleCountFlags
{
    e_NONE = 0,
    e_1_BIT = VK_SAMPLE_COUNT_1_BIT,
    e_2_BIT = VK_SAMPLE_COUNT_2_BIT,
    e_4_BIT = VK_SAMPLE_COUNT_4_BIT,
    e_8_BIT = VK_SAMPLE_COUNT_8_BIT,
    e_16_BIT = VK_SAMPLE_COUNT_16_BIT,
    e_32_BIT = VK_SAMPLE_COUNT_32_BIT,
    e_64_BIT = VK_SAMPLE_COUNT_64_BIT,
    e_MAX_ENUM = 0x7FFFFFFF,
    e_ALL_BITS = e_1_BIT | e_2_BIT | e_4_BIT | e_8_BIT | e_16_BIT | e_32_BIT | e_64_BIT
};
DEFINE_ENUM_BITWISE_OPERATORS(SampleCountFlags)
inline std::string to_string(SampleCountFlags value)
{
    std::string returnString = "";
    bool addedFlags = false;
    if(static_cast<uint32_t>(value & SampleCountFlags::e_1_BIT) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_SAMPLE_COUNT_1_BIT";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & SampleCountFlags::e_2_BIT) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_SAMPLE_COUNT_2_BIT";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & SampleCountFlags::e_4_BIT) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_SAMPLE_COUNT_4_BIT";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & SampleCountFlags::e_8_BIT) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_SAMPLE_COUNT_8_BIT";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & SampleCountFlags::e_16_BIT) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_SAMPLE_COUNT_16_BIT";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & SampleCountFlags::e_32_BIT) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_SAMPLE_COUNT_32_BIT";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & SampleCountFlags::e_64_BIT) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_SAMPLE_COUNT_64_BIT";
        addedFlags = true;
    }
    return returnString;
}

enum class PhysicalDeviceType
{
    e_OTHER = VK_PHYSICAL_DEVICE_TYPE_OTHER,
    e_INTEGRATED_GPU = VK_PHYSICAL_DEVICE_TYPE_INTEGRATED_GPU,
    e_DISCRETE_GPU = VK_PHYSICAL_DEVICE_TYPE_DISCRETE_GPU,
    e_VIRTUAL_GPU = VK_PHYSICAL_DEVICE_TYPE_VIRTUAL_GPU,
    e_CPU = VK_PHYSICAL_DEVICE_TYPE_CPU,
    e_BEGIN_RANGE = VK_PHYSICAL_DEVICE_TYPE_BEGIN_RANGE,
    e_END_RANGE = VK_PHYSICAL_DEVICE_TYPE_END_RANGE,
    e_RANGE_SIZE = VK_PHYSICAL_DEVICE_TYPE_RANGE_SIZE,
    e_MAX_ENUM = 0x7FFFFFFF

};
DEFINE_ENUM_BITWISE_OPERATORS(PhysicalDeviceType)
inline std::string to_string(PhysicalDeviceType value)
{
    switch(value)
    {
    case PhysicalDeviceType::e_OTHER: return "VK_PHYSICAL_DEVICE_TYPE_OTHER";
    case PhysicalDeviceType::e_INTEGRATED_GPU: return "VK_PHYSICAL_DEVICE_TYPE_INTEGRATED_GPU";
    case PhysicalDeviceType::e_DISCRETE_GPU: return "VK_PHYSICAL_DEVICE_TYPE_DISCRETE_GPU";
    case PhysicalDeviceType::e_VIRTUAL_GPU: return "VK_PHYSICAL_DEVICE_TYPE_VIRTUAL_GPU";
    case PhysicalDeviceType::e_CPU: return "VK_PHYSICAL_DEVICE_TYPE_CPU";
    default: return "invalid";
    }
}

enum class QueueFlags
{
    e_NONE = 0,
    e_GRAPHICS_BIT = VK_QUEUE_GRAPHICS_BIT,
    e_COMPUTE_BIT = VK_QUEUE_COMPUTE_BIT,
    e_TRANSFER_BIT = VK_QUEUE_TRANSFER_BIT,
    e_SPARSE_BINDING_BIT = VK_QUEUE_SPARSE_BINDING_BIT,
    e_PROTECTED_BIT = VK_QUEUE_PROTECTED_BIT,
    e_MAX_ENUM = 0x7FFFFFFF,
    e_ALL_BITS = e_GRAPHICS_BIT | e_COMPUTE_BIT | e_TRANSFER_BIT | e_SPARSE_BINDING_BIT | e_PROTECTED_BIT
};
DEFINE_ENUM_BITWISE_OPERATORS(QueueFlags)
inline std::string to_string(QueueFlags value)
{
    std::string returnString = "";
    bool addedFlags = false;
    if(static_cast<uint32_t>(value & QueueFlags::e_GRAPHICS_BIT) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_QUEUE_GRAPHICS_BIT";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & QueueFlags::e_COMPUTE_BIT) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_QUEUE_COMPUTE_BIT";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & QueueFlags::e_TRANSFER_BIT) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_QUEUE_TRANSFER_BIT";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & QueueFlags::e_SPARSE_BINDING_BIT) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_QUEUE_SPARSE_BINDING_BIT";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & QueueFlags::e_PROTECTED_BIT) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_QUEUE_PROTECTED_BIT";
        addedFlags = true;
    }
    return returnString;
}

enum class MemoryPropertyFlags
{
    e_NONE = 0,
    e_DEVICE_LOCAL_BIT = VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT,
    e_HOST_VISIBLE_BIT = VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT,
    e_HOST_COHERENT_BIT = VK_MEMORY_PROPERTY_HOST_COHERENT_BIT,
    e_HOST_CACHED_BIT = VK_MEMORY_PROPERTY_HOST_CACHED_BIT,
    e_LAZILY_ALLOCATED_BIT = VK_MEMORY_PROPERTY_LAZILY_ALLOCATED_BIT,
    e_PROTECTED_BIT = VK_MEMORY_PROPERTY_PROTECTED_BIT,
    e_MAX_ENUM = 0x7FFFFFFF,
    e_ALL_BITS = e_DEVICE_LOCAL_BIT | e_HOST_VISIBLE_BIT | e_HOST_COHERENT_BIT | e_HOST_CACHED_BIT | e_LAZILY_ALLOCATED_BIT | e_PROTECTED_BIT
};
DEFINE_ENUM_BITWISE_OPERATORS(MemoryPropertyFlags)
inline std::string to_string(MemoryPropertyFlags value)
{
    std::string returnString = "";
    bool addedFlags = false;
    if(static_cast<uint32_t>(value & MemoryPropertyFlags::e_DEVICE_LOCAL_BIT) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & MemoryPropertyFlags::e_HOST_VISIBLE_BIT) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & MemoryPropertyFlags::e_HOST_COHERENT_BIT) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_MEMORY_PROPERTY_HOST_COHERENT_BIT";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & MemoryPropertyFlags::e_HOST_CACHED_BIT) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_MEMORY_PROPERTY_HOST_CACHED_BIT";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & MemoryPropertyFlags::e_LAZILY_ALLOCATED_BIT) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_MEMORY_PROPERTY_LAZILY_ALLOCATED_BIT";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & MemoryPropertyFlags::e_PROTECTED_BIT) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_MEMORY_PROPERTY_PROTECTED_BIT";
        addedFlags = true;
    }
    return returnString;
}

enum class MemoryHeapFlags
{
    e_NONE = 0,
    e_DEVICE_LOCAL_BIT = VK_MEMORY_HEAP_DEVICE_LOCAL_BIT,
    e_MULTI_INSTANCE_BIT = VK_MEMORY_HEAP_MULTI_INSTANCE_BIT,
    e_MULTI_INSTANCE_BIT_KHR = VK_MEMORY_HEAP_MULTI_INSTANCE_BIT_KHR,
    e_MAX_ENUM = 0x7FFFFFFF,
    e_ALL_BITS = e_DEVICE_LOCAL_BIT | e_MULTI_INSTANCE_BIT | e_MULTI_INSTANCE_BIT_KHR
};
DEFINE_ENUM_BITWISE_OPERATORS(MemoryHeapFlags)
inline std::string to_string(MemoryHeapFlags value)
{
    std::string returnString = "";
    bool addedFlags = false;
    if(static_cast<uint32_t>(value & MemoryHeapFlags::e_DEVICE_LOCAL_BIT) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_MEMORY_HEAP_DEVICE_LOCAL_BIT";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & MemoryHeapFlags::e_MULTI_INSTANCE_BIT) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_MEMORY_HEAP_MULTI_INSTANCE_BIT";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & MemoryHeapFlags::e_MULTI_INSTANCE_BIT_KHR) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_MEMORY_HEAP_MULTI_INSTANCE_BIT_KHR";
        addedFlags = true;
    }
    return returnString;
}

enum class DeviceQueueCreateFlags
{
    e_NONE = 0,
    e_PROTECTED_BIT = VK_DEVICE_QUEUE_CREATE_PROTECTED_BIT,
    e_MAX_ENUM = 0x7FFFFFFF,
    e_ALL_BITS = e_PROTECTED_BIT
};
DEFINE_ENUM_BITWISE_OPERATORS(DeviceQueueCreateFlags)
inline std::string to_string(DeviceQueueCreateFlags value)
{
    std::string returnString = "";
    bool addedFlags = false;
    if(static_cast<uint32_t>(value & DeviceQueueCreateFlags::e_PROTECTED_BIT) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_DEVICE_QUEUE_CREATE_PROTECTED_BIT";
        addedFlags = true;
    }
    return returnString;
}

enum class PipelineStageFlags
{
    e_NONE = 0,
    e_TOP_OF_PIPE_BIT = VK_PIPELINE_STAGE_TOP_OF_PIPE_BIT,
    e_DRAW_INDIRECT_BIT = VK_PIPELINE_STAGE_DRAW_INDIRECT_BIT,
    e_VERTEX_INPUT_BIT = VK_PIPELINE_STAGE_VERTEX_INPUT_BIT,
    e_VERTEX_SHADER_BIT = VK_PIPELINE_STAGE_VERTEX_SHADER_BIT,
    e_TESSELLATION_CONTROL_SHADER_BIT = VK_PIPELINE_STAGE_TESSELLATION_CONTROL_SHADER_BIT,
    e_TESSELLATION_EVALUATION_SHADER_BIT = VK_PIPELINE_STAGE_TESSELLATION_EVALUATION_SHADER_BIT,
    e_GEOMETRY_SHADER_BIT = VK_PIPELINE_STAGE_GEOMETRY_SHADER_BIT,
    e_FRAGMENT_SHADER_BIT = VK_PIPELINE_STAGE_FRAGMENT_SHADER_BIT,
    e_EARLY_FRAGMENT_TESTS_BIT = VK_PIPELINE_STAGE_EARLY_FRAGMENT_TESTS_BIT,
    e_LATE_FRAGMENT_TESTS_BIT = VK_PIPELINE_STAGE_LATE_FRAGMENT_TESTS_BIT,
    e_COLOR_ATTACHMENT_OUTPUT_BIT = VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT,
    e_COMPUTE_SHADER_BIT = VK_PIPELINE_STAGE_COMPUTE_SHADER_BIT,
    e_TRANSFER_BIT = VK_PIPELINE_STAGE_TRANSFER_BIT,
    e_BOTTOM_OF_PIPE_BIT = VK_PIPELINE_STAGE_BOTTOM_OF_PIPE_BIT,
    e_HOST_BIT = VK_PIPELINE_STAGE_HOST_BIT,
    e_ALL_GRAPHICS_BIT = VK_PIPELINE_STAGE_ALL_GRAPHICS_BIT,
    e_ALL_COMMANDS_BIT = VK_PIPELINE_STAGE_ALL_COMMANDS_BIT,
    e_TRANSFORM_FEEDBACK_BIT_EXT = VK_PIPELINE_STAGE_TRANSFORM_FEEDBACK_BIT_EXT,
    e_CONDITIONAL_RENDERING_BIT_EXT = VK_PIPELINE_STAGE_CONDITIONAL_RENDERING_BIT_EXT,
    e_COMMAND_PROCESS_BIT_NVX = VK_PIPELINE_STAGE_COMMAND_PROCESS_BIT_NVX,
    e_SHADING_RATE_IMAGE_BIT_NV = VK_PIPELINE_STAGE_SHADING_RATE_IMAGE_BIT_NV,
    e_RAY_TRACING_SHADER_BIT_NV = VK_PIPELINE_STAGE_RAY_TRACING_SHADER_BIT_NV,
    e_ACCELERATION_STRUCTURE_BUILD_BIT_NV = VK_PIPELINE_STAGE_ACCELERATION_STRUCTURE_BUILD_BIT_NV,
    e_TASK_SHADER_BIT_NV = VK_PIPELINE_STAGE_TASK_SHADER_BIT_NV,
    e_MESH_SHADER_BIT_NV = VK_PIPELINE_STAGE_MESH_SHADER_BIT_NV,
    e_MAX_ENUM = 0x7FFFFFFF,
    e_ALL_BITS = e_TOP_OF_PIPE_BIT | e_DRAW_INDIRECT_BIT | e_VERTEX_INPUT_BIT | e_VERTEX_SHADER_BIT | e_TESSELLATION_CONTROL_SHADER_BIT | e_TESSELLATION_EVALUATION_SHADER_BIT | e_GEOMETRY_SHADER_BIT | e_FRAGMENT_SHADER_BIT | e_EARLY_FRAGMENT_TESTS_BIT | e_LATE_FRAGMENT_TESTS_BIT | e_COLOR_ATTACHMENT_OUTPUT_BIT | e_COMPUTE_SHADER_BIT | e_TRANSFER_BIT | e_BOTTOM_OF_PIPE_BIT | e_HOST_BIT | e_ALL_GRAPHICS_BIT | e_ALL_COMMANDS_BIT | e_TRANSFORM_FEEDBACK_BIT_EXT | e_CONDITIONAL_RENDERING_BIT_EXT | e_COMMAND_PROCESS_BIT_NVX | e_SHADING_RATE_IMAGE_BIT_NV | e_RAY_TRACING_SHADER_BIT_NV | e_ACCELERATION_STRUCTURE_BUILD_BIT_NV | e_TASK_SHADER_BIT_NV | e_MESH_SHADER_BIT_NV
};
DEFINE_ENUM_BITWISE_OPERATORS(PipelineStageFlags)
inline std::string to_string(PipelineStageFlags value)
{
    std::string returnString = "";
    bool addedFlags = false;
    if(static_cast<uint32_t>(value & PipelineStageFlags::e_TOP_OF_PIPE_BIT) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_PIPELINE_STAGE_TOP_OF_PIPE_BIT";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & PipelineStageFlags::e_DRAW_INDIRECT_BIT) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_PIPELINE_STAGE_DRAW_INDIRECT_BIT";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & PipelineStageFlags::e_VERTEX_INPUT_BIT) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_PIPELINE_STAGE_VERTEX_INPUT_BIT";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & PipelineStageFlags::e_VERTEX_SHADER_BIT) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_PIPELINE_STAGE_VERTEX_SHADER_BIT";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & PipelineStageFlags::e_TESSELLATION_CONTROL_SHADER_BIT) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_PIPELINE_STAGE_TESSELLATION_CONTROL_SHADER_BIT";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & PipelineStageFlags::e_TESSELLATION_EVALUATION_SHADER_BIT) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_PIPELINE_STAGE_TESSELLATION_EVALUATION_SHADER_BIT";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & PipelineStageFlags::e_GEOMETRY_SHADER_BIT) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_PIPELINE_STAGE_GEOMETRY_SHADER_BIT";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & PipelineStageFlags::e_FRAGMENT_SHADER_BIT) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_PIPELINE_STAGE_FRAGMENT_SHADER_BIT";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & PipelineStageFlags::e_EARLY_FRAGMENT_TESTS_BIT) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_PIPELINE_STAGE_EARLY_FRAGMENT_TESTS_BIT";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & PipelineStageFlags::e_LATE_FRAGMENT_TESTS_BIT) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_PIPELINE_STAGE_LATE_FRAGMENT_TESTS_BIT";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & PipelineStageFlags::e_COLOR_ATTACHMENT_OUTPUT_BIT) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & PipelineStageFlags::e_COMPUTE_SHADER_BIT) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_PIPELINE_STAGE_COMPUTE_SHADER_BIT";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & PipelineStageFlags::e_TRANSFER_BIT) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_PIPELINE_STAGE_TRANSFER_BIT";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & PipelineStageFlags::e_BOTTOM_OF_PIPE_BIT) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_PIPELINE_STAGE_BOTTOM_OF_PIPE_BIT";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & PipelineStageFlags::e_HOST_BIT) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_PIPELINE_STAGE_HOST_BIT";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & PipelineStageFlags::e_ALL_GRAPHICS_BIT) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_PIPELINE_STAGE_ALL_GRAPHICS_BIT";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & PipelineStageFlags::e_ALL_COMMANDS_BIT) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_PIPELINE_STAGE_ALL_COMMANDS_BIT";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & PipelineStageFlags::e_TRANSFORM_FEEDBACK_BIT_EXT) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_PIPELINE_STAGE_TRANSFORM_FEEDBACK_BIT_EXT";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & PipelineStageFlags::e_CONDITIONAL_RENDERING_BIT_EXT) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_PIPELINE_STAGE_CONDITIONAL_RENDERING_BIT_EXT";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & PipelineStageFlags::e_COMMAND_PROCESS_BIT_NVX) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_PIPELINE_STAGE_COMMAND_PROCESS_BIT_NVX";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & PipelineStageFlags::e_SHADING_RATE_IMAGE_BIT_NV) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_PIPELINE_STAGE_SHADING_RATE_IMAGE_BIT_NV";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & PipelineStageFlags::e_RAY_TRACING_SHADER_BIT_NV) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_PIPELINE_STAGE_RAY_TRACING_SHADER_BIT_NV";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & PipelineStageFlags::e_ACCELERATION_STRUCTURE_BUILD_BIT_NV) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_PIPELINE_STAGE_ACCELERATION_STRUCTURE_BUILD_BIT_NV";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & PipelineStageFlags::e_TASK_SHADER_BIT_NV) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_PIPELINE_STAGE_TASK_SHADER_BIT_NV";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & PipelineStageFlags::e_MESH_SHADER_BIT_NV) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_PIPELINE_STAGE_MESH_SHADER_BIT_NV";
        addedFlags = true;
    }
    return returnString;
}

enum class ImageAspectFlags
{
    e_NONE = 0,
    e_COLOR_BIT = VK_IMAGE_ASPECT_COLOR_BIT,
    e_DEPTH_BIT = VK_IMAGE_ASPECT_DEPTH_BIT,
    e_STENCIL_BIT = VK_IMAGE_ASPECT_STENCIL_BIT,
    e_METADATA_BIT = VK_IMAGE_ASPECT_METADATA_BIT,
    e_PLANE_0_BIT = VK_IMAGE_ASPECT_PLANE_0_BIT,
    e_PLANE_1_BIT = VK_IMAGE_ASPECT_PLANE_1_BIT,
    e_PLANE_2_BIT = VK_IMAGE_ASPECT_PLANE_2_BIT,
    e_PLANE_0_BIT_KHR = VK_IMAGE_ASPECT_PLANE_0_BIT_KHR,
    e_PLANE_1_BIT_KHR = VK_IMAGE_ASPECT_PLANE_1_BIT_KHR,
    e_PLANE_2_BIT_KHR = VK_IMAGE_ASPECT_PLANE_2_BIT_KHR,
    e_MEMORY_PLANE_0_BIT_EXT = VK_IMAGE_ASPECT_MEMORY_PLANE_0_BIT_EXT,
    e_MEMORY_PLANE_1_BIT_EXT = VK_IMAGE_ASPECT_MEMORY_PLANE_1_BIT_EXT,
    e_MEMORY_PLANE_2_BIT_EXT = VK_IMAGE_ASPECT_MEMORY_PLANE_2_BIT_EXT,
    e_MEMORY_PLANE_3_BIT_EXT = VK_IMAGE_ASPECT_MEMORY_PLANE_3_BIT_EXT,
    e_MAX_ENUM = 0x7FFFFFFF,
    e_ALL_BITS = e_COLOR_BIT | e_DEPTH_BIT | e_STENCIL_BIT | e_METADATA_BIT | e_PLANE_0_BIT | e_PLANE_1_BIT | e_PLANE_2_BIT | e_PLANE_0_BIT_KHR | e_PLANE_1_BIT_KHR | e_PLANE_2_BIT_KHR | e_MEMORY_PLANE_0_BIT_EXT | e_MEMORY_PLANE_1_BIT_EXT | e_MEMORY_PLANE_2_BIT_EXT | e_MEMORY_PLANE_3_BIT_EXT
};
DEFINE_ENUM_BITWISE_OPERATORS(ImageAspectFlags)
inline std::string to_string(ImageAspectFlags value)
{
    std::string returnString = "";
    bool addedFlags = false;
    if(static_cast<uint32_t>(value & ImageAspectFlags::e_COLOR_BIT) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_IMAGE_ASPECT_COLOR_BIT";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & ImageAspectFlags::e_DEPTH_BIT) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_IMAGE_ASPECT_DEPTH_BIT";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & ImageAspectFlags::e_STENCIL_BIT) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_IMAGE_ASPECT_STENCIL_BIT";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & ImageAspectFlags::e_METADATA_BIT) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_IMAGE_ASPECT_METADATA_BIT";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & ImageAspectFlags::e_PLANE_0_BIT) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_IMAGE_ASPECT_PLANE_0_BIT";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & ImageAspectFlags::e_PLANE_1_BIT) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_IMAGE_ASPECT_PLANE_1_BIT";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & ImageAspectFlags::e_PLANE_2_BIT) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_IMAGE_ASPECT_PLANE_2_BIT";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & ImageAspectFlags::e_PLANE_0_BIT_KHR) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_IMAGE_ASPECT_PLANE_0_BIT_KHR";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & ImageAspectFlags::e_PLANE_1_BIT_KHR) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_IMAGE_ASPECT_PLANE_1_BIT_KHR";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & ImageAspectFlags::e_PLANE_2_BIT_KHR) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_IMAGE_ASPECT_PLANE_2_BIT_KHR";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & ImageAspectFlags::e_MEMORY_PLANE_0_BIT_EXT) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_IMAGE_ASPECT_MEMORY_PLANE_0_BIT_EXT";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & ImageAspectFlags::e_MEMORY_PLANE_1_BIT_EXT) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_IMAGE_ASPECT_MEMORY_PLANE_1_BIT_EXT";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & ImageAspectFlags::e_MEMORY_PLANE_2_BIT_EXT) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_IMAGE_ASPECT_MEMORY_PLANE_2_BIT_EXT";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & ImageAspectFlags::e_MEMORY_PLANE_3_BIT_EXT) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_IMAGE_ASPECT_MEMORY_PLANE_3_BIT_EXT";
        addedFlags = true;
    }
    return returnString;
}

enum class SparseImageFormatFlags
{
    e_NONE = 0,
    e_SINGLE_MIPTAIL_BIT = VK_SPARSE_IMAGE_FORMAT_SINGLE_MIPTAIL_BIT,
    e_ALIGNED_MIP_SIZE_BIT = VK_SPARSE_IMAGE_FORMAT_ALIGNED_MIP_SIZE_BIT,
    e_NONSTANDARD_BLOCK_SIZE_BIT = VK_SPARSE_IMAGE_FORMAT_NONSTANDARD_BLOCK_SIZE_BIT,
    e_MAX_ENUM = 0x7FFFFFFF,
    e_ALL_BITS = e_SINGLE_MIPTAIL_BIT | e_ALIGNED_MIP_SIZE_BIT | e_NONSTANDARD_BLOCK_SIZE_BIT
};
DEFINE_ENUM_BITWISE_OPERATORS(SparseImageFormatFlags)
inline std::string to_string(SparseImageFormatFlags value)
{
    std::string returnString = "";
    bool addedFlags = false;
    if(static_cast<uint32_t>(value & SparseImageFormatFlags::e_SINGLE_MIPTAIL_BIT) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_SPARSE_IMAGE_FORMAT_SINGLE_MIPTAIL_BIT";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & SparseImageFormatFlags::e_ALIGNED_MIP_SIZE_BIT) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_SPARSE_IMAGE_FORMAT_ALIGNED_MIP_SIZE_BIT";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & SparseImageFormatFlags::e_NONSTANDARD_BLOCK_SIZE_BIT) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_SPARSE_IMAGE_FORMAT_NONSTANDARD_BLOCK_SIZE_BIT";
        addedFlags = true;
    }
    return returnString;
}

enum class SparseMemoryBindFlags
{
    e_NONE = 0,
    e_METADATA_BIT = VK_SPARSE_MEMORY_BIND_METADATA_BIT,
    e_MAX_ENUM = 0x7FFFFFFF,
    e_ALL_BITS = e_METADATA_BIT
};
DEFINE_ENUM_BITWISE_OPERATORS(SparseMemoryBindFlags)
inline std::string to_string(SparseMemoryBindFlags value)
{
    std::string returnString = "";
    bool addedFlags = false;
    if(static_cast<uint32_t>(value & SparseMemoryBindFlags::e_METADATA_BIT) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_SPARSE_MEMORY_BIND_METADATA_BIT";
        addedFlags = true;
    }
    return returnString;
}

enum class FenceCreateFlags
{
    e_NONE = 0,
    e_SIGNALED_BIT = VK_FENCE_CREATE_SIGNALED_BIT,
    e_MAX_ENUM = 0x7FFFFFFF,
    e_ALL_BITS = e_SIGNALED_BIT
};
DEFINE_ENUM_BITWISE_OPERATORS(FenceCreateFlags)
inline std::string to_string(FenceCreateFlags value)
{
    std::string returnString = "";
    bool addedFlags = false;
    if(static_cast<uint32_t>(value & FenceCreateFlags::e_SIGNALED_BIT) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_FENCE_CREATE_SIGNALED_BIT";
        addedFlags = true;
    }
    return returnString;
}

enum class QueryType
{
    e_OCCLUSION = VK_QUERY_TYPE_OCCLUSION,
    e_PIPELINE_STATISTICS = VK_QUERY_TYPE_PIPELINE_STATISTICS,
    e_TIMESTAMP = VK_QUERY_TYPE_TIMESTAMP,
    e_TRANSFORM_FEEDBACK_STREAM_EXT = VK_QUERY_TYPE_TRANSFORM_FEEDBACK_STREAM_EXT,
    e_ACCELERATION_STRUCTURE_COMPACTED_SIZE_NV = VK_QUERY_TYPE_ACCELERATION_STRUCTURE_COMPACTED_SIZE_NV,
    e_BEGIN_RANGE = VK_QUERY_TYPE_BEGIN_RANGE,
    e_END_RANGE = VK_QUERY_TYPE_END_RANGE,
    e_RANGE_SIZE = VK_QUERY_TYPE_RANGE_SIZE,
    e_MAX_ENUM = 0x7FFFFFFF

};
DEFINE_ENUM_BITWISE_OPERATORS(QueryType)
inline std::string to_string(QueryType value)
{
    switch(value)
    {
    case QueryType::e_OCCLUSION: return "VK_QUERY_TYPE_OCCLUSION";
    case QueryType::e_PIPELINE_STATISTICS: return "VK_QUERY_TYPE_PIPELINE_STATISTICS";
    case QueryType::e_TIMESTAMP: return "VK_QUERY_TYPE_TIMESTAMP";
    case QueryType::e_TRANSFORM_FEEDBACK_STREAM_EXT: return "VK_QUERY_TYPE_TRANSFORM_FEEDBACK_STREAM_EXT";
    case QueryType::e_ACCELERATION_STRUCTURE_COMPACTED_SIZE_NV: return "VK_QUERY_TYPE_ACCELERATION_STRUCTURE_COMPACTED_SIZE_NV";
    default: return "invalid";
    }
}

enum class QueryPipelineStatisticFlags
{
    e_NONE = 0,
    e_INPUT_ASSEMBLY_VERTICES_BIT = VK_QUERY_PIPELINE_STATISTIC_INPUT_ASSEMBLY_VERTICES_BIT,
    e_INPUT_ASSEMBLY_PRIMITIVES_BIT = VK_QUERY_PIPELINE_STATISTIC_INPUT_ASSEMBLY_PRIMITIVES_BIT,
    e_VERTEX_SHADER_INVOCATIONS_BIT = VK_QUERY_PIPELINE_STATISTIC_VERTEX_SHADER_INVOCATIONS_BIT,
    e_GEOMETRY_SHADER_INVOCATIONS_BIT = VK_QUERY_PIPELINE_STATISTIC_GEOMETRY_SHADER_INVOCATIONS_BIT,
    e_GEOMETRY_SHADER_PRIMITIVES_BIT = VK_QUERY_PIPELINE_STATISTIC_GEOMETRY_SHADER_PRIMITIVES_BIT,
    e_CLIPPING_INVOCATIONS_BIT = VK_QUERY_PIPELINE_STATISTIC_CLIPPING_INVOCATIONS_BIT,
    e_CLIPPING_PRIMITIVES_BIT = VK_QUERY_PIPELINE_STATISTIC_CLIPPING_PRIMITIVES_BIT,
    e_FRAGMENT_SHADER_INVOCATIONS_BIT = VK_QUERY_PIPELINE_STATISTIC_FRAGMENT_SHADER_INVOCATIONS_BIT,
    e_TESSELLATION_CONTROL_SHADER_PATCHES_BIT = VK_QUERY_PIPELINE_STATISTIC_TESSELLATION_CONTROL_SHADER_PATCHES_BIT,
    e_TESSELLATION_EVALUATION_SHADER_INVOCATIONS_BIT = VK_QUERY_PIPELINE_STATISTIC_TESSELLATION_EVALUATION_SHADER_INVOCATIONS_BIT,
    e_COMPUTE_SHADER_INVOCATIONS_BIT = VK_QUERY_PIPELINE_STATISTIC_COMPUTE_SHADER_INVOCATIONS_BIT,
    e_MAX_ENUM = 0x7FFFFFFF,
    e_ALL_BITS = e_INPUT_ASSEMBLY_VERTICES_BIT | e_INPUT_ASSEMBLY_PRIMITIVES_BIT | e_VERTEX_SHADER_INVOCATIONS_BIT | e_GEOMETRY_SHADER_INVOCATIONS_BIT | e_GEOMETRY_SHADER_PRIMITIVES_BIT | e_CLIPPING_INVOCATIONS_BIT | e_CLIPPING_PRIMITIVES_BIT | e_FRAGMENT_SHADER_INVOCATIONS_BIT | e_TESSELLATION_CONTROL_SHADER_PATCHES_BIT | e_TESSELLATION_EVALUATION_SHADER_INVOCATIONS_BIT | e_COMPUTE_SHADER_INVOCATIONS_BIT
};
DEFINE_ENUM_BITWISE_OPERATORS(QueryPipelineStatisticFlags)
inline std::string to_string(QueryPipelineStatisticFlags value)
{
    std::string returnString = "";
    bool addedFlags = false;
    if(static_cast<uint32_t>(value & QueryPipelineStatisticFlags::e_INPUT_ASSEMBLY_VERTICES_BIT) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_QUERY_PIPELINE_STATISTIC_INPUT_ASSEMBLY_VERTICES_BIT";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & QueryPipelineStatisticFlags::e_INPUT_ASSEMBLY_PRIMITIVES_BIT) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_QUERY_PIPELINE_STATISTIC_INPUT_ASSEMBLY_PRIMITIVES_BIT";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & QueryPipelineStatisticFlags::e_VERTEX_SHADER_INVOCATIONS_BIT) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_QUERY_PIPELINE_STATISTIC_VERTEX_SHADER_INVOCATIONS_BIT";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & QueryPipelineStatisticFlags::e_GEOMETRY_SHADER_INVOCATIONS_BIT) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_QUERY_PIPELINE_STATISTIC_GEOMETRY_SHADER_INVOCATIONS_BIT";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & QueryPipelineStatisticFlags::e_GEOMETRY_SHADER_PRIMITIVES_BIT) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_QUERY_PIPELINE_STATISTIC_GEOMETRY_SHADER_PRIMITIVES_BIT";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & QueryPipelineStatisticFlags::e_CLIPPING_INVOCATIONS_BIT) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_QUERY_PIPELINE_STATISTIC_CLIPPING_INVOCATIONS_BIT";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & QueryPipelineStatisticFlags::e_CLIPPING_PRIMITIVES_BIT) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_QUERY_PIPELINE_STATISTIC_CLIPPING_PRIMITIVES_BIT";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & QueryPipelineStatisticFlags::e_FRAGMENT_SHADER_INVOCATIONS_BIT) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_QUERY_PIPELINE_STATISTIC_FRAGMENT_SHADER_INVOCATIONS_BIT";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & QueryPipelineStatisticFlags::e_TESSELLATION_CONTROL_SHADER_PATCHES_BIT) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_QUERY_PIPELINE_STATISTIC_TESSELLATION_CONTROL_SHADER_PATCHES_BIT";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & QueryPipelineStatisticFlags::e_TESSELLATION_EVALUATION_SHADER_INVOCATIONS_BIT) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_QUERY_PIPELINE_STATISTIC_TESSELLATION_EVALUATION_SHADER_INVOCATIONS_BIT";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & QueryPipelineStatisticFlags::e_COMPUTE_SHADER_INVOCATIONS_BIT) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_QUERY_PIPELINE_STATISTIC_COMPUTE_SHADER_INVOCATIONS_BIT";
        addedFlags = true;
    }
    return returnString;
}

enum class QueryResultFlags
{
    e_NONE = 0,
    e_64_BIT = VK_QUERY_RESULT_64_BIT,
    e_WAIT_BIT = VK_QUERY_RESULT_WAIT_BIT,
    e_WITH_AVAILABILITY_BIT = VK_QUERY_RESULT_WITH_AVAILABILITY_BIT,
    e_PARTIAL_BIT = VK_QUERY_RESULT_PARTIAL_BIT,
    e_MAX_ENUM = 0x7FFFFFFF,
    e_ALL_BITS = e_64_BIT | e_WAIT_BIT | e_WITH_AVAILABILITY_BIT | e_PARTIAL_BIT
};
DEFINE_ENUM_BITWISE_OPERATORS(QueryResultFlags)
inline std::string to_string(QueryResultFlags value)
{
    std::string returnString = "";
    bool addedFlags = false;
    if(static_cast<uint32_t>(value & QueryResultFlags::e_64_BIT) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_QUERY_RESULT_64_BIT";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & QueryResultFlags::e_WAIT_BIT) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_QUERY_RESULT_WAIT_BIT";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & QueryResultFlags::e_WITH_AVAILABILITY_BIT) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_QUERY_RESULT_WITH_AVAILABILITY_BIT";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & QueryResultFlags::e_PARTIAL_BIT) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_QUERY_RESULT_PARTIAL_BIT";
        addedFlags = true;
    }
    return returnString;
}

enum class BufferCreateFlags
{
    e_NONE = 0,
    e_SPARSE_BINDING_BIT = VK_BUFFER_CREATE_SPARSE_BINDING_BIT,
    e_SPARSE_RESIDENCY_BIT = VK_BUFFER_CREATE_SPARSE_RESIDENCY_BIT,
    e_SPARSE_ALIASED_BIT = VK_BUFFER_CREATE_SPARSE_ALIASED_BIT,
    e_PROTECTED_BIT = VK_BUFFER_CREATE_PROTECTED_BIT,
    e_MAX_ENUM = 0x7FFFFFFF,
    e_ALL_BITS = e_SPARSE_BINDING_BIT | e_SPARSE_RESIDENCY_BIT | e_SPARSE_ALIASED_BIT | e_PROTECTED_BIT
};
DEFINE_ENUM_BITWISE_OPERATORS(BufferCreateFlags)
inline std::string to_string(BufferCreateFlags value)
{
    std::string returnString = "";
    bool addedFlags = false;
    if(static_cast<uint32_t>(value & BufferCreateFlags::e_SPARSE_BINDING_BIT) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_BUFFER_CREATE_SPARSE_BINDING_BIT";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & BufferCreateFlags::e_SPARSE_RESIDENCY_BIT) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_BUFFER_CREATE_SPARSE_RESIDENCY_BIT";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & BufferCreateFlags::e_SPARSE_ALIASED_BIT) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_BUFFER_CREATE_SPARSE_ALIASED_BIT";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & BufferCreateFlags::e_PROTECTED_BIT) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_BUFFER_CREATE_PROTECTED_BIT";
        addedFlags = true;
    }
    return returnString;
}

enum class BufferUsageFlags
{
    e_NONE = 0,
    e_TRANSFER_SRC_BIT = VK_BUFFER_USAGE_TRANSFER_SRC_BIT,
    e_TRANSFER_DST_BIT = VK_BUFFER_USAGE_TRANSFER_DST_BIT,
    e_UNIFORM_TEXEL_BUFFER_BIT = VK_BUFFER_USAGE_UNIFORM_TEXEL_BUFFER_BIT,
    e_STORAGE_TEXEL_BUFFER_BIT = VK_BUFFER_USAGE_STORAGE_TEXEL_BUFFER_BIT,
    e_UNIFORM_BUFFER_BIT = VK_BUFFER_USAGE_UNIFORM_BUFFER_BIT,
    e_STORAGE_BUFFER_BIT = VK_BUFFER_USAGE_STORAGE_BUFFER_BIT,
    e_INDEX_BUFFER_BIT = VK_BUFFER_USAGE_INDEX_BUFFER_BIT,
    e_VERTEX_BUFFER_BIT = VK_BUFFER_USAGE_VERTEX_BUFFER_BIT,
    e_INDIRECT_BUFFER_BIT = VK_BUFFER_USAGE_INDIRECT_BUFFER_BIT,
    e_TRANSFORM_FEEDBACK_BUFFER_BIT_EXT = VK_BUFFER_USAGE_TRANSFORM_FEEDBACK_BUFFER_BIT_EXT,
    e_TRANSFORM_FEEDBACK_COUNTER_BUFFER_BIT_EXT = VK_BUFFER_USAGE_TRANSFORM_FEEDBACK_COUNTER_BUFFER_BIT_EXT,
    e_CONDITIONAL_RENDERING_BIT_EXT = VK_BUFFER_USAGE_CONDITIONAL_RENDERING_BIT_EXT,
    e_RAY_TRACING_BIT_NV = VK_BUFFER_USAGE_RAY_TRACING_BIT_NV,
    e_MAX_ENUM = 0x7FFFFFFF,
    e_ALL_BITS = e_TRANSFER_SRC_BIT | e_TRANSFER_DST_BIT | e_UNIFORM_TEXEL_BUFFER_BIT | e_STORAGE_TEXEL_BUFFER_BIT | e_UNIFORM_BUFFER_BIT | e_STORAGE_BUFFER_BIT | e_INDEX_BUFFER_BIT | e_VERTEX_BUFFER_BIT | e_INDIRECT_BUFFER_BIT | e_TRANSFORM_FEEDBACK_BUFFER_BIT_EXT | e_TRANSFORM_FEEDBACK_COUNTER_BUFFER_BIT_EXT | e_CONDITIONAL_RENDERING_BIT_EXT | e_RAY_TRACING_BIT_NV
};
DEFINE_ENUM_BITWISE_OPERATORS(BufferUsageFlags)
inline std::string to_string(BufferUsageFlags value)
{
    std::string returnString = "";
    bool addedFlags = false;
    if(static_cast<uint32_t>(value & BufferUsageFlags::e_TRANSFER_SRC_BIT) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_BUFFER_USAGE_TRANSFER_SRC_BIT";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & BufferUsageFlags::e_TRANSFER_DST_BIT) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_BUFFER_USAGE_TRANSFER_DST_BIT";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & BufferUsageFlags::e_UNIFORM_TEXEL_BUFFER_BIT) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_BUFFER_USAGE_UNIFORM_TEXEL_BUFFER_BIT";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & BufferUsageFlags::e_STORAGE_TEXEL_BUFFER_BIT) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_BUFFER_USAGE_STORAGE_TEXEL_BUFFER_BIT";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & BufferUsageFlags::e_UNIFORM_BUFFER_BIT) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_BUFFER_USAGE_UNIFORM_BUFFER_BIT";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & BufferUsageFlags::e_STORAGE_BUFFER_BIT) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_BUFFER_USAGE_STORAGE_BUFFER_BIT";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & BufferUsageFlags::e_INDEX_BUFFER_BIT) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_BUFFER_USAGE_INDEX_BUFFER_BIT";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & BufferUsageFlags::e_VERTEX_BUFFER_BIT) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_BUFFER_USAGE_VERTEX_BUFFER_BIT";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & BufferUsageFlags::e_INDIRECT_BUFFER_BIT) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_BUFFER_USAGE_INDIRECT_BUFFER_BIT";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & BufferUsageFlags::e_TRANSFORM_FEEDBACK_BUFFER_BIT_EXT) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_BUFFER_USAGE_TRANSFORM_FEEDBACK_BUFFER_BIT_EXT";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & BufferUsageFlags::e_TRANSFORM_FEEDBACK_COUNTER_BUFFER_BIT_EXT) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_BUFFER_USAGE_TRANSFORM_FEEDBACK_COUNTER_BUFFER_BIT_EXT";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & BufferUsageFlags::e_CONDITIONAL_RENDERING_BIT_EXT) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_BUFFER_USAGE_CONDITIONAL_RENDERING_BIT_EXT";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & BufferUsageFlags::e_RAY_TRACING_BIT_NV) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_BUFFER_USAGE_RAY_TRACING_BIT_NV";
        addedFlags = true;
    }
    return returnString;
}

enum class SharingMode
{
    e_EXCLUSIVE = VK_SHARING_MODE_EXCLUSIVE,
    e_CONCURRENT = VK_SHARING_MODE_CONCURRENT,
    e_BEGIN_RANGE = VK_SHARING_MODE_BEGIN_RANGE,
    e_END_RANGE = VK_SHARING_MODE_END_RANGE,
    e_RANGE_SIZE = VK_SHARING_MODE_RANGE_SIZE,
    e_MAX_ENUM = 0x7FFFFFFF

};
DEFINE_ENUM_BITWISE_OPERATORS(SharingMode)
inline std::string to_string(SharingMode value)
{
    switch(value)
    {
    case SharingMode::e_EXCLUSIVE: return "VK_SHARING_MODE_EXCLUSIVE";
    case SharingMode::e_CONCURRENT: return "VK_SHARING_MODE_CONCURRENT";
    default: return "invalid";
    }
}

enum class ImageLayout
{
    e_UNDEFINED = VK_IMAGE_LAYOUT_UNDEFINED,
    e_GENERAL = VK_IMAGE_LAYOUT_GENERAL,
    e_COLOR_ATTACHMENT_OPTIMAL = VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL,
    e_DEPTH_STENCIL_ATTACHMENT_OPTIMAL = VK_IMAGE_LAYOUT_DEPTH_STENCIL_ATTACHMENT_OPTIMAL,
    e_DEPTH_STENCIL_READ_ONLY_OPTIMAL = VK_IMAGE_LAYOUT_DEPTH_STENCIL_READ_ONLY_OPTIMAL,
    e_SHADER_READ_ONLY_OPTIMAL = VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL,
    e_TRANSFER_SRC_OPTIMAL = VK_IMAGE_LAYOUT_TRANSFER_SRC_OPTIMAL,
    e_TRANSFER_DST_OPTIMAL = VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL,
    e_PREINITIALIZED = VK_IMAGE_LAYOUT_PREINITIALIZED,
    e_DEPTH_READ_ONLY_STENCIL_ATTACHMENT_OPTIMAL = VK_IMAGE_LAYOUT_DEPTH_READ_ONLY_STENCIL_ATTACHMENT_OPTIMAL,
    e_DEPTH_ATTACHMENT_STENCIL_READ_ONLY_OPTIMAL = VK_IMAGE_LAYOUT_DEPTH_ATTACHMENT_STENCIL_READ_ONLY_OPTIMAL,
    e_PRESENT_SRC_KHR = VK_IMAGE_LAYOUT_PRESENT_SRC_KHR,
    e_SHARED_PRESENT_KHR = VK_IMAGE_LAYOUT_SHARED_PRESENT_KHR,
    e_DEPTH_READ_ONLY_STENCIL_ATTACHMENT_OPTIMAL_KHR = VK_IMAGE_LAYOUT_DEPTH_READ_ONLY_STENCIL_ATTACHMENT_OPTIMAL_KHR,
    e_DEPTH_ATTACHMENT_STENCIL_READ_ONLY_OPTIMAL_KHR = VK_IMAGE_LAYOUT_DEPTH_ATTACHMENT_STENCIL_READ_ONLY_OPTIMAL_KHR,
    e_SHADING_RATE_OPTIMAL_NV = VK_IMAGE_LAYOUT_SHADING_RATE_OPTIMAL_NV,
    e_BEGIN_RANGE = VK_IMAGE_LAYOUT_BEGIN_RANGE,
    e_END_RANGE = VK_IMAGE_LAYOUT_END_RANGE,
    e_RANGE_SIZE = VK_IMAGE_LAYOUT_RANGE_SIZE,
    e_MAX_ENUM = 0x7FFFFFFF

};
DEFINE_ENUM_BITWISE_OPERATORS(ImageLayout)
inline std::string to_string(ImageLayout value)
{
    switch(value)
    {
    case ImageLayout::e_UNDEFINED: return "VK_IMAGE_LAYOUT_UNDEFINED";
    case ImageLayout::e_GENERAL: return "VK_IMAGE_LAYOUT_GENERAL";
    case ImageLayout::e_COLOR_ATTACHMENT_OPTIMAL: return "VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL";
    case ImageLayout::e_DEPTH_STENCIL_ATTACHMENT_OPTIMAL: return "VK_IMAGE_LAYOUT_DEPTH_STENCIL_ATTACHMENT_OPTIMAL";
    case ImageLayout::e_DEPTH_STENCIL_READ_ONLY_OPTIMAL: return "VK_IMAGE_LAYOUT_DEPTH_STENCIL_READ_ONLY_OPTIMAL";
    case ImageLayout::e_SHADER_READ_ONLY_OPTIMAL: return "VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL";
    case ImageLayout::e_TRANSFER_SRC_OPTIMAL: return "VK_IMAGE_LAYOUT_TRANSFER_SRC_OPTIMAL";
    case ImageLayout::e_TRANSFER_DST_OPTIMAL: return "VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL";
    case ImageLayout::e_PREINITIALIZED: return "VK_IMAGE_LAYOUT_PREINITIALIZED";
    case ImageLayout::e_DEPTH_READ_ONLY_STENCIL_ATTACHMENT_OPTIMAL: return "VK_IMAGE_LAYOUT_DEPTH_READ_ONLY_STENCIL_ATTACHMENT_OPTIMAL";
    case ImageLayout::e_DEPTH_ATTACHMENT_STENCIL_READ_ONLY_OPTIMAL: return "VK_IMAGE_LAYOUT_DEPTH_ATTACHMENT_STENCIL_READ_ONLY_OPTIMAL";
    case ImageLayout::e_PRESENT_SRC_KHR: return "VK_IMAGE_LAYOUT_PRESENT_SRC_KHR";
    case ImageLayout::e_SHARED_PRESENT_KHR: return "VK_IMAGE_LAYOUT_SHARED_PRESENT_KHR";
    case ImageLayout::e_SHADING_RATE_OPTIMAL_NV: return "VK_IMAGE_LAYOUT_SHADING_RATE_OPTIMAL_NV";
    default: return "invalid";
    }
}

enum class ImageViewType
{
    e_1D = VK_IMAGE_VIEW_TYPE_1D,
    e_2D = VK_IMAGE_VIEW_TYPE_2D,
    e_3D = VK_IMAGE_VIEW_TYPE_3D,
    e_CUBE = VK_IMAGE_VIEW_TYPE_CUBE,
    e_1D_ARRAY = VK_IMAGE_VIEW_TYPE_1D_ARRAY,
    e_2D_ARRAY = VK_IMAGE_VIEW_TYPE_2D_ARRAY,
    e_CUBE_ARRAY = VK_IMAGE_VIEW_TYPE_CUBE_ARRAY,
    e_BEGIN_RANGE = VK_IMAGE_VIEW_TYPE_BEGIN_RANGE,
    e_END_RANGE = VK_IMAGE_VIEW_TYPE_END_RANGE,
    e_RANGE_SIZE = VK_IMAGE_VIEW_TYPE_RANGE_SIZE,
    e_MAX_ENUM = 0x7FFFFFFF

};
DEFINE_ENUM_BITWISE_OPERATORS(ImageViewType)
inline std::string to_string(ImageViewType value)
{
    switch(value)
    {
    case ImageViewType::e_1D: return "VK_IMAGE_VIEW_TYPE_1D";
    case ImageViewType::e_2D: return "VK_IMAGE_VIEW_TYPE_2D";
    case ImageViewType::e_3D: return "VK_IMAGE_VIEW_TYPE_3D";
    case ImageViewType::e_CUBE: return "VK_IMAGE_VIEW_TYPE_CUBE";
    case ImageViewType::e_1D_ARRAY: return "VK_IMAGE_VIEW_TYPE_1D_ARRAY";
    case ImageViewType::e_2D_ARRAY: return "VK_IMAGE_VIEW_TYPE_2D_ARRAY";
    case ImageViewType::e_CUBE_ARRAY: return "VK_IMAGE_VIEW_TYPE_CUBE_ARRAY";
    default: return "invalid";
    }
}

enum class ComponentSwizzle
{
    e_IDENTITY = VK_COMPONENT_SWIZZLE_IDENTITY,
    e_ZERO = VK_COMPONENT_SWIZZLE_ZERO,
    e_ONE = VK_COMPONENT_SWIZZLE_ONE,
    e_R = VK_COMPONENT_SWIZZLE_R,
    e_G = VK_COMPONENT_SWIZZLE_G,
    e_B = VK_COMPONENT_SWIZZLE_B,
    e_A = VK_COMPONENT_SWIZZLE_A,
    e_BEGIN_RANGE = VK_COMPONENT_SWIZZLE_BEGIN_RANGE,
    e_END_RANGE = VK_COMPONENT_SWIZZLE_END_RANGE,
    e_RANGE_SIZE = VK_COMPONENT_SWIZZLE_RANGE_SIZE,
    e_MAX_ENUM = 0x7FFFFFFF

};
DEFINE_ENUM_BITWISE_OPERATORS(ComponentSwizzle)
inline std::string to_string(ComponentSwizzle value)
{
    switch(value)
    {
    case ComponentSwizzle::e_IDENTITY: return "VK_COMPONENT_SWIZZLE_IDENTITY";
    case ComponentSwizzle::e_ZERO: return "VK_COMPONENT_SWIZZLE_ZERO";
    case ComponentSwizzle::e_ONE: return "VK_COMPONENT_SWIZZLE_ONE";
    case ComponentSwizzle::e_R: return "VK_COMPONENT_SWIZZLE_R";
    case ComponentSwizzle::e_G: return "VK_COMPONENT_SWIZZLE_G";
    case ComponentSwizzle::e_B: return "VK_COMPONENT_SWIZZLE_B";
    case ComponentSwizzle::e_A: return "VK_COMPONENT_SWIZZLE_A";
    default: return "invalid";
    }
}

enum class PipelineCreateFlags
{
    e_NONE = 0,
    e_DISABLE_OPTIMIZATION_BIT = VK_PIPELINE_CREATE_DISABLE_OPTIMIZATION_BIT,
    e_ALLOW_DERIVATIVES_BIT = VK_PIPELINE_CREATE_ALLOW_DERIVATIVES_BIT,
    e_DERIVATIVE_BIT = VK_PIPELINE_CREATE_DERIVATIVE_BIT,
    e_VIEW_INDEX_FROM_DEVICE_INDEX_BIT = VK_PIPELINE_CREATE_VIEW_INDEX_FROM_DEVICE_INDEX_BIT,
    e_DISPATCH_BASE = VK_PIPELINE_CREATE_DISPATCH_BASE,
    e_VIEW_INDEX_FROM_DEVICE_INDEX_BIT_KHR = VK_PIPELINE_CREATE_VIEW_INDEX_FROM_DEVICE_INDEX_BIT_KHR,
    e_DISPATCH_BASE_KHR = VK_PIPELINE_CREATE_DISPATCH_BASE_KHR,
    e_DEFER_COMPILE_BIT_NV = VK_PIPELINE_CREATE_DEFER_COMPILE_BIT_NV,
    e_MAX_ENUM = 0x7FFFFFFF,
    e_ALL_BITS = e_DISABLE_OPTIMIZATION_BIT | e_ALLOW_DERIVATIVES_BIT | e_DERIVATIVE_BIT | e_VIEW_INDEX_FROM_DEVICE_INDEX_BIT | e_DISPATCH_BASE | e_VIEW_INDEX_FROM_DEVICE_INDEX_BIT_KHR | e_DISPATCH_BASE_KHR | e_DEFER_COMPILE_BIT_NV
};
DEFINE_ENUM_BITWISE_OPERATORS(PipelineCreateFlags)
inline std::string to_string(PipelineCreateFlags value)
{
    std::string returnString = "";
    bool addedFlags = false;
    if(static_cast<uint32_t>(value & PipelineCreateFlags::e_DISABLE_OPTIMIZATION_BIT) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_PIPELINE_CREATE_DISABLE_OPTIMIZATION_BIT";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & PipelineCreateFlags::e_ALLOW_DERIVATIVES_BIT) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_PIPELINE_CREATE_ALLOW_DERIVATIVES_BIT";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & PipelineCreateFlags::e_DERIVATIVE_BIT) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_PIPELINE_CREATE_DERIVATIVE_BIT";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & PipelineCreateFlags::e_VIEW_INDEX_FROM_DEVICE_INDEX_BIT) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_PIPELINE_CREATE_VIEW_INDEX_FROM_DEVICE_INDEX_BIT";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & PipelineCreateFlags::e_DISPATCH_BASE) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_PIPELINE_CREATE_DISPATCH_BASE";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & PipelineCreateFlags::e_VIEW_INDEX_FROM_DEVICE_INDEX_BIT_KHR) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_PIPELINE_CREATE_VIEW_INDEX_FROM_DEVICE_INDEX_BIT_KHR";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & PipelineCreateFlags::e_DISPATCH_BASE_KHR) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_PIPELINE_CREATE_DISPATCH_BASE_KHR";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & PipelineCreateFlags::e_DEFER_COMPILE_BIT_NV) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_PIPELINE_CREATE_DEFER_COMPILE_BIT_NV";
        addedFlags = true;
    }
    return returnString;
}

enum class ShaderStageFlags
{
    e_NONE = 0,
    e_VERTEX_BIT = VK_SHADER_STAGE_VERTEX_BIT,
    e_TESSELLATION_CONTROL_BIT = VK_SHADER_STAGE_TESSELLATION_CONTROL_BIT,
    e_TESSELLATION_EVALUATION_BIT = VK_SHADER_STAGE_TESSELLATION_EVALUATION_BIT,
    e_GEOMETRY_BIT = VK_SHADER_STAGE_GEOMETRY_BIT,
    e_FRAGMENT_BIT = VK_SHADER_STAGE_FRAGMENT_BIT,
    e_COMPUTE_BIT = VK_SHADER_STAGE_COMPUTE_BIT,
    e_ALL_GRAPHICS = VK_SHADER_STAGE_ALL_GRAPHICS,
    e_ALL = VK_SHADER_STAGE_ALL,
    e_RAYGEN_BIT_NV = VK_SHADER_STAGE_RAYGEN_BIT_NV,
    e_ANY_HIT_BIT_NV = VK_SHADER_STAGE_ANY_HIT_BIT_NV,
    e_CLOSEST_HIT_BIT_NV = VK_SHADER_STAGE_CLOSEST_HIT_BIT_NV,
    e_MISS_BIT_NV = VK_SHADER_STAGE_MISS_BIT_NV,
    e_INTERSECTION_BIT_NV = VK_SHADER_STAGE_INTERSECTION_BIT_NV,
    e_CALLABLE_BIT_NV = VK_SHADER_STAGE_CALLABLE_BIT_NV,
    e_TASK_BIT_NV = VK_SHADER_STAGE_TASK_BIT_NV,
    e_MESH_BIT_NV = VK_SHADER_STAGE_MESH_BIT_NV,
    e_MAX_ENUM = 0x7FFFFFFF,
    e_ALL_BITS = e_VERTEX_BIT | e_TESSELLATION_CONTROL_BIT | e_TESSELLATION_EVALUATION_BIT | e_GEOMETRY_BIT | e_FRAGMENT_BIT | e_COMPUTE_BIT | e_ALL_GRAPHICS | e_ALL | e_RAYGEN_BIT_NV | e_ANY_HIT_BIT_NV | e_CLOSEST_HIT_BIT_NV | e_MISS_BIT_NV | e_INTERSECTION_BIT_NV | e_CALLABLE_BIT_NV | e_TASK_BIT_NV | e_MESH_BIT_NV
};
DEFINE_ENUM_BITWISE_OPERATORS(ShaderStageFlags)
inline std::string to_string(ShaderStageFlags value)
{
    std::string returnString = "";
    bool addedFlags = false;
    if(static_cast<uint32_t>(value & ShaderStageFlags::e_VERTEX_BIT) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_SHADER_STAGE_VERTEX_BIT";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & ShaderStageFlags::e_TESSELLATION_CONTROL_BIT) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_SHADER_STAGE_TESSELLATION_CONTROL_BIT";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & ShaderStageFlags::e_TESSELLATION_EVALUATION_BIT) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_SHADER_STAGE_TESSELLATION_EVALUATION_BIT";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & ShaderStageFlags::e_GEOMETRY_BIT) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_SHADER_STAGE_GEOMETRY_BIT";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & ShaderStageFlags::e_FRAGMENT_BIT) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_SHADER_STAGE_FRAGMENT_BIT";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & ShaderStageFlags::e_COMPUTE_BIT) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_SHADER_STAGE_COMPUTE_BIT";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & ShaderStageFlags::e_ALL_GRAPHICS) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_SHADER_STAGE_ALL_GRAPHICS";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & ShaderStageFlags::e_ALL) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_SHADER_STAGE_ALL";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & ShaderStageFlags::e_RAYGEN_BIT_NV) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_SHADER_STAGE_RAYGEN_BIT_NV";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & ShaderStageFlags::e_ANY_HIT_BIT_NV) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_SHADER_STAGE_ANY_HIT_BIT_NV";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & ShaderStageFlags::e_CLOSEST_HIT_BIT_NV) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_SHADER_STAGE_CLOSEST_HIT_BIT_NV";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & ShaderStageFlags::e_MISS_BIT_NV) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_SHADER_STAGE_MISS_BIT_NV";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & ShaderStageFlags::e_INTERSECTION_BIT_NV) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_SHADER_STAGE_INTERSECTION_BIT_NV";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & ShaderStageFlags::e_CALLABLE_BIT_NV) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_SHADER_STAGE_CALLABLE_BIT_NV";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & ShaderStageFlags::e_TASK_BIT_NV) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_SHADER_STAGE_TASK_BIT_NV";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & ShaderStageFlags::e_MESH_BIT_NV) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_SHADER_STAGE_MESH_BIT_NV";
        addedFlags = true;
    }
    return returnString;
}

enum class VertexInputRate
{
    e_VERTEX = VK_VERTEX_INPUT_RATE_VERTEX,
    e_INSTANCE = VK_VERTEX_INPUT_RATE_INSTANCE,
    e_BEGIN_RANGE = VK_VERTEX_INPUT_RATE_BEGIN_RANGE,
    e_END_RANGE = VK_VERTEX_INPUT_RATE_END_RANGE,
    e_RANGE_SIZE = VK_VERTEX_INPUT_RATE_RANGE_SIZE,
    e_MAX_ENUM = 0x7FFFFFFF

};
DEFINE_ENUM_BITWISE_OPERATORS(VertexInputRate)
inline std::string to_string(VertexInputRate value)
{
    switch(value)
    {
    case VertexInputRate::e_VERTEX: return "VK_VERTEX_INPUT_RATE_VERTEX";
    case VertexInputRate::e_INSTANCE: return "VK_VERTEX_INPUT_RATE_INSTANCE";
    default: return "invalid";
    }
}

enum class PrimitiveTopology
{
    e_POINT_LIST = VK_PRIMITIVE_TOPOLOGY_POINT_LIST,
    e_LINE_LIST = VK_PRIMITIVE_TOPOLOGY_LINE_LIST,
    e_LINE_STRIP = VK_PRIMITIVE_TOPOLOGY_LINE_STRIP,
    e_TRIANGLE_LIST = VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST,
    e_TRIANGLE_STRIP = VK_PRIMITIVE_TOPOLOGY_TRIANGLE_STRIP,
    e_TRIANGLE_FAN = VK_PRIMITIVE_TOPOLOGY_TRIANGLE_FAN,
    e_LINE_LIST_WITH_ADJACENCY = VK_PRIMITIVE_TOPOLOGY_LINE_LIST_WITH_ADJACENCY,
    e_LINE_STRIP_WITH_ADJACENCY = VK_PRIMITIVE_TOPOLOGY_LINE_STRIP_WITH_ADJACENCY,
    e_TRIANGLE_LIST_WITH_ADJACENCY = VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST_WITH_ADJACENCY,
    e_TRIANGLE_STRIP_WITH_ADJACENCY = VK_PRIMITIVE_TOPOLOGY_TRIANGLE_STRIP_WITH_ADJACENCY,
    e_PATCH_LIST = VK_PRIMITIVE_TOPOLOGY_PATCH_LIST,
    e_BEGIN_RANGE = VK_PRIMITIVE_TOPOLOGY_BEGIN_RANGE,
    e_END_RANGE = VK_PRIMITIVE_TOPOLOGY_END_RANGE,
    e_RANGE_SIZE = VK_PRIMITIVE_TOPOLOGY_RANGE_SIZE,
    e_MAX_ENUM = 0x7FFFFFFF

};
DEFINE_ENUM_BITWISE_OPERATORS(PrimitiveTopology)
inline std::string to_string(PrimitiveTopology value)
{
    switch(value)
    {
    case PrimitiveTopology::e_POINT_LIST: return "VK_PRIMITIVE_TOPOLOGY_POINT_LIST";
    case PrimitiveTopology::e_LINE_LIST: return "VK_PRIMITIVE_TOPOLOGY_LINE_LIST";
    case PrimitiveTopology::e_LINE_STRIP: return "VK_PRIMITIVE_TOPOLOGY_LINE_STRIP";
    case PrimitiveTopology::e_TRIANGLE_LIST: return "VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST";
    case PrimitiveTopology::e_TRIANGLE_STRIP: return "VK_PRIMITIVE_TOPOLOGY_TRIANGLE_STRIP";
    case PrimitiveTopology::e_TRIANGLE_FAN: return "VK_PRIMITIVE_TOPOLOGY_TRIANGLE_FAN";
    case PrimitiveTopology::e_LINE_LIST_WITH_ADJACENCY: return "VK_PRIMITIVE_TOPOLOGY_LINE_LIST_WITH_ADJACENCY";
    case PrimitiveTopology::e_LINE_STRIP_WITH_ADJACENCY: return "VK_PRIMITIVE_TOPOLOGY_LINE_STRIP_WITH_ADJACENCY";
    case PrimitiveTopology::e_TRIANGLE_LIST_WITH_ADJACENCY: return "VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST_WITH_ADJACENCY";
    case PrimitiveTopology::e_TRIANGLE_STRIP_WITH_ADJACENCY: return "VK_PRIMITIVE_TOPOLOGY_TRIANGLE_STRIP_WITH_ADJACENCY";
    case PrimitiveTopology::e_PATCH_LIST: return "VK_PRIMITIVE_TOPOLOGY_PATCH_LIST";
    default: return "invalid";
    }
}

enum class PolygonMode
{
    e_FILL = VK_POLYGON_MODE_FILL,
    e_LINE = VK_POLYGON_MODE_LINE,
    e_POINT = VK_POLYGON_MODE_POINT,
    e_FILL_RECTANGLE_NV = VK_POLYGON_MODE_FILL_RECTANGLE_NV,
    e_BEGIN_RANGE = VK_POLYGON_MODE_BEGIN_RANGE,
    e_END_RANGE = VK_POLYGON_MODE_END_RANGE,
    e_RANGE_SIZE = VK_POLYGON_MODE_RANGE_SIZE,
    e_MAX_ENUM = 0x7FFFFFFF

};
DEFINE_ENUM_BITWISE_OPERATORS(PolygonMode)
inline std::string to_string(PolygonMode value)
{
    switch(value)
    {
    case PolygonMode::e_FILL: return "VK_POLYGON_MODE_FILL";
    case PolygonMode::e_LINE: return "VK_POLYGON_MODE_LINE";
    case PolygonMode::e_POINT: return "VK_POLYGON_MODE_POINT";
    case PolygonMode::e_FILL_RECTANGLE_NV: return "VK_POLYGON_MODE_FILL_RECTANGLE_NV";
    default: return "invalid";
    }
}

enum class CullModeFlags
{
    e_NONE = VK_CULL_MODE_NONE,
    e_FRONT_BIT = VK_CULL_MODE_FRONT_BIT,
    e_BACK_BIT = VK_CULL_MODE_BACK_BIT,
    e_FRONT_AND_BACK = VK_CULL_MODE_FRONT_AND_BACK,
    e_MAX_ENUM = 0x7FFFFFFF,
    e_ALL_BITS = e_NONE | e_FRONT_BIT | e_BACK_BIT | e_FRONT_AND_BACK
};
DEFINE_ENUM_BITWISE_OPERATORS(CullModeFlags)
inline std::string to_string(CullModeFlags value)
{
    std::string returnString = "";
    bool addedFlags = false;
    if(static_cast<uint32_t>(value & CullModeFlags::e_NONE) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_CULL_MODE_NONE";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & CullModeFlags::e_FRONT_BIT) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_CULL_MODE_FRONT_BIT";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & CullModeFlags::e_BACK_BIT) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_CULL_MODE_BACK_BIT";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & CullModeFlags::e_FRONT_AND_BACK) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_CULL_MODE_FRONT_AND_BACK";
        addedFlags = true;
    }
    return returnString;
}

enum class FrontFace
{
    e_COUNTER_CLOCKWISE = VK_FRONT_FACE_COUNTER_CLOCKWISE,
    e_CLOCKWISE = VK_FRONT_FACE_CLOCKWISE,
    e_BEGIN_RANGE = VK_FRONT_FACE_BEGIN_RANGE,
    e_END_RANGE = VK_FRONT_FACE_END_RANGE,
    e_RANGE_SIZE = VK_FRONT_FACE_RANGE_SIZE,
    e_MAX_ENUM = 0x7FFFFFFF

};
DEFINE_ENUM_BITWISE_OPERATORS(FrontFace)
inline std::string to_string(FrontFace value)
{
    switch(value)
    {
    case FrontFace::e_COUNTER_CLOCKWISE: return "VK_FRONT_FACE_COUNTER_CLOCKWISE";
    case FrontFace::e_CLOCKWISE: return "VK_FRONT_FACE_CLOCKWISE";
    default: return "invalid";
    }
}

enum class CompareOp
{
    e_NEVER = VK_COMPARE_OP_NEVER,
    e_LESS = VK_COMPARE_OP_LESS,
    e_EQUAL = VK_COMPARE_OP_EQUAL,
    e_LESS_OR_EQUAL = VK_COMPARE_OP_LESS_OR_EQUAL,
    e_GREATER = VK_COMPARE_OP_GREATER,
    e_NOT_EQUAL = VK_COMPARE_OP_NOT_EQUAL,
    e_GREATER_OR_EQUAL = VK_COMPARE_OP_GREATER_OR_EQUAL,
    e_ALWAYS = VK_COMPARE_OP_ALWAYS,
    e_BEGIN_RANGE = VK_COMPARE_OP_BEGIN_RANGE,
    e_END_RANGE = VK_COMPARE_OP_END_RANGE,
    e_RANGE_SIZE = VK_COMPARE_OP_RANGE_SIZE,
    e_MAX_ENUM = 0x7FFFFFFF

};
DEFINE_ENUM_BITWISE_OPERATORS(CompareOp)
inline std::string to_string(CompareOp value)
{
    switch(value)
    {
    case CompareOp::e_NEVER: return "VK_COMPARE_OP_NEVER";
    case CompareOp::e_LESS: return "VK_COMPARE_OP_LESS";
    case CompareOp::e_EQUAL: return "VK_COMPARE_OP_EQUAL";
    case CompareOp::e_LESS_OR_EQUAL: return "VK_COMPARE_OP_LESS_OR_EQUAL";
    case CompareOp::e_GREATER: return "VK_COMPARE_OP_GREATER";
    case CompareOp::e_NOT_EQUAL: return "VK_COMPARE_OP_NOT_EQUAL";
    case CompareOp::e_GREATER_OR_EQUAL: return "VK_COMPARE_OP_GREATER_OR_EQUAL";
    case CompareOp::e_ALWAYS: return "VK_COMPARE_OP_ALWAYS";
    default: return "invalid";
    }
}

enum class StencilOp
{
    e_KEEP = VK_STENCIL_OP_KEEP,
    e_ZERO = VK_STENCIL_OP_ZERO,
    e_REPLACE = VK_STENCIL_OP_REPLACE,
    e_INCREMENT_AND_CLAMP = VK_STENCIL_OP_INCREMENT_AND_CLAMP,
    e_DECREMENT_AND_CLAMP = VK_STENCIL_OP_DECREMENT_AND_CLAMP,
    e_INVERT = VK_STENCIL_OP_INVERT,
    e_INCREMENT_AND_WRAP = VK_STENCIL_OP_INCREMENT_AND_WRAP,
    e_DECREMENT_AND_WRAP = VK_STENCIL_OP_DECREMENT_AND_WRAP,
    e_BEGIN_RANGE = VK_STENCIL_OP_BEGIN_RANGE,
    e_END_RANGE = VK_STENCIL_OP_END_RANGE,
    e_RANGE_SIZE = VK_STENCIL_OP_RANGE_SIZE,
    e_MAX_ENUM = 0x7FFFFFFF

};
DEFINE_ENUM_BITWISE_OPERATORS(StencilOp)
inline std::string to_string(StencilOp value)
{
    switch(value)
    {
    case StencilOp::e_KEEP: return "VK_STENCIL_OP_KEEP";
    case StencilOp::e_ZERO: return "VK_STENCIL_OP_ZERO";
    case StencilOp::e_REPLACE: return "VK_STENCIL_OP_REPLACE";
    case StencilOp::e_INCREMENT_AND_CLAMP: return "VK_STENCIL_OP_INCREMENT_AND_CLAMP";
    case StencilOp::e_DECREMENT_AND_CLAMP: return "VK_STENCIL_OP_DECREMENT_AND_CLAMP";
    case StencilOp::e_INVERT: return "VK_STENCIL_OP_INVERT";
    case StencilOp::e_INCREMENT_AND_WRAP: return "VK_STENCIL_OP_INCREMENT_AND_WRAP";
    case StencilOp::e_DECREMENT_AND_WRAP: return "VK_STENCIL_OP_DECREMENT_AND_WRAP";
    default: return "invalid";
    }
}

enum class LogicOp
{
    e_CLEAR = VK_LOGIC_OP_CLEAR,
    e_AND = VK_LOGIC_OP_AND,
    e_AND_REVERSE = VK_LOGIC_OP_AND_REVERSE,
    e_COPY = VK_LOGIC_OP_COPY,
    e_AND_INVERTED = VK_LOGIC_OP_AND_INVERTED,
    e_NO_OP = VK_LOGIC_OP_NO_OP,
    e_XOR = VK_LOGIC_OP_XOR,
    e_OR = VK_LOGIC_OP_OR,
    e_NOR = VK_LOGIC_OP_NOR,
    e_EQUIVALENT = VK_LOGIC_OP_EQUIVALENT,
    e_INVERT = VK_LOGIC_OP_INVERT,
    e_OR_REVERSE = VK_LOGIC_OP_OR_REVERSE,
    e_COPY_INVERTED = VK_LOGIC_OP_COPY_INVERTED,
    e_OR_INVERTED = VK_LOGIC_OP_OR_INVERTED,
    e_NAND = VK_LOGIC_OP_NAND,
    e_SET = VK_LOGIC_OP_SET,
    e_BEGIN_RANGE = VK_LOGIC_OP_BEGIN_RANGE,
    e_END_RANGE = VK_LOGIC_OP_END_RANGE,
    e_RANGE_SIZE = VK_LOGIC_OP_RANGE_SIZE,
    e_MAX_ENUM = 0x7FFFFFFF

};
DEFINE_ENUM_BITWISE_OPERATORS(LogicOp)
inline std::string to_string(LogicOp value)
{
    switch(value)
    {
    case LogicOp::e_CLEAR: return "VK_LOGIC_OP_CLEAR";
    case LogicOp::e_AND: return "VK_LOGIC_OP_AND";
    case LogicOp::e_AND_REVERSE: return "VK_LOGIC_OP_AND_REVERSE";
    case LogicOp::e_COPY: return "VK_LOGIC_OP_COPY";
    case LogicOp::e_AND_INVERTED: return "VK_LOGIC_OP_AND_INVERTED";
    case LogicOp::e_NO_OP: return "VK_LOGIC_OP_NO_OP";
    case LogicOp::e_XOR: return "VK_LOGIC_OP_XOR";
    case LogicOp::e_OR: return "VK_LOGIC_OP_OR";
    case LogicOp::e_NOR: return "VK_LOGIC_OP_NOR";
    case LogicOp::e_EQUIVALENT: return "VK_LOGIC_OP_EQUIVALENT";
    case LogicOp::e_INVERT: return "VK_LOGIC_OP_INVERT";
    case LogicOp::e_OR_REVERSE: return "VK_LOGIC_OP_OR_REVERSE";
    case LogicOp::e_COPY_INVERTED: return "VK_LOGIC_OP_COPY_INVERTED";
    case LogicOp::e_OR_INVERTED: return "VK_LOGIC_OP_OR_INVERTED";
    case LogicOp::e_NAND: return "VK_LOGIC_OP_NAND";
    case LogicOp::e_SET: return "VK_LOGIC_OP_SET";
    default: return "invalid";
    }
}

enum class BlendFactor
{
    e_ZERO = VK_BLEND_FACTOR_ZERO,
    e_ONE = VK_BLEND_FACTOR_ONE,
    e_SRC_COLOR = VK_BLEND_FACTOR_SRC_COLOR,
    e_ONE_MINUS_SRC_COLOR = VK_BLEND_FACTOR_ONE_MINUS_SRC_COLOR,
    e_DST_COLOR = VK_BLEND_FACTOR_DST_COLOR,
    e_ONE_MINUS_DST_COLOR = VK_BLEND_FACTOR_ONE_MINUS_DST_COLOR,
    e_SRC_ALPHA = VK_BLEND_FACTOR_SRC_ALPHA,
    e_ONE_MINUS_SRC_ALPHA = VK_BLEND_FACTOR_ONE_MINUS_SRC_ALPHA,
    e_DST_ALPHA = VK_BLEND_FACTOR_DST_ALPHA,
    e_ONE_MINUS_DST_ALPHA = VK_BLEND_FACTOR_ONE_MINUS_DST_ALPHA,
    e_CONSTANT_COLOR = VK_BLEND_FACTOR_CONSTANT_COLOR,
    e_ONE_MINUS_CONSTANT_COLOR = VK_BLEND_FACTOR_ONE_MINUS_CONSTANT_COLOR,
    e_CONSTANT_ALPHA = VK_BLEND_FACTOR_CONSTANT_ALPHA,
    e_ONE_MINUS_CONSTANT_ALPHA = VK_BLEND_FACTOR_ONE_MINUS_CONSTANT_ALPHA,
    e_SRC_ALPHA_SATURATE = VK_BLEND_FACTOR_SRC_ALPHA_SATURATE,
    e_SRC1_COLOR = VK_BLEND_FACTOR_SRC1_COLOR,
    e_ONE_MINUS_SRC1_COLOR = VK_BLEND_FACTOR_ONE_MINUS_SRC1_COLOR,
    e_SRC1_ALPHA = VK_BLEND_FACTOR_SRC1_ALPHA,
    e_ONE_MINUS_SRC1_ALPHA = VK_BLEND_FACTOR_ONE_MINUS_SRC1_ALPHA,
    e_BEGIN_RANGE = VK_BLEND_FACTOR_BEGIN_RANGE,
    e_END_RANGE = VK_BLEND_FACTOR_END_RANGE,
    e_RANGE_SIZE = VK_BLEND_FACTOR_RANGE_SIZE,
    e_MAX_ENUM = 0x7FFFFFFF

};
DEFINE_ENUM_BITWISE_OPERATORS(BlendFactor)
inline std::string to_string(BlendFactor value)
{
    switch(value)
    {
    case BlendFactor::e_ZERO: return "VK_BLEND_FACTOR_ZERO";
    case BlendFactor::e_ONE: return "VK_BLEND_FACTOR_ONE";
    case BlendFactor::e_SRC_COLOR: return "VK_BLEND_FACTOR_SRC_COLOR";
    case BlendFactor::e_ONE_MINUS_SRC_COLOR: return "VK_BLEND_FACTOR_ONE_MINUS_SRC_COLOR";
    case BlendFactor::e_DST_COLOR: return "VK_BLEND_FACTOR_DST_COLOR";
    case BlendFactor::e_ONE_MINUS_DST_COLOR: return "VK_BLEND_FACTOR_ONE_MINUS_DST_COLOR";
    case BlendFactor::e_SRC_ALPHA: return "VK_BLEND_FACTOR_SRC_ALPHA";
    case BlendFactor::e_ONE_MINUS_SRC_ALPHA: return "VK_BLEND_FACTOR_ONE_MINUS_SRC_ALPHA";
    case BlendFactor::e_DST_ALPHA: return "VK_BLEND_FACTOR_DST_ALPHA";
    case BlendFactor::e_ONE_MINUS_DST_ALPHA: return "VK_BLEND_FACTOR_ONE_MINUS_DST_ALPHA";
    case BlendFactor::e_CONSTANT_COLOR: return "VK_BLEND_FACTOR_CONSTANT_COLOR";
    case BlendFactor::e_ONE_MINUS_CONSTANT_COLOR: return "VK_BLEND_FACTOR_ONE_MINUS_CONSTANT_COLOR";
    case BlendFactor::e_CONSTANT_ALPHA: return "VK_BLEND_FACTOR_CONSTANT_ALPHA";
    case BlendFactor::e_ONE_MINUS_CONSTANT_ALPHA: return "VK_BLEND_FACTOR_ONE_MINUS_CONSTANT_ALPHA";
    case BlendFactor::e_SRC_ALPHA_SATURATE: return "VK_BLEND_FACTOR_SRC_ALPHA_SATURATE";
    case BlendFactor::e_SRC1_COLOR: return "VK_BLEND_FACTOR_SRC1_COLOR";
    case BlendFactor::e_ONE_MINUS_SRC1_COLOR: return "VK_BLEND_FACTOR_ONE_MINUS_SRC1_COLOR";
    case BlendFactor::e_SRC1_ALPHA: return "VK_BLEND_FACTOR_SRC1_ALPHA";
    case BlendFactor::e_ONE_MINUS_SRC1_ALPHA: return "VK_BLEND_FACTOR_ONE_MINUS_SRC1_ALPHA";
    default: return "invalid";
    }
}

enum class BlendOp
{
    e_ADD = VK_BLEND_OP_ADD,
    e_SUBTRACT = VK_BLEND_OP_SUBTRACT,
    e_REVERSE_SUBTRACT = VK_BLEND_OP_REVERSE_SUBTRACT,
    e_MIN = VK_BLEND_OP_MIN,
    e_MAX = VK_BLEND_OP_MAX,
    e_ZERO_EXT = VK_BLEND_OP_ZERO_EXT,
    e_SRC_EXT = VK_BLEND_OP_SRC_EXT,
    e_DST_EXT = VK_BLEND_OP_DST_EXT,
    e_SRC_OVER_EXT = VK_BLEND_OP_SRC_OVER_EXT,
    e_DST_OVER_EXT = VK_BLEND_OP_DST_OVER_EXT,
    e_SRC_IN_EXT = VK_BLEND_OP_SRC_IN_EXT,
    e_DST_IN_EXT = VK_BLEND_OP_DST_IN_EXT,
    e_SRC_OUT_EXT = VK_BLEND_OP_SRC_OUT_EXT,
    e_DST_OUT_EXT = VK_BLEND_OP_DST_OUT_EXT,
    e_SRC_ATOP_EXT = VK_BLEND_OP_SRC_ATOP_EXT,
    e_DST_ATOP_EXT = VK_BLEND_OP_DST_ATOP_EXT,
    e_XOR_EXT = VK_BLEND_OP_XOR_EXT,
    e_MULTIPLY_EXT = VK_BLEND_OP_MULTIPLY_EXT,
    e_SCREEN_EXT = VK_BLEND_OP_SCREEN_EXT,
    e_OVERLAY_EXT = VK_BLEND_OP_OVERLAY_EXT,
    e_DARKEN_EXT = VK_BLEND_OP_DARKEN_EXT,
    e_LIGHTEN_EXT = VK_BLEND_OP_LIGHTEN_EXT,
    e_COLORDODGE_EXT = VK_BLEND_OP_COLORDODGE_EXT,
    e_COLORBURN_EXT = VK_BLEND_OP_COLORBURN_EXT,
    e_HARDLIGHT_EXT = VK_BLEND_OP_HARDLIGHT_EXT,
    e_SOFTLIGHT_EXT = VK_BLEND_OP_SOFTLIGHT_EXT,
    e_DIFFERENCE_EXT = VK_BLEND_OP_DIFFERENCE_EXT,
    e_EXCLUSION_EXT = VK_BLEND_OP_EXCLUSION_EXT,
    e_INVERT_EXT = VK_BLEND_OP_INVERT_EXT,
    e_INVERT_RGB_EXT = VK_BLEND_OP_INVERT_RGB_EXT,
    e_LINEARDODGE_EXT = VK_BLEND_OP_LINEARDODGE_EXT,
    e_LINEARBURN_EXT = VK_BLEND_OP_LINEARBURN_EXT,
    e_VIVIDLIGHT_EXT = VK_BLEND_OP_VIVIDLIGHT_EXT,
    e_LINEARLIGHT_EXT = VK_BLEND_OP_LINEARLIGHT_EXT,
    e_PINLIGHT_EXT = VK_BLEND_OP_PINLIGHT_EXT,
    e_HARDMIX_EXT = VK_BLEND_OP_HARDMIX_EXT,
    e_HSL_HUE_EXT = VK_BLEND_OP_HSL_HUE_EXT,
    e_HSL_SATURATION_EXT = VK_BLEND_OP_HSL_SATURATION_EXT,
    e_HSL_COLOR_EXT = VK_BLEND_OP_HSL_COLOR_EXT,
    e_HSL_LUMINOSITY_EXT = VK_BLEND_OP_HSL_LUMINOSITY_EXT,
    e_PLUS_EXT = VK_BLEND_OP_PLUS_EXT,
    e_PLUS_CLAMPED_EXT = VK_BLEND_OP_PLUS_CLAMPED_EXT,
    e_PLUS_CLAMPED_ALPHA_EXT = VK_BLEND_OP_PLUS_CLAMPED_ALPHA_EXT,
    e_PLUS_DARKER_EXT = VK_BLEND_OP_PLUS_DARKER_EXT,
    e_MINUS_EXT = VK_BLEND_OP_MINUS_EXT,
    e_MINUS_CLAMPED_EXT = VK_BLEND_OP_MINUS_CLAMPED_EXT,
    e_CONTRAST_EXT = VK_BLEND_OP_CONTRAST_EXT,
    e_INVERT_OVG_EXT = VK_BLEND_OP_INVERT_OVG_EXT,
    e_RED_EXT = VK_BLEND_OP_RED_EXT,
    e_GREEN_EXT = VK_BLEND_OP_GREEN_EXT,
    e_BLUE_EXT = VK_BLEND_OP_BLUE_EXT,
    e_BEGIN_RANGE = VK_BLEND_OP_BEGIN_RANGE,
    e_END_RANGE = VK_BLEND_OP_END_RANGE,
    e_RANGE_SIZE = VK_BLEND_OP_RANGE_SIZE,
    e_MAX_ENUM = 0x7FFFFFFF

};
DEFINE_ENUM_BITWISE_OPERATORS(BlendOp)
inline std::string to_string(BlendOp value)
{
    switch(value)
    {
    case BlendOp::e_ADD: return "VK_BLEND_OP_ADD";
    case BlendOp::e_SUBTRACT: return "VK_BLEND_OP_SUBTRACT";
    case BlendOp::e_REVERSE_SUBTRACT: return "VK_BLEND_OP_REVERSE_SUBTRACT";
    case BlendOp::e_MIN: return "VK_BLEND_OP_MIN";
    case BlendOp::e_MAX: return "VK_BLEND_OP_MAX";
    case BlendOp::e_ZERO_EXT: return "VK_BLEND_OP_ZERO_EXT";
    case BlendOp::e_SRC_EXT: return "VK_BLEND_OP_SRC_EXT";
    case BlendOp::e_DST_EXT: return "VK_BLEND_OP_DST_EXT";
    case BlendOp::e_SRC_OVER_EXT: return "VK_BLEND_OP_SRC_OVER_EXT";
    case BlendOp::e_DST_OVER_EXT: return "VK_BLEND_OP_DST_OVER_EXT";
    case BlendOp::e_SRC_IN_EXT: return "VK_BLEND_OP_SRC_IN_EXT";
    case BlendOp::e_DST_IN_EXT: return "VK_BLEND_OP_DST_IN_EXT";
    case BlendOp::e_SRC_OUT_EXT: return "VK_BLEND_OP_SRC_OUT_EXT";
    case BlendOp::e_DST_OUT_EXT: return "VK_BLEND_OP_DST_OUT_EXT";
    case BlendOp::e_SRC_ATOP_EXT: return "VK_BLEND_OP_SRC_ATOP_EXT";
    case BlendOp::e_DST_ATOP_EXT: return "VK_BLEND_OP_DST_ATOP_EXT";
    case BlendOp::e_XOR_EXT: return "VK_BLEND_OP_XOR_EXT";
    case BlendOp::e_MULTIPLY_EXT: return "VK_BLEND_OP_MULTIPLY_EXT";
    case BlendOp::e_SCREEN_EXT: return "VK_BLEND_OP_SCREEN_EXT";
    case BlendOp::e_OVERLAY_EXT: return "VK_BLEND_OP_OVERLAY_EXT";
    case BlendOp::e_DARKEN_EXT: return "VK_BLEND_OP_DARKEN_EXT";
    case BlendOp::e_LIGHTEN_EXT: return "VK_BLEND_OP_LIGHTEN_EXT";
    case BlendOp::e_COLORDODGE_EXT: return "VK_BLEND_OP_COLORDODGE_EXT";
    case BlendOp::e_COLORBURN_EXT: return "VK_BLEND_OP_COLORBURN_EXT";
    case BlendOp::e_HARDLIGHT_EXT: return "VK_BLEND_OP_HARDLIGHT_EXT";
    case BlendOp::e_SOFTLIGHT_EXT: return "VK_BLEND_OP_SOFTLIGHT_EXT";
    case BlendOp::e_DIFFERENCE_EXT: return "VK_BLEND_OP_DIFFERENCE_EXT";
    case BlendOp::e_EXCLUSION_EXT: return "VK_BLEND_OP_EXCLUSION_EXT";
    case BlendOp::e_INVERT_EXT: return "VK_BLEND_OP_INVERT_EXT";
    case BlendOp::e_INVERT_RGB_EXT: return "VK_BLEND_OP_INVERT_RGB_EXT";
    case BlendOp::e_LINEARDODGE_EXT: return "VK_BLEND_OP_LINEARDODGE_EXT";
    case BlendOp::e_LINEARBURN_EXT: return "VK_BLEND_OP_LINEARBURN_EXT";
    case BlendOp::e_VIVIDLIGHT_EXT: return "VK_BLEND_OP_VIVIDLIGHT_EXT";
    case BlendOp::e_LINEARLIGHT_EXT: return "VK_BLEND_OP_LINEARLIGHT_EXT";
    case BlendOp::e_PINLIGHT_EXT: return "VK_BLEND_OP_PINLIGHT_EXT";
    case BlendOp::e_HARDMIX_EXT: return "VK_BLEND_OP_HARDMIX_EXT";
    case BlendOp::e_HSL_HUE_EXT: return "VK_BLEND_OP_HSL_HUE_EXT";
    case BlendOp::e_HSL_SATURATION_EXT: return "VK_BLEND_OP_HSL_SATURATION_EXT";
    case BlendOp::e_HSL_COLOR_EXT: return "VK_BLEND_OP_HSL_COLOR_EXT";
    case BlendOp::e_HSL_LUMINOSITY_EXT: return "VK_BLEND_OP_HSL_LUMINOSITY_EXT";
    case BlendOp::e_PLUS_EXT: return "VK_BLEND_OP_PLUS_EXT";
    case BlendOp::e_PLUS_CLAMPED_EXT: return "VK_BLEND_OP_PLUS_CLAMPED_EXT";
    case BlendOp::e_PLUS_CLAMPED_ALPHA_EXT: return "VK_BLEND_OP_PLUS_CLAMPED_ALPHA_EXT";
    case BlendOp::e_PLUS_DARKER_EXT: return "VK_BLEND_OP_PLUS_DARKER_EXT";
    case BlendOp::e_MINUS_EXT: return "VK_BLEND_OP_MINUS_EXT";
    case BlendOp::e_MINUS_CLAMPED_EXT: return "VK_BLEND_OP_MINUS_CLAMPED_EXT";
    case BlendOp::e_CONTRAST_EXT: return "VK_BLEND_OP_CONTRAST_EXT";
    case BlendOp::e_INVERT_OVG_EXT: return "VK_BLEND_OP_INVERT_OVG_EXT";
    case BlendOp::e_RED_EXT: return "VK_BLEND_OP_RED_EXT";
    case BlendOp::e_GREEN_EXT: return "VK_BLEND_OP_GREEN_EXT";
    case BlendOp::e_BLUE_EXT: return "VK_BLEND_OP_BLUE_EXT";
    default: return "invalid";
    }
}

enum class ColorComponentFlags
{
    e_NONE = 0,
    e_R_BIT = VK_COLOR_COMPONENT_R_BIT,
    e_G_BIT = VK_COLOR_COMPONENT_G_BIT,
    e_B_BIT = VK_COLOR_COMPONENT_B_BIT,
    e_A_BIT = VK_COLOR_COMPONENT_A_BIT,
    e_MAX_ENUM = 0x7FFFFFFF,
    e_ALL_BITS = e_R_BIT | e_G_BIT | e_B_BIT | e_A_BIT
};
DEFINE_ENUM_BITWISE_OPERATORS(ColorComponentFlags)
inline std::string to_string(ColorComponentFlags value)
{
    std::string returnString = "";
    bool addedFlags = false;
    if(static_cast<uint32_t>(value & ColorComponentFlags::e_R_BIT) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_COLOR_COMPONENT_R_BIT";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & ColorComponentFlags::e_G_BIT) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_COLOR_COMPONENT_G_BIT";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & ColorComponentFlags::e_B_BIT) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_COLOR_COMPONENT_B_BIT";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & ColorComponentFlags::e_A_BIT) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_COLOR_COMPONENT_A_BIT";
        addedFlags = true;
    }
    return returnString;
}

enum class DynamicState
{
    e_VIEWPORT = VK_DYNAMIC_STATE_VIEWPORT,
    e_SCISSOR = VK_DYNAMIC_STATE_SCISSOR,
    e_LINE_WIDTH = VK_DYNAMIC_STATE_LINE_WIDTH,
    e_DEPTH_BIAS = VK_DYNAMIC_STATE_DEPTH_BIAS,
    e_BLEND_CONSTANTS = VK_DYNAMIC_STATE_BLEND_CONSTANTS,
    e_DEPTH_BOUNDS = VK_DYNAMIC_STATE_DEPTH_BOUNDS,
    e_STENCIL_COMPARE_MASK = VK_DYNAMIC_STATE_STENCIL_COMPARE_MASK,
    e_STENCIL_WRITE_MASK = VK_DYNAMIC_STATE_STENCIL_WRITE_MASK,
    e_STENCIL_REFERENCE = VK_DYNAMIC_STATE_STENCIL_REFERENCE,
    e_VIEWPORT_W_SCALING_NV = VK_DYNAMIC_STATE_VIEWPORT_W_SCALING_NV,
    e_DISCARD_RECTANGLE_EXT = VK_DYNAMIC_STATE_DISCARD_RECTANGLE_EXT,
    e_SAMPLE_LOCATIONS_EXT = VK_DYNAMIC_STATE_SAMPLE_LOCATIONS_EXT,
    e_VIEWPORT_SHADING_RATE_PALETTE_NV = VK_DYNAMIC_STATE_VIEWPORT_SHADING_RATE_PALETTE_NV,
    e_VIEWPORT_COARSE_SAMPLE_ORDER_NV = VK_DYNAMIC_STATE_VIEWPORT_COARSE_SAMPLE_ORDER_NV,
    e_EXCLUSIVE_SCISSOR_NV = VK_DYNAMIC_STATE_EXCLUSIVE_SCISSOR_NV,
    e_BEGIN_RANGE = VK_DYNAMIC_STATE_BEGIN_RANGE,
    e_END_RANGE = VK_DYNAMIC_STATE_END_RANGE,
    e_RANGE_SIZE = VK_DYNAMIC_STATE_RANGE_SIZE,
    e_MAX_ENUM = 0x7FFFFFFF

};
DEFINE_ENUM_BITWISE_OPERATORS(DynamicState)
inline std::string to_string(DynamicState value)
{
    switch(value)
    {
    case DynamicState::e_VIEWPORT: return "VK_DYNAMIC_STATE_VIEWPORT";
    case DynamicState::e_SCISSOR: return "VK_DYNAMIC_STATE_SCISSOR";
    case DynamicState::e_LINE_WIDTH: return "VK_DYNAMIC_STATE_LINE_WIDTH";
    case DynamicState::e_DEPTH_BIAS: return "VK_DYNAMIC_STATE_DEPTH_BIAS";
    case DynamicState::e_BLEND_CONSTANTS: return "VK_DYNAMIC_STATE_BLEND_CONSTANTS";
    case DynamicState::e_DEPTH_BOUNDS: return "VK_DYNAMIC_STATE_DEPTH_BOUNDS";
    case DynamicState::e_STENCIL_COMPARE_MASK: return "VK_DYNAMIC_STATE_STENCIL_COMPARE_MASK";
    case DynamicState::e_STENCIL_WRITE_MASK: return "VK_DYNAMIC_STATE_STENCIL_WRITE_MASK";
    case DynamicState::e_STENCIL_REFERENCE: return "VK_DYNAMIC_STATE_STENCIL_REFERENCE";
    case DynamicState::e_VIEWPORT_W_SCALING_NV: return "VK_DYNAMIC_STATE_VIEWPORT_W_SCALING_NV";
    case DynamicState::e_DISCARD_RECTANGLE_EXT: return "VK_DYNAMIC_STATE_DISCARD_RECTANGLE_EXT";
    case DynamicState::e_SAMPLE_LOCATIONS_EXT: return "VK_DYNAMIC_STATE_SAMPLE_LOCATIONS_EXT";
    case DynamicState::e_VIEWPORT_SHADING_RATE_PALETTE_NV: return "VK_DYNAMIC_STATE_VIEWPORT_SHADING_RATE_PALETTE_NV";
    case DynamicState::e_VIEWPORT_COARSE_SAMPLE_ORDER_NV: return "VK_DYNAMIC_STATE_VIEWPORT_COARSE_SAMPLE_ORDER_NV";
    case DynamicState::e_EXCLUSIVE_SCISSOR_NV: return "VK_DYNAMIC_STATE_EXCLUSIVE_SCISSOR_NV";
    default: return "invalid";
    }
}

enum class Filter
{
    e_NEAREST = VK_FILTER_NEAREST,
    e_LINEAR = VK_FILTER_LINEAR,
    e_CUBIC_IMG = VK_FILTER_CUBIC_IMG,
    e_BEGIN_RANGE = VK_FILTER_BEGIN_RANGE,
    e_END_RANGE = VK_FILTER_END_RANGE,
    e_RANGE_SIZE = VK_FILTER_RANGE_SIZE,
    e_MAX_ENUM = 0x7FFFFFFF

};
DEFINE_ENUM_BITWISE_OPERATORS(Filter)
inline std::string to_string(Filter value)
{
    switch(value)
    {
    case Filter::e_NEAREST: return "VK_FILTER_NEAREST";
    case Filter::e_LINEAR: return "VK_FILTER_LINEAR";
    case Filter::e_CUBIC_IMG: return "VK_FILTER_CUBIC_IMG";
    default: return "invalid";
    }
}

enum class SamplerMipmapMode
{
    e_NEAREST = VK_SAMPLER_MIPMAP_MODE_NEAREST,
    e_LINEAR = VK_SAMPLER_MIPMAP_MODE_LINEAR,
    e_BEGIN_RANGE = VK_SAMPLER_MIPMAP_MODE_BEGIN_RANGE,
    e_END_RANGE = VK_SAMPLER_MIPMAP_MODE_END_RANGE,
    e_RANGE_SIZE = VK_SAMPLER_MIPMAP_MODE_RANGE_SIZE,
    e_MAX_ENUM = 0x7FFFFFFF

};
DEFINE_ENUM_BITWISE_OPERATORS(SamplerMipmapMode)
inline std::string to_string(SamplerMipmapMode value)
{
    switch(value)
    {
    case SamplerMipmapMode::e_NEAREST: return "VK_SAMPLER_MIPMAP_MODE_NEAREST";
    case SamplerMipmapMode::e_LINEAR: return "VK_SAMPLER_MIPMAP_MODE_LINEAR";
    default: return "invalid";
    }
}

enum class SamplerAddressMode
{
    e_REPEAT = VK_SAMPLER_ADDRESS_MODE_REPEAT,
    e_MIRRORED_REPEAT = VK_SAMPLER_ADDRESS_MODE_MIRRORED_REPEAT,
    e_CLAMP_TO_EDGE = VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_EDGE,
    e_CLAMP_TO_BORDER = VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_BORDER,
    e_MIRROR_CLAMP_TO_EDGE = VK_SAMPLER_ADDRESS_MODE_MIRROR_CLAMP_TO_EDGE,
    e_BEGIN_RANGE = VK_SAMPLER_ADDRESS_MODE_BEGIN_RANGE,
    e_END_RANGE = VK_SAMPLER_ADDRESS_MODE_END_RANGE,
    e_RANGE_SIZE = VK_SAMPLER_ADDRESS_MODE_RANGE_SIZE,
    e_MAX_ENUM = 0x7FFFFFFF

};
DEFINE_ENUM_BITWISE_OPERATORS(SamplerAddressMode)
inline std::string to_string(SamplerAddressMode value)
{
    switch(value)
    {
    case SamplerAddressMode::e_REPEAT: return "VK_SAMPLER_ADDRESS_MODE_REPEAT";
    case SamplerAddressMode::e_MIRRORED_REPEAT: return "VK_SAMPLER_ADDRESS_MODE_MIRRORED_REPEAT";
    case SamplerAddressMode::e_CLAMP_TO_EDGE: return "VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_EDGE";
    case SamplerAddressMode::e_CLAMP_TO_BORDER: return "VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_BORDER";
    case SamplerAddressMode::e_MIRROR_CLAMP_TO_EDGE: return "VK_SAMPLER_ADDRESS_MODE_MIRROR_CLAMP_TO_EDGE";
    default: return "invalid";
    }
}

enum class BorderColor
{
    e_FLOAT_TRANSPARENT_BLACK = VK_BORDER_COLOR_FLOAT_TRANSPARENT_BLACK,
    e_INT_TRANSPARENT_BLACK = VK_BORDER_COLOR_INT_TRANSPARENT_BLACK,
    e_FLOAT_OPAQUE_BLACK = VK_BORDER_COLOR_FLOAT_OPAQUE_BLACK,
    e_INT_OPAQUE_BLACK = VK_BORDER_COLOR_INT_OPAQUE_BLACK,
    e_FLOAT_OPAQUE_WHITE = VK_BORDER_COLOR_FLOAT_OPAQUE_WHITE,
    e_INT_OPAQUE_WHITE = VK_BORDER_COLOR_INT_OPAQUE_WHITE,
    e_BEGIN_RANGE = VK_BORDER_COLOR_BEGIN_RANGE,
    e_END_RANGE = VK_BORDER_COLOR_END_RANGE,
    e_RANGE_SIZE = VK_BORDER_COLOR_RANGE_SIZE,
    e_MAX_ENUM = 0x7FFFFFFF

};
DEFINE_ENUM_BITWISE_OPERATORS(BorderColor)
inline std::string to_string(BorderColor value)
{
    switch(value)
    {
    case BorderColor::e_FLOAT_TRANSPARENT_BLACK: return "VK_BORDER_COLOR_FLOAT_TRANSPARENT_BLACK";
    case BorderColor::e_INT_TRANSPARENT_BLACK: return "VK_BORDER_COLOR_INT_TRANSPARENT_BLACK";
    case BorderColor::e_FLOAT_OPAQUE_BLACK: return "VK_BORDER_COLOR_FLOAT_OPAQUE_BLACK";
    case BorderColor::e_INT_OPAQUE_BLACK: return "VK_BORDER_COLOR_INT_OPAQUE_BLACK";
    case BorderColor::e_FLOAT_OPAQUE_WHITE: return "VK_BORDER_COLOR_FLOAT_OPAQUE_WHITE";
    case BorderColor::e_INT_OPAQUE_WHITE: return "VK_BORDER_COLOR_INT_OPAQUE_WHITE";
    default: return "invalid";
    }
}

enum class DescriptorSetLayoutCreateFlags
{
    e_NONE = 0,
    e_PUSH_DESCRIPTOR_BIT_KHR = VK_DESCRIPTOR_SET_LAYOUT_CREATE_PUSH_DESCRIPTOR_BIT_KHR,
    e_UPDATE_AFTER_BIND_POOL_BIT_EXT = VK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT_EXT,
    e_MAX_ENUM = 0x7FFFFFFF,
    e_ALL_BITS = e_PUSH_DESCRIPTOR_BIT_KHR | e_UPDATE_AFTER_BIND_POOL_BIT_EXT
};
DEFINE_ENUM_BITWISE_OPERATORS(DescriptorSetLayoutCreateFlags)
inline std::string to_string(DescriptorSetLayoutCreateFlags value)
{
    std::string returnString = "";
    bool addedFlags = false;
    if(static_cast<uint32_t>(value & DescriptorSetLayoutCreateFlags::e_PUSH_DESCRIPTOR_BIT_KHR) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_DESCRIPTOR_SET_LAYOUT_CREATE_PUSH_DESCRIPTOR_BIT_KHR";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & DescriptorSetLayoutCreateFlags::e_UPDATE_AFTER_BIND_POOL_BIT_EXT) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT_EXT";
        addedFlags = true;
    }
    return returnString;
}

enum class DescriptorType
{
    e_SAMPLER = VK_DESCRIPTOR_TYPE_SAMPLER,
    e_COMBINED_IMAGE_SAMPLER = VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER,
    e_SAMPLED_IMAGE = VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE,
    e_STORAGE_IMAGE = VK_DESCRIPTOR_TYPE_STORAGE_IMAGE,
    e_UNIFORM_TEXEL_BUFFER = VK_DESCRIPTOR_TYPE_UNIFORM_TEXEL_BUFFER,
    e_STORAGE_TEXEL_BUFFER = VK_DESCRIPTOR_TYPE_STORAGE_TEXEL_BUFFER,
    e_UNIFORM_BUFFER = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER,
    e_STORAGE_BUFFER = VK_DESCRIPTOR_TYPE_STORAGE_BUFFER,
    e_UNIFORM_BUFFER_DYNAMIC = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC,
    e_STORAGE_BUFFER_DYNAMIC = VK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC,
    e_INPUT_ATTACHMENT = VK_DESCRIPTOR_TYPE_INPUT_ATTACHMENT,
    e_INLINE_UNIFORM_BLOCK_EXT = VK_DESCRIPTOR_TYPE_INLINE_UNIFORM_BLOCK_EXT,
    e_ACCELERATION_STRUCTURE_NV = VK_DESCRIPTOR_TYPE_ACCELERATION_STRUCTURE_NV,
    e_BEGIN_RANGE = VK_DESCRIPTOR_TYPE_BEGIN_RANGE,
    e_END_RANGE = VK_DESCRIPTOR_TYPE_END_RANGE,
    e_RANGE_SIZE = VK_DESCRIPTOR_TYPE_RANGE_SIZE,
    e_MAX_ENUM = 0x7FFFFFFF

};
DEFINE_ENUM_BITWISE_OPERATORS(DescriptorType)
inline std::string to_string(DescriptorType value)
{
    switch(value)
    {
    case DescriptorType::e_SAMPLER: return "VK_DESCRIPTOR_TYPE_SAMPLER";
    case DescriptorType::e_COMBINED_IMAGE_SAMPLER: return "VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER";
    case DescriptorType::e_SAMPLED_IMAGE: return "VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE";
    case DescriptorType::e_STORAGE_IMAGE: return "VK_DESCRIPTOR_TYPE_STORAGE_IMAGE";
    case DescriptorType::e_UNIFORM_TEXEL_BUFFER: return "VK_DESCRIPTOR_TYPE_UNIFORM_TEXEL_BUFFER";
    case DescriptorType::e_STORAGE_TEXEL_BUFFER: return "VK_DESCRIPTOR_TYPE_STORAGE_TEXEL_BUFFER";
    case DescriptorType::e_UNIFORM_BUFFER: return "VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER";
    case DescriptorType::e_STORAGE_BUFFER: return "VK_DESCRIPTOR_TYPE_STORAGE_BUFFER";
    case DescriptorType::e_UNIFORM_BUFFER_DYNAMIC: return "VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC";
    case DescriptorType::e_STORAGE_BUFFER_DYNAMIC: return "VK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC";
    case DescriptorType::e_INPUT_ATTACHMENT: return "VK_DESCRIPTOR_TYPE_INPUT_ATTACHMENT";
    case DescriptorType::e_INLINE_UNIFORM_BLOCK_EXT: return "VK_DESCRIPTOR_TYPE_INLINE_UNIFORM_BLOCK_EXT";
    case DescriptorType::e_ACCELERATION_STRUCTURE_NV: return "VK_DESCRIPTOR_TYPE_ACCELERATION_STRUCTURE_NV";
    default: return "invalid";
    }
}

enum class DescriptorPoolCreateFlags
{
    e_NONE = 0,
    e_FREE_DESCRIPTOR_SET_BIT = VK_DESCRIPTOR_POOL_CREATE_FREE_DESCRIPTOR_SET_BIT,
    e_UPDATE_AFTER_BIND_BIT_EXT = VK_DESCRIPTOR_POOL_CREATE_UPDATE_AFTER_BIND_BIT_EXT,
    e_MAX_ENUM = 0x7FFFFFFF,
    e_ALL_BITS = e_FREE_DESCRIPTOR_SET_BIT | e_UPDATE_AFTER_BIND_BIT_EXT
};
DEFINE_ENUM_BITWISE_OPERATORS(DescriptorPoolCreateFlags)
inline std::string to_string(DescriptorPoolCreateFlags value)
{
    std::string returnString = "";
    bool addedFlags = false;
    if(static_cast<uint32_t>(value & DescriptorPoolCreateFlags::e_FREE_DESCRIPTOR_SET_BIT) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_DESCRIPTOR_POOL_CREATE_FREE_DESCRIPTOR_SET_BIT";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & DescriptorPoolCreateFlags::e_UPDATE_AFTER_BIND_BIT_EXT) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_DESCRIPTOR_POOL_CREATE_UPDATE_AFTER_BIND_BIT_EXT";
        addedFlags = true;
    }
    return returnString;
}

enum class AttachmentDescriptionFlags
{
    e_NONE = 0,
    e_MAY_ALIAS_BIT = VK_ATTACHMENT_DESCRIPTION_MAY_ALIAS_BIT,
    e_MAX_ENUM = 0x7FFFFFFF,
    e_ALL_BITS = e_MAY_ALIAS_BIT
};
DEFINE_ENUM_BITWISE_OPERATORS(AttachmentDescriptionFlags)
inline std::string to_string(AttachmentDescriptionFlags value)
{
    std::string returnString = "";
    bool addedFlags = false;
    if(static_cast<uint32_t>(value & AttachmentDescriptionFlags::e_MAY_ALIAS_BIT) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_ATTACHMENT_DESCRIPTION_MAY_ALIAS_BIT";
        addedFlags = true;
    }
    return returnString;
}

enum class AttachmentLoadOp
{
    e_LOAD = VK_ATTACHMENT_LOAD_OP_LOAD,
    e_CLEAR = VK_ATTACHMENT_LOAD_OP_CLEAR,
    e_DONT_CARE = VK_ATTACHMENT_LOAD_OP_DONT_CARE,
    e_BEGIN_RANGE = VK_ATTACHMENT_LOAD_OP_BEGIN_RANGE,
    e_END_RANGE = VK_ATTACHMENT_LOAD_OP_END_RANGE,
    e_RANGE_SIZE = VK_ATTACHMENT_LOAD_OP_RANGE_SIZE,
    e_MAX_ENUM = 0x7FFFFFFF

};
DEFINE_ENUM_BITWISE_OPERATORS(AttachmentLoadOp)
inline std::string to_string(AttachmentLoadOp value)
{
    switch(value)
    {
    case AttachmentLoadOp::e_LOAD: return "VK_ATTACHMENT_LOAD_OP_LOAD";
    case AttachmentLoadOp::e_CLEAR: return "VK_ATTACHMENT_LOAD_OP_CLEAR";
    case AttachmentLoadOp::e_DONT_CARE: return "VK_ATTACHMENT_LOAD_OP_DONT_CARE";
    default: return "invalid";
    }
}

enum class AttachmentStoreOp
{
    e_STORE = VK_ATTACHMENT_STORE_OP_STORE,
    e_DONT_CARE = VK_ATTACHMENT_STORE_OP_DONT_CARE,
    e_BEGIN_RANGE = VK_ATTACHMENT_STORE_OP_BEGIN_RANGE,
    e_END_RANGE = VK_ATTACHMENT_STORE_OP_END_RANGE,
    e_RANGE_SIZE = VK_ATTACHMENT_STORE_OP_RANGE_SIZE,
    e_MAX_ENUM = 0x7FFFFFFF

};
DEFINE_ENUM_BITWISE_OPERATORS(AttachmentStoreOp)
inline std::string to_string(AttachmentStoreOp value)
{
    switch(value)
    {
    case AttachmentStoreOp::e_STORE: return "VK_ATTACHMENT_STORE_OP_STORE";
    case AttachmentStoreOp::e_DONT_CARE: return "VK_ATTACHMENT_STORE_OP_DONT_CARE";
    default: return "invalid";
    }
}

enum class SubpassDescriptionFlags
{
    e_NONE = 0,
    e_PER_VIEW_ATTRIBUTES_BIT_NVX = VK_SUBPASS_DESCRIPTION_PER_VIEW_ATTRIBUTES_BIT_NVX,
    e_PER_VIEW_POSITION_X_ONLY_BIT_NVX = VK_SUBPASS_DESCRIPTION_PER_VIEW_POSITION_X_ONLY_BIT_NVX,
    e_MAX_ENUM = 0x7FFFFFFF,
    e_ALL_BITS = e_PER_VIEW_ATTRIBUTES_BIT_NVX | e_PER_VIEW_POSITION_X_ONLY_BIT_NVX
};
DEFINE_ENUM_BITWISE_OPERATORS(SubpassDescriptionFlags)
inline std::string to_string(SubpassDescriptionFlags value)
{
    std::string returnString = "";
    bool addedFlags = false;
    if(static_cast<uint32_t>(value & SubpassDescriptionFlags::e_PER_VIEW_ATTRIBUTES_BIT_NVX) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_SUBPASS_DESCRIPTION_PER_VIEW_ATTRIBUTES_BIT_NVX";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & SubpassDescriptionFlags::e_PER_VIEW_POSITION_X_ONLY_BIT_NVX) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_SUBPASS_DESCRIPTION_PER_VIEW_POSITION_X_ONLY_BIT_NVX";
        addedFlags = true;
    }
    return returnString;
}

enum class PipelineBindPoint
{
    e_GRAPHICS = VK_PIPELINE_BIND_POINT_GRAPHICS,
    e_COMPUTE = VK_PIPELINE_BIND_POINT_COMPUTE,
    e_RAY_TRACING_NV = VK_PIPELINE_BIND_POINT_RAY_TRACING_NV,
    e_BEGIN_RANGE = VK_PIPELINE_BIND_POINT_BEGIN_RANGE,
    e_END_RANGE = VK_PIPELINE_BIND_POINT_END_RANGE,
    e_RANGE_SIZE = VK_PIPELINE_BIND_POINT_RANGE_SIZE,
    e_MAX_ENUM = 0x7FFFFFFF

};
DEFINE_ENUM_BITWISE_OPERATORS(PipelineBindPoint)
inline std::string to_string(PipelineBindPoint value)
{
    switch(value)
    {
    case PipelineBindPoint::e_GRAPHICS: return "VK_PIPELINE_BIND_POINT_GRAPHICS";
    case PipelineBindPoint::e_COMPUTE: return "VK_PIPELINE_BIND_POINT_COMPUTE";
    case PipelineBindPoint::e_RAY_TRACING_NV: return "VK_PIPELINE_BIND_POINT_RAY_TRACING_NV";
    default: return "invalid";
    }
}

enum class AccessFlags
{
    e_NONE = 0,
    e_INDIRECT_COMMAND_READ_BIT = VK_ACCESS_INDIRECT_COMMAND_READ_BIT,
    e_INDEX_READ_BIT = VK_ACCESS_INDEX_READ_BIT,
    e_VERTEX_ATTRIBUTE_READ_BIT = VK_ACCESS_VERTEX_ATTRIBUTE_READ_BIT,
    e_UNIFORM_READ_BIT = VK_ACCESS_UNIFORM_READ_BIT,
    e_INPUT_ATTACHMENT_READ_BIT = VK_ACCESS_INPUT_ATTACHMENT_READ_BIT,
    e_SHADER_READ_BIT = VK_ACCESS_SHADER_READ_BIT,
    e_SHADER_WRITE_BIT = VK_ACCESS_SHADER_WRITE_BIT,
    e_COLOR_ATTACHMENT_READ_BIT = VK_ACCESS_COLOR_ATTACHMENT_READ_BIT,
    e_COLOR_ATTACHMENT_WRITE_BIT = VK_ACCESS_COLOR_ATTACHMENT_WRITE_BIT,
    e_DEPTH_STENCIL_ATTACHMENT_READ_BIT = VK_ACCESS_DEPTH_STENCIL_ATTACHMENT_READ_BIT,
    e_DEPTH_STENCIL_ATTACHMENT_WRITE_BIT = VK_ACCESS_DEPTH_STENCIL_ATTACHMENT_WRITE_BIT,
    e_TRANSFER_READ_BIT = VK_ACCESS_TRANSFER_READ_BIT,
    e_TRANSFER_WRITE_BIT = VK_ACCESS_TRANSFER_WRITE_BIT,
    e_HOST_READ_BIT = VK_ACCESS_HOST_READ_BIT,
    e_HOST_WRITE_BIT = VK_ACCESS_HOST_WRITE_BIT,
    e_MEMORY_READ_BIT = VK_ACCESS_MEMORY_READ_BIT,
    e_MEMORY_WRITE_BIT = VK_ACCESS_MEMORY_WRITE_BIT,
    e_TRANSFORM_FEEDBACK_WRITE_BIT_EXT = VK_ACCESS_TRANSFORM_FEEDBACK_WRITE_BIT_EXT,
    e_TRANSFORM_FEEDBACK_COUNTER_READ_BIT_EXT = VK_ACCESS_TRANSFORM_FEEDBACK_COUNTER_READ_BIT_EXT,
    e_TRANSFORM_FEEDBACK_COUNTER_WRITE_BIT_EXT = VK_ACCESS_TRANSFORM_FEEDBACK_COUNTER_WRITE_BIT_EXT,
    e_CONDITIONAL_RENDERING_READ_BIT_EXT = VK_ACCESS_CONDITIONAL_RENDERING_READ_BIT_EXT,
    e_COMMAND_PROCESS_READ_BIT_NVX = VK_ACCESS_COMMAND_PROCESS_READ_BIT_NVX,
    e_COMMAND_PROCESS_WRITE_BIT_NVX = VK_ACCESS_COMMAND_PROCESS_WRITE_BIT_NVX,
    e_COLOR_ATTACHMENT_READ_NONCOHERENT_BIT_EXT = VK_ACCESS_COLOR_ATTACHMENT_READ_NONCOHERENT_BIT_EXT,
    e_SHADING_RATE_IMAGE_READ_BIT_NV = VK_ACCESS_SHADING_RATE_IMAGE_READ_BIT_NV,
    e_ACCELERATION_STRUCTURE_READ_BIT_NV = VK_ACCESS_ACCELERATION_STRUCTURE_READ_BIT_NV,
    e_ACCELERATION_STRUCTURE_WRITE_BIT_NV = VK_ACCESS_ACCELERATION_STRUCTURE_WRITE_BIT_NV,
    e_MAX_ENUM = 0x7FFFFFFF,
    e_ALL_BITS = e_INDIRECT_COMMAND_READ_BIT | e_INDEX_READ_BIT | e_VERTEX_ATTRIBUTE_READ_BIT | e_UNIFORM_READ_BIT | e_INPUT_ATTACHMENT_READ_BIT | e_SHADER_READ_BIT | e_SHADER_WRITE_BIT | e_COLOR_ATTACHMENT_READ_BIT | e_COLOR_ATTACHMENT_WRITE_BIT | e_DEPTH_STENCIL_ATTACHMENT_READ_BIT | e_DEPTH_STENCIL_ATTACHMENT_WRITE_BIT | e_TRANSFER_READ_BIT | e_TRANSFER_WRITE_BIT | e_HOST_READ_BIT | e_HOST_WRITE_BIT | e_MEMORY_READ_BIT | e_MEMORY_WRITE_BIT | e_TRANSFORM_FEEDBACK_WRITE_BIT_EXT | e_TRANSFORM_FEEDBACK_COUNTER_READ_BIT_EXT | e_TRANSFORM_FEEDBACK_COUNTER_WRITE_BIT_EXT | e_CONDITIONAL_RENDERING_READ_BIT_EXT | e_COMMAND_PROCESS_READ_BIT_NVX | e_COMMAND_PROCESS_WRITE_BIT_NVX | e_COLOR_ATTACHMENT_READ_NONCOHERENT_BIT_EXT | e_SHADING_RATE_IMAGE_READ_BIT_NV | e_ACCELERATION_STRUCTURE_READ_BIT_NV | e_ACCELERATION_STRUCTURE_WRITE_BIT_NV
};
DEFINE_ENUM_BITWISE_OPERATORS(AccessFlags)
inline std::string to_string(AccessFlags value)
{
    std::string returnString = "";
    bool addedFlags = false;
    if(static_cast<uint32_t>(value & AccessFlags::e_INDIRECT_COMMAND_READ_BIT) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_ACCESS_INDIRECT_COMMAND_READ_BIT";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & AccessFlags::e_INDEX_READ_BIT) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_ACCESS_INDEX_READ_BIT";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & AccessFlags::e_VERTEX_ATTRIBUTE_READ_BIT) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_ACCESS_VERTEX_ATTRIBUTE_READ_BIT";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & AccessFlags::e_UNIFORM_READ_BIT) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_ACCESS_UNIFORM_READ_BIT";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & AccessFlags::e_INPUT_ATTACHMENT_READ_BIT) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_ACCESS_INPUT_ATTACHMENT_READ_BIT";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & AccessFlags::e_SHADER_READ_BIT) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_ACCESS_SHADER_READ_BIT";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & AccessFlags::e_SHADER_WRITE_BIT) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_ACCESS_SHADER_WRITE_BIT";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & AccessFlags::e_COLOR_ATTACHMENT_READ_BIT) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_ACCESS_COLOR_ATTACHMENT_READ_BIT";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & AccessFlags::e_COLOR_ATTACHMENT_WRITE_BIT) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_ACCESS_COLOR_ATTACHMENT_WRITE_BIT";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & AccessFlags::e_DEPTH_STENCIL_ATTACHMENT_READ_BIT) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_ACCESS_DEPTH_STENCIL_ATTACHMENT_READ_BIT";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & AccessFlags::e_DEPTH_STENCIL_ATTACHMENT_WRITE_BIT) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_ACCESS_DEPTH_STENCIL_ATTACHMENT_WRITE_BIT";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & AccessFlags::e_TRANSFER_READ_BIT) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_ACCESS_TRANSFER_READ_BIT";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & AccessFlags::e_TRANSFER_WRITE_BIT) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_ACCESS_TRANSFER_WRITE_BIT";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & AccessFlags::e_HOST_READ_BIT) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_ACCESS_HOST_READ_BIT";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & AccessFlags::e_HOST_WRITE_BIT) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_ACCESS_HOST_WRITE_BIT";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & AccessFlags::e_MEMORY_READ_BIT) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_ACCESS_MEMORY_READ_BIT";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & AccessFlags::e_MEMORY_WRITE_BIT) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_ACCESS_MEMORY_WRITE_BIT";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & AccessFlags::e_TRANSFORM_FEEDBACK_WRITE_BIT_EXT) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_ACCESS_TRANSFORM_FEEDBACK_WRITE_BIT_EXT";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & AccessFlags::e_TRANSFORM_FEEDBACK_COUNTER_READ_BIT_EXT) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_ACCESS_TRANSFORM_FEEDBACK_COUNTER_READ_BIT_EXT";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & AccessFlags::e_TRANSFORM_FEEDBACK_COUNTER_WRITE_BIT_EXT) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_ACCESS_TRANSFORM_FEEDBACK_COUNTER_WRITE_BIT_EXT";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & AccessFlags::e_CONDITIONAL_RENDERING_READ_BIT_EXT) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_ACCESS_CONDITIONAL_RENDERING_READ_BIT_EXT";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & AccessFlags::e_COMMAND_PROCESS_READ_BIT_NVX) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_ACCESS_COMMAND_PROCESS_READ_BIT_NVX";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & AccessFlags::e_COMMAND_PROCESS_WRITE_BIT_NVX) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_ACCESS_COMMAND_PROCESS_WRITE_BIT_NVX";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & AccessFlags::e_COLOR_ATTACHMENT_READ_NONCOHERENT_BIT_EXT) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_ACCESS_COLOR_ATTACHMENT_READ_NONCOHERENT_BIT_EXT";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & AccessFlags::e_SHADING_RATE_IMAGE_READ_BIT_NV) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_ACCESS_SHADING_RATE_IMAGE_READ_BIT_NV";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & AccessFlags::e_ACCELERATION_STRUCTURE_READ_BIT_NV) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_ACCESS_ACCELERATION_STRUCTURE_READ_BIT_NV";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & AccessFlags::e_ACCELERATION_STRUCTURE_WRITE_BIT_NV) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_ACCESS_ACCELERATION_STRUCTURE_WRITE_BIT_NV";
        addedFlags = true;
    }
    return returnString;
}

enum class DependencyFlags
{
    e_NONE = 0,
    e_BY_REGION_BIT = VK_DEPENDENCY_BY_REGION_BIT,
    e_DEVICE_GROUP_BIT = VK_DEPENDENCY_DEVICE_GROUP_BIT,
    e_VIEW_LOCAL_BIT = VK_DEPENDENCY_VIEW_LOCAL_BIT,
    e_VIEW_LOCAL_BIT_KHR = VK_DEPENDENCY_VIEW_LOCAL_BIT_KHR,
    e_DEVICE_GROUP_BIT_KHR = VK_DEPENDENCY_DEVICE_GROUP_BIT_KHR,
    e_MAX_ENUM = 0x7FFFFFFF,
    e_ALL_BITS = e_BY_REGION_BIT | e_DEVICE_GROUP_BIT | e_VIEW_LOCAL_BIT | e_VIEW_LOCAL_BIT_KHR | e_DEVICE_GROUP_BIT_KHR
};
DEFINE_ENUM_BITWISE_OPERATORS(DependencyFlags)
inline std::string to_string(DependencyFlags value)
{
    std::string returnString = "";
    bool addedFlags = false;
    if(static_cast<uint32_t>(value & DependencyFlags::e_BY_REGION_BIT) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_DEPENDENCY_BY_REGION_BIT";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & DependencyFlags::e_DEVICE_GROUP_BIT) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_DEPENDENCY_DEVICE_GROUP_BIT";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & DependencyFlags::e_VIEW_LOCAL_BIT) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_DEPENDENCY_VIEW_LOCAL_BIT";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & DependencyFlags::e_VIEW_LOCAL_BIT_KHR) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_DEPENDENCY_VIEW_LOCAL_BIT_KHR";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & DependencyFlags::e_DEVICE_GROUP_BIT_KHR) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_DEPENDENCY_DEVICE_GROUP_BIT_KHR";
        addedFlags = true;
    }
    return returnString;
}

enum class CommandPoolCreateFlags
{
    e_NONE = 0,
    e_TRANSIENT_BIT = VK_COMMAND_POOL_CREATE_TRANSIENT_BIT,
    e_RESET_COMMAND_BUFFER_BIT = VK_COMMAND_POOL_CREATE_RESET_COMMAND_BUFFER_BIT,
    e_PROTECTED_BIT = VK_COMMAND_POOL_CREATE_PROTECTED_BIT,
    e_MAX_ENUM = 0x7FFFFFFF,
    e_ALL_BITS = e_TRANSIENT_BIT | e_RESET_COMMAND_BUFFER_BIT | e_PROTECTED_BIT
};
DEFINE_ENUM_BITWISE_OPERATORS(CommandPoolCreateFlags)
inline std::string to_string(CommandPoolCreateFlags value)
{
    std::string returnString = "";
    bool addedFlags = false;
    if(static_cast<uint32_t>(value & CommandPoolCreateFlags::e_TRANSIENT_BIT) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_COMMAND_POOL_CREATE_TRANSIENT_BIT";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & CommandPoolCreateFlags::e_RESET_COMMAND_BUFFER_BIT) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_COMMAND_POOL_CREATE_RESET_COMMAND_BUFFER_BIT";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & CommandPoolCreateFlags::e_PROTECTED_BIT) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_COMMAND_POOL_CREATE_PROTECTED_BIT";
        addedFlags = true;
    }
    return returnString;
}

enum class CommandPoolResetFlags
{
    e_NONE = 0,
    e_RELEASE_RESOURCES_BIT = VK_COMMAND_POOL_RESET_RELEASE_RESOURCES_BIT,
    e_MAX_ENUM = 0x7FFFFFFF,
    e_ALL_BITS = e_RELEASE_RESOURCES_BIT
};
DEFINE_ENUM_BITWISE_OPERATORS(CommandPoolResetFlags)
inline std::string to_string(CommandPoolResetFlags value)
{
    std::string returnString = "";
    bool addedFlags = false;
    if(static_cast<uint32_t>(value & CommandPoolResetFlags::e_RELEASE_RESOURCES_BIT) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_COMMAND_POOL_RESET_RELEASE_RESOURCES_BIT";
        addedFlags = true;
    }
    return returnString;
}

enum class CommandBufferLevel
{
    e_PRIMARY = VK_COMMAND_BUFFER_LEVEL_PRIMARY,
    e_SECONDARY = VK_COMMAND_BUFFER_LEVEL_SECONDARY,
    e_BEGIN_RANGE = VK_COMMAND_BUFFER_LEVEL_BEGIN_RANGE,
    e_END_RANGE = VK_COMMAND_BUFFER_LEVEL_END_RANGE,
    e_RANGE_SIZE = VK_COMMAND_BUFFER_LEVEL_RANGE_SIZE,
    e_MAX_ENUM = 0x7FFFFFFF

};
DEFINE_ENUM_BITWISE_OPERATORS(CommandBufferLevel)
inline std::string to_string(CommandBufferLevel value)
{
    switch(value)
    {
    case CommandBufferLevel::e_PRIMARY: return "VK_COMMAND_BUFFER_LEVEL_PRIMARY";
    case CommandBufferLevel::e_SECONDARY: return "VK_COMMAND_BUFFER_LEVEL_SECONDARY";
    default: return "invalid";
    }
}

enum class CommandBufferUsageFlags
{
    e_NONE = 0,
    e_ONE_TIME_SUBMIT_BIT = VK_COMMAND_BUFFER_USAGE_ONE_TIME_SUBMIT_BIT,
    e_RENDER_PASS_CONTINUE_BIT = VK_COMMAND_BUFFER_USAGE_RENDER_PASS_CONTINUE_BIT,
    e_SIMULTANEOUS_USE_BIT = VK_COMMAND_BUFFER_USAGE_SIMULTANEOUS_USE_BIT,
    e_MAX_ENUM = 0x7FFFFFFF,
    e_ALL_BITS = e_ONE_TIME_SUBMIT_BIT | e_RENDER_PASS_CONTINUE_BIT | e_SIMULTANEOUS_USE_BIT
};
DEFINE_ENUM_BITWISE_OPERATORS(CommandBufferUsageFlags)
inline std::string to_string(CommandBufferUsageFlags value)
{
    std::string returnString = "";
    bool addedFlags = false;
    if(static_cast<uint32_t>(value & CommandBufferUsageFlags::e_ONE_TIME_SUBMIT_BIT) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_COMMAND_BUFFER_USAGE_ONE_TIME_SUBMIT_BIT";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & CommandBufferUsageFlags::e_RENDER_PASS_CONTINUE_BIT) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_COMMAND_BUFFER_USAGE_RENDER_PASS_CONTINUE_BIT";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & CommandBufferUsageFlags::e_SIMULTANEOUS_USE_BIT) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_COMMAND_BUFFER_USAGE_SIMULTANEOUS_USE_BIT";
        addedFlags = true;
    }
    return returnString;
}

enum class QueryControlFlags
{
    e_NONE = 0,
    e_PRECISE_BIT = VK_QUERY_CONTROL_PRECISE_BIT,
    e_MAX_ENUM = 0x7FFFFFFF,
    e_ALL_BITS = e_PRECISE_BIT
};
DEFINE_ENUM_BITWISE_OPERATORS(QueryControlFlags)
inline std::string to_string(QueryControlFlags value)
{
    std::string returnString = "";
    bool addedFlags = false;
    if(static_cast<uint32_t>(value & QueryControlFlags::e_PRECISE_BIT) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_QUERY_CONTROL_PRECISE_BIT";
        addedFlags = true;
    }
    return returnString;
}

enum class CommandBufferResetFlags
{
    e_NONE = 0,
    e_RELEASE_RESOURCES_BIT = VK_COMMAND_BUFFER_RESET_RELEASE_RESOURCES_BIT,
    e_MAX_ENUM = 0x7FFFFFFF,
    e_ALL_BITS = e_RELEASE_RESOURCES_BIT
};
DEFINE_ENUM_BITWISE_OPERATORS(CommandBufferResetFlags)
inline std::string to_string(CommandBufferResetFlags value)
{
    std::string returnString = "";
    bool addedFlags = false;
    if(static_cast<uint32_t>(value & CommandBufferResetFlags::e_RELEASE_RESOURCES_BIT) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_COMMAND_BUFFER_RESET_RELEASE_RESOURCES_BIT";
        addedFlags = true;
    }
    return returnString;
}

enum class StencilFaceFlags
{
    e_NONE = 0,
    e_FRONT_BIT = VK_STENCIL_FACE_FRONT_BIT,
    e_BACK_BIT = VK_STENCIL_FACE_BACK_BIT,
    e_VK_STENCIL_FRONT_AND_BACK = VK_STENCIL_FRONT_AND_BACK,
    e_MAX_ENUM = 0x7FFFFFFF,
    e_ALL_BITS = e_FRONT_BIT | e_BACK_BIT | e_VK_STENCIL_FRONT_AND_BACK
};
DEFINE_ENUM_BITWISE_OPERATORS(StencilFaceFlags)
inline std::string to_string(StencilFaceFlags value)
{
    std::string returnString = "";
    bool addedFlags = false;
    if(static_cast<uint32_t>(value & StencilFaceFlags::e_FRONT_BIT) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_STENCIL_FACE_FRONT_BIT";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & StencilFaceFlags::e_BACK_BIT) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_STENCIL_FACE_BACK_BIT";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & StencilFaceFlags::e_VK_STENCIL_FRONT_AND_BACK) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_STENCIL_FRONT_AND_BACK";
        addedFlags = true;
    }
    return returnString;
}

enum class IndexType
{
    e_UINT16 = VK_INDEX_TYPE_UINT16,
    e_UINT32 = VK_INDEX_TYPE_UINT32,
    e_NONE_NV = VK_INDEX_TYPE_NONE_NV,
    e_BEGIN_RANGE = VK_INDEX_TYPE_BEGIN_RANGE,
    e_END_RANGE = VK_INDEX_TYPE_END_RANGE,
    e_RANGE_SIZE = VK_INDEX_TYPE_RANGE_SIZE,
    e_MAX_ENUM = 0x7FFFFFFF

};
DEFINE_ENUM_BITWISE_OPERATORS(IndexType)
inline std::string to_string(IndexType value)
{
    switch(value)
    {
    case IndexType::e_UINT16: return "VK_INDEX_TYPE_UINT16";
    case IndexType::e_UINT32: return "VK_INDEX_TYPE_UINT32";
    case IndexType::e_NONE_NV: return "VK_INDEX_TYPE_NONE_NV";
    default: return "invalid";
    }
}

enum class SubpassContents
{
    e_INLINE = VK_SUBPASS_CONTENTS_INLINE,
    e_SECONDARY_COMMAND_BUFFERS = VK_SUBPASS_CONTENTS_SECONDARY_COMMAND_BUFFERS,
    e_BEGIN_RANGE = VK_SUBPASS_CONTENTS_BEGIN_RANGE,
    e_END_RANGE = VK_SUBPASS_CONTENTS_END_RANGE,
    e_RANGE_SIZE = VK_SUBPASS_CONTENTS_RANGE_SIZE,
    e_MAX_ENUM = 0x7FFFFFFF

};
DEFINE_ENUM_BITWISE_OPERATORS(SubpassContents)
inline std::string to_string(SubpassContents value)
{
    switch(value)
    {
    case SubpassContents::e_INLINE: return "VK_SUBPASS_CONTENTS_INLINE";
    case SubpassContents::e_SECONDARY_COMMAND_BUFFERS: return "VK_SUBPASS_CONTENTS_SECONDARY_COMMAND_BUFFERS";
    default: return "invalid";
    }
}

enum class ObjectType
{
    e_UNKNOWN = VK_OBJECT_TYPE_UNKNOWN,
    e_INSTANCE = VK_OBJECT_TYPE_INSTANCE,
    e_PHYSICAL_DEVICE = VK_OBJECT_TYPE_PHYSICAL_DEVICE,
    e_DEVICE = VK_OBJECT_TYPE_DEVICE,
    e_QUEUE = VK_OBJECT_TYPE_QUEUE,
    e_SEMAPHORE = VK_OBJECT_TYPE_SEMAPHORE,
    e_COMMAND_BUFFER = VK_OBJECT_TYPE_COMMAND_BUFFER,
    e_FENCE = VK_OBJECT_TYPE_FENCE,
    e_DEVICE_MEMORY = VK_OBJECT_TYPE_DEVICE_MEMORY,
    e_BUFFER = VK_OBJECT_TYPE_BUFFER,
    e_IMAGE = VK_OBJECT_TYPE_IMAGE,
    e_EVENT = VK_OBJECT_TYPE_EVENT,
    e_QUERY_POOL = VK_OBJECT_TYPE_QUERY_POOL,
    e_BUFFER_VIEW = VK_OBJECT_TYPE_BUFFER_VIEW,
    e_IMAGE_VIEW = VK_OBJECT_TYPE_IMAGE_VIEW,
    e_SHADER_MODULE = VK_OBJECT_TYPE_SHADER_MODULE,
    e_PIPELINE_CACHE = VK_OBJECT_TYPE_PIPELINE_CACHE,
    e_PIPELINE_LAYOUT = VK_OBJECT_TYPE_PIPELINE_LAYOUT,
    e_RENDER_PASS = VK_OBJECT_TYPE_RENDER_PASS,
    e_PIPELINE = VK_OBJECT_TYPE_PIPELINE,
    e_DESCRIPTOR_SET_LAYOUT = VK_OBJECT_TYPE_DESCRIPTOR_SET_LAYOUT,
    e_SAMPLER = VK_OBJECT_TYPE_SAMPLER,
    e_DESCRIPTOR_POOL = VK_OBJECT_TYPE_DESCRIPTOR_POOL,
    e_DESCRIPTOR_SET = VK_OBJECT_TYPE_DESCRIPTOR_SET,
    e_FRAMEBUFFER = VK_OBJECT_TYPE_FRAMEBUFFER,
    e_COMMAND_POOL = VK_OBJECT_TYPE_COMMAND_POOL,
    e_SAMPLER_YCBCR_CONVERSION = VK_OBJECT_TYPE_SAMPLER_YCBCR_CONVERSION,
    e_DESCRIPTOR_UPDATE_TEMPLATE = VK_OBJECT_TYPE_DESCRIPTOR_UPDATE_TEMPLATE,
    e_SURFACE_KHR = VK_OBJECT_TYPE_SURFACE_KHR,
    e_SWAPCHAIN_KHR = VK_OBJECT_TYPE_SWAPCHAIN_KHR,
    e_DISPLAY_KHR = VK_OBJECT_TYPE_DISPLAY_KHR,
    e_DISPLAY_MODE_KHR = VK_OBJECT_TYPE_DISPLAY_MODE_KHR,
    e_DEBUG_REPORT_CALLBACK_EXT = VK_OBJECT_TYPE_DEBUG_REPORT_CALLBACK_EXT,
    e_DESCRIPTOR_UPDATE_TEMPLATE_KHR = VK_OBJECT_TYPE_DESCRIPTOR_UPDATE_TEMPLATE_KHR,
    e_OBJECT_TABLE_NVX = VK_OBJECT_TYPE_OBJECT_TABLE_NVX,
    e_INDIRECT_COMMANDS_LAYOUT_NVX = VK_OBJECT_TYPE_INDIRECT_COMMANDS_LAYOUT_NVX,
    e_DEBUG_UTILS_MESSENGER_EXT = VK_OBJECT_TYPE_DEBUG_UTILS_MESSENGER_EXT,
    e_SAMPLER_YCBCR_CONVERSION_KHR = VK_OBJECT_TYPE_SAMPLER_YCBCR_CONVERSION_KHR,
    e_VALIDATION_CACHE_EXT = VK_OBJECT_TYPE_VALIDATION_CACHE_EXT,
    e_ACCELERATION_STRUCTURE_NV = VK_OBJECT_TYPE_ACCELERATION_STRUCTURE_NV,
    e_BEGIN_RANGE = VK_OBJECT_TYPE_BEGIN_RANGE,
    e_END_RANGE = VK_OBJECT_TYPE_END_RANGE,
    e_RANGE_SIZE = VK_OBJECT_TYPE_RANGE_SIZE,
    e_MAX_ENUM = 0x7FFFFFFF

};
DEFINE_ENUM_BITWISE_OPERATORS(ObjectType)
inline std::string to_string(ObjectType value)
{
    switch(value)
    {
    case ObjectType::e_UNKNOWN: return "VK_OBJECT_TYPE_UNKNOWN";
    case ObjectType::e_INSTANCE: return "VK_OBJECT_TYPE_INSTANCE";
    case ObjectType::e_PHYSICAL_DEVICE: return "VK_OBJECT_TYPE_PHYSICAL_DEVICE";
    case ObjectType::e_DEVICE: return "VK_OBJECT_TYPE_DEVICE";
    case ObjectType::e_QUEUE: return "VK_OBJECT_TYPE_QUEUE";
    case ObjectType::e_SEMAPHORE: return "VK_OBJECT_TYPE_SEMAPHORE";
    case ObjectType::e_COMMAND_BUFFER: return "VK_OBJECT_TYPE_COMMAND_BUFFER";
    case ObjectType::e_FENCE: return "VK_OBJECT_TYPE_FENCE";
    case ObjectType::e_DEVICE_MEMORY: return "VK_OBJECT_TYPE_DEVICE_MEMORY";
    case ObjectType::e_BUFFER: return "VK_OBJECT_TYPE_BUFFER";
    case ObjectType::e_IMAGE: return "VK_OBJECT_TYPE_IMAGE";
    case ObjectType::e_EVENT: return "VK_OBJECT_TYPE_EVENT";
    case ObjectType::e_QUERY_POOL: return "VK_OBJECT_TYPE_QUERY_POOL";
    case ObjectType::e_BUFFER_VIEW: return "VK_OBJECT_TYPE_BUFFER_VIEW";
    case ObjectType::e_IMAGE_VIEW: return "VK_OBJECT_TYPE_IMAGE_VIEW";
    case ObjectType::e_SHADER_MODULE: return "VK_OBJECT_TYPE_SHADER_MODULE";
    case ObjectType::e_PIPELINE_CACHE: return "VK_OBJECT_TYPE_PIPELINE_CACHE";
    case ObjectType::e_PIPELINE_LAYOUT: return "VK_OBJECT_TYPE_PIPELINE_LAYOUT";
    case ObjectType::e_RENDER_PASS: return "VK_OBJECT_TYPE_RENDER_PASS";
    case ObjectType::e_PIPELINE: return "VK_OBJECT_TYPE_PIPELINE";
    case ObjectType::e_DESCRIPTOR_SET_LAYOUT: return "VK_OBJECT_TYPE_DESCRIPTOR_SET_LAYOUT";
    case ObjectType::e_SAMPLER: return "VK_OBJECT_TYPE_SAMPLER";
    case ObjectType::e_DESCRIPTOR_POOL: return "VK_OBJECT_TYPE_DESCRIPTOR_POOL";
    case ObjectType::e_DESCRIPTOR_SET: return "VK_OBJECT_TYPE_DESCRIPTOR_SET";
    case ObjectType::e_FRAMEBUFFER: return "VK_OBJECT_TYPE_FRAMEBUFFER";
    case ObjectType::e_COMMAND_POOL: return "VK_OBJECT_TYPE_COMMAND_POOL";
    case ObjectType::e_SAMPLER_YCBCR_CONVERSION: return "VK_OBJECT_TYPE_SAMPLER_YCBCR_CONVERSION";
    case ObjectType::e_DESCRIPTOR_UPDATE_TEMPLATE: return "VK_OBJECT_TYPE_DESCRIPTOR_UPDATE_TEMPLATE";
    case ObjectType::e_SURFACE_KHR: return "VK_OBJECT_TYPE_SURFACE_KHR";
    case ObjectType::e_SWAPCHAIN_KHR: return "VK_OBJECT_TYPE_SWAPCHAIN_KHR";
    case ObjectType::e_DISPLAY_KHR: return "VK_OBJECT_TYPE_DISPLAY_KHR";
    case ObjectType::e_DISPLAY_MODE_KHR: return "VK_OBJECT_TYPE_DISPLAY_MODE_KHR";
    case ObjectType::e_DEBUG_REPORT_CALLBACK_EXT: return "VK_OBJECT_TYPE_DEBUG_REPORT_CALLBACK_EXT";
    case ObjectType::e_OBJECT_TABLE_NVX: return "VK_OBJECT_TYPE_OBJECT_TABLE_NVX";
    case ObjectType::e_INDIRECT_COMMANDS_LAYOUT_NVX: return "VK_OBJECT_TYPE_INDIRECT_COMMANDS_LAYOUT_NVX";
    case ObjectType::e_DEBUG_UTILS_MESSENGER_EXT: return "VK_OBJECT_TYPE_DEBUG_UTILS_MESSENGER_EXT";
    case ObjectType::e_VALIDATION_CACHE_EXT: return "VK_OBJECT_TYPE_VALIDATION_CACHE_EXT";
    case ObjectType::e_ACCELERATION_STRUCTURE_NV: return "VK_OBJECT_TYPE_ACCELERATION_STRUCTURE_NV";
    default: return "invalid";
    }
}

enum class VendorId
{
    e_VIV = VK_VENDOR_ID_VIV,
    e_VSI = VK_VENDOR_ID_VSI,
    e_KAZAN = VK_VENDOR_ID_KAZAN,
    e_BEGIN_RANGE = VK_VENDOR_ID_BEGIN_RANGE,
    e_END_RANGE = VK_VENDOR_ID_END_RANGE,
    e_RANGE_SIZE = VK_VENDOR_ID_RANGE_SIZE,
    e_MAX_ENUM = 0x7FFFFFFF

};
DEFINE_ENUM_BITWISE_OPERATORS(VendorId)
inline std::string to_string(VendorId value)
{
    switch(value)
    {
    case VendorId::e_VIV: return "VK_VENDOR_ID_VIV";
    case VendorId::e_VSI: return "VK_VENDOR_ID_VSI";
    case VendorId::e_KAZAN: return "VK_VENDOR_ID_KAZAN";
    default: return "invalid";
    }
}

enum class RenderPassCreateFlags
{
    e_NONE = 0,
    e_MAX_ENUM = 0x7FFFFFFF,

};
DEFINE_ENUM_BITWISE_OPERATORS(RenderPassCreateFlags)
inline std::string to_string(RenderPassCreateFlags value)
{
    std::string returnString = "";
    bool addedFlags = false;
    return returnString;
}

enum class SubgroupFeatureFlags
{
    e_NONE = 0,
    e_BASIC_BIT = VK_SUBGROUP_FEATURE_BASIC_BIT,
    e_VOTE_BIT = VK_SUBGROUP_FEATURE_VOTE_BIT,
    e_ARITHMETIC_BIT = VK_SUBGROUP_FEATURE_ARITHMETIC_BIT,
    e_BALLOT_BIT = VK_SUBGROUP_FEATURE_BALLOT_BIT,
    e_SHUFFLE_BIT = VK_SUBGROUP_FEATURE_SHUFFLE_BIT,
    e_SHUFFLE_RELATIVE_BIT = VK_SUBGROUP_FEATURE_SHUFFLE_RELATIVE_BIT,
    e_CLUSTERED_BIT = VK_SUBGROUP_FEATURE_CLUSTERED_BIT,
    e_QUAD_BIT = VK_SUBGROUP_FEATURE_QUAD_BIT,
    e_PARTITIONED_BIT_NV = VK_SUBGROUP_FEATURE_PARTITIONED_BIT_NV,
    e_MAX_ENUM = 0x7FFFFFFF,
    e_ALL_BITS = e_BASIC_BIT | e_VOTE_BIT | e_ARITHMETIC_BIT | e_BALLOT_BIT | e_SHUFFLE_BIT | e_SHUFFLE_RELATIVE_BIT | e_CLUSTERED_BIT | e_QUAD_BIT | e_PARTITIONED_BIT_NV
};
DEFINE_ENUM_BITWISE_OPERATORS(SubgroupFeatureFlags)
inline std::string to_string(SubgroupFeatureFlags value)
{
    std::string returnString = "";
    bool addedFlags = false;
    if(static_cast<uint32_t>(value & SubgroupFeatureFlags::e_BASIC_BIT) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_SUBGROUP_FEATURE_BASIC_BIT";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & SubgroupFeatureFlags::e_VOTE_BIT) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_SUBGROUP_FEATURE_VOTE_BIT";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & SubgroupFeatureFlags::e_ARITHMETIC_BIT) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_SUBGROUP_FEATURE_ARITHMETIC_BIT";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & SubgroupFeatureFlags::e_BALLOT_BIT) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_SUBGROUP_FEATURE_BALLOT_BIT";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & SubgroupFeatureFlags::e_SHUFFLE_BIT) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_SUBGROUP_FEATURE_SHUFFLE_BIT";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & SubgroupFeatureFlags::e_SHUFFLE_RELATIVE_BIT) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_SUBGROUP_FEATURE_SHUFFLE_RELATIVE_BIT";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & SubgroupFeatureFlags::e_CLUSTERED_BIT) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_SUBGROUP_FEATURE_CLUSTERED_BIT";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & SubgroupFeatureFlags::e_QUAD_BIT) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_SUBGROUP_FEATURE_QUAD_BIT";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & SubgroupFeatureFlags::e_PARTITIONED_BIT_NV) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_SUBGROUP_FEATURE_PARTITIONED_BIT_NV";
        addedFlags = true;
    }
    return returnString;
}

enum class PeerMemoryFeatureFlags
{
    e_NONE = 0,
    e_COPY_SRC_BIT = VK_PEER_MEMORY_FEATURE_COPY_SRC_BIT,
    e_COPY_DST_BIT = VK_PEER_MEMORY_FEATURE_COPY_DST_BIT,
    e_GENERIC_SRC_BIT = VK_PEER_MEMORY_FEATURE_GENERIC_SRC_BIT,
    e_GENERIC_DST_BIT = VK_PEER_MEMORY_FEATURE_GENERIC_DST_BIT,
    e_COPY_SRC_BIT_KHR = VK_PEER_MEMORY_FEATURE_COPY_SRC_BIT_KHR,
    e_COPY_DST_BIT_KHR = VK_PEER_MEMORY_FEATURE_COPY_DST_BIT_KHR,
    e_GENERIC_SRC_BIT_KHR = VK_PEER_MEMORY_FEATURE_GENERIC_SRC_BIT_KHR,
    e_GENERIC_DST_BIT_KHR = VK_PEER_MEMORY_FEATURE_GENERIC_DST_BIT_KHR,
    e_MAX_ENUM = 0x7FFFFFFF,
    e_ALL_BITS = e_COPY_SRC_BIT | e_COPY_DST_BIT | e_GENERIC_SRC_BIT | e_GENERIC_DST_BIT | e_COPY_SRC_BIT_KHR | e_COPY_DST_BIT_KHR | e_GENERIC_SRC_BIT_KHR | e_GENERIC_DST_BIT_KHR
};
DEFINE_ENUM_BITWISE_OPERATORS(PeerMemoryFeatureFlags)
inline std::string to_string(PeerMemoryFeatureFlags value)
{
    std::string returnString = "";
    bool addedFlags = false;
    if(static_cast<uint32_t>(value & PeerMemoryFeatureFlags::e_COPY_SRC_BIT) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_PEER_MEMORY_FEATURE_COPY_SRC_BIT";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & PeerMemoryFeatureFlags::e_COPY_DST_BIT) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_PEER_MEMORY_FEATURE_COPY_DST_BIT";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & PeerMemoryFeatureFlags::e_GENERIC_SRC_BIT) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_PEER_MEMORY_FEATURE_GENERIC_SRC_BIT";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & PeerMemoryFeatureFlags::e_GENERIC_DST_BIT) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_PEER_MEMORY_FEATURE_GENERIC_DST_BIT";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & PeerMemoryFeatureFlags::e_COPY_SRC_BIT_KHR) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_PEER_MEMORY_FEATURE_COPY_SRC_BIT_KHR";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & PeerMemoryFeatureFlags::e_COPY_DST_BIT_KHR) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_PEER_MEMORY_FEATURE_COPY_DST_BIT_KHR";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & PeerMemoryFeatureFlags::e_GENERIC_SRC_BIT_KHR) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_PEER_MEMORY_FEATURE_GENERIC_SRC_BIT_KHR";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & PeerMemoryFeatureFlags::e_GENERIC_DST_BIT_KHR) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_PEER_MEMORY_FEATURE_GENERIC_DST_BIT_KHR";
        addedFlags = true;
    }
    return returnString;
}

enum class MemoryAllocateFlags
{
    e_NONE = 0,
    e_DEVICE_MASK_BIT = VK_MEMORY_ALLOCATE_DEVICE_MASK_BIT,
    e_DEVICE_MASK_BIT_KHR = VK_MEMORY_ALLOCATE_DEVICE_MASK_BIT_KHR,
    e_MAX_ENUM = 0x7FFFFFFF,
    e_ALL_BITS = e_DEVICE_MASK_BIT | e_DEVICE_MASK_BIT_KHR
};
DEFINE_ENUM_BITWISE_OPERATORS(MemoryAllocateFlags)
inline std::string to_string(MemoryAllocateFlags value)
{
    std::string returnString = "";
    bool addedFlags = false;
    if(static_cast<uint32_t>(value & MemoryAllocateFlags::e_DEVICE_MASK_BIT) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_MEMORY_ALLOCATE_DEVICE_MASK_BIT";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & MemoryAllocateFlags::e_DEVICE_MASK_BIT_KHR) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_MEMORY_ALLOCATE_DEVICE_MASK_BIT_KHR";
        addedFlags = true;
    }
    return returnString;
}

enum class PointClippingBehavior
{
    e_ALL_CLIP_PLANES = VK_POINT_CLIPPING_BEHAVIOR_ALL_CLIP_PLANES,
    e_USER_CLIP_PLANES_ONLY = VK_POINT_CLIPPING_BEHAVIOR_USER_CLIP_PLANES_ONLY,
    e_ALL_CLIP_PLANES_KHR = VK_POINT_CLIPPING_BEHAVIOR_ALL_CLIP_PLANES_KHR,
    e_USER_CLIP_PLANES_ONLY_KHR = VK_POINT_CLIPPING_BEHAVIOR_USER_CLIP_PLANES_ONLY_KHR,
    e_BEGIN_RANGE = VK_POINT_CLIPPING_BEHAVIOR_BEGIN_RANGE,
    e_END_RANGE = VK_POINT_CLIPPING_BEHAVIOR_END_RANGE,
    e_RANGE_SIZE = VK_POINT_CLIPPING_BEHAVIOR_RANGE_SIZE,
    e_MAX_ENUM = 0x7FFFFFFF

};
DEFINE_ENUM_BITWISE_OPERATORS(PointClippingBehavior)
inline std::string to_string(PointClippingBehavior value)
{
    switch(value)
    {
    case PointClippingBehavior::e_ALL_CLIP_PLANES: return "VK_POINT_CLIPPING_BEHAVIOR_ALL_CLIP_PLANES";
    case PointClippingBehavior::e_USER_CLIP_PLANES_ONLY: return "VK_POINT_CLIPPING_BEHAVIOR_USER_CLIP_PLANES_ONLY";
    default: return "invalid";
    }
}

enum class TessellationDomainOrigin
{
    e_UPPER_LEFT = VK_TESSELLATION_DOMAIN_ORIGIN_UPPER_LEFT,
    e_LOWER_LEFT = VK_TESSELLATION_DOMAIN_ORIGIN_LOWER_LEFT,
    e_UPPER_LEFT_KHR = VK_TESSELLATION_DOMAIN_ORIGIN_UPPER_LEFT_KHR,
    e_LOWER_LEFT_KHR = VK_TESSELLATION_DOMAIN_ORIGIN_LOWER_LEFT_KHR,
    e_BEGIN_RANGE = VK_TESSELLATION_DOMAIN_ORIGIN_BEGIN_RANGE,
    e_END_RANGE = VK_TESSELLATION_DOMAIN_ORIGIN_END_RANGE,
    e_RANGE_SIZE = VK_TESSELLATION_DOMAIN_ORIGIN_RANGE_SIZE,
    e_MAX_ENUM = 0x7FFFFFFF

};
DEFINE_ENUM_BITWISE_OPERATORS(TessellationDomainOrigin)
inline std::string to_string(TessellationDomainOrigin value)
{
    switch(value)
    {
    case TessellationDomainOrigin::e_UPPER_LEFT: return "VK_TESSELLATION_DOMAIN_ORIGIN_UPPER_LEFT";
    case TessellationDomainOrigin::e_LOWER_LEFT: return "VK_TESSELLATION_DOMAIN_ORIGIN_LOWER_LEFT";
    default: return "invalid";
    }
}

enum class SamplerYcbcrModelConversion
{
    e_RGB_IDENTITY = VK_SAMPLER_YCBCR_MODEL_CONVERSION_RGB_IDENTITY,
    e_YCBCR_IDENTITY = VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_IDENTITY,
    e_YCBCR_709 = VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_709,
    e_YCBCR_601 = VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_601,
    e_YCBCR_2020 = VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_2020,
    e_RGB_IDENTITY_KHR = VK_SAMPLER_YCBCR_MODEL_CONVERSION_RGB_IDENTITY_KHR,
    e_YCBCR_IDENTITY_KHR = VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_IDENTITY_KHR,
    e_YCBCR_709_KHR = VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_709_KHR,
    e_YCBCR_601_KHR = VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_601_KHR,
    e_YCBCR_2020_KHR = VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_2020_KHR,
    e_BEGIN_RANGE = VK_SAMPLER_YCBCR_MODEL_CONVERSION_BEGIN_RANGE,
    e_END_RANGE = VK_SAMPLER_YCBCR_MODEL_CONVERSION_END_RANGE,
    e_RANGE_SIZE = VK_SAMPLER_YCBCR_MODEL_CONVERSION_RANGE_SIZE,
    e_MAX_ENUM = 0x7FFFFFFF

};
DEFINE_ENUM_BITWISE_OPERATORS(SamplerYcbcrModelConversion)
inline std::string to_string(SamplerYcbcrModelConversion value)
{
    switch(value)
    {
    case SamplerYcbcrModelConversion::e_RGB_IDENTITY: return "VK_SAMPLER_YCBCR_MODEL_CONVERSION_RGB_IDENTITY";
    case SamplerYcbcrModelConversion::e_YCBCR_IDENTITY: return "VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_IDENTITY";
    case SamplerYcbcrModelConversion::e_YCBCR_709: return "VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_709";
    case SamplerYcbcrModelConversion::e_YCBCR_601: return "VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_601";
    case SamplerYcbcrModelConversion::e_YCBCR_2020: return "VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_2020";
    default: return "invalid";
    }
}

enum class SamplerYcbcrRange
{
    e_ITU_FULL = VK_SAMPLER_YCBCR_RANGE_ITU_FULL,
    e_ITU_NARROW = VK_SAMPLER_YCBCR_RANGE_ITU_NARROW,
    e_ITU_FULL_KHR = VK_SAMPLER_YCBCR_RANGE_ITU_FULL_KHR,
    e_ITU_NARROW_KHR = VK_SAMPLER_YCBCR_RANGE_ITU_NARROW_KHR,
    e_BEGIN_RANGE = VK_SAMPLER_YCBCR_RANGE_BEGIN_RANGE,
    e_END_RANGE = VK_SAMPLER_YCBCR_RANGE_END_RANGE,
    e_RANGE_SIZE = VK_SAMPLER_YCBCR_RANGE_RANGE_SIZE,
    e_MAX_ENUM = 0x7FFFFFFF

};
DEFINE_ENUM_BITWISE_OPERATORS(SamplerYcbcrRange)
inline std::string to_string(SamplerYcbcrRange value)
{
    switch(value)
    {
    case SamplerYcbcrRange::e_ITU_FULL: return "VK_SAMPLER_YCBCR_RANGE_ITU_FULL";
    case SamplerYcbcrRange::e_ITU_NARROW: return "VK_SAMPLER_YCBCR_RANGE_ITU_NARROW";
    default: return "invalid";
    }
}

enum class ChromaLocation
{
    e_COSITED_EVEN = VK_CHROMA_LOCATION_COSITED_EVEN,
    e_MIDPOINT = VK_CHROMA_LOCATION_MIDPOINT,
    e_COSITED_EVEN_KHR = VK_CHROMA_LOCATION_COSITED_EVEN_KHR,
    e_MIDPOINT_KHR = VK_CHROMA_LOCATION_MIDPOINT_KHR,
    e_BEGIN_RANGE = VK_CHROMA_LOCATION_BEGIN_RANGE,
    e_END_RANGE = VK_CHROMA_LOCATION_END_RANGE,
    e_RANGE_SIZE = VK_CHROMA_LOCATION_RANGE_SIZE,
    e_MAX_ENUM = 0x7FFFFFFF

};
DEFINE_ENUM_BITWISE_OPERATORS(ChromaLocation)
inline std::string to_string(ChromaLocation value)
{
    switch(value)
    {
    case ChromaLocation::e_COSITED_EVEN: return "VK_CHROMA_LOCATION_COSITED_EVEN";
    case ChromaLocation::e_MIDPOINT: return "VK_CHROMA_LOCATION_MIDPOINT";
    default: return "invalid";
    }
}

enum class DescriptorUpdateTemplateType
{
    e_DESCRIPTOR_SET = VK_DESCRIPTOR_UPDATE_TEMPLATE_TYPE_DESCRIPTOR_SET,
    e_PUSH_DESCRIPTORS_KHR = VK_DESCRIPTOR_UPDATE_TEMPLATE_TYPE_PUSH_DESCRIPTORS_KHR,
    e_DESCRIPTOR_SET_KHR = VK_DESCRIPTOR_UPDATE_TEMPLATE_TYPE_DESCRIPTOR_SET_KHR,
    e_BEGIN_RANGE = VK_DESCRIPTOR_UPDATE_TEMPLATE_TYPE_BEGIN_RANGE,
    e_END_RANGE = VK_DESCRIPTOR_UPDATE_TEMPLATE_TYPE_END_RANGE,
    e_RANGE_SIZE = VK_DESCRIPTOR_UPDATE_TEMPLATE_TYPE_RANGE_SIZE,
    e_MAX_ENUM = 0x7FFFFFFF

};
DEFINE_ENUM_BITWISE_OPERATORS(DescriptorUpdateTemplateType)
inline std::string to_string(DescriptorUpdateTemplateType value)
{
    switch(value)
    {
    case DescriptorUpdateTemplateType::e_DESCRIPTOR_SET: return "VK_DESCRIPTOR_UPDATE_TEMPLATE_TYPE_DESCRIPTOR_SET";
    case DescriptorUpdateTemplateType::e_PUSH_DESCRIPTORS_KHR: return "VK_DESCRIPTOR_UPDATE_TEMPLATE_TYPE_PUSH_DESCRIPTORS_KHR";
    default: return "invalid";
    }
}

enum class ExternalMemoryHandleTypeFlags
{
    e_NONE = 0,
    e_OPAQUE_FD_BIT = VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_FD_BIT,
    e_OPAQUE_WIN32_BIT = VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_BIT,
    e_OPAQUE_WIN32_KMT_BIT = VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT,
    e_D3D11_TEXTURE_BIT = VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_TEXTURE_BIT,
    e_D3D11_TEXTURE_KMT_BIT = VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_TEXTURE_KMT_BIT,
    e_D3D12_HEAP_BIT = VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D12_HEAP_BIT,
    e_D3D12_RESOURCE_BIT = VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D12_RESOURCE_BIT,
    e_OPAQUE_FD_BIT_KHR = VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_FD_BIT_KHR,
    e_OPAQUE_WIN32_BIT_KHR = VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_BIT_KHR,
    e_OPAQUE_WIN32_KMT_BIT_KHR = VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT_KHR,
    e_D3D11_TEXTURE_BIT_KHR = VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_TEXTURE_BIT_KHR,
    e_D3D11_TEXTURE_KMT_BIT_KHR = VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_TEXTURE_KMT_BIT_KHR,
    e_D3D12_HEAP_BIT_KHR = VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D12_HEAP_BIT_KHR,
    e_D3D12_RESOURCE_BIT_KHR = VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D12_RESOURCE_BIT_KHR,
    e_DMA_BUF_BIT_EXT = VK_EXTERNAL_MEMORY_HANDLE_TYPE_DMA_BUF_BIT_EXT,
    e_ANDROID_HARDWARE_BUFFER_BIT_ANDROID = VK_EXTERNAL_MEMORY_HANDLE_TYPE_ANDROID_HARDWARE_BUFFER_BIT_ANDROID,
    e_HOST_ALLOCATION_BIT_EXT = VK_EXTERNAL_MEMORY_HANDLE_TYPE_HOST_ALLOCATION_BIT_EXT,
    e_HOST_MAPPED_FOREIGN_MEMORY_BIT_EXT = VK_EXTERNAL_MEMORY_HANDLE_TYPE_HOST_MAPPED_FOREIGN_MEMORY_BIT_EXT,
    e_MAX_ENUM = 0x7FFFFFFF,
    e_ALL_BITS = e_OPAQUE_FD_BIT | e_OPAQUE_WIN32_BIT | e_OPAQUE_WIN32_KMT_BIT | e_D3D11_TEXTURE_BIT | e_D3D11_TEXTURE_KMT_BIT | e_D3D12_HEAP_BIT | e_D3D12_RESOURCE_BIT | e_OPAQUE_FD_BIT_KHR | e_OPAQUE_WIN32_BIT_KHR | e_OPAQUE_WIN32_KMT_BIT_KHR | e_D3D11_TEXTURE_BIT_KHR | e_D3D11_TEXTURE_KMT_BIT_KHR | e_D3D12_HEAP_BIT_KHR | e_D3D12_RESOURCE_BIT_KHR | e_DMA_BUF_BIT_EXT | e_ANDROID_HARDWARE_BUFFER_BIT_ANDROID | e_HOST_ALLOCATION_BIT_EXT | e_HOST_MAPPED_FOREIGN_MEMORY_BIT_EXT
};
DEFINE_ENUM_BITWISE_OPERATORS(ExternalMemoryHandleTypeFlags)
inline std::string to_string(ExternalMemoryHandleTypeFlags value)
{
    std::string returnString = "";
    bool addedFlags = false;
    if(static_cast<uint32_t>(value & ExternalMemoryHandleTypeFlags::e_OPAQUE_FD_BIT) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_FD_BIT";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & ExternalMemoryHandleTypeFlags::e_OPAQUE_WIN32_BIT) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_BIT";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & ExternalMemoryHandleTypeFlags::e_OPAQUE_WIN32_KMT_BIT) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & ExternalMemoryHandleTypeFlags::e_D3D11_TEXTURE_BIT) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_TEXTURE_BIT";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & ExternalMemoryHandleTypeFlags::e_D3D11_TEXTURE_KMT_BIT) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_TEXTURE_KMT_BIT";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & ExternalMemoryHandleTypeFlags::e_D3D12_HEAP_BIT) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D12_HEAP_BIT";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & ExternalMemoryHandleTypeFlags::e_D3D12_RESOURCE_BIT) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D12_RESOURCE_BIT";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & ExternalMemoryHandleTypeFlags::e_OPAQUE_FD_BIT_KHR) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_FD_BIT_KHR";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & ExternalMemoryHandleTypeFlags::e_OPAQUE_WIN32_BIT_KHR) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_BIT_KHR";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & ExternalMemoryHandleTypeFlags::e_OPAQUE_WIN32_KMT_BIT_KHR) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT_KHR";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & ExternalMemoryHandleTypeFlags::e_D3D11_TEXTURE_BIT_KHR) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_TEXTURE_BIT_KHR";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & ExternalMemoryHandleTypeFlags::e_D3D11_TEXTURE_KMT_BIT_KHR) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_TEXTURE_KMT_BIT_KHR";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & ExternalMemoryHandleTypeFlags::e_D3D12_HEAP_BIT_KHR) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D12_HEAP_BIT_KHR";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & ExternalMemoryHandleTypeFlags::e_D3D12_RESOURCE_BIT_KHR) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D12_RESOURCE_BIT_KHR";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & ExternalMemoryHandleTypeFlags::e_DMA_BUF_BIT_EXT) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_EXTERNAL_MEMORY_HANDLE_TYPE_DMA_BUF_BIT_EXT";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & ExternalMemoryHandleTypeFlags::e_ANDROID_HARDWARE_BUFFER_BIT_ANDROID) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_EXTERNAL_MEMORY_HANDLE_TYPE_ANDROID_HARDWARE_BUFFER_BIT_ANDROID";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & ExternalMemoryHandleTypeFlags::e_HOST_ALLOCATION_BIT_EXT) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_EXTERNAL_MEMORY_HANDLE_TYPE_HOST_ALLOCATION_BIT_EXT";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & ExternalMemoryHandleTypeFlags::e_HOST_MAPPED_FOREIGN_MEMORY_BIT_EXT) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_EXTERNAL_MEMORY_HANDLE_TYPE_HOST_MAPPED_FOREIGN_MEMORY_BIT_EXT";
        addedFlags = true;
    }
    return returnString;
}

enum class ExternalMemoryFeatureFlags
{
    e_NONE = 0,
    e_DEDICATED_ONLY_BIT = VK_EXTERNAL_MEMORY_FEATURE_DEDICATED_ONLY_BIT,
    e_EXPORTABLE_BIT = VK_EXTERNAL_MEMORY_FEATURE_EXPORTABLE_BIT,
    e_IMPORTABLE_BIT = VK_EXTERNAL_MEMORY_FEATURE_IMPORTABLE_BIT,
    e_DEDICATED_ONLY_BIT_KHR = VK_EXTERNAL_MEMORY_FEATURE_DEDICATED_ONLY_BIT_KHR,
    e_EXPORTABLE_BIT_KHR = VK_EXTERNAL_MEMORY_FEATURE_EXPORTABLE_BIT_KHR,
    e_IMPORTABLE_BIT_KHR = VK_EXTERNAL_MEMORY_FEATURE_IMPORTABLE_BIT_KHR,
    e_MAX_ENUM = 0x7FFFFFFF,
    e_ALL_BITS = e_DEDICATED_ONLY_BIT | e_EXPORTABLE_BIT | e_IMPORTABLE_BIT | e_DEDICATED_ONLY_BIT_KHR | e_EXPORTABLE_BIT_KHR | e_IMPORTABLE_BIT_KHR
};
DEFINE_ENUM_BITWISE_OPERATORS(ExternalMemoryFeatureFlags)
inline std::string to_string(ExternalMemoryFeatureFlags value)
{
    std::string returnString = "";
    bool addedFlags = false;
    if(static_cast<uint32_t>(value & ExternalMemoryFeatureFlags::e_DEDICATED_ONLY_BIT) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_EXTERNAL_MEMORY_FEATURE_DEDICATED_ONLY_BIT";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & ExternalMemoryFeatureFlags::e_EXPORTABLE_BIT) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_EXTERNAL_MEMORY_FEATURE_EXPORTABLE_BIT";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & ExternalMemoryFeatureFlags::e_IMPORTABLE_BIT) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_EXTERNAL_MEMORY_FEATURE_IMPORTABLE_BIT";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & ExternalMemoryFeatureFlags::e_DEDICATED_ONLY_BIT_KHR) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_EXTERNAL_MEMORY_FEATURE_DEDICATED_ONLY_BIT_KHR";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & ExternalMemoryFeatureFlags::e_EXPORTABLE_BIT_KHR) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_EXTERNAL_MEMORY_FEATURE_EXPORTABLE_BIT_KHR";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & ExternalMemoryFeatureFlags::e_IMPORTABLE_BIT_KHR) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_EXTERNAL_MEMORY_FEATURE_IMPORTABLE_BIT_KHR";
        addedFlags = true;
    }
    return returnString;
}

enum class ExternalFenceHandleTypeFlags
{
    e_NONE = 0,
    e_OPAQUE_FD_BIT = VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_FD_BIT,
    e_OPAQUE_WIN32_BIT = VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_WIN32_BIT,
    e_OPAQUE_WIN32_KMT_BIT = VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT,
    e_SYNC_FD_BIT = VK_EXTERNAL_FENCE_HANDLE_TYPE_SYNC_FD_BIT,
    e_OPAQUE_FD_BIT_KHR = VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_FD_BIT_KHR,
    e_OPAQUE_WIN32_BIT_KHR = VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_WIN32_BIT_KHR,
    e_OPAQUE_WIN32_KMT_BIT_KHR = VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT_KHR,
    e_SYNC_FD_BIT_KHR = VK_EXTERNAL_FENCE_HANDLE_TYPE_SYNC_FD_BIT_KHR,
    e_MAX_ENUM = 0x7FFFFFFF,
    e_ALL_BITS = e_OPAQUE_FD_BIT | e_OPAQUE_WIN32_BIT | e_OPAQUE_WIN32_KMT_BIT | e_SYNC_FD_BIT | e_OPAQUE_FD_BIT_KHR | e_OPAQUE_WIN32_BIT_KHR | e_OPAQUE_WIN32_KMT_BIT_KHR | e_SYNC_FD_BIT_KHR
};
DEFINE_ENUM_BITWISE_OPERATORS(ExternalFenceHandleTypeFlags)
inline std::string to_string(ExternalFenceHandleTypeFlags value)
{
    std::string returnString = "";
    bool addedFlags = false;
    if(static_cast<uint32_t>(value & ExternalFenceHandleTypeFlags::e_OPAQUE_FD_BIT) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_FD_BIT";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & ExternalFenceHandleTypeFlags::e_OPAQUE_WIN32_BIT) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_WIN32_BIT";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & ExternalFenceHandleTypeFlags::e_OPAQUE_WIN32_KMT_BIT) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & ExternalFenceHandleTypeFlags::e_SYNC_FD_BIT) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_EXTERNAL_FENCE_HANDLE_TYPE_SYNC_FD_BIT";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & ExternalFenceHandleTypeFlags::e_OPAQUE_FD_BIT_KHR) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_FD_BIT_KHR";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & ExternalFenceHandleTypeFlags::e_OPAQUE_WIN32_BIT_KHR) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_WIN32_BIT_KHR";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & ExternalFenceHandleTypeFlags::e_OPAQUE_WIN32_KMT_BIT_KHR) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT_KHR";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & ExternalFenceHandleTypeFlags::e_SYNC_FD_BIT_KHR) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_EXTERNAL_FENCE_HANDLE_TYPE_SYNC_FD_BIT_KHR";
        addedFlags = true;
    }
    return returnString;
}

enum class ExternalFenceFeatureFlags
{
    e_NONE = 0,
    e_EXPORTABLE_BIT = VK_EXTERNAL_FENCE_FEATURE_EXPORTABLE_BIT,
    e_IMPORTABLE_BIT = VK_EXTERNAL_FENCE_FEATURE_IMPORTABLE_BIT,
    e_EXPORTABLE_BIT_KHR = VK_EXTERNAL_FENCE_FEATURE_EXPORTABLE_BIT_KHR,
    e_IMPORTABLE_BIT_KHR = VK_EXTERNAL_FENCE_FEATURE_IMPORTABLE_BIT_KHR,
    e_MAX_ENUM = 0x7FFFFFFF,
    e_ALL_BITS = e_EXPORTABLE_BIT | e_IMPORTABLE_BIT | e_EXPORTABLE_BIT_KHR | e_IMPORTABLE_BIT_KHR
};
DEFINE_ENUM_BITWISE_OPERATORS(ExternalFenceFeatureFlags)
inline std::string to_string(ExternalFenceFeatureFlags value)
{
    std::string returnString = "";
    bool addedFlags = false;
    if(static_cast<uint32_t>(value & ExternalFenceFeatureFlags::e_EXPORTABLE_BIT) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_EXTERNAL_FENCE_FEATURE_EXPORTABLE_BIT";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & ExternalFenceFeatureFlags::e_IMPORTABLE_BIT) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_EXTERNAL_FENCE_FEATURE_IMPORTABLE_BIT";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & ExternalFenceFeatureFlags::e_EXPORTABLE_BIT_KHR) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_EXTERNAL_FENCE_FEATURE_EXPORTABLE_BIT_KHR";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & ExternalFenceFeatureFlags::e_IMPORTABLE_BIT_KHR) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_EXTERNAL_FENCE_FEATURE_IMPORTABLE_BIT_KHR";
        addedFlags = true;
    }
    return returnString;
}

enum class FenceImportFlags
{
    e_NONE = 0,
    e_TEMPORARY_BIT = VK_FENCE_IMPORT_TEMPORARY_BIT,
    e_TEMPORARY_BIT_KHR = VK_FENCE_IMPORT_TEMPORARY_BIT_KHR,
    e_MAX_ENUM = 0x7FFFFFFF,
    e_ALL_BITS = e_TEMPORARY_BIT | e_TEMPORARY_BIT_KHR
};
DEFINE_ENUM_BITWISE_OPERATORS(FenceImportFlags)
inline std::string to_string(FenceImportFlags value)
{
    std::string returnString = "";
    bool addedFlags = false;
    if(static_cast<uint32_t>(value & FenceImportFlags::e_TEMPORARY_BIT) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_FENCE_IMPORT_TEMPORARY_BIT";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & FenceImportFlags::e_TEMPORARY_BIT_KHR) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_FENCE_IMPORT_TEMPORARY_BIT_KHR";
        addedFlags = true;
    }
    return returnString;
}

enum class SemaphoreImportFlags
{
    e_NONE = 0,
    e_TEMPORARY_BIT = VK_SEMAPHORE_IMPORT_TEMPORARY_BIT,
    e_TEMPORARY_BIT_KHR = VK_SEMAPHORE_IMPORT_TEMPORARY_BIT_KHR,
    e_MAX_ENUM = 0x7FFFFFFF,
    e_ALL_BITS = e_TEMPORARY_BIT | e_TEMPORARY_BIT_KHR
};
DEFINE_ENUM_BITWISE_OPERATORS(SemaphoreImportFlags)
inline std::string to_string(SemaphoreImportFlags value)
{
    std::string returnString = "";
    bool addedFlags = false;
    if(static_cast<uint32_t>(value & SemaphoreImportFlags::e_TEMPORARY_BIT) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_SEMAPHORE_IMPORT_TEMPORARY_BIT";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & SemaphoreImportFlags::e_TEMPORARY_BIT_KHR) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_SEMAPHORE_IMPORT_TEMPORARY_BIT_KHR";
        addedFlags = true;
    }
    return returnString;
}

enum class ExternalSemaphoreHandleTypeFlags
{
    e_NONE = 0,
    e_OPAQUE_FD_BIT = VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_FD_BIT,
    e_OPAQUE_WIN32_BIT = VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32_BIT,
    e_OPAQUE_WIN32_KMT_BIT = VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT,
    e_D3D12_FENCE_BIT = VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_D3D12_FENCE_BIT,
    e_SYNC_FD_BIT = VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_SYNC_FD_BIT,
    e_OPAQUE_FD_BIT_KHR = VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_FD_BIT_KHR,
    e_OPAQUE_WIN32_BIT_KHR = VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32_BIT_KHR,
    e_OPAQUE_WIN32_KMT_BIT_KHR = VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT_KHR,
    e_D3D12_FENCE_BIT_KHR = VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_D3D12_FENCE_BIT_KHR,
    e_SYNC_FD_BIT_KHR = VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_SYNC_FD_BIT_KHR,
    e_MAX_ENUM = 0x7FFFFFFF,
    e_ALL_BITS = e_OPAQUE_FD_BIT | e_OPAQUE_WIN32_BIT | e_OPAQUE_WIN32_KMT_BIT | e_D3D12_FENCE_BIT | e_SYNC_FD_BIT | e_OPAQUE_FD_BIT_KHR | e_OPAQUE_WIN32_BIT_KHR | e_OPAQUE_WIN32_KMT_BIT_KHR | e_D3D12_FENCE_BIT_KHR | e_SYNC_FD_BIT_KHR
};
DEFINE_ENUM_BITWISE_OPERATORS(ExternalSemaphoreHandleTypeFlags)
inline std::string to_string(ExternalSemaphoreHandleTypeFlags value)
{
    std::string returnString = "";
    bool addedFlags = false;
    if(static_cast<uint32_t>(value & ExternalSemaphoreHandleTypeFlags::e_OPAQUE_FD_BIT) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_FD_BIT";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & ExternalSemaphoreHandleTypeFlags::e_OPAQUE_WIN32_BIT) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32_BIT";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & ExternalSemaphoreHandleTypeFlags::e_OPAQUE_WIN32_KMT_BIT) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & ExternalSemaphoreHandleTypeFlags::e_D3D12_FENCE_BIT) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_D3D12_FENCE_BIT";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & ExternalSemaphoreHandleTypeFlags::e_SYNC_FD_BIT) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_SYNC_FD_BIT";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & ExternalSemaphoreHandleTypeFlags::e_OPAQUE_FD_BIT_KHR) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_FD_BIT_KHR";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & ExternalSemaphoreHandleTypeFlags::e_OPAQUE_WIN32_BIT_KHR) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32_BIT_KHR";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & ExternalSemaphoreHandleTypeFlags::e_OPAQUE_WIN32_KMT_BIT_KHR) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT_KHR";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & ExternalSemaphoreHandleTypeFlags::e_D3D12_FENCE_BIT_KHR) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_D3D12_FENCE_BIT_KHR";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & ExternalSemaphoreHandleTypeFlags::e_SYNC_FD_BIT_KHR) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_SYNC_FD_BIT_KHR";
        addedFlags = true;
    }
    return returnString;
}

enum class ExternalSemaphoreFeatureFlags
{
    e_NONE = 0,
    e_EXPORTABLE_BIT = VK_EXTERNAL_SEMAPHORE_FEATURE_EXPORTABLE_BIT,
    e_IMPORTABLE_BIT = VK_EXTERNAL_SEMAPHORE_FEATURE_IMPORTABLE_BIT,
    e_EXPORTABLE_BIT_KHR = VK_EXTERNAL_SEMAPHORE_FEATURE_EXPORTABLE_BIT_KHR,
    e_IMPORTABLE_BIT_KHR = VK_EXTERNAL_SEMAPHORE_FEATURE_IMPORTABLE_BIT_KHR,
    e_MAX_ENUM = 0x7FFFFFFF,
    e_ALL_BITS = e_EXPORTABLE_BIT | e_IMPORTABLE_BIT | e_EXPORTABLE_BIT_KHR | e_IMPORTABLE_BIT_KHR
};
DEFINE_ENUM_BITWISE_OPERATORS(ExternalSemaphoreFeatureFlags)
inline std::string to_string(ExternalSemaphoreFeatureFlags value)
{
    std::string returnString = "";
    bool addedFlags = false;
    if(static_cast<uint32_t>(value & ExternalSemaphoreFeatureFlags::e_EXPORTABLE_BIT) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_EXTERNAL_SEMAPHORE_FEATURE_EXPORTABLE_BIT";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & ExternalSemaphoreFeatureFlags::e_IMPORTABLE_BIT) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_EXTERNAL_SEMAPHORE_FEATURE_IMPORTABLE_BIT";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & ExternalSemaphoreFeatureFlags::e_EXPORTABLE_BIT_KHR) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_EXTERNAL_SEMAPHORE_FEATURE_EXPORTABLE_BIT_KHR";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & ExternalSemaphoreFeatureFlags::e_IMPORTABLE_BIT_KHR) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_EXTERNAL_SEMAPHORE_FEATURE_IMPORTABLE_BIT_KHR";
        addedFlags = true;
    }
    return returnString;
}

enum class SurfaceTransformFlagsKHR
{
    e_NONE = 0,
    e_IDENTITY_BIT_KHR = VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR,
    e_ROTATE_90_BIT_KHR = VK_SURFACE_TRANSFORM_ROTATE_90_BIT_KHR,
    e_ROTATE_180_BIT_KHR = VK_SURFACE_TRANSFORM_ROTATE_180_BIT_KHR,
    e_ROTATE_270_BIT_KHR = VK_SURFACE_TRANSFORM_ROTATE_270_BIT_KHR,
    e_HORIZONTAL_MIRROR_BIT_KHR = VK_SURFACE_TRANSFORM_HORIZONTAL_MIRROR_BIT_KHR,
    e_HORIZONTAL_MIRROR_ROTATE_90_BIT_KHR = VK_SURFACE_TRANSFORM_HORIZONTAL_MIRROR_ROTATE_90_BIT_KHR,
    e_HORIZONTAL_MIRROR_ROTATE_180_BIT_KHR = VK_SURFACE_TRANSFORM_HORIZONTAL_MIRROR_ROTATE_180_BIT_KHR,
    e_HORIZONTAL_MIRROR_ROTATE_270_BIT_KHR = VK_SURFACE_TRANSFORM_HORIZONTAL_MIRROR_ROTATE_270_BIT_KHR,
    e_INHERIT_BIT_KHR = VK_SURFACE_TRANSFORM_INHERIT_BIT_KHR,
    e_MAX_ENUM = 0x7FFFFFFF,
    e_ALL_BITS = e_IDENTITY_BIT_KHR | e_ROTATE_90_BIT_KHR | e_ROTATE_180_BIT_KHR | e_ROTATE_270_BIT_KHR | e_HORIZONTAL_MIRROR_BIT_KHR | e_HORIZONTAL_MIRROR_ROTATE_90_BIT_KHR | e_HORIZONTAL_MIRROR_ROTATE_180_BIT_KHR | e_HORIZONTAL_MIRROR_ROTATE_270_BIT_KHR | e_INHERIT_BIT_KHR
};
DEFINE_ENUM_BITWISE_OPERATORS(SurfaceTransformFlagsKHR)
inline std::string to_string(SurfaceTransformFlagsKHR value)
{
    std::string returnString = "";
    bool addedFlags = false;
    if(static_cast<uint32_t>(value & SurfaceTransformFlagsKHR::e_IDENTITY_BIT_KHR) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & SurfaceTransformFlagsKHR::e_ROTATE_90_BIT_KHR) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_SURFACE_TRANSFORM_ROTATE_90_BIT_KHR";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & SurfaceTransformFlagsKHR::e_ROTATE_180_BIT_KHR) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_SURFACE_TRANSFORM_ROTATE_180_BIT_KHR";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & SurfaceTransformFlagsKHR::e_ROTATE_270_BIT_KHR) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_SURFACE_TRANSFORM_ROTATE_270_BIT_KHR";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & SurfaceTransformFlagsKHR::e_HORIZONTAL_MIRROR_BIT_KHR) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_SURFACE_TRANSFORM_HORIZONTAL_MIRROR_BIT_KHR";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & SurfaceTransformFlagsKHR::e_HORIZONTAL_MIRROR_ROTATE_90_BIT_KHR) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_SURFACE_TRANSFORM_HORIZONTAL_MIRROR_ROTATE_90_BIT_KHR";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & SurfaceTransformFlagsKHR::e_HORIZONTAL_MIRROR_ROTATE_180_BIT_KHR) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_SURFACE_TRANSFORM_HORIZONTAL_MIRROR_ROTATE_180_BIT_KHR";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & SurfaceTransformFlagsKHR::e_HORIZONTAL_MIRROR_ROTATE_270_BIT_KHR) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_SURFACE_TRANSFORM_HORIZONTAL_MIRROR_ROTATE_270_BIT_KHR";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & SurfaceTransformFlagsKHR::e_INHERIT_BIT_KHR) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_SURFACE_TRANSFORM_INHERIT_BIT_KHR";
        addedFlags = true;
    }
    return returnString;
}

enum class CompositeAlphaFlagsKHR
{
    e_NONE = 0,
    e_OPAQUE_BIT_KHR = VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR,
    e_PRE_MULTIPLIED_BIT_KHR = VK_COMPOSITE_ALPHA_PRE_MULTIPLIED_BIT_KHR,
    e_POST_MULTIPLIED_BIT_KHR = VK_COMPOSITE_ALPHA_POST_MULTIPLIED_BIT_KHR,
    e_INHERIT_BIT_KHR = VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR,
    e_MAX_ENUM = 0x7FFFFFFF,
    e_ALL_BITS = e_OPAQUE_BIT_KHR | e_PRE_MULTIPLIED_BIT_KHR | e_POST_MULTIPLIED_BIT_KHR | e_INHERIT_BIT_KHR
};
DEFINE_ENUM_BITWISE_OPERATORS(CompositeAlphaFlagsKHR)
inline std::string to_string(CompositeAlphaFlagsKHR value)
{
    std::string returnString = "";
    bool addedFlags = false;
    if(static_cast<uint32_t>(value & CompositeAlphaFlagsKHR::e_OPAQUE_BIT_KHR) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & CompositeAlphaFlagsKHR::e_PRE_MULTIPLIED_BIT_KHR) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_COMPOSITE_ALPHA_PRE_MULTIPLIED_BIT_KHR";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & CompositeAlphaFlagsKHR::e_POST_MULTIPLIED_BIT_KHR) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_COMPOSITE_ALPHA_POST_MULTIPLIED_BIT_KHR";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & CompositeAlphaFlagsKHR::e_INHERIT_BIT_KHR) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR";
        addedFlags = true;
    }
    return returnString;
}

enum class ColorSpaceKHR
{
    e_SRGB_NONLINEAR_KHR = VK_COLOR_SPACE_SRGB_NONLINEAR_KHR,
    e_DISPLAY_P3_NONLINEAR_EXT = VK_COLOR_SPACE_DISPLAY_P3_NONLINEAR_EXT,
    e_EXTENDED_SRGB_LINEAR_EXT = VK_COLOR_SPACE_EXTENDED_SRGB_LINEAR_EXT,
    e_DCI_P3_LINEAR_EXT = VK_COLOR_SPACE_DCI_P3_LINEAR_EXT,
    e_DCI_P3_NONLINEAR_EXT = VK_COLOR_SPACE_DCI_P3_NONLINEAR_EXT,
    e_BT709_LINEAR_EXT = VK_COLOR_SPACE_BT709_LINEAR_EXT,
    e_BT709_NONLINEAR_EXT = VK_COLOR_SPACE_BT709_NONLINEAR_EXT,
    e_BT2020_LINEAR_EXT = VK_COLOR_SPACE_BT2020_LINEAR_EXT,
    e_HDR10_ST2084_EXT = VK_COLOR_SPACE_HDR10_ST2084_EXT,
    e_DOLBYVISION_EXT = VK_COLOR_SPACE_DOLBYVISION_EXT,
    e_HDR10_HLG_EXT = VK_COLOR_SPACE_HDR10_HLG_EXT,
    e_ADOBERGB_LINEAR_EXT = VK_COLOR_SPACE_ADOBERGB_LINEAR_EXT,
    e_ADOBERGB_NONLINEAR_EXT = VK_COLOR_SPACE_ADOBERGB_NONLINEAR_EXT,
    e_PASS_THROUGH_EXT = VK_COLOR_SPACE_PASS_THROUGH_EXT,
    e_EXTENDED_SRGB_NONLINEAR_EXT = VK_COLOR_SPACE_EXTENDED_SRGB_NONLINEAR_EXT,
    e_BEGIN_RANGE = VK_COLOR_SPACE_BEGIN_RANGE_KHR,
    e_END_RANGE = VK_COLOR_SPACE_END_RANGE_KHR,
    e_RANGE_SIZE = VK_COLOR_SPACE_RANGE_SIZE_KHR,
    e_MAX_ENUM = 0x7FFFFFFF

};
DEFINE_ENUM_BITWISE_OPERATORS(ColorSpaceKHR)
inline std::string to_string(ColorSpaceKHR value)
{
    switch(value)
    {
    case ColorSpaceKHR::e_SRGB_NONLINEAR_KHR: return "VK_COLOR_SPACE_SRGB_NONLINEAR_KHR";
    case ColorSpaceKHR::e_DISPLAY_P3_NONLINEAR_EXT: return "VK_COLOR_SPACE_DISPLAY_P3_NONLINEAR_EXT";
    case ColorSpaceKHR::e_EXTENDED_SRGB_LINEAR_EXT: return "VK_COLOR_SPACE_EXTENDED_SRGB_LINEAR_EXT";
    case ColorSpaceKHR::e_DCI_P3_LINEAR_EXT: return "VK_COLOR_SPACE_DCI_P3_LINEAR_EXT";
    case ColorSpaceKHR::e_DCI_P3_NONLINEAR_EXT: return "VK_COLOR_SPACE_DCI_P3_NONLINEAR_EXT";
    case ColorSpaceKHR::e_BT709_LINEAR_EXT: return "VK_COLOR_SPACE_BT709_LINEAR_EXT";
    case ColorSpaceKHR::e_BT709_NONLINEAR_EXT: return "VK_COLOR_SPACE_BT709_NONLINEAR_EXT";
    case ColorSpaceKHR::e_BT2020_LINEAR_EXT: return "VK_COLOR_SPACE_BT2020_LINEAR_EXT";
    case ColorSpaceKHR::e_HDR10_ST2084_EXT: return "VK_COLOR_SPACE_HDR10_ST2084_EXT";
    case ColorSpaceKHR::e_DOLBYVISION_EXT: return "VK_COLOR_SPACE_DOLBYVISION_EXT";
    case ColorSpaceKHR::e_HDR10_HLG_EXT: return "VK_COLOR_SPACE_HDR10_HLG_EXT";
    case ColorSpaceKHR::e_ADOBERGB_LINEAR_EXT: return "VK_COLOR_SPACE_ADOBERGB_LINEAR_EXT";
    case ColorSpaceKHR::e_ADOBERGB_NONLINEAR_EXT: return "VK_COLOR_SPACE_ADOBERGB_NONLINEAR_EXT";
    case ColorSpaceKHR::e_PASS_THROUGH_EXT: return "VK_COLOR_SPACE_PASS_THROUGH_EXT";
    case ColorSpaceKHR::e_EXTENDED_SRGB_NONLINEAR_EXT: return "VK_COLOR_SPACE_EXTENDED_SRGB_NONLINEAR_EXT";
    default: return "invalid";
    }
}

enum class PresentModeKHR
{
    e_IMMEDIATE_KHR = VK_PRESENT_MODE_IMMEDIATE_KHR,
    e_MAILBOX_KHR = VK_PRESENT_MODE_MAILBOX_KHR,
    e_FIFO_KHR = VK_PRESENT_MODE_FIFO_KHR,
    e_FIFO_RELAXED_KHR = VK_PRESENT_MODE_FIFO_RELAXED_KHR,
    e_SHARED_DEMAND_REFRESH_KHR = VK_PRESENT_MODE_SHARED_DEMAND_REFRESH_KHR,
    e_SHARED_CONTINUOUS_REFRESH_KHR = VK_PRESENT_MODE_SHARED_CONTINUOUS_REFRESH_KHR,
    e_BEGIN_RANGE = VK_PRESENT_MODE_BEGIN_RANGE_KHR,
    e_END_RANGE = VK_PRESENT_MODE_END_RANGE_KHR,
    e_RANGE_SIZE = VK_PRESENT_MODE_RANGE_SIZE_KHR,
    e_MAX_ENUM = 0x7FFFFFFF

};
DEFINE_ENUM_BITWISE_OPERATORS(PresentModeKHR)
inline std::string to_string(PresentModeKHR value)
{
    switch(value)
    {
    case PresentModeKHR::e_IMMEDIATE_KHR: return "VK_PRESENT_MODE_IMMEDIATE_KHR";
    case PresentModeKHR::e_MAILBOX_KHR: return "VK_PRESENT_MODE_MAILBOX_KHR";
    case PresentModeKHR::e_FIFO_KHR: return "VK_PRESENT_MODE_FIFO_KHR";
    case PresentModeKHR::e_FIFO_RELAXED_KHR: return "VK_PRESENT_MODE_FIFO_RELAXED_KHR";
    case PresentModeKHR::e_SHARED_DEMAND_REFRESH_KHR: return "VK_PRESENT_MODE_SHARED_DEMAND_REFRESH_KHR";
    case PresentModeKHR::e_SHARED_CONTINUOUS_REFRESH_KHR: return "VK_PRESENT_MODE_SHARED_CONTINUOUS_REFRESH_KHR";
    default: return "invalid";
    }
}

enum class SwapchainCreateFlagsKHR
{
    e_NONE = 0,
    e_SPLIT_INSTANCE_BIND_REGIONS_BIT_KHR = VK_SWAPCHAIN_CREATE_SPLIT_INSTANCE_BIND_REGIONS_BIT_KHR,
    e_PROTECTED_BIT_KHR = VK_SWAPCHAIN_CREATE_PROTECTED_BIT_KHR,
    e_MAX_ENUM = 0x7FFFFFFF,
    e_ALL_BITS = e_SPLIT_INSTANCE_BIND_REGIONS_BIT_KHR | e_PROTECTED_BIT_KHR
};
DEFINE_ENUM_BITWISE_OPERATORS(SwapchainCreateFlagsKHR)
inline std::string to_string(SwapchainCreateFlagsKHR value)
{
    std::string returnString = "";
    bool addedFlags = false;
    if(static_cast<uint32_t>(value & SwapchainCreateFlagsKHR::e_SPLIT_INSTANCE_BIND_REGIONS_BIT_KHR) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_SWAPCHAIN_CREATE_SPLIT_INSTANCE_BIND_REGIONS_BIT_KHR";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & SwapchainCreateFlagsKHR::e_PROTECTED_BIT_KHR) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_SWAPCHAIN_CREATE_PROTECTED_BIT_KHR";
        addedFlags = true;
    }
    return returnString;
}

enum class DeviceGroupPresentModeFlagsKHR
{
    e_NONE = 0,
    e_LOCAL_BIT_KHR = VK_DEVICE_GROUP_PRESENT_MODE_LOCAL_BIT_KHR,
    e_REMOTE_BIT_KHR = VK_DEVICE_GROUP_PRESENT_MODE_REMOTE_BIT_KHR,
    e_SUM_BIT_KHR = VK_DEVICE_GROUP_PRESENT_MODE_SUM_BIT_KHR,
    e_LOCAL_MULTI_DEVICE_BIT_KHR = VK_DEVICE_GROUP_PRESENT_MODE_LOCAL_MULTI_DEVICE_BIT_KHR,
    e_MAX_ENUM = 0x7FFFFFFF,
    e_ALL_BITS = e_LOCAL_BIT_KHR | e_REMOTE_BIT_KHR | e_SUM_BIT_KHR | e_LOCAL_MULTI_DEVICE_BIT_KHR
};
DEFINE_ENUM_BITWISE_OPERATORS(DeviceGroupPresentModeFlagsKHR)
inline std::string to_string(DeviceGroupPresentModeFlagsKHR value)
{
    std::string returnString = "";
    bool addedFlags = false;
    if(static_cast<uint32_t>(value & DeviceGroupPresentModeFlagsKHR::e_LOCAL_BIT_KHR) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_DEVICE_GROUP_PRESENT_MODE_LOCAL_BIT_KHR";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & DeviceGroupPresentModeFlagsKHR::e_REMOTE_BIT_KHR) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_DEVICE_GROUP_PRESENT_MODE_REMOTE_BIT_KHR";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & DeviceGroupPresentModeFlagsKHR::e_SUM_BIT_KHR) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_DEVICE_GROUP_PRESENT_MODE_SUM_BIT_KHR";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & DeviceGroupPresentModeFlagsKHR::e_LOCAL_MULTI_DEVICE_BIT_KHR) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_DEVICE_GROUP_PRESENT_MODE_LOCAL_MULTI_DEVICE_BIT_KHR";
        addedFlags = true;
    }
    return returnString;
}

enum class DisplayPlaneAlphaFlagsKHR
{
    e_NONE = 0,
    e_OPAQUE_BIT_KHR = VK_DISPLAY_PLANE_ALPHA_OPAQUE_BIT_KHR,
    e_GLOBAL_BIT_KHR = VK_DISPLAY_PLANE_ALPHA_GLOBAL_BIT_KHR,
    e_PER_PIXEL_BIT_KHR = VK_DISPLAY_PLANE_ALPHA_PER_PIXEL_BIT_KHR,
    e_PER_PIXEL_PREMULTIPLIED_BIT_KHR = VK_DISPLAY_PLANE_ALPHA_PER_PIXEL_PREMULTIPLIED_BIT_KHR,
    e_MAX_ENUM = 0x7FFFFFFF,
    e_ALL_BITS = e_OPAQUE_BIT_KHR | e_GLOBAL_BIT_KHR | e_PER_PIXEL_BIT_KHR | e_PER_PIXEL_PREMULTIPLIED_BIT_KHR
};
DEFINE_ENUM_BITWISE_OPERATORS(DisplayPlaneAlphaFlagsKHR)
inline std::string to_string(DisplayPlaneAlphaFlagsKHR value)
{
    std::string returnString = "";
    bool addedFlags = false;
    if(static_cast<uint32_t>(value & DisplayPlaneAlphaFlagsKHR::e_OPAQUE_BIT_KHR) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_DISPLAY_PLANE_ALPHA_OPAQUE_BIT_KHR";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & DisplayPlaneAlphaFlagsKHR::e_GLOBAL_BIT_KHR) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_DISPLAY_PLANE_ALPHA_GLOBAL_BIT_KHR";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & DisplayPlaneAlphaFlagsKHR::e_PER_PIXEL_BIT_KHR) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_DISPLAY_PLANE_ALPHA_PER_PIXEL_BIT_KHR";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & DisplayPlaneAlphaFlagsKHR::e_PER_PIXEL_PREMULTIPLIED_BIT_KHR) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_DISPLAY_PLANE_ALPHA_PER_PIXEL_PREMULTIPLIED_BIT_KHR";
        addedFlags = true;
    }
    return returnString;
}

typedef PeerMemoryFeatureFlags PeerMemoryFeatureFlagsKHR;

typedef MemoryAllocateFlags MemoryAllocateFlagsKHR;

typedef ExternalMemoryHandleTypeFlags ExternalMemoryHandleTypeFlagsKHR;

typedef ExternalMemoryFeatureFlags ExternalMemoryFeatureFlagsKHR;

typedef ExternalSemaphoreHandleTypeFlags ExternalSemaphoreHandleTypeFlagsKHR;

typedef ExternalSemaphoreFeatureFlags ExternalSemaphoreFeatureFlagsKHR;

typedef SemaphoreImportFlags SemaphoreImportFlagsKHR;

typedef DescriptorUpdateTemplateType DescriptorUpdateTemplateTypeKHR;

typedef ExternalFenceHandleTypeFlags ExternalFenceHandleTypeFlagsKHR;

typedef ExternalFenceFeatureFlags ExternalFenceFeatureFlagsKHR;

typedef FenceImportFlags FenceImportFlagsKHR;

typedef PointClippingBehavior PointClippingBehaviorKHR;

typedef TessellationDomainOrigin TessellationDomainOriginKHR;

typedef SamplerYcbcrModelConversion SamplerYcbcrModelConversionKHR;

typedef SamplerYcbcrRange SamplerYcbcrRangeKHR;

typedef ChromaLocation ChromaLocationKHR;

enum class DriverIdKHR
{
    e_AMD_PROPRIETARY_KHR = VK_DRIVER_ID_AMD_PROPRIETARY_KHR,
    e_AMD_OPEN_SOURCE_KHR = VK_DRIVER_ID_AMD_OPEN_SOURCE_KHR,
    e_MESA_RADV_KHR = VK_DRIVER_ID_MESA_RADV_KHR,
    e_NVIDIA_PROPRIETARY_KHR = VK_DRIVER_ID_NVIDIA_PROPRIETARY_KHR,
    e_INTEL_PROPRIETARY_WINDOWS_KHR = VK_DRIVER_ID_INTEL_PROPRIETARY_WINDOWS_KHR,
    e_INTEL_OPEN_SOURCE_MESA_KHR = VK_DRIVER_ID_INTEL_OPEN_SOURCE_MESA_KHR,
    e_IMAGINATION_PROPRIETARY_KHR = VK_DRIVER_ID_IMAGINATION_PROPRIETARY_KHR,
    e_QUALCOMM_PROPRIETARY_KHR = VK_DRIVER_ID_QUALCOMM_PROPRIETARY_KHR,
    e_ARM_PROPRIETARY_KHR = VK_DRIVER_ID_ARM_PROPRIETARY_KHR,
    e_BEGIN_RANGE = VK_DRIVER_ID_BEGIN_RANGE_KHR,
    e_END_RANGE = VK_DRIVER_ID_END_RANGE_KHR,
    e_RANGE_SIZE = VK_DRIVER_ID_RANGE_SIZE_KHR,
    e_MAX_ENUM = 0x7FFFFFFF

};
DEFINE_ENUM_BITWISE_OPERATORS(DriverIdKHR)
inline std::string to_string(DriverIdKHR value)
{
    switch(value)
    {
    case DriverIdKHR::e_AMD_PROPRIETARY_KHR: return "VK_DRIVER_ID_AMD_PROPRIETARY_KHR";
    case DriverIdKHR::e_AMD_OPEN_SOURCE_KHR: return "VK_DRIVER_ID_AMD_OPEN_SOURCE_KHR";
    case DriverIdKHR::e_MESA_RADV_KHR: return "VK_DRIVER_ID_MESA_RADV_KHR";
    case DriverIdKHR::e_NVIDIA_PROPRIETARY_KHR: return "VK_DRIVER_ID_NVIDIA_PROPRIETARY_KHR";
    case DriverIdKHR::e_INTEL_PROPRIETARY_WINDOWS_KHR: return "VK_DRIVER_ID_INTEL_PROPRIETARY_WINDOWS_KHR";
    case DriverIdKHR::e_INTEL_OPEN_SOURCE_MESA_KHR: return "VK_DRIVER_ID_INTEL_OPEN_SOURCE_MESA_KHR";
    case DriverIdKHR::e_IMAGINATION_PROPRIETARY_KHR: return "VK_DRIVER_ID_IMAGINATION_PROPRIETARY_KHR";
    case DriverIdKHR::e_QUALCOMM_PROPRIETARY_KHR: return "VK_DRIVER_ID_QUALCOMM_PROPRIETARY_KHR";
    case DriverIdKHR::e_ARM_PROPRIETARY_KHR: return "VK_DRIVER_ID_ARM_PROPRIETARY_KHR";
    default: return "invalid";
    }
}

enum class DebugReportObjectTypeEXT
{
    e_UNKNOWN_EXT = VK_DEBUG_REPORT_OBJECT_TYPE_UNKNOWN_EXT,
    e_INSTANCE_EXT = VK_DEBUG_REPORT_OBJECT_TYPE_INSTANCE_EXT,
    e_PHYSICAL_DEVICE_EXT = VK_DEBUG_REPORT_OBJECT_TYPE_PHYSICAL_DEVICE_EXT,
    e_DEVICE_EXT = VK_DEBUG_REPORT_OBJECT_TYPE_DEVICE_EXT,
    e_QUEUE_EXT = VK_DEBUG_REPORT_OBJECT_TYPE_QUEUE_EXT,
    e_SEMAPHORE_EXT = VK_DEBUG_REPORT_OBJECT_TYPE_SEMAPHORE_EXT,
    e_COMMAND_BUFFER_EXT = VK_DEBUG_REPORT_OBJECT_TYPE_COMMAND_BUFFER_EXT,
    e_FENCE_EXT = VK_DEBUG_REPORT_OBJECT_TYPE_FENCE_EXT,
    e_DEVICE_MEMORY_EXT = VK_DEBUG_REPORT_OBJECT_TYPE_DEVICE_MEMORY_EXT,
    e_BUFFER_EXT = VK_DEBUG_REPORT_OBJECT_TYPE_BUFFER_EXT,
    e_IMAGE_EXT = VK_DEBUG_REPORT_OBJECT_TYPE_IMAGE_EXT,
    e_EVENT_EXT = VK_DEBUG_REPORT_OBJECT_TYPE_EVENT_EXT,
    e_QUERY_POOL_EXT = VK_DEBUG_REPORT_OBJECT_TYPE_QUERY_POOL_EXT,
    e_BUFFER_VIEW_EXT = VK_DEBUG_REPORT_OBJECT_TYPE_BUFFER_VIEW_EXT,
    e_IMAGE_VIEW_EXT = VK_DEBUG_REPORT_OBJECT_TYPE_IMAGE_VIEW_EXT,
    e_SHADER_MODULE_EXT = VK_DEBUG_REPORT_OBJECT_TYPE_SHADER_MODULE_EXT,
    e_PIPELINE_CACHE_EXT = VK_DEBUG_REPORT_OBJECT_TYPE_PIPELINE_CACHE_EXT,
    e_PIPELINE_LAYOUT_EXT = VK_DEBUG_REPORT_OBJECT_TYPE_PIPELINE_LAYOUT_EXT,
    e_RENDER_PASS_EXT = VK_DEBUG_REPORT_OBJECT_TYPE_RENDER_PASS_EXT,
    e_PIPELINE_EXT = VK_DEBUG_REPORT_OBJECT_TYPE_PIPELINE_EXT,
    e_DESCRIPTOR_SET_LAYOUT_EXT = VK_DEBUG_REPORT_OBJECT_TYPE_DESCRIPTOR_SET_LAYOUT_EXT,
    e_SAMPLER_EXT = VK_DEBUG_REPORT_OBJECT_TYPE_SAMPLER_EXT,
    e_DESCRIPTOR_POOL_EXT = VK_DEBUG_REPORT_OBJECT_TYPE_DESCRIPTOR_POOL_EXT,
    e_DESCRIPTOR_SET_EXT = VK_DEBUG_REPORT_OBJECT_TYPE_DESCRIPTOR_SET_EXT,
    e_FRAMEBUFFER_EXT = VK_DEBUG_REPORT_OBJECT_TYPE_FRAMEBUFFER_EXT,
    e_COMMAND_POOL_EXT = VK_DEBUG_REPORT_OBJECT_TYPE_COMMAND_POOL_EXT,
    e_SURFACE_KHR_EXT = VK_DEBUG_REPORT_OBJECT_TYPE_SURFACE_KHR_EXT,
    e_SWAPCHAIN_KHR_EXT = VK_DEBUG_REPORT_OBJECT_TYPE_SWAPCHAIN_KHR_EXT,
    e_DEBUG_REPORT_CALLBACK_EXT_EXT = VK_DEBUG_REPORT_OBJECT_TYPE_DEBUG_REPORT_CALLBACK_EXT_EXT,
    e_DEBUG_REPORT_EXT = VK_DEBUG_REPORT_OBJECT_TYPE_DEBUG_REPORT_EXT,
    e_DISPLAY_KHR_EXT = VK_DEBUG_REPORT_OBJECT_TYPE_DISPLAY_KHR_EXT,
    e_DISPLAY_MODE_KHR_EXT = VK_DEBUG_REPORT_OBJECT_TYPE_DISPLAY_MODE_KHR_EXT,
    e_OBJECT_TABLE_NVX_EXT = VK_DEBUG_REPORT_OBJECT_TYPE_OBJECT_TABLE_NVX_EXT,
    e_INDIRECT_COMMANDS_LAYOUT_NVX_EXT = VK_DEBUG_REPORT_OBJECT_TYPE_INDIRECT_COMMANDS_LAYOUT_NVX_EXT,
    e_VALIDATION_CACHE_EXT_EXT = VK_DEBUG_REPORT_OBJECT_TYPE_VALIDATION_CACHE_EXT_EXT,
    e_VALIDATION_CACHE_EXT = VK_DEBUG_REPORT_OBJECT_TYPE_VALIDATION_CACHE_EXT,
    e_SAMPLER_YCBCR_CONVERSION_EXT = VK_DEBUG_REPORT_OBJECT_TYPE_SAMPLER_YCBCR_CONVERSION_EXT,
    e_DESCRIPTOR_UPDATE_TEMPLATE_EXT = VK_DEBUG_REPORT_OBJECT_TYPE_DESCRIPTOR_UPDATE_TEMPLATE_EXT,
    e_DESCRIPTOR_UPDATE_TEMPLATE_KHR_EXT = VK_DEBUG_REPORT_OBJECT_TYPE_DESCRIPTOR_UPDATE_TEMPLATE_KHR_EXT,
    e_SAMPLER_YCBCR_CONVERSION_KHR_EXT = VK_DEBUG_REPORT_OBJECT_TYPE_SAMPLER_YCBCR_CONVERSION_KHR_EXT,
    e_ACCELERATION_STRUCTURE_NV_EXT = VK_DEBUG_REPORT_OBJECT_TYPE_ACCELERATION_STRUCTURE_NV_EXT,
    e_BEGIN_RANGE = VK_DEBUG_REPORT_OBJECT_TYPE_BEGIN_RANGE_EXT,
    e_END_RANGE = VK_DEBUG_REPORT_OBJECT_TYPE_END_RANGE_EXT,
    e_RANGE_SIZE = VK_DEBUG_REPORT_OBJECT_TYPE_RANGE_SIZE_EXT,
    e_MAX_ENUM = 0x7FFFFFFF

};
DEFINE_ENUM_BITWISE_OPERATORS(DebugReportObjectTypeEXT)
inline std::string to_string(DebugReportObjectTypeEXT value)
{
    switch(value)
    {
    case DebugReportObjectTypeEXT::e_UNKNOWN_EXT: return "VK_DEBUG_REPORT_OBJECT_TYPE_UNKNOWN_EXT";
    case DebugReportObjectTypeEXT::e_INSTANCE_EXT: return "VK_DEBUG_REPORT_OBJECT_TYPE_INSTANCE_EXT";
    case DebugReportObjectTypeEXT::e_PHYSICAL_DEVICE_EXT: return "VK_DEBUG_REPORT_OBJECT_TYPE_PHYSICAL_DEVICE_EXT";
    case DebugReportObjectTypeEXT::e_DEVICE_EXT: return "VK_DEBUG_REPORT_OBJECT_TYPE_DEVICE_EXT";
    case DebugReportObjectTypeEXT::e_QUEUE_EXT: return "VK_DEBUG_REPORT_OBJECT_TYPE_QUEUE_EXT";
    case DebugReportObjectTypeEXT::e_SEMAPHORE_EXT: return "VK_DEBUG_REPORT_OBJECT_TYPE_SEMAPHORE_EXT";
    case DebugReportObjectTypeEXT::e_COMMAND_BUFFER_EXT: return "VK_DEBUG_REPORT_OBJECT_TYPE_COMMAND_BUFFER_EXT";
    case DebugReportObjectTypeEXT::e_FENCE_EXT: return "VK_DEBUG_REPORT_OBJECT_TYPE_FENCE_EXT";
    case DebugReportObjectTypeEXT::e_DEVICE_MEMORY_EXT: return "VK_DEBUG_REPORT_OBJECT_TYPE_DEVICE_MEMORY_EXT";
    case DebugReportObjectTypeEXT::e_BUFFER_EXT: return "VK_DEBUG_REPORT_OBJECT_TYPE_BUFFER_EXT";
    case DebugReportObjectTypeEXT::e_IMAGE_EXT: return "VK_DEBUG_REPORT_OBJECT_TYPE_IMAGE_EXT";
    case DebugReportObjectTypeEXT::e_EVENT_EXT: return "VK_DEBUG_REPORT_OBJECT_TYPE_EVENT_EXT";
    case DebugReportObjectTypeEXT::e_QUERY_POOL_EXT: return "VK_DEBUG_REPORT_OBJECT_TYPE_QUERY_POOL_EXT";
    case DebugReportObjectTypeEXT::e_BUFFER_VIEW_EXT: return "VK_DEBUG_REPORT_OBJECT_TYPE_BUFFER_VIEW_EXT";
    case DebugReportObjectTypeEXT::e_IMAGE_VIEW_EXT: return "VK_DEBUG_REPORT_OBJECT_TYPE_IMAGE_VIEW_EXT";
    case DebugReportObjectTypeEXT::e_SHADER_MODULE_EXT: return "VK_DEBUG_REPORT_OBJECT_TYPE_SHADER_MODULE_EXT";
    case DebugReportObjectTypeEXT::e_PIPELINE_CACHE_EXT: return "VK_DEBUG_REPORT_OBJECT_TYPE_PIPELINE_CACHE_EXT";
    case DebugReportObjectTypeEXT::e_PIPELINE_LAYOUT_EXT: return "VK_DEBUG_REPORT_OBJECT_TYPE_PIPELINE_LAYOUT_EXT";
    case DebugReportObjectTypeEXT::e_RENDER_PASS_EXT: return "VK_DEBUG_REPORT_OBJECT_TYPE_RENDER_PASS_EXT";
    case DebugReportObjectTypeEXT::e_PIPELINE_EXT: return "VK_DEBUG_REPORT_OBJECT_TYPE_PIPELINE_EXT";
    case DebugReportObjectTypeEXT::e_DESCRIPTOR_SET_LAYOUT_EXT: return "VK_DEBUG_REPORT_OBJECT_TYPE_DESCRIPTOR_SET_LAYOUT_EXT";
    case DebugReportObjectTypeEXT::e_SAMPLER_EXT: return "VK_DEBUG_REPORT_OBJECT_TYPE_SAMPLER_EXT";
    case DebugReportObjectTypeEXT::e_DESCRIPTOR_POOL_EXT: return "VK_DEBUG_REPORT_OBJECT_TYPE_DESCRIPTOR_POOL_EXT";
    case DebugReportObjectTypeEXT::e_DESCRIPTOR_SET_EXT: return "VK_DEBUG_REPORT_OBJECT_TYPE_DESCRIPTOR_SET_EXT";
    case DebugReportObjectTypeEXT::e_FRAMEBUFFER_EXT: return "VK_DEBUG_REPORT_OBJECT_TYPE_FRAMEBUFFER_EXT";
    case DebugReportObjectTypeEXT::e_COMMAND_POOL_EXT: return "VK_DEBUG_REPORT_OBJECT_TYPE_COMMAND_POOL_EXT";
    case DebugReportObjectTypeEXT::e_SURFACE_KHR_EXT: return "VK_DEBUG_REPORT_OBJECT_TYPE_SURFACE_KHR_EXT";
    case DebugReportObjectTypeEXT::e_SWAPCHAIN_KHR_EXT: return "VK_DEBUG_REPORT_OBJECT_TYPE_SWAPCHAIN_KHR_EXT";
    case DebugReportObjectTypeEXT::e_DEBUG_REPORT_CALLBACK_EXT_EXT: return "VK_DEBUG_REPORT_OBJECT_TYPE_DEBUG_REPORT_CALLBACK_EXT_EXT";
    case DebugReportObjectTypeEXT::e_DISPLAY_KHR_EXT: return "VK_DEBUG_REPORT_OBJECT_TYPE_DISPLAY_KHR_EXT";
    case DebugReportObjectTypeEXT::e_DISPLAY_MODE_KHR_EXT: return "VK_DEBUG_REPORT_OBJECT_TYPE_DISPLAY_MODE_KHR_EXT";
    case DebugReportObjectTypeEXT::e_OBJECT_TABLE_NVX_EXT: return "VK_DEBUG_REPORT_OBJECT_TYPE_OBJECT_TABLE_NVX_EXT";
    case DebugReportObjectTypeEXT::e_INDIRECT_COMMANDS_LAYOUT_NVX_EXT: return "VK_DEBUG_REPORT_OBJECT_TYPE_INDIRECT_COMMANDS_LAYOUT_NVX_EXT";
    case DebugReportObjectTypeEXT::e_VALIDATION_CACHE_EXT_EXT: return "VK_DEBUG_REPORT_OBJECT_TYPE_VALIDATION_CACHE_EXT_EXT";
    case DebugReportObjectTypeEXT::e_SAMPLER_YCBCR_CONVERSION_EXT: return "VK_DEBUG_REPORT_OBJECT_TYPE_SAMPLER_YCBCR_CONVERSION_EXT";
    case DebugReportObjectTypeEXT::e_DESCRIPTOR_UPDATE_TEMPLATE_EXT: return "VK_DEBUG_REPORT_OBJECT_TYPE_DESCRIPTOR_UPDATE_TEMPLATE_EXT";
    case DebugReportObjectTypeEXT::e_ACCELERATION_STRUCTURE_NV_EXT: return "VK_DEBUG_REPORT_OBJECT_TYPE_ACCELERATION_STRUCTURE_NV_EXT";
    default: return "invalid";
    }
}

enum class DebugReportFlagsEXT
{
    e_NONE = 0,
    e_INFORMATION_BIT_EXT = VK_DEBUG_REPORT_INFORMATION_BIT_EXT,
    e_WARNING_BIT_EXT = VK_DEBUG_REPORT_WARNING_BIT_EXT,
    e_PERFORMANCE_WARNING_BIT_EXT = VK_DEBUG_REPORT_PERFORMANCE_WARNING_BIT_EXT,
    e_ERROR_BIT_EXT = VK_DEBUG_REPORT_ERROR_BIT_EXT,
    e_DEBUG_BIT_EXT = VK_DEBUG_REPORT_DEBUG_BIT_EXT,
    e_MAX_ENUM = 0x7FFFFFFF,
    e_ALL_BITS = e_INFORMATION_BIT_EXT | e_WARNING_BIT_EXT | e_PERFORMANCE_WARNING_BIT_EXT | e_ERROR_BIT_EXT | e_DEBUG_BIT_EXT
};
DEFINE_ENUM_BITWISE_OPERATORS(DebugReportFlagsEXT)
inline std::string to_string(DebugReportFlagsEXT value)
{
    std::string returnString = "";
    bool addedFlags = false;
    if(static_cast<uint32_t>(value & DebugReportFlagsEXT::e_INFORMATION_BIT_EXT) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_DEBUG_REPORT_INFORMATION_BIT_EXT";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & DebugReportFlagsEXT::e_WARNING_BIT_EXT) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_DEBUG_REPORT_WARNING_BIT_EXT";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & DebugReportFlagsEXT::e_PERFORMANCE_WARNING_BIT_EXT) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_DEBUG_REPORT_PERFORMANCE_WARNING_BIT_EXT";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & DebugReportFlagsEXT::e_ERROR_BIT_EXT) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_DEBUG_REPORT_ERROR_BIT_EXT";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & DebugReportFlagsEXT::e_DEBUG_BIT_EXT) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_DEBUG_REPORT_DEBUG_BIT_EXT";
        addedFlags = true;
    }
    return returnString;
}

enum class RasterizationOrderAMD
{
    e_STRICT_AMD = VK_RASTERIZATION_ORDER_STRICT_AMD,
    e_RELAXED_AMD = VK_RASTERIZATION_ORDER_RELAXED_AMD,
    e_BEGIN_RANGE = VK_RASTERIZATION_ORDER_BEGIN_RANGE_AMD,
    e_END_RANGE = VK_RASTERIZATION_ORDER_END_RANGE_AMD,
    e_RANGE_SIZE = VK_RASTERIZATION_ORDER_RANGE_SIZE_AMD,
    e_MAX_ENUM = 0x7FFFFFFF

};
DEFINE_ENUM_BITWISE_OPERATORS(RasterizationOrderAMD)
inline std::string to_string(RasterizationOrderAMD value)
{
    switch(value)
    {
    case RasterizationOrderAMD::e_STRICT_AMD: return "VK_RASTERIZATION_ORDER_STRICT_AMD";
    case RasterizationOrderAMD::e_RELAXED_AMD: return "VK_RASTERIZATION_ORDER_RELAXED_AMD";
    default: return "invalid";
    }
}

enum class ShaderInfoTypeAMD
{
    e_STATISTICS_AMD = VK_SHADER_INFO_TYPE_STATISTICS_AMD,
    e_BINARY_AMD = VK_SHADER_INFO_TYPE_BINARY_AMD,
    e_DISASSEMBLY_AMD = VK_SHADER_INFO_TYPE_DISASSEMBLY_AMD,
    e_BEGIN_RANGE = VK_SHADER_INFO_TYPE_BEGIN_RANGE_AMD,
    e_END_RANGE = VK_SHADER_INFO_TYPE_END_RANGE_AMD,
    e_RANGE_SIZE = VK_SHADER_INFO_TYPE_RANGE_SIZE_AMD,
    e_MAX_ENUM = 0x7FFFFFFF

};
DEFINE_ENUM_BITWISE_OPERATORS(ShaderInfoTypeAMD)
inline std::string to_string(ShaderInfoTypeAMD value)
{
    switch(value)
    {
    case ShaderInfoTypeAMD::e_STATISTICS_AMD: return "VK_SHADER_INFO_TYPE_STATISTICS_AMD";
    case ShaderInfoTypeAMD::e_BINARY_AMD: return "VK_SHADER_INFO_TYPE_BINARY_AMD";
    case ShaderInfoTypeAMD::e_DISASSEMBLY_AMD: return "VK_SHADER_INFO_TYPE_DISASSEMBLY_AMD";
    default: return "invalid";
    }
}

enum class ExternalMemoryHandleTypeFlagsNV
{
    e_NONE = 0,
    e_OPAQUE_WIN32_BIT_NV = VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_BIT_NV,
    e_OPAQUE_WIN32_KMT_BIT_NV = VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT_NV,
    e_D3D11_IMAGE_BIT_NV = VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_IMAGE_BIT_NV,
    e_D3D11_IMAGE_KMT_BIT_NV = VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_IMAGE_KMT_BIT_NV,
    e_MAX_ENUM = 0x7FFFFFFF,
    e_ALL_BITS = e_OPAQUE_WIN32_BIT_NV | e_OPAQUE_WIN32_KMT_BIT_NV | e_D3D11_IMAGE_BIT_NV | e_D3D11_IMAGE_KMT_BIT_NV
};
DEFINE_ENUM_BITWISE_OPERATORS(ExternalMemoryHandleTypeFlagsNV)
inline std::string to_string(ExternalMemoryHandleTypeFlagsNV value)
{
    std::string returnString = "";
    bool addedFlags = false;
    if(static_cast<uint32_t>(value & ExternalMemoryHandleTypeFlagsNV::e_OPAQUE_WIN32_BIT_NV) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_BIT_NV";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & ExternalMemoryHandleTypeFlagsNV::e_OPAQUE_WIN32_KMT_BIT_NV) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT_NV";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & ExternalMemoryHandleTypeFlagsNV::e_D3D11_IMAGE_BIT_NV) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_IMAGE_BIT_NV";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & ExternalMemoryHandleTypeFlagsNV::e_D3D11_IMAGE_KMT_BIT_NV) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_IMAGE_KMT_BIT_NV";
        addedFlags = true;
    }
    return returnString;
}

enum class ExternalMemoryFeatureFlagsNV
{
    e_NONE = 0,
    e_DEDICATED_ONLY_BIT_NV = VK_EXTERNAL_MEMORY_FEATURE_DEDICATED_ONLY_BIT_NV,
    e_EXPORTABLE_BIT_NV = VK_EXTERNAL_MEMORY_FEATURE_EXPORTABLE_BIT_NV,
    e_IMPORTABLE_BIT_NV = VK_EXTERNAL_MEMORY_FEATURE_IMPORTABLE_BIT_NV,
    e_MAX_ENUM = 0x7FFFFFFF,
    e_ALL_BITS = e_DEDICATED_ONLY_BIT_NV | e_EXPORTABLE_BIT_NV | e_IMPORTABLE_BIT_NV
};
DEFINE_ENUM_BITWISE_OPERATORS(ExternalMemoryFeatureFlagsNV)
inline std::string to_string(ExternalMemoryFeatureFlagsNV value)
{
    std::string returnString = "";
    bool addedFlags = false;
    if(static_cast<uint32_t>(value & ExternalMemoryFeatureFlagsNV::e_DEDICATED_ONLY_BIT_NV) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_EXTERNAL_MEMORY_FEATURE_DEDICATED_ONLY_BIT_NV";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & ExternalMemoryFeatureFlagsNV::e_EXPORTABLE_BIT_NV) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_EXTERNAL_MEMORY_FEATURE_EXPORTABLE_BIT_NV";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & ExternalMemoryFeatureFlagsNV::e_IMPORTABLE_BIT_NV) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_EXTERNAL_MEMORY_FEATURE_IMPORTABLE_BIT_NV";
        addedFlags = true;
    }
    return returnString;
}

enum class ValidationCheckEXT
{
    e_ALL_EXT = VK_VALIDATION_CHECK_ALL_EXT,
    e_SHADERS_EXT = VK_VALIDATION_CHECK_SHADERS_EXT,
    e_BEGIN_RANGE = VK_VALIDATION_CHECK_BEGIN_RANGE_EXT,
    e_END_RANGE = VK_VALIDATION_CHECK_END_RANGE_EXT,
    e_RANGE_SIZE = VK_VALIDATION_CHECK_RANGE_SIZE_EXT,
    e_MAX_ENUM = 0x7FFFFFFF

};
DEFINE_ENUM_BITWISE_OPERATORS(ValidationCheckEXT)
inline std::string to_string(ValidationCheckEXT value)
{
    switch(value)
    {
    case ValidationCheckEXT::e_ALL_EXT: return "VK_VALIDATION_CHECK_ALL_EXT";
    case ValidationCheckEXT::e_SHADERS_EXT: return "VK_VALIDATION_CHECK_SHADERS_EXT";
    default: return "invalid";
    }
}

enum class ConditionalRenderingFlagsEXT
{
    e_NONE = 0,
    e_INVERTED_BIT_EXT = VK_CONDITIONAL_RENDERING_INVERTED_BIT_EXT,
    e_MAX_ENUM = 0x7FFFFFFF,
    e_ALL_BITS = e_INVERTED_BIT_EXT
};
DEFINE_ENUM_BITWISE_OPERATORS(ConditionalRenderingFlagsEXT)
inline std::string to_string(ConditionalRenderingFlagsEXT value)
{
    std::string returnString = "";
    bool addedFlags = false;
    if(static_cast<uint32_t>(value & ConditionalRenderingFlagsEXT::e_INVERTED_BIT_EXT) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_CONDITIONAL_RENDERING_INVERTED_BIT_EXT";
        addedFlags = true;
    }
    return returnString;
}

enum class IndirectCommandsLayoutUsageFlagsNVX
{
    e_NONE = 0,
    e_UNORDERED_SEQUENCES_BIT_NVX = VK_INDIRECT_COMMANDS_LAYOUT_USAGE_UNORDERED_SEQUENCES_BIT_NVX,
    e_SPARSE_SEQUENCES_BIT_NVX = VK_INDIRECT_COMMANDS_LAYOUT_USAGE_SPARSE_SEQUENCES_BIT_NVX,
    e_EMPTY_EXECUTIONS_BIT_NVX = VK_INDIRECT_COMMANDS_LAYOUT_USAGE_EMPTY_EXECUTIONS_BIT_NVX,
    e_INDEXED_SEQUENCES_BIT_NVX = VK_INDIRECT_COMMANDS_LAYOUT_USAGE_INDEXED_SEQUENCES_BIT_NVX,
    e_MAX_ENUM = 0x7FFFFFFF,
    e_ALL_BITS = e_UNORDERED_SEQUENCES_BIT_NVX | e_SPARSE_SEQUENCES_BIT_NVX | e_EMPTY_EXECUTIONS_BIT_NVX | e_INDEXED_SEQUENCES_BIT_NVX
};
DEFINE_ENUM_BITWISE_OPERATORS(IndirectCommandsLayoutUsageFlagsNVX)
inline std::string to_string(IndirectCommandsLayoutUsageFlagsNVX value)
{
    std::string returnString = "";
    bool addedFlags = false;
    if(static_cast<uint32_t>(value & IndirectCommandsLayoutUsageFlagsNVX::e_UNORDERED_SEQUENCES_BIT_NVX) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_INDIRECT_COMMANDS_LAYOUT_USAGE_UNORDERED_SEQUENCES_BIT_NVX";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & IndirectCommandsLayoutUsageFlagsNVX::e_SPARSE_SEQUENCES_BIT_NVX) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_INDIRECT_COMMANDS_LAYOUT_USAGE_SPARSE_SEQUENCES_BIT_NVX";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & IndirectCommandsLayoutUsageFlagsNVX::e_EMPTY_EXECUTIONS_BIT_NVX) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_INDIRECT_COMMANDS_LAYOUT_USAGE_EMPTY_EXECUTIONS_BIT_NVX";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & IndirectCommandsLayoutUsageFlagsNVX::e_INDEXED_SEQUENCES_BIT_NVX) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_INDIRECT_COMMANDS_LAYOUT_USAGE_INDEXED_SEQUENCES_BIT_NVX";
        addedFlags = true;
    }
    return returnString;
}

enum class ObjectEntryUsageFlagsNVX
{
    e_NONE = 0,
    e_GRAPHICS_BIT_NVX = VK_OBJECT_ENTRY_USAGE_GRAPHICS_BIT_NVX,
    e_COMPUTE_BIT_NVX = VK_OBJECT_ENTRY_USAGE_COMPUTE_BIT_NVX,
    e_MAX_ENUM = 0x7FFFFFFF,
    e_ALL_BITS = e_GRAPHICS_BIT_NVX | e_COMPUTE_BIT_NVX
};
DEFINE_ENUM_BITWISE_OPERATORS(ObjectEntryUsageFlagsNVX)
inline std::string to_string(ObjectEntryUsageFlagsNVX value)
{
    std::string returnString = "";
    bool addedFlags = false;
    if(static_cast<uint32_t>(value & ObjectEntryUsageFlagsNVX::e_GRAPHICS_BIT_NVX) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_OBJECT_ENTRY_USAGE_GRAPHICS_BIT_NVX";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & ObjectEntryUsageFlagsNVX::e_COMPUTE_BIT_NVX) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_OBJECT_ENTRY_USAGE_COMPUTE_BIT_NVX";
        addedFlags = true;
    }
    return returnString;
}

enum class IndirectCommandsTokenTypeNVX
{
    e_PIPELINE_NVX = VK_INDIRECT_COMMANDS_TOKEN_TYPE_PIPELINE_NVX,
    e_DESCRIPTOR_SET_NVX = VK_INDIRECT_COMMANDS_TOKEN_TYPE_DESCRIPTOR_SET_NVX,
    e_INDEX_BUFFER_NVX = VK_INDIRECT_COMMANDS_TOKEN_TYPE_INDEX_BUFFER_NVX,
    e_VERTEX_BUFFER_NVX = VK_INDIRECT_COMMANDS_TOKEN_TYPE_VERTEX_BUFFER_NVX,
    e_PUSH_CONSTANT_NVX = VK_INDIRECT_COMMANDS_TOKEN_TYPE_PUSH_CONSTANT_NVX,
    e_DRAW_INDEXED_NVX = VK_INDIRECT_COMMANDS_TOKEN_TYPE_DRAW_INDEXED_NVX,
    e_DRAW_NVX = VK_INDIRECT_COMMANDS_TOKEN_TYPE_DRAW_NVX,
    e_DISPATCH_NVX = VK_INDIRECT_COMMANDS_TOKEN_TYPE_DISPATCH_NVX,
    e_BEGIN_RANGE = VK_INDIRECT_COMMANDS_TOKEN_TYPE_BEGIN_RANGE_NVX,
    e_END_RANGE = VK_INDIRECT_COMMANDS_TOKEN_TYPE_END_RANGE_NVX,
    e_RANGE_SIZE = VK_INDIRECT_COMMANDS_TOKEN_TYPE_RANGE_SIZE_NVX,
    e_MAX_ENUM = 0x7FFFFFFF

};
DEFINE_ENUM_BITWISE_OPERATORS(IndirectCommandsTokenTypeNVX)
inline std::string to_string(IndirectCommandsTokenTypeNVX value)
{
    switch(value)
    {
    case IndirectCommandsTokenTypeNVX::e_PIPELINE_NVX: return "VK_INDIRECT_COMMANDS_TOKEN_TYPE_PIPELINE_NVX";
    case IndirectCommandsTokenTypeNVX::e_DESCRIPTOR_SET_NVX: return "VK_INDIRECT_COMMANDS_TOKEN_TYPE_DESCRIPTOR_SET_NVX";
    case IndirectCommandsTokenTypeNVX::e_INDEX_BUFFER_NVX: return "VK_INDIRECT_COMMANDS_TOKEN_TYPE_INDEX_BUFFER_NVX";
    case IndirectCommandsTokenTypeNVX::e_VERTEX_BUFFER_NVX: return "VK_INDIRECT_COMMANDS_TOKEN_TYPE_VERTEX_BUFFER_NVX";
    case IndirectCommandsTokenTypeNVX::e_PUSH_CONSTANT_NVX: return "VK_INDIRECT_COMMANDS_TOKEN_TYPE_PUSH_CONSTANT_NVX";
    case IndirectCommandsTokenTypeNVX::e_DRAW_INDEXED_NVX: return "VK_INDIRECT_COMMANDS_TOKEN_TYPE_DRAW_INDEXED_NVX";
    case IndirectCommandsTokenTypeNVX::e_DRAW_NVX: return "VK_INDIRECT_COMMANDS_TOKEN_TYPE_DRAW_NVX";
    case IndirectCommandsTokenTypeNVX::e_DISPATCH_NVX: return "VK_INDIRECT_COMMANDS_TOKEN_TYPE_DISPATCH_NVX";
    default: return "invalid";
    }
}

enum class ObjectEntryTypeNVX
{
    e_DESCRIPTOR_SET_NVX = VK_OBJECT_ENTRY_TYPE_DESCRIPTOR_SET_NVX,
    e_PIPELINE_NVX = VK_OBJECT_ENTRY_TYPE_PIPELINE_NVX,
    e_INDEX_BUFFER_NVX = VK_OBJECT_ENTRY_TYPE_INDEX_BUFFER_NVX,
    e_VERTEX_BUFFER_NVX = VK_OBJECT_ENTRY_TYPE_VERTEX_BUFFER_NVX,
    e_PUSH_CONSTANT_NVX = VK_OBJECT_ENTRY_TYPE_PUSH_CONSTANT_NVX,
    e_BEGIN_RANGE = VK_OBJECT_ENTRY_TYPE_BEGIN_RANGE_NVX,
    e_END_RANGE = VK_OBJECT_ENTRY_TYPE_END_RANGE_NVX,
    e_RANGE_SIZE = VK_OBJECT_ENTRY_TYPE_RANGE_SIZE_NVX,
    e_MAX_ENUM = 0x7FFFFFFF

};
DEFINE_ENUM_BITWISE_OPERATORS(ObjectEntryTypeNVX)
inline std::string to_string(ObjectEntryTypeNVX value)
{
    switch(value)
    {
    case ObjectEntryTypeNVX::e_DESCRIPTOR_SET_NVX: return "VK_OBJECT_ENTRY_TYPE_DESCRIPTOR_SET_NVX";
    case ObjectEntryTypeNVX::e_PIPELINE_NVX: return "VK_OBJECT_ENTRY_TYPE_PIPELINE_NVX";
    case ObjectEntryTypeNVX::e_INDEX_BUFFER_NVX: return "VK_OBJECT_ENTRY_TYPE_INDEX_BUFFER_NVX";
    case ObjectEntryTypeNVX::e_VERTEX_BUFFER_NVX: return "VK_OBJECT_ENTRY_TYPE_VERTEX_BUFFER_NVX";
    case ObjectEntryTypeNVX::e_PUSH_CONSTANT_NVX: return "VK_OBJECT_ENTRY_TYPE_PUSH_CONSTANT_NVX";
    default: return "invalid";
    }
}

enum class SurfaceCounterFlagsEXT
{
    e_NONE = 0,
    e_VBLANK_EXT = VK_SURFACE_COUNTER_VBLANK_EXT,
    e_MAX_ENUM = 0x7FFFFFFF,
    e_ALL_BITS = e_VBLANK_EXT
};
DEFINE_ENUM_BITWISE_OPERATORS(SurfaceCounterFlagsEXT)
inline std::string to_string(SurfaceCounterFlagsEXT value)
{
    std::string returnString = "";
    bool addedFlags = false;
    if(static_cast<uint32_t>(value & SurfaceCounterFlagsEXT::e_VBLANK_EXT) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_SURFACE_COUNTER_VBLANK_EXT";
        addedFlags = true;
    }
    return returnString;
}

enum class DisplayPowerStateEXT
{
    e_OFF_EXT = VK_DISPLAY_POWER_STATE_OFF_EXT,
    e_SUSPEND_EXT = VK_DISPLAY_POWER_STATE_SUSPEND_EXT,
    e_ON_EXT = VK_DISPLAY_POWER_STATE_ON_EXT,
    e_BEGIN_RANGE = VK_DISPLAY_POWER_STATE_BEGIN_RANGE_EXT,
    e_END_RANGE = VK_DISPLAY_POWER_STATE_END_RANGE_EXT,
    e_RANGE_SIZE = VK_DISPLAY_POWER_STATE_RANGE_SIZE_EXT,
    e_MAX_ENUM = 0x7FFFFFFF

};
DEFINE_ENUM_BITWISE_OPERATORS(DisplayPowerStateEXT)
inline std::string to_string(DisplayPowerStateEXT value)
{
    switch(value)
    {
    case DisplayPowerStateEXT::e_OFF_EXT: return "VK_DISPLAY_POWER_STATE_OFF_EXT";
    case DisplayPowerStateEXT::e_SUSPEND_EXT: return "VK_DISPLAY_POWER_STATE_SUSPEND_EXT";
    case DisplayPowerStateEXT::e_ON_EXT: return "VK_DISPLAY_POWER_STATE_ON_EXT";
    default: return "invalid";
    }
}

enum class DeviceEventTypeEXT
{
    e_DISPLAY_HOTPLUG_EXT = VK_DEVICE_EVENT_TYPE_DISPLAY_HOTPLUG_EXT,
    e_BEGIN_RANGE = VK_DEVICE_EVENT_TYPE_BEGIN_RANGE_EXT,
    e_END_RANGE = VK_DEVICE_EVENT_TYPE_END_RANGE_EXT,
    e_RANGE_SIZE = VK_DEVICE_EVENT_TYPE_RANGE_SIZE_EXT,
    e_MAX_ENUM = 0x7FFFFFFF

};
DEFINE_ENUM_BITWISE_OPERATORS(DeviceEventTypeEXT)
inline std::string to_string(DeviceEventTypeEXT value)
{
    switch(value)
    {
    case DeviceEventTypeEXT::e_DISPLAY_HOTPLUG_EXT: return "VK_DEVICE_EVENT_TYPE_DISPLAY_HOTPLUG_EXT";
    default: return "invalid";
    }
}

enum class DisplayEventTypeEXT
{
    e_FIRST_PIXEL_OUT_EXT = VK_DISPLAY_EVENT_TYPE_FIRST_PIXEL_OUT_EXT,
    e_BEGIN_RANGE = VK_DISPLAY_EVENT_TYPE_BEGIN_RANGE_EXT,
    e_END_RANGE = VK_DISPLAY_EVENT_TYPE_END_RANGE_EXT,
    e_RANGE_SIZE = VK_DISPLAY_EVENT_TYPE_RANGE_SIZE_EXT,
    e_MAX_ENUM = 0x7FFFFFFF

};
DEFINE_ENUM_BITWISE_OPERATORS(DisplayEventTypeEXT)
inline std::string to_string(DisplayEventTypeEXT value)
{
    switch(value)
    {
    case DisplayEventTypeEXT::e_FIRST_PIXEL_OUT_EXT: return "VK_DISPLAY_EVENT_TYPE_FIRST_PIXEL_OUT_EXT";
    default: return "invalid";
    }
}

enum class ViewportCoordinateSwizzleNV
{
    e_POSITIVE_X_NV = VK_VIEWPORT_COORDINATE_SWIZZLE_POSITIVE_X_NV,
    e_NEGATIVE_X_NV = VK_VIEWPORT_COORDINATE_SWIZZLE_NEGATIVE_X_NV,
    e_POSITIVE_Y_NV = VK_VIEWPORT_COORDINATE_SWIZZLE_POSITIVE_Y_NV,
    e_NEGATIVE_Y_NV = VK_VIEWPORT_COORDINATE_SWIZZLE_NEGATIVE_Y_NV,
    e_POSITIVE_Z_NV = VK_VIEWPORT_COORDINATE_SWIZZLE_POSITIVE_Z_NV,
    e_NEGATIVE_Z_NV = VK_VIEWPORT_COORDINATE_SWIZZLE_NEGATIVE_Z_NV,
    e_POSITIVE_W_NV = VK_VIEWPORT_COORDINATE_SWIZZLE_POSITIVE_W_NV,
    e_NEGATIVE_W_NV = VK_VIEWPORT_COORDINATE_SWIZZLE_NEGATIVE_W_NV,
    e_BEGIN_RANGE = VK_VIEWPORT_COORDINATE_SWIZZLE_BEGIN_RANGE_NV,
    e_END_RANGE = VK_VIEWPORT_COORDINATE_SWIZZLE_END_RANGE_NV,
    e_RANGE_SIZE = VK_VIEWPORT_COORDINATE_SWIZZLE_RANGE_SIZE_NV,
    e_MAX_ENUM = 0x7FFFFFFF

};
DEFINE_ENUM_BITWISE_OPERATORS(ViewportCoordinateSwizzleNV)
inline std::string to_string(ViewportCoordinateSwizzleNV value)
{
    switch(value)
    {
    case ViewportCoordinateSwizzleNV::e_POSITIVE_X_NV: return "VK_VIEWPORT_COORDINATE_SWIZZLE_POSITIVE_X_NV";
    case ViewportCoordinateSwizzleNV::e_NEGATIVE_X_NV: return "VK_VIEWPORT_COORDINATE_SWIZZLE_NEGATIVE_X_NV";
    case ViewportCoordinateSwizzleNV::e_POSITIVE_Y_NV: return "VK_VIEWPORT_COORDINATE_SWIZZLE_POSITIVE_Y_NV";
    case ViewportCoordinateSwizzleNV::e_NEGATIVE_Y_NV: return "VK_VIEWPORT_COORDINATE_SWIZZLE_NEGATIVE_Y_NV";
    case ViewportCoordinateSwizzleNV::e_POSITIVE_Z_NV: return "VK_VIEWPORT_COORDINATE_SWIZZLE_POSITIVE_Z_NV";
    case ViewportCoordinateSwizzleNV::e_NEGATIVE_Z_NV: return "VK_VIEWPORT_COORDINATE_SWIZZLE_NEGATIVE_Z_NV";
    case ViewportCoordinateSwizzleNV::e_POSITIVE_W_NV: return "VK_VIEWPORT_COORDINATE_SWIZZLE_POSITIVE_W_NV";
    case ViewportCoordinateSwizzleNV::e_NEGATIVE_W_NV: return "VK_VIEWPORT_COORDINATE_SWIZZLE_NEGATIVE_W_NV";
    default: return "invalid";
    }
}

enum class DiscardRectangleModeEXT
{
    e_INCLUSIVE_EXT = VK_DISCARD_RECTANGLE_MODE_INCLUSIVE_EXT,
    e_EXCLUSIVE_EXT = VK_DISCARD_RECTANGLE_MODE_EXCLUSIVE_EXT,
    e_BEGIN_RANGE = VK_DISCARD_RECTANGLE_MODE_BEGIN_RANGE_EXT,
    e_END_RANGE = VK_DISCARD_RECTANGLE_MODE_END_RANGE_EXT,
    e_RANGE_SIZE = VK_DISCARD_RECTANGLE_MODE_RANGE_SIZE_EXT,
    e_MAX_ENUM = 0x7FFFFFFF

};
DEFINE_ENUM_BITWISE_OPERATORS(DiscardRectangleModeEXT)
inline std::string to_string(DiscardRectangleModeEXT value)
{
    switch(value)
    {
    case DiscardRectangleModeEXT::e_INCLUSIVE_EXT: return "VK_DISCARD_RECTANGLE_MODE_INCLUSIVE_EXT";
    case DiscardRectangleModeEXT::e_EXCLUSIVE_EXT: return "VK_DISCARD_RECTANGLE_MODE_EXCLUSIVE_EXT";
    default: return "invalid";
    }
}

enum class ConservativeRasterizationModeEXT
{
    e_DISABLED_EXT = VK_CONSERVATIVE_RASTERIZATION_MODE_DISABLED_EXT,
    e_OVERESTIMATE_EXT = VK_CONSERVATIVE_RASTERIZATION_MODE_OVERESTIMATE_EXT,
    e_UNDERESTIMATE_EXT = VK_CONSERVATIVE_RASTERIZATION_MODE_UNDERESTIMATE_EXT,
    e_BEGIN_RANGE = VK_CONSERVATIVE_RASTERIZATION_MODE_BEGIN_RANGE_EXT,
    e_END_RANGE = VK_CONSERVATIVE_RASTERIZATION_MODE_END_RANGE_EXT,
    e_RANGE_SIZE = VK_CONSERVATIVE_RASTERIZATION_MODE_RANGE_SIZE_EXT,
    e_MAX_ENUM = 0x7FFFFFFF

};
DEFINE_ENUM_BITWISE_OPERATORS(ConservativeRasterizationModeEXT)
inline std::string to_string(ConservativeRasterizationModeEXT value)
{
    switch(value)
    {
    case ConservativeRasterizationModeEXT::e_DISABLED_EXT: return "VK_CONSERVATIVE_RASTERIZATION_MODE_DISABLED_EXT";
    case ConservativeRasterizationModeEXT::e_OVERESTIMATE_EXT: return "VK_CONSERVATIVE_RASTERIZATION_MODE_OVERESTIMATE_EXT";
    case ConservativeRasterizationModeEXT::e_UNDERESTIMATE_EXT: return "VK_CONSERVATIVE_RASTERIZATION_MODE_UNDERESTIMATE_EXT";
    default: return "invalid";
    }
}

enum class DebugUtilsMessageSeverityFlagsEXT
{
    e_NONE = 0,
    e_VERBOSE_BIT_EXT = VK_DEBUG_UTILS_MESSAGE_SEVERITY_VERBOSE_BIT_EXT,
    e_INFO_BIT_EXT = VK_DEBUG_UTILS_MESSAGE_SEVERITY_INFO_BIT_EXT,
    e_WARNING_BIT_EXT = VK_DEBUG_UTILS_MESSAGE_SEVERITY_WARNING_BIT_EXT,
    e_ERROR_BIT_EXT = VK_DEBUG_UTILS_MESSAGE_SEVERITY_ERROR_BIT_EXT,
    e_MAX_ENUM = 0x7FFFFFFF,
    e_ALL_BITS = e_VERBOSE_BIT_EXT | e_INFO_BIT_EXT | e_WARNING_BIT_EXT | e_ERROR_BIT_EXT
};
DEFINE_ENUM_BITWISE_OPERATORS(DebugUtilsMessageSeverityFlagsEXT)
inline std::string to_string(DebugUtilsMessageSeverityFlagsEXT value)
{
    std::string returnString = "";
    bool addedFlags = false;
    if(static_cast<uint32_t>(value & DebugUtilsMessageSeverityFlagsEXT::e_VERBOSE_BIT_EXT) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_DEBUG_UTILS_MESSAGE_SEVERITY_VERBOSE_BIT_EXT";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & DebugUtilsMessageSeverityFlagsEXT::e_INFO_BIT_EXT) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_DEBUG_UTILS_MESSAGE_SEVERITY_INFO_BIT_EXT";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & DebugUtilsMessageSeverityFlagsEXT::e_WARNING_BIT_EXT) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_DEBUG_UTILS_MESSAGE_SEVERITY_WARNING_BIT_EXT";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & DebugUtilsMessageSeverityFlagsEXT::e_ERROR_BIT_EXT) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_DEBUG_UTILS_MESSAGE_SEVERITY_ERROR_BIT_EXT";
        addedFlags = true;
    }
    return returnString;
}

enum class DebugUtilsMessageTypeFlagsEXT
{
    e_NONE = 0,
    e_GENERAL_BIT_EXT = VK_DEBUG_UTILS_MESSAGE_TYPE_GENERAL_BIT_EXT,
    e_VALIDATION_BIT_EXT = VK_DEBUG_UTILS_MESSAGE_TYPE_VALIDATION_BIT_EXT,
    e_PERFORMANCE_BIT_EXT = VK_DEBUG_UTILS_MESSAGE_TYPE_PERFORMANCE_BIT_EXT,
    e_MAX_ENUM = 0x7FFFFFFF,
    e_ALL_BITS = e_GENERAL_BIT_EXT | e_VALIDATION_BIT_EXT | e_PERFORMANCE_BIT_EXT
};
DEFINE_ENUM_BITWISE_OPERATORS(DebugUtilsMessageTypeFlagsEXT)
inline std::string to_string(DebugUtilsMessageTypeFlagsEXT value)
{
    std::string returnString = "";
    bool addedFlags = false;
    if(static_cast<uint32_t>(value & DebugUtilsMessageTypeFlagsEXT::e_GENERAL_BIT_EXT) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_DEBUG_UTILS_MESSAGE_TYPE_GENERAL_BIT_EXT";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & DebugUtilsMessageTypeFlagsEXT::e_VALIDATION_BIT_EXT) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_DEBUG_UTILS_MESSAGE_TYPE_VALIDATION_BIT_EXT";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & DebugUtilsMessageTypeFlagsEXT::e_PERFORMANCE_BIT_EXT) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_DEBUG_UTILS_MESSAGE_TYPE_PERFORMANCE_BIT_EXT";
        addedFlags = true;
    }
    return returnString;
}

enum class SamplerReductionModeEXT
{
    e_WEIGHTED_AVERAGE_EXT = VK_SAMPLER_REDUCTION_MODE_WEIGHTED_AVERAGE_EXT,
    e_MIN_EXT = VK_SAMPLER_REDUCTION_MODE_MIN_EXT,
    e_MAX_EXT = VK_SAMPLER_REDUCTION_MODE_MAX_EXT,
    e_BEGIN_RANGE = VK_SAMPLER_REDUCTION_MODE_BEGIN_RANGE_EXT,
    e_END_RANGE = VK_SAMPLER_REDUCTION_MODE_END_RANGE_EXT,
    e_RANGE_SIZE = VK_SAMPLER_REDUCTION_MODE_RANGE_SIZE_EXT,
    e_MAX_ENUM = 0x7FFFFFFF

};
DEFINE_ENUM_BITWISE_OPERATORS(SamplerReductionModeEXT)
inline std::string to_string(SamplerReductionModeEXT value)
{
    switch(value)
    {
    case SamplerReductionModeEXT::e_WEIGHTED_AVERAGE_EXT: return "VK_SAMPLER_REDUCTION_MODE_WEIGHTED_AVERAGE_EXT";
    case SamplerReductionModeEXT::e_MIN_EXT: return "VK_SAMPLER_REDUCTION_MODE_MIN_EXT";
    case SamplerReductionModeEXT::e_MAX_EXT: return "VK_SAMPLER_REDUCTION_MODE_MAX_EXT";
    default: return "invalid";
    }
}

enum class BlendOverlapEXT
{
    e_UNCORRELATED_EXT = VK_BLEND_OVERLAP_UNCORRELATED_EXT,
    e_DISJOINT_EXT = VK_BLEND_OVERLAP_DISJOINT_EXT,
    e_CONJOINT_EXT = VK_BLEND_OVERLAP_CONJOINT_EXT,
    e_BEGIN_RANGE = VK_BLEND_OVERLAP_BEGIN_RANGE_EXT,
    e_END_RANGE = VK_BLEND_OVERLAP_END_RANGE_EXT,
    e_RANGE_SIZE = VK_BLEND_OVERLAP_RANGE_SIZE_EXT,
    e_MAX_ENUM = 0x7FFFFFFF

};
DEFINE_ENUM_BITWISE_OPERATORS(BlendOverlapEXT)
inline std::string to_string(BlendOverlapEXT value)
{
    switch(value)
    {
    case BlendOverlapEXT::e_UNCORRELATED_EXT: return "VK_BLEND_OVERLAP_UNCORRELATED_EXT";
    case BlendOverlapEXT::e_DISJOINT_EXT: return "VK_BLEND_OVERLAP_DISJOINT_EXT";
    case BlendOverlapEXT::e_CONJOINT_EXT: return "VK_BLEND_OVERLAP_CONJOINT_EXT";
    default: return "invalid";
    }
}

enum class CoverageModulationModeNV
{
    e_NONE_NV = VK_COVERAGE_MODULATION_MODE_NONE_NV,
    e_RGB_NV = VK_COVERAGE_MODULATION_MODE_RGB_NV,
    e_ALPHA_NV = VK_COVERAGE_MODULATION_MODE_ALPHA_NV,
    e_RGBA_NV = VK_COVERAGE_MODULATION_MODE_RGBA_NV,
    e_BEGIN_RANGE = VK_COVERAGE_MODULATION_MODE_BEGIN_RANGE_NV,
    e_END_RANGE = VK_COVERAGE_MODULATION_MODE_END_RANGE_NV,
    e_RANGE_SIZE = VK_COVERAGE_MODULATION_MODE_RANGE_SIZE_NV,
    e_MAX_ENUM = 0x7FFFFFFF

};
DEFINE_ENUM_BITWISE_OPERATORS(CoverageModulationModeNV)
inline std::string to_string(CoverageModulationModeNV value)
{
    switch(value)
    {
    case CoverageModulationModeNV::e_NONE_NV: return "VK_COVERAGE_MODULATION_MODE_NONE_NV";
    case CoverageModulationModeNV::e_RGB_NV: return "VK_COVERAGE_MODULATION_MODE_RGB_NV";
    case CoverageModulationModeNV::e_ALPHA_NV: return "VK_COVERAGE_MODULATION_MODE_ALPHA_NV";
    case CoverageModulationModeNV::e_RGBA_NV: return "VK_COVERAGE_MODULATION_MODE_RGBA_NV";
    default: return "invalid";
    }
}

enum class ValidationCacheHeaderVersionEXT
{
    e_ONE_EXT = VK_VALIDATION_CACHE_HEADER_VERSION_ONE_EXT,
    e_BEGIN_RANGE = VK_VALIDATION_CACHE_HEADER_VERSION_BEGIN_RANGE_EXT,
    e_END_RANGE = VK_VALIDATION_CACHE_HEADER_VERSION_END_RANGE_EXT,
    e_RANGE_SIZE = VK_VALIDATION_CACHE_HEADER_VERSION_RANGE_SIZE_EXT,
    e_MAX_ENUM = 0x7FFFFFFF

};
DEFINE_ENUM_BITWISE_OPERATORS(ValidationCacheHeaderVersionEXT)
inline std::string to_string(ValidationCacheHeaderVersionEXT value)
{
    switch(value)
    {
    case ValidationCacheHeaderVersionEXT::e_ONE_EXT: return "VK_VALIDATION_CACHE_HEADER_VERSION_ONE_EXT";
    default: return "invalid";
    }
}

enum class DescriptorBindingFlagsEXT
{
    e_NONE = 0,
    e_UPDATE_AFTER_BIND_BIT_EXT = VK_DESCRIPTOR_BINDING_UPDATE_AFTER_BIND_BIT_EXT,
    e_UPDATE_UNUSED_WHILE_PENDING_BIT_EXT = VK_DESCRIPTOR_BINDING_UPDATE_UNUSED_WHILE_PENDING_BIT_EXT,
    e_PARTIALLY_BOUND_BIT_EXT = VK_DESCRIPTOR_BINDING_PARTIALLY_BOUND_BIT_EXT,
    e_VARIABLE_DESCRIPTOR_COUNT_BIT_EXT = VK_DESCRIPTOR_BINDING_VARIABLE_DESCRIPTOR_COUNT_BIT_EXT,
    e_MAX_ENUM = 0x7FFFFFFF,
    e_ALL_BITS = e_UPDATE_AFTER_BIND_BIT_EXT | e_UPDATE_UNUSED_WHILE_PENDING_BIT_EXT | e_PARTIALLY_BOUND_BIT_EXT | e_VARIABLE_DESCRIPTOR_COUNT_BIT_EXT
};
DEFINE_ENUM_BITWISE_OPERATORS(DescriptorBindingFlagsEXT)
inline std::string to_string(DescriptorBindingFlagsEXT value)
{
    std::string returnString = "";
    bool addedFlags = false;
    if(static_cast<uint32_t>(value & DescriptorBindingFlagsEXT::e_UPDATE_AFTER_BIND_BIT_EXT) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_DESCRIPTOR_BINDING_UPDATE_AFTER_BIND_BIT_EXT";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & DescriptorBindingFlagsEXT::e_UPDATE_UNUSED_WHILE_PENDING_BIT_EXT) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_DESCRIPTOR_BINDING_UPDATE_UNUSED_WHILE_PENDING_BIT_EXT";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & DescriptorBindingFlagsEXT::e_PARTIALLY_BOUND_BIT_EXT) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_DESCRIPTOR_BINDING_PARTIALLY_BOUND_BIT_EXT";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & DescriptorBindingFlagsEXT::e_VARIABLE_DESCRIPTOR_COUNT_BIT_EXT) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_DESCRIPTOR_BINDING_VARIABLE_DESCRIPTOR_COUNT_BIT_EXT";
        addedFlags = true;
    }
    return returnString;
}

enum class ShadingRatePaletteEntryNV
{
    e_NO_INVOCATIONS_NV = VK_SHADING_RATE_PALETTE_ENTRY_NO_INVOCATIONS_NV,
    e_16_INVOCATIONS_PER_PIXEL_NV = VK_SHADING_RATE_PALETTE_ENTRY_16_INVOCATIONS_PER_PIXEL_NV,
    e_8_INVOCATIONS_PER_PIXEL_NV = VK_SHADING_RATE_PALETTE_ENTRY_8_INVOCATIONS_PER_PIXEL_NV,
    e_4_INVOCATIONS_PER_PIXEL_NV = VK_SHADING_RATE_PALETTE_ENTRY_4_INVOCATIONS_PER_PIXEL_NV,
    e_2_INVOCATIONS_PER_PIXEL_NV = VK_SHADING_RATE_PALETTE_ENTRY_2_INVOCATIONS_PER_PIXEL_NV,
    e_1_INVOCATION_PER_PIXEL_NV = VK_SHADING_RATE_PALETTE_ENTRY_1_INVOCATION_PER_PIXEL_NV,
    e_1_INVOCATION_PER_2X1_PIXELS_NV = VK_SHADING_RATE_PALETTE_ENTRY_1_INVOCATION_PER_2X1_PIXELS_NV,
    e_1_INVOCATION_PER_1X2_PIXELS_NV = VK_SHADING_RATE_PALETTE_ENTRY_1_INVOCATION_PER_1X2_PIXELS_NV,
    e_1_INVOCATION_PER_2X2_PIXELS_NV = VK_SHADING_RATE_PALETTE_ENTRY_1_INVOCATION_PER_2X2_PIXELS_NV,
    e_1_INVOCATION_PER_4X2_PIXELS_NV = VK_SHADING_RATE_PALETTE_ENTRY_1_INVOCATION_PER_4X2_PIXELS_NV,
    e_1_INVOCATION_PER_2X4_PIXELS_NV = VK_SHADING_RATE_PALETTE_ENTRY_1_INVOCATION_PER_2X4_PIXELS_NV,
    e_1_INVOCATION_PER_4X4_PIXELS_NV = VK_SHADING_RATE_PALETTE_ENTRY_1_INVOCATION_PER_4X4_PIXELS_NV,
    e_BEGIN_RANGE = VK_SHADING_RATE_PALETTE_ENTRY_BEGIN_RANGE_NV,
    e_END_RANGE = VK_SHADING_RATE_PALETTE_ENTRY_END_RANGE_NV,
    e_RANGE_SIZE = VK_SHADING_RATE_PALETTE_ENTRY_RANGE_SIZE_NV,
    e_MAX_ENUM = 0x7FFFFFFF

};
DEFINE_ENUM_BITWISE_OPERATORS(ShadingRatePaletteEntryNV)
inline std::string to_string(ShadingRatePaletteEntryNV value)
{
    switch(value)
    {
    case ShadingRatePaletteEntryNV::e_NO_INVOCATIONS_NV: return "VK_SHADING_RATE_PALETTE_ENTRY_NO_INVOCATIONS_NV";
    case ShadingRatePaletteEntryNV::e_16_INVOCATIONS_PER_PIXEL_NV: return "VK_SHADING_RATE_PALETTE_ENTRY_16_INVOCATIONS_PER_PIXEL_NV";
    case ShadingRatePaletteEntryNV::e_8_INVOCATIONS_PER_PIXEL_NV: return "VK_SHADING_RATE_PALETTE_ENTRY_8_INVOCATIONS_PER_PIXEL_NV";
    case ShadingRatePaletteEntryNV::e_4_INVOCATIONS_PER_PIXEL_NV: return "VK_SHADING_RATE_PALETTE_ENTRY_4_INVOCATIONS_PER_PIXEL_NV";
    case ShadingRatePaletteEntryNV::e_2_INVOCATIONS_PER_PIXEL_NV: return "VK_SHADING_RATE_PALETTE_ENTRY_2_INVOCATIONS_PER_PIXEL_NV";
    case ShadingRatePaletteEntryNV::e_1_INVOCATION_PER_PIXEL_NV: return "VK_SHADING_RATE_PALETTE_ENTRY_1_INVOCATION_PER_PIXEL_NV";
    case ShadingRatePaletteEntryNV::e_1_INVOCATION_PER_2X1_PIXELS_NV: return "VK_SHADING_RATE_PALETTE_ENTRY_1_INVOCATION_PER_2X1_PIXELS_NV";
    case ShadingRatePaletteEntryNV::e_1_INVOCATION_PER_1X2_PIXELS_NV: return "VK_SHADING_RATE_PALETTE_ENTRY_1_INVOCATION_PER_1X2_PIXELS_NV";
    case ShadingRatePaletteEntryNV::e_1_INVOCATION_PER_2X2_PIXELS_NV: return "VK_SHADING_RATE_PALETTE_ENTRY_1_INVOCATION_PER_2X2_PIXELS_NV";
    case ShadingRatePaletteEntryNV::e_1_INVOCATION_PER_4X2_PIXELS_NV: return "VK_SHADING_RATE_PALETTE_ENTRY_1_INVOCATION_PER_4X2_PIXELS_NV";
    case ShadingRatePaletteEntryNV::e_1_INVOCATION_PER_2X4_PIXELS_NV: return "VK_SHADING_RATE_PALETTE_ENTRY_1_INVOCATION_PER_2X4_PIXELS_NV";
    case ShadingRatePaletteEntryNV::e_1_INVOCATION_PER_4X4_PIXELS_NV: return "VK_SHADING_RATE_PALETTE_ENTRY_1_INVOCATION_PER_4X4_PIXELS_NV";
    default: return "invalid";
    }
}

enum class CoarseSampleOrderTypeNV
{
    e_DEFAULT_NV = VK_COARSE_SAMPLE_ORDER_TYPE_DEFAULT_NV,
    e_CUSTOM_NV = VK_COARSE_SAMPLE_ORDER_TYPE_CUSTOM_NV,
    e_PIXEL_MAJOR_NV = VK_COARSE_SAMPLE_ORDER_TYPE_PIXEL_MAJOR_NV,
    e_SAMPLE_MAJOR_NV = VK_COARSE_SAMPLE_ORDER_TYPE_SAMPLE_MAJOR_NV,
    e_BEGIN_RANGE = VK_COARSE_SAMPLE_ORDER_TYPE_BEGIN_RANGE_NV,
    e_END_RANGE = VK_COARSE_SAMPLE_ORDER_TYPE_END_RANGE_NV,
    e_RANGE_SIZE = VK_COARSE_SAMPLE_ORDER_TYPE_RANGE_SIZE_NV,
    e_MAX_ENUM = 0x7FFFFFFF

};
DEFINE_ENUM_BITWISE_OPERATORS(CoarseSampleOrderTypeNV)
inline std::string to_string(CoarseSampleOrderTypeNV value)
{
    switch(value)
    {
    case CoarseSampleOrderTypeNV::e_DEFAULT_NV: return "VK_COARSE_SAMPLE_ORDER_TYPE_DEFAULT_NV";
    case CoarseSampleOrderTypeNV::e_CUSTOM_NV: return "VK_COARSE_SAMPLE_ORDER_TYPE_CUSTOM_NV";
    case CoarseSampleOrderTypeNV::e_PIXEL_MAJOR_NV: return "VK_COARSE_SAMPLE_ORDER_TYPE_PIXEL_MAJOR_NV";
    case CoarseSampleOrderTypeNV::e_SAMPLE_MAJOR_NV: return "VK_COARSE_SAMPLE_ORDER_TYPE_SAMPLE_MAJOR_NV";
    default: return "invalid";
    }
}

enum class RayTracingShaderGroupTypeNV
{
    e_GENERAL_NV = VK_RAY_TRACING_SHADER_GROUP_TYPE_GENERAL_NV,
    e_TRIANGLES_HIT_GROUP_NV = VK_RAY_TRACING_SHADER_GROUP_TYPE_TRIANGLES_HIT_GROUP_NV,
    e_PROCEDURAL_HIT_GROUP_NV = VK_RAY_TRACING_SHADER_GROUP_TYPE_PROCEDURAL_HIT_GROUP_NV,
    e_BEGIN_RANGE = VK_RAY_TRACING_SHADER_GROUP_TYPE_BEGIN_RANGE_NV,
    e_END_RANGE = VK_RAY_TRACING_SHADER_GROUP_TYPE_END_RANGE_NV,
    e_RANGE_SIZE = VK_RAY_TRACING_SHADER_GROUP_TYPE_RANGE_SIZE_NV,
    e_MAX_ENUM = 0x7FFFFFFF

};
DEFINE_ENUM_BITWISE_OPERATORS(RayTracingShaderGroupTypeNV)
inline std::string to_string(RayTracingShaderGroupTypeNV value)
{
    switch(value)
    {
    case RayTracingShaderGroupTypeNV::e_GENERAL_NV: return "VK_RAY_TRACING_SHADER_GROUP_TYPE_GENERAL_NV";
    case RayTracingShaderGroupTypeNV::e_TRIANGLES_HIT_GROUP_NV: return "VK_RAY_TRACING_SHADER_GROUP_TYPE_TRIANGLES_HIT_GROUP_NV";
    case RayTracingShaderGroupTypeNV::e_PROCEDURAL_HIT_GROUP_NV: return "VK_RAY_TRACING_SHADER_GROUP_TYPE_PROCEDURAL_HIT_GROUP_NV";
    default: return "invalid";
    }
}

enum class GeometryTypeNV
{
    e_TRIANGLES_NV = VK_GEOMETRY_TYPE_TRIANGLES_NV,
    e_AABBS_NV = VK_GEOMETRY_TYPE_AABBS_NV,
    e_BEGIN_RANGE = VK_GEOMETRY_TYPE_BEGIN_RANGE_NV,
    e_END_RANGE = VK_GEOMETRY_TYPE_END_RANGE_NV,
    e_RANGE_SIZE = VK_GEOMETRY_TYPE_RANGE_SIZE_NV,
    e_MAX_ENUM = 0x7FFFFFFF

};
DEFINE_ENUM_BITWISE_OPERATORS(GeometryTypeNV)
inline std::string to_string(GeometryTypeNV value)
{
    switch(value)
    {
    case GeometryTypeNV::e_TRIANGLES_NV: return "VK_GEOMETRY_TYPE_TRIANGLES_NV";
    case GeometryTypeNV::e_AABBS_NV: return "VK_GEOMETRY_TYPE_AABBS_NV";
    default: return "invalid";
    }
}

enum class GeometryFlagsNV
{
    e_NONE = 0,
    e_OPAQUE_BIT_NV = VK_GEOMETRY_OPAQUE_BIT_NV,
    e_NO_DUPLICATE_ANY_HIT_INVOCATION_BIT_NV = VK_GEOMETRY_NO_DUPLICATE_ANY_HIT_INVOCATION_BIT_NV,
    e_MAX_ENUM = 0x7FFFFFFF,
    e_ALL_BITS = e_OPAQUE_BIT_NV | e_NO_DUPLICATE_ANY_HIT_INVOCATION_BIT_NV
};
DEFINE_ENUM_BITWISE_OPERATORS(GeometryFlagsNV)
inline std::string to_string(GeometryFlagsNV value)
{
    std::string returnString = "";
    bool addedFlags = false;
    if(static_cast<uint32_t>(value & GeometryFlagsNV::e_OPAQUE_BIT_NV) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_GEOMETRY_OPAQUE_BIT_NV";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & GeometryFlagsNV::e_NO_DUPLICATE_ANY_HIT_INVOCATION_BIT_NV) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_GEOMETRY_NO_DUPLICATE_ANY_HIT_INVOCATION_BIT_NV";
        addedFlags = true;
    }
    return returnString;
}

enum class GeometryInstanceFlagsNV
{
    e_NONE = 0,
    e_TRIANGLE_CULL_DISABLE_BIT_NV = VK_GEOMETRY_INSTANCE_TRIANGLE_CULL_DISABLE_BIT_NV,
    e_TRIANGLE_FRONT_COUNTERCLOCKWISE_BIT_NV = VK_GEOMETRY_INSTANCE_TRIANGLE_FRONT_COUNTERCLOCKWISE_BIT_NV,
    e_FORCE_OPAQUE_BIT_NV = VK_GEOMETRY_INSTANCE_FORCE_OPAQUE_BIT_NV,
    e_FORCE_NO_OPAQUE_BIT_NV = VK_GEOMETRY_INSTANCE_FORCE_NO_OPAQUE_BIT_NV,
    e_MAX_ENUM = 0x7FFFFFFF,
    e_ALL_BITS = e_TRIANGLE_CULL_DISABLE_BIT_NV | e_TRIANGLE_FRONT_COUNTERCLOCKWISE_BIT_NV | e_FORCE_OPAQUE_BIT_NV | e_FORCE_NO_OPAQUE_BIT_NV
};
DEFINE_ENUM_BITWISE_OPERATORS(GeometryInstanceFlagsNV)
inline std::string to_string(GeometryInstanceFlagsNV value)
{
    std::string returnString = "";
    bool addedFlags = false;
    if(static_cast<uint32_t>(value & GeometryInstanceFlagsNV::e_TRIANGLE_CULL_DISABLE_BIT_NV) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_GEOMETRY_INSTANCE_TRIANGLE_CULL_DISABLE_BIT_NV";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & GeometryInstanceFlagsNV::e_TRIANGLE_FRONT_COUNTERCLOCKWISE_BIT_NV) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_GEOMETRY_INSTANCE_TRIANGLE_FRONT_COUNTERCLOCKWISE_BIT_NV";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & GeometryInstanceFlagsNV::e_FORCE_OPAQUE_BIT_NV) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_GEOMETRY_INSTANCE_FORCE_OPAQUE_BIT_NV";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & GeometryInstanceFlagsNV::e_FORCE_NO_OPAQUE_BIT_NV) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_GEOMETRY_INSTANCE_FORCE_NO_OPAQUE_BIT_NV";
        addedFlags = true;
    }
    return returnString;
}

enum class AccelerationStructureTypeNV
{
    e_TOP_LEVEL_NV = VK_ACCELERATION_STRUCTURE_TYPE_TOP_LEVEL_NV,
    e_BOTTOM_LEVEL_NV = VK_ACCELERATION_STRUCTURE_TYPE_BOTTOM_LEVEL_NV,
    e_BEGIN_RANGE = VK_ACCELERATION_STRUCTURE_TYPE_BEGIN_RANGE_NV,
    e_END_RANGE = VK_ACCELERATION_STRUCTURE_TYPE_END_RANGE_NV,
    e_RANGE_SIZE = VK_ACCELERATION_STRUCTURE_TYPE_RANGE_SIZE_NV,
    e_MAX_ENUM = 0x7FFFFFFF

};
DEFINE_ENUM_BITWISE_OPERATORS(AccelerationStructureTypeNV)
inline std::string to_string(AccelerationStructureTypeNV value)
{
    switch(value)
    {
    case AccelerationStructureTypeNV::e_TOP_LEVEL_NV: return "VK_ACCELERATION_STRUCTURE_TYPE_TOP_LEVEL_NV";
    case AccelerationStructureTypeNV::e_BOTTOM_LEVEL_NV: return "VK_ACCELERATION_STRUCTURE_TYPE_BOTTOM_LEVEL_NV";
    default: return "invalid";
    }
}

enum class BuildAccelerationStructureFlagsNV
{
    e_NONE = 0,
    e_ALLOW_UPDATE_BIT_NV = VK_BUILD_ACCELERATION_STRUCTURE_ALLOW_UPDATE_BIT_NV,
    e_ALLOW_COMPACTION_BIT_NV = VK_BUILD_ACCELERATION_STRUCTURE_ALLOW_COMPACTION_BIT_NV,
    e_PREFER_FAST_TRACE_BIT_NV = VK_BUILD_ACCELERATION_STRUCTURE_PREFER_FAST_TRACE_BIT_NV,
    e_PREFER_FAST_BUILD_BIT_NV = VK_BUILD_ACCELERATION_STRUCTURE_PREFER_FAST_BUILD_BIT_NV,
    e_LOW_MEMORY_BIT_NV = VK_BUILD_ACCELERATION_STRUCTURE_LOW_MEMORY_BIT_NV,
    e_MAX_ENUM = 0x7FFFFFFF,
    e_ALL_BITS = e_ALLOW_UPDATE_BIT_NV | e_ALLOW_COMPACTION_BIT_NV | e_PREFER_FAST_TRACE_BIT_NV | e_PREFER_FAST_BUILD_BIT_NV | e_LOW_MEMORY_BIT_NV
};
DEFINE_ENUM_BITWISE_OPERATORS(BuildAccelerationStructureFlagsNV)
inline std::string to_string(BuildAccelerationStructureFlagsNV value)
{
    std::string returnString = "";
    bool addedFlags = false;
    if(static_cast<uint32_t>(value & BuildAccelerationStructureFlagsNV::e_ALLOW_UPDATE_BIT_NV) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_BUILD_ACCELERATION_STRUCTURE_ALLOW_UPDATE_BIT_NV";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & BuildAccelerationStructureFlagsNV::e_ALLOW_COMPACTION_BIT_NV) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_BUILD_ACCELERATION_STRUCTURE_ALLOW_COMPACTION_BIT_NV";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & BuildAccelerationStructureFlagsNV::e_PREFER_FAST_TRACE_BIT_NV) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_BUILD_ACCELERATION_STRUCTURE_PREFER_FAST_TRACE_BIT_NV";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & BuildAccelerationStructureFlagsNV::e_PREFER_FAST_BUILD_BIT_NV) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_BUILD_ACCELERATION_STRUCTURE_PREFER_FAST_BUILD_BIT_NV";
        addedFlags = true;
    }
    if(static_cast<uint32_t>(value & BuildAccelerationStructureFlagsNV::e_LOW_MEMORY_BIT_NV) != 0)
    {
        if(addedFlags)
        {
            returnString += " | ";
        }
        returnString += "VK_BUILD_ACCELERATION_STRUCTURE_LOW_MEMORY_BIT_NV";
        addedFlags = true;
    }
    return returnString;
}

enum class CopyAccelerationStructureModeNV
{
    e_CLONE_NV = VK_COPY_ACCELERATION_STRUCTURE_MODE_CLONE_NV,
    e_COMPACT_NV = VK_COPY_ACCELERATION_STRUCTURE_MODE_COMPACT_NV,
    e_BEGIN_RANGE = VK_COPY_ACCELERATION_STRUCTURE_MODE_BEGIN_RANGE_NV,
    e_END_RANGE = VK_COPY_ACCELERATION_STRUCTURE_MODE_END_RANGE_NV,
    e_RANGE_SIZE = VK_COPY_ACCELERATION_STRUCTURE_MODE_RANGE_SIZE_NV,
    e_MAX_ENUM = 0x7FFFFFFF

};
DEFINE_ENUM_BITWISE_OPERATORS(CopyAccelerationStructureModeNV)
inline std::string to_string(CopyAccelerationStructureModeNV value)
{
    switch(value)
    {
    case CopyAccelerationStructureModeNV::e_CLONE_NV: return "VK_COPY_ACCELERATION_STRUCTURE_MODE_CLONE_NV";
    case CopyAccelerationStructureModeNV::e_COMPACT_NV: return "VK_COPY_ACCELERATION_STRUCTURE_MODE_COMPACT_NV";
    default: return "invalid";
    }
}

enum class AccelerationStructureMemoryRequirementsTypeNV
{
    e_OBJECT_NV = VK_ACCELERATION_STRUCTURE_MEMORY_REQUIREMENTS_TYPE_OBJECT_NV,
    e_BUILD_SCRATCH_NV = VK_ACCELERATION_STRUCTURE_MEMORY_REQUIREMENTS_TYPE_BUILD_SCRATCH_NV,
    e_UPDATE_SCRATCH_NV = VK_ACCELERATION_STRUCTURE_MEMORY_REQUIREMENTS_TYPE_UPDATE_SCRATCH_NV,
    e_BEGIN_RANGE = VK_ACCELERATION_STRUCTURE_MEMORY_REQUIREMENTS_TYPE_BEGIN_RANGE_NV,
    e_END_RANGE = VK_ACCELERATION_STRUCTURE_MEMORY_REQUIREMENTS_TYPE_END_RANGE_NV,
    e_RANGE_SIZE = VK_ACCELERATION_STRUCTURE_MEMORY_REQUIREMENTS_TYPE_RANGE_SIZE_NV,
    e_MAX_ENUM = 0x7FFFFFFF

};
DEFINE_ENUM_BITWISE_OPERATORS(AccelerationStructureMemoryRequirementsTypeNV)
inline std::string to_string(AccelerationStructureMemoryRequirementsTypeNV value)
{
    switch(value)
    {
    case AccelerationStructureMemoryRequirementsTypeNV::e_OBJECT_NV: return "VK_ACCELERATION_STRUCTURE_MEMORY_REQUIREMENTS_TYPE_OBJECT_NV";
    case AccelerationStructureMemoryRequirementsTypeNV::e_BUILD_SCRATCH_NV: return "VK_ACCELERATION_STRUCTURE_MEMORY_REQUIREMENTS_TYPE_BUILD_SCRATCH_NV";
    case AccelerationStructureMemoryRequirementsTypeNV::e_UPDATE_SCRATCH_NV: return "VK_ACCELERATION_STRUCTURE_MEMORY_REQUIREMENTS_TYPE_UPDATE_SCRATCH_NV";
    default: return "invalid";
    }
}

enum class QueueGlobalPriorityEXT
{
    e_LOW_EXT = VK_QUEUE_GLOBAL_PRIORITY_LOW_EXT,
    e_MEDIUM_EXT = VK_QUEUE_GLOBAL_PRIORITY_MEDIUM_EXT,
    e_HIGH_EXT = VK_QUEUE_GLOBAL_PRIORITY_HIGH_EXT,
    e_REALTIME_EXT = VK_QUEUE_GLOBAL_PRIORITY_REALTIME_EXT,
    e_BEGIN_RANGE = VK_QUEUE_GLOBAL_PRIORITY_BEGIN_RANGE_EXT,
    e_END_RANGE = VK_QUEUE_GLOBAL_PRIORITY_END_RANGE_EXT,
    e_RANGE_SIZE = VK_QUEUE_GLOBAL_PRIORITY_RANGE_SIZE_EXT,
    e_MAX_ENUM = 0x7FFFFFFF

};
DEFINE_ENUM_BITWISE_OPERATORS(QueueGlobalPriorityEXT)
inline std::string to_string(QueueGlobalPriorityEXT value)
{
    switch(value)
    {
    case QueueGlobalPriorityEXT::e_LOW_EXT: return "VK_QUEUE_GLOBAL_PRIORITY_LOW_EXT";
    case QueueGlobalPriorityEXT::e_MEDIUM_EXT: return "VK_QUEUE_GLOBAL_PRIORITY_MEDIUM_EXT";
    case QueueGlobalPriorityEXT::e_HIGH_EXT: return "VK_QUEUE_GLOBAL_PRIORITY_HIGH_EXT";
    case QueueGlobalPriorityEXT::e_REALTIME_EXT: return "VK_QUEUE_GLOBAL_PRIORITY_REALTIME_EXT";
    default: return "invalid";
    }
}

enum class TimeDomainEXT
{
    e_DEVICE_EXT = VK_TIME_DOMAIN_DEVICE_EXT,
    e_CLOCK_MONOTONIC_EXT = VK_TIME_DOMAIN_CLOCK_MONOTONIC_EXT,
    e_CLOCK_MONOTONIC_RAW_EXT = VK_TIME_DOMAIN_CLOCK_MONOTONIC_RAW_EXT,
    e_QUERY_PERFORMANCE_COUNTER_EXT = VK_TIME_DOMAIN_QUERY_PERFORMANCE_COUNTER_EXT,
    e_BEGIN_RANGE = VK_TIME_DOMAIN_BEGIN_RANGE_EXT,
    e_END_RANGE = VK_TIME_DOMAIN_END_RANGE_EXT,
    e_RANGE_SIZE = VK_TIME_DOMAIN_RANGE_SIZE_EXT,
    e_MAX_ENUM = 0x7FFFFFFF

};
DEFINE_ENUM_BITWISE_OPERATORS(TimeDomainEXT)
inline std::string to_string(TimeDomainEXT value)
{
    switch(value)
    {
    case TimeDomainEXT::e_DEVICE_EXT: return "VK_TIME_DOMAIN_DEVICE_EXT";
    case TimeDomainEXT::e_CLOCK_MONOTONIC_EXT: return "VK_TIME_DOMAIN_CLOCK_MONOTONIC_EXT";
    case TimeDomainEXT::e_CLOCK_MONOTONIC_RAW_EXT: return "VK_TIME_DOMAIN_CLOCK_MONOTONIC_RAW_EXT";
    case TimeDomainEXT::e_QUERY_PERFORMANCE_COUNTER_EXT: return "VK_TIME_DOMAIN_QUERY_PERFORMANCE_COUNTER_EXT";
    default: return "invalid";
    }
}

enum class MemoryOverallocationBehaviorAMD
{
    e_DEFAULT_AMD = VK_MEMORY_OVERALLOCATION_BEHAVIOR_DEFAULT_AMD,
    e_ALLOWED_AMD = VK_MEMORY_OVERALLOCATION_BEHAVIOR_ALLOWED_AMD,
    e_DISALLOWED_AMD = VK_MEMORY_OVERALLOCATION_BEHAVIOR_DISALLOWED_AMD,
    e_BEGIN_RANGE = VK_MEMORY_OVERALLOCATION_BEHAVIOR_BEGIN_RANGE_AMD,
    e_END_RANGE = VK_MEMORY_OVERALLOCATION_BEHAVIOR_END_RANGE_AMD,
    e_RANGE_SIZE = VK_MEMORY_OVERALLOCATION_BEHAVIOR_RANGE_SIZE_AMD,
    e_MAX_ENUM = 0x7FFFFFFF

};
DEFINE_ENUM_BITWISE_OPERATORS(MemoryOverallocationBehaviorAMD)
inline std::string to_string(MemoryOverallocationBehaviorAMD value)
{
    switch(value)
    {
    case MemoryOverallocationBehaviorAMD::e_DEFAULT_AMD: return "VK_MEMORY_OVERALLOCATION_BEHAVIOR_DEFAULT_AMD";
    case MemoryOverallocationBehaviorAMD::e_ALLOWED_AMD: return "VK_MEMORY_OVERALLOCATION_BEHAVIOR_ALLOWED_AMD";
    case MemoryOverallocationBehaviorAMD::e_DISALLOWED_AMD: return "VK_MEMORY_OVERALLOCATION_BEHAVIOR_DISALLOWED_AMD";
    default: return "invalid";
    }
}

// PVRVk Format queries: isSrgb()
inline bool isSrgb(Format value)
{
    // This list is sorted by enum values
    const Format srgb_formats[] = {
        Format::e_R8_SRGB,
        Format::e_R8G8_SRGB,
        Format::e_R8G8B8_SRGB,
        Format::e_B8G8R8_SRGB,
        Format::e_R8G8B8A8_SRGB,
        Format::e_B8G8R8A8_SRGB,
        Format::e_A8B8G8R8_SRGB_PACK32,
        Format::e_BC1_RGB_SRGB_BLOCK,
        Format::e_BC1_RGBA_SRGB_BLOCK,
        Format::e_BC2_SRGB_BLOCK,
        Format::e_BC3_SRGB_BLOCK,
        Format::e_BC7_SRGB_BLOCK,
        Format::e_ETC2_R8G8B8_SRGB_BLOCK,
        Format::e_ETC2_R8G8B8A1_SRGB_BLOCK,
        Format::e_ETC2_R8G8B8A8_SRGB_BLOCK,
        Format::e_ASTC_4x4_SRGB_BLOCK,
        Format::e_ASTC_5x4_SRGB_BLOCK,
        Format::e_ASTC_5x5_SRGB_BLOCK,
        Format::e_ASTC_6x5_SRGB_BLOCK,
        Format::e_ASTC_6x6_SRGB_BLOCK,
        Format::e_ASTC_8x5_SRGB_BLOCK,
        Format::e_ASTC_8x6_SRGB_BLOCK,
        Format::e_ASTC_8x8_SRGB_BLOCK,
        Format::e_ASTC_10x5_SRGB_BLOCK,
        Format::e_ASTC_10x6_SRGB_BLOCK,
        Format::e_ASTC_10x8_SRGB_BLOCK,
        Format::e_ASTC_10x10_SRGB_BLOCK,
        Format::e_ASTC_12x10_SRGB_BLOCK,
        Format::e_ASTC_12x12_SRGB_BLOCK,
        Format::e_PVRTC1_2BPP_SRGB_BLOCK_IMG,
        Format::e_PVRTC1_4BPP_SRGB_BLOCK_IMG,
        Format::e_PVRTC2_2BPP_SRGB_BLOCK_IMG,
        Format::e_PVRTC2_4BPP_SRGB_BLOCK_IMG,
    };
    return std::binary_search(srgb_formats, srgb_formats + sizeof(srgb_formats)/sizeof(srgb_formats[0]), value);
}




// PVRVk Structures
struct AllocationCallbacks : private VkAllocationCallbacks
{
    AllocationCallbacks()
    {
        pUserData = nullptr;
        setPfnAllocation(PFN_vkAllocationFunction());
        setPfnReallocation(PFN_vkReallocationFunction());
        setPfnFree(PFN_vkFreeFunction());
        setPfnInternalAllocation(PFN_vkInternalAllocationNotification());
        setPfnInternalFree(PFN_vkInternalFreeNotification());
    }
    AllocationCallbacks(const VkAllocationCallbacks& vkType): VkAllocationCallbacks(vkType) { }
    AllocationCallbacks(void* pUserData, PFN_vkAllocationFunction pfnAllocation, PFN_vkReallocationFunction pfnReallocation, PFN_vkFreeFunction pfnFree, PFN_vkInternalAllocationNotification pfnInternalAllocation, PFN_vkInternalFreeNotification pfnInternalFree)
    {
        setPUserData(pUserData);
        setPfnAllocation(pfnAllocation);
        setPfnReallocation(pfnReallocation);
        setPfnFree(pfnFree);
        setPfnInternalAllocation(pfnInternalAllocation);
        setPfnInternalFree(pfnInternalFree);
    }
    inline const void* getPUserData() const { return pUserData; }
    inline void setPUserData(void* pUserData) { this->pUserData = pUserData; }
    inline PFN_vkAllocationFunction getPfnAllocation() const { return pfnAllocation; }
    inline void setPfnAllocation(const PFN_vkAllocationFunction& pfnAllocation) { this->pfnAllocation = pfnAllocation; }
    inline PFN_vkReallocationFunction getPfnReallocation() const { return pfnReallocation; }
    inline void setPfnReallocation(const PFN_vkReallocationFunction& pfnReallocation) { this->pfnReallocation = pfnReallocation; }
    inline PFN_vkFreeFunction getPfnFree() const { return pfnFree; }
    inline void setPfnFree(const PFN_vkFreeFunction& pfnFree) { this->pfnFree = pfnFree; }
    inline PFN_vkInternalAllocationNotification getPfnInternalAllocation() const { return pfnInternalAllocation; }
    inline void setPfnInternalAllocation(const PFN_vkInternalAllocationNotification& pfnInternalAllocation) { this->pfnInternalAllocation = pfnInternalAllocation; }
    inline PFN_vkInternalFreeNotification getPfnInternalFree() const { return pfnInternalFree; }
    inline void setPfnInternalFree(const PFN_vkInternalFreeNotification& pfnInternalFree) { this->pfnInternalFree = pfnInternalFree; }
    inline VkAllocationCallbacks& get() { return *this; }
    inline const VkAllocationCallbacks& get() const { return *this; }
};

struct PhysicalDeviceFeatures : private VkPhysicalDeviceFeatures
{
    PhysicalDeviceFeatures()
    {
        setRobustBufferAccess(VkBool32());
        setFullDrawIndexUint32(VkBool32());
        setImageCubeArray(VkBool32());
        setIndependentBlend(VkBool32());
        setGeometryShader(VkBool32());
        setTessellationShader(VkBool32());
        setSampleRateShading(VkBool32());
        setDualSrcBlend(VkBool32());
        setLogicOp(VkBool32());
        setMultiDrawIndirect(VkBool32());
        setDrawIndirectFirstInstance(VkBool32());
        setDepthClamp(VkBool32());
        setDepthBiasClamp(VkBool32());
        setFillModeNonSolid(VkBool32());
        setDepthBounds(VkBool32());
        setWideLines(VkBool32());
        setLargePoints(VkBool32());
        setAlphaToOne(VkBool32());
        setMultiViewport(VkBool32());
        setSamplerAnisotropy(VkBool32());
        setTextureCompressionETC2(VkBool32());
        setTextureCompressionASTC_LDR(VkBool32());
        setTextureCompressionBC(VkBool32());
        setOcclusionQueryPrecise(VkBool32());
        setPipelineStatisticsQuery(VkBool32());
        setVertexPipelineStoresAndAtomics(VkBool32());
        setFragmentStoresAndAtomics(VkBool32());
        setShaderTessellationAndGeometryPointSize(VkBool32());
        setShaderImageGatherExtended(VkBool32());
        setShaderStorageImageExtendedFormats(VkBool32());
        setShaderStorageImageMultisample(VkBool32());
        setShaderStorageImageReadWithoutFormat(VkBool32());
        setShaderStorageImageWriteWithoutFormat(VkBool32());
        setShaderUniformBufferArrayDynamicIndexing(VkBool32());
        setShaderSampledImageArrayDynamicIndexing(VkBool32());
        setShaderStorageBufferArrayDynamicIndexing(VkBool32());
        setShaderStorageImageArrayDynamicIndexing(VkBool32());
        setShaderClipDistance(VkBool32());
        setShaderCullDistance(VkBool32());
        setShaderFloat64(VkBool32());
        setShaderInt64(VkBool32());
        setShaderInt16(VkBool32());
        setShaderResourceResidency(VkBool32());
        setShaderResourceMinLod(VkBool32());
        setSparseBinding(VkBool32());
        setSparseResidencyBuffer(VkBool32());
        setSparseResidencyImage2D(VkBool32());
        setSparseResidencyImage3D(VkBool32());
        setSparseResidency2Samples(VkBool32());
        setSparseResidency4Samples(VkBool32());
        setSparseResidency8Samples(VkBool32());
        setSparseResidency16Samples(VkBool32());
        setSparseResidencyAliased(VkBool32());
        setVariableMultisampleRate(VkBool32());
        setInheritedQueries(VkBool32());
    }
    PhysicalDeviceFeatures(const VkPhysicalDeviceFeatures& vkType): VkPhysicalDeviceFeatures(vkType) { }
    PhysicalDeviceFeatures(VkBool32 robustBufferAccess, VkBool32 fullDrawIndexUint32, VkBool32 imageCubeArray, VkBool32 independentBlend, VkBool32 geometryShader, VkBool32 tessellationShader, VkBool32 sampleRateShading, VkBool32 dualSrcBlend, VkBool32 logicOp, VkBool32 multiDrawIndirect, VkBool32 drawIndirectFirstInstance, VkBool32 depthClamp, VkBool32 depthBiasClamp, VkBool32 fillModeNonSolid, VkBool32 depthBounds, VkBool32 wideLines, VkBool32 largePoints, VkBool32 alphaToOne, VkBool32 multiViewport, VkBool32 samplerAnisotropy, VkBool32 textureCompressionETC2, VkBool32 textureCompressionASTC_LDR, VkBool32 textureCompressionBC, VkBool32 occlusionQueryPrecise, VkBool32 pipelineStatisticsQuery, VkBool32 vertexPipelineStoresAndAtomics, VkBool32 fragmentStoresAndAtomics, VkBool32 shaderTessellationAndGeometryPointSize, VkBool32 shaderImageGatherExtended, VkBool32 shaderStorageImageExtendedFormats, VkBool32 shaderStorageImageMultisample, VkBool32 shaderStorageImageReadWithoutFormat, VkBool32 shaderStorageImageWriteWithoutFormat, VkBool32 shaderUniformBufferArrayDynamicIndexing, VkBool32 shaderSampledImageArrayDynamicIndexing, VkBool32 shaderStorageBufferArrayDynamicIndexing, VkBool32 shaderStorageImageArrayDynamicIndexing, VkBool32 shaderClipDistance, VkBool32 shaderCullDistance, VkBool32 shaderFloat64, VkBool32 shaderInt64, VkBool32 shaderInt16, VkBool32 shaderResourceResidency, VkBool32 shaderResourceMinLod, VkBool32 sparseBinding, VkBool32 sparseResidencyBuffer, VkBool32 sparseResidencyImage2D, VkBool32 sparseResidencyImage3D, VkBool32 sparseResidency2Samples, VkBool32 sparseResidency4Samples, VkBool32 sparseResidency8Samples, VkBool32 sparseResidency16Samples, VkBool32 sparseResidencyAliased, VkBool32 variableMultisampleRate, VkBool32 inheritedQueries)
    {
        setRobustBufferAccess(robustBufferAccess);
        setFullDrawIndexUint32(fullDrawIndexUint32);
        setImageCubeArray(imageCubeArray);
        setIndependentBlend(independentBlend);
        setGeometryShader(geometryShader);
        setTessellationShader(tessellationShader);
        setSampleRateShading(sampleRateShading);
        setDualSrcBlend(dualSrcBlend);
        setLogicOp(logicOp);
        setMultiDrawIndirect(multiDrawIndirect);
        setDrawIndirectFirstInstance(drawIndirectFirstInstance);
        setDepthClamp(depthClamp);
        setDepthBiasClamp(depthBiasClamp);
        setFillModeNonSolid(fillModeNonSolid);
        setDepthBounds(depthBounds);
        setWideLines(wideLines);
        setLargePoints(largePoints);
        setAlphaToOne(alphaToOne);
        setMultiViewport(multiViewport);
        setSamplerAnisotropy(samplerAnisotropy);
        setTextureCompressionETC2(textureCompressionETC2);
        setTextureCompressionASTC_LDR(textureCompressionASTC_LDR);
        setTextureCompressionBC(textureCompressionBC);
        setOcclusionQueryPrecise(occlusionQueryPrecise);
        setPipelineStatisticsQuery(pipelineStatisticsQuery);
        setVertexPipelineStoresAndAtomics(vertexPipelineStoresAndAtomics);
        setFragmentStoresAndAtomics(fragmentStoresAndAtomics);
        setShaderTessellationAndGeometryPointSize(shaderTessellationAndGeometryPointSize);
        setShaderImageGatherExtended(shaderImageGatherExtended);
        setShaderStorageImageExtendedFormats(shaderStorageImageExtendedFormats);
        setShaderStorageImageMultisample(shaderStorageImageMultisample);
        setShaderStorageImageReadWithoutFormat(shaderStorageImageReadWithoutFormat);
        setShaderStorageImageWriteWithoutFormat(shaderStorageImageWriteWithoutFormat);
        setShaderUniformBufferArrayDynamicIndexing(shaderUniformBufferArrayDynamicIndexing);
        setShaderSampledImageArrayDynamicIndexing(shaderSampledImageArrayDynamicIndexing);
        setShaderStorageBufferArrayDynamicIndexing(shaderStorageBufferArrayDynamicIndexing);
        setShaderStorageImageArrayDynamicIndexing(shaderStorageImageArrayDynamicIndexing);
        setShaderClipDistance(shaderClipDistance);
        setShaderCullDistance(shaderCullDistance);
        setShaderFloat64(shaderFloat64);
        setShaderInt64(shaderInt64);
        setShaderInt16(shaderInt16);
        setShaderResourceResidency(shaderResourceResidency);
        setShaderResourceMinLod(shaderResourceMinLod);
        setSparseBinding(sparseBinding);
        setSparseResidencyBuffer(sparseResidencyBuffer);
        setSparseResidencyImage2D(sparseResidencyImage2D);
        setSparseResidencyImage3D(sparseResidencyImage3D);
        setSparseResidency2Samples(sparseResidency2Samples);
        setSparseResidency4Samples(sparseResidency4Samples);
        setSparseResidency8Samples(sparseResidency8Samples);
        setSparseResidency16Samples(sparseResidency16Samples);
        setSparseResidencyAliased(sparseResidencyAliased);
        setVariableMultisampleRate(variableMultisampleRate);
        setInheritedQueries(inheritedQueries);
    }
    inline VkBool32 getRobustBufferAccess() const { return robustBufferAccess; }
    inline void setRobustBufferAccess(VkBool32 robustBufferAccess) { this->robustBufferAccess = robustBufferAccess; }
    inline VkBool32 getFullDrawIndexUint32() const { return fullDrawIndexUint32; }
    inline void setFullDrawIndexUint32(VkBool32 fullDrawIndexUint32) { this->fullDrawIndexUint32 = fullDrawIndexUint32; }
    inline VkBool32 getImageCubeArray() const { return imageCubeArray; }
    inline void setImageCubeArray(VkBool32 imageCubeArray) { this->imageCubeArray = imageCubeArray; }
    inline VkBool32 getIndependentBlend() const { return independentBlend; }
    inline void setIndependentBlend(VkBool32 independentBlend) { this->independentBlend = independentBlend; }
    inline VkBool32 getGeometryShader() const { return geometryShader; }
    inline void setGeometryShader(VkBool32 geometryShader) { this->geometryShader = geometryShader; }
    inline VkBool32 getTessellationShader() const { return tessellationShader; }
    inline void setTessellationShader(VkBool32 tessellationShader) { this->tessellationShader = tessellationShader; }
    inline VkBool32 getSampleRateShading() const { return sampleRateShading; }
    inline void setSampleRateShading(VkBool32 sampleRateShading) { this->sampleRateShading = sampleRateShading; }
    inline VkBool32 getDualSrcBlend() const { return dualSrcBlend; }
    inline void setDualSrcBlend(VkBool32 dualSrcBlend) { this->dualSrcBlend = dualSrcBlend; }
    inline VkBool32 getLogicOp() const { return logicOp; }
    inline void setLogicOp(VkBool32 logicOp) { this->logicOp = logicOp; }
    inline VkBool32 getMultiDrawIndirect() const { return multiDrawIndirect; }
    inline void setMultiDrawIndirect(VkBool32 multiDrawIndirect) { this->multiDrawIndirect = multiDrawIndirect; }
    inline VkBool32 getDrawIndirectFirstInstance() const { return drawIndirectFirstInstance; }
    inline void setDrawIndirectFirstInstance(VkBool32 drawIndirectFirstInstance) { this->drawIndirectFirstInstance = drawIndirectFirstInstance; }
    inline VkBool32 getDepthClamp() const { return depthClamp; }
    inline void setDepthClamp(VkBool32 depthClamp) { this->depthClamp = depthClamp; }
    inline VkBool32 getDepthBiasClamp() const { return depthBiasClamp; }
    inline void setDepthBiasClamp(VkBool32 depthBiasClamp) { this->depthBiasClamp = depthBiasClamp; }
    inline VkBool32 getFillModeNonSolid() const { return fillModeNonSolid; }
    inline void setFillModeNonSolid(VkBool32 fillModeNonSolid) { this->fillModeNonSolid = fillModeNonSolid; }
    inline VkBool32 getDepthBounds() const { return depthBounds; }
    inline void setDepthBounds(VkBool32 depthBounds) { this->depthBounds = depthBounds; }
    inline VkBool32 getWideLines() const { return wideLines; }
    inline void setWideLines(VkBool32 wideLines) { this->wideLines = wideLines; }
    inline VkBool32 getLargePoints() const { return largePoints; }
    inline void setLargePoints(VkBool32 largePoints) { this->largePoints = largePoints; }
    inline VkBool32 getAlphaToOne() const { return alphaToOne; }
    inline void setAlphaToOne(VkBool32 alphaToOne) { this->alphaToOne = alphaToOne; }
    inline VkBool32 getMultiViewport() const { return multiViewport; }
    inline void setMultiViewport(VkBool32 multiViewport) { this->multiViewport = multiViewport; }
    inline VkBool32 getSamplerAnisotropy() const { return samplerAnisotropy; }
    inline void setSamplerAnisotropy(VkBool32 samplerAnisotropy) { this->samplerAnisotropy = samplerAnisotropy; }
    inline VkBool32 getTextureCompressionETC2() const { return textureCompressionETC2; }
    inline void setTextureCompressionETC2(VkBool32 textureCompressionETC2) { this->textureCompressionETC2 = textureCompressionETC2; }
    inline VkBool32 getTextureCompressionASTC_LDR() const { return textureCompressionASTC_LDR; }
    inline void setTextureCompressionASTC_LDR(VkBool32 textureCompressionASTC_LDR) { this->textureCompressionASTC_LDR = textureCompressionASTC_LDR; }
    inline VkBool32 getTextureCompressionBC() const { return textureCompressionBC; }
    inline void setTextureCompressionBC(VkBool32 textureCompressionBC) { this->textureCompressionBC = textureCompressionBC; }
    inline VkBool32 getOcclusionQueryPrecise() const { return occlusionQueryPrecise; }
    inline void setOcclusionQueryPrecise(VkBool32 occlusionQueryPrecise) { this->occlusionQueryPrecise = occlusionQueryPrecise; }
    inline VkBool32 getPipelineStatisticsQuery() const { return pipelineStatisticsQuery; }
    inline void setPipelineStatisticsQuery(VkBool32 pipelineStatisticsQuery) { this->pipelineStatisticsQuery = pipelineStatisticsQuery; }
    inline VkBool32 getVertexPipelineStoresAndAtomics() const { return vertexPipelineStoresAndAtomics; }
    inline void setVertexPipelineStoresAndAtomics(VkBool32 vertexPipelineStoresAndAtomics) { this->vertexPipelineStoresAndAtomics = vertexPipelineStoresAndAtomics; }
    inline VkBool32 getFragmentStoresAndAtomics() const { return fragmentStoresAndAtomics; }
    inline void setFragmentStoresAndAtomics(VkBool32 fragmentStoresAndAtomics) { this->fragmentStoresAndAtomics = fragmentStoresAndAtomics; }
    inline VkBool32 getShaderTessellationAndGeometryPointSize() const { return shaderTessellationAndGeometryPointSize; }
    inline void setShaderTessellationAndGeometryPointSize(VkBool32 shaderTessellationAndGeometryPointSize) { this->shaderTessellationAndGeometryPointSize = shaderTessellationAndGeometryPointSize; }
    inline VkBool32 getShaderImageGatherExtended() const { return shaderImageGatherExtended; }
    inline void setShaderImageGatherExtended(VkBool32 shaderImageGatherExtended) { this->shaderImageGatherExtended = shaderImageGatherExtended; }
    inline VkBool32 getShaderStorageImageExtendedFormats() const { return shaderStorageImageExtendedFormats; }
    inline void setShaderStorageImageExtendedFormats(VkBool32 shaderStorageImageExtendedFormats) { this->shaderStorageImageExtendedFormats = shaderStorageImageExtendedFormats; }
    inline VkBool32 getShaderStorageImageMultisample() const { return shaderStorageImageMultisample; }
    inline void setShaderStorageImageMultisample(VkBool32 shaderStorageImageMultisample) { this->shaderStorageImageMultisample = shaderStorageImageMultisample; }
    inline VkBool32 getShaderStorageImageReadWithoutFormat() const { return shaderStorageImageReadWithoutFormat; }
    inline void setShaderStorageImageReadWithoutFormat(VkBool32 shaderStorageImageReadWithoutFormat) { this->shaderStorageImageReadWithoutFormat = shaderStorageImageReadWithoutFormat; }
    inline VkBool32 getShaderStorageImageWriteWithoutFormat() const { return shaderStorageImageWriteWithoutFormat; }
    inline void setShaderStorageImageWriteWithoutFormat(VkBool32 shaderStorageImageWriteWithoutFormat) { this->shaderStorageImageWriteWithoutFormat = shaderStorageImageWriteWithoutFormat; }
    inline VkBool32 getShaderUniformBufferArrayDynamicIndexing() const { return shaderUniformBufferArrayDynamicIndexing; }
    inline void setShaderUniformBufferArrayDynamicIndexing(VkBool32 shaderUniformBufferArrayDynamicIndexing) { this->shaderUniformBufferArrayDynamicIndexing = shaderUniformBufferArrayDynamicIndexing; }
    inline VkBool32 getShaderSampledImageArrayDynamicIndexing() const { return shaderSampledImageArrayDynamicIndexing; }
    inline void setShaderSampledImageArrayDynamicIndexing(VkBool32 shaderSampledImageArrayDynamicIndexing) { this->shaderSampledImageArrayDynamicIndexing = shaderSampledImageArrayDynamicIndexing; }
    inline VkBool32 getShaderStorageBufferArrayDynamicIndexing() const { return shaderStorageBufferArrayDynamicIndexing; }
    inline void setShaderStorageBufferArrayDynamicIndexing(VkBool32 shaderStorageBufferArrayDynamicIndexing) { this->shaderStorageBufferArrayDynamicIndexing = shaderStorageBufferArrayDynamicIndexing; }
    inline VkBool32 getShaderStorageImageArrayDynamicIndexing() const { return shaderStorageImageArrayDynamicIndexing; }
    inline void setShaderStorageImageArrayDynamicIndexing(VkBool32 shaderStorageImageArrayDynamicIndexing) { this->shaderStorageImageArrayDynamicIndexing = shaderStorageImageArrayDynamicIndexing; }
    inline VkBool32 getShaderClipDistance() const { return shaderClipDistance; }
    inline void setShaderClipDistance(VkBool32 shaderClipDistance) { this->shaderClipDistance = shaderClipDistance; }
    inline VkBool32 getShaderCullDistance() const { return shaderCullDistance; }
    inline void setShaderCullDistance(VkBool32 shaderCullDistance) { this->shaderCullDistance = shaderCullDistance; }
    inline VkBool32 getShaderFloat64() const { return shaderFloat64; }
    inline void setShaderFloat64(VkBool32 shaderFloat64) { this->shaderFloat64 = shaderFloat64; }
    inline VkBool32 getShaderInt64() const { return shaderInt64; }
    inline void setShaderInt64(VkBool32 shaderInt64) { this->shaderInt64 = shaderInt64; }
    inline VkBool32 getShaderInt16() const { return shaderInt16; }
    inline void setShaderInt16(VkBool32 shaderInt16) { this->shaderInt16 = shaderInt16; }
    inline VkBool32 getShaderResourceResidency() const { return shaderResourceResidency; }
    inline void setShaderResourceResidency(VkBool32 shaderResourceResidency) { this->shaderResourceResidency = shaderResourceResidency; }
    inline VkBool32 getShaderResourceMinLod() const { return shaderResourceMinLod; }
    inline void setShaderResourceMinLod(VkBool32 shaderResourceMinLod) { this->shaderResourceMinLod = shaderResourceMinLod; }
    inline VkBool32 getSparseBinding() const { return sparseBinding; }
    inline void setSparseBinding(VkBool32 sparseBinding) { this->sparseBinding = sparseBinding; }
    inline VkBool32 getSparseResidencyBuffer() const { return sparseResidencyBuffer; }
    inline void setSparseResidencyBuffer(VkBool32 sparseResidencyBuffer) { this->sparseResidencyBuffer = sparseResidencyBuffer; }
    inline VkBool32 getSparseResidencyImage2D() const { return sparseResidencyImage2D; }
    inline void setSparseResidencyImage2D(VkBool32 sparseResidencyImage2D) { this->sparseResidencyImage2D = sparseResidencyImage2D; }
    inline VkBool32 getSparseResidencyImage3D() const { return sparseResidencyImage3D; }
    inline void setSparseResidencyImage3D(VkBool32 sparseResidencyImage3D) { this->sparseResidencyImage3D = sparseResidencyImage3D; }
    inline VkBool32 getSparseResidency2Samples() const { return sparseResidency2Samples; }
    inline void setSparseResidency2Samples(VkBool32 sparseResidency2Samples) { this->sparseResidency2Samples = sparseResidency2Samples; }
    inline VkBool32 getSparseResidency4Samples() const { return sparseResidency4Samples; }
    inline void setSparseResidency4Samples(VkBool32 sparseResidency4Samples) { this->sparseResidency4Samples = sparseResidency4Samples; }
    inline VkBool32 getSparseResidency8Samples() const { return sparseResidency8Samples; }
    inline void setSparseResidency8Samples(VkBool32 sparseResidency8Samples) { this->sparseResidency8Samples = sparseResidency8Samples; }
    inline VkBool32 getSparseResidency16Samples() const { return sparseResidency16Samples; }
    inline void setSparseResidency16Samples(VkBool32 sparseResidency16Samples) { this->sparseResidency16Samples = sparseResidency16Samples; }
    inline VkBool32 getSparseResidencyAliased() const { return sparseResidencyAliased; }
    inline void setSparseResidencyAliased(VkBool32 sparseResidencyAliased) { this->sparseResidencyAliased = sparseResidencyAliased; }
    inline VkBool32 getVariableMultisampleRate() const { return variableMultisampleRate; }
    inline void setVariableMultisampleRate(VkBool32 variableMultisampleRate) { this->variableMultisampleRate = variableMultisampleRate; }
    inline VkBool32 getInheritedQueries() const { return inheritedQueries; }
    inline void setInheritedQueries(VkBool32 inheritedQueries) { this->inheritedQueries = inheritedQueries; }
    inline VkPhysicalDeviceFeatures& get() { return *this; }
    inline const VkPhysicalDeviceFeatures& get() const { return *this; }
};

// FormatProperties is a structure used only as a return type so only getters are defined
struct FormatProperties : private VkFormatProperties
{
    FormatProperties() { }
    FormatProperties(const VkFormatProperties& vkType): VkFormatProperties(vkType) { }
    inline FormatFeatureFlags getLinearTilingFeatures() const { return (FormatFeatureFlags&)linearTilingFeatures; }
    inline FormatFeatureFlags getOptimalTilingFeatures() const { return (FormatFeatureFlags&)optimalTilingFeatures; }
    inline FormatFeatureFlags getBufferFeatures() const { return (FormatFeatureFlags&)bufferFeatures; }
    inline VkFormatProperties& get() { return *this; }
    inline const VkFormatProperties& get() const { return *this; }
};

struct Extent3D : private VkExtent3D
{
    Extent3D()
    {
        setWidth(uint32_t());
        setHeight(uint32_t());
        setDepth(uint32_t());
    }
    Extent3D(const VkExtent3D& vkType): VkExtent3D(vkType) { }
    Extent3D(uint32_t width, uint32_t height, uint32_t depth)
    {
        setWidth(width);
        setHeight(height);
        setDepth(depth);
    }
    inline uint32_t getWidth() const { return width; }
    inline void setWidth(uint32_t width) { this->width = width; }
    inline uint32_t getHeight() const { return height; }
    inline void setHeight(uint32_t height) { this->height = height; }
    inline uint32_t getDepth() const { return depth; }
    inline void setDepth(uint32_t depth) { this->depth = depth; }
    inline VkExtent3D& get() { return *this; }
    inline const VkExtent3D& get() const { return *this; }
};

// ImageFormatProperties is a structure used only as a return type so only getters are defined
struct ImageFormatProperties : private VkImageFormatProperties
{
    ImageFormatProperties() { }
    ImageFormatProperties(const VkImageFormatProperties& vkType): VkImageFormatProperties(vkType) { }
    inline const Extent3D& getMaxExtent() const { return (Extent3D&)maxExtent; }
    inline uint32_t getMaxMipLevels() const { return maxMipLevels; }
    inline uint32_t getMaxArrayLayers() const { return maxArrayLayers; }
    inline SampleCountFlags getSampleCounts() const { return (SampleCountFlags&)sampleCounts; }
    inline VkDeviceSize getMaxResourceSize() const { return maxResourceSize; }
    inline VkImageFormatProperties& get() { return *this; }
    inline const VkImageFormatProperties& get() const { return *this; }
};

// PhysicalDeviceLimits is a structure used only as a return type so only getters are defined
struct PhysicalDeviceLimits : private VkPhysicalDeviceLimits
{
    PhysicalDeviceLimits() { }
    PhysicalDeviceLimits(const VkPhysicalDeviceLimits& vkType): VkPhysicalDeviceLimits(vkType) { }
    inline uint32_t getMaxImageDimension1D() const { return maxImageDimension1D; }
    inline uint32_t getMaxImageDimension2D() const { return maxImageDimension2D; }
    inline uint32_t getMaxImageDimension3D() const { return maxImageDimension3D; }
    inline uint32_t getMaxImageDimensionCube() const { return maxImageDimensionCube; }
    inline uint32_t getMaxImageArrayLayers() const { return maxImageArrayLayers; }
    inline uint32_t getMaxTexelBufferElements() const { return maxTexelBufferElements; }
    inline uint32_t getMaxUniformBufferRange() const { return maxUniformBufferRange; }
    inline uint32_t getMaxStorageBufferRange() const { return maxStorageBufferRange; }
    inline uint32_t getMaxPushConstantsSize() const { return maxPushConstantsSize; }
    inline uint32_t getMaxMemoryAllocationCount() const { return maxMemoryAllocationCount; }
    inline uint32_t getMaxSamplerAllocationCount() const { return maxSamplerAllocationCount; }
    inline VkDeviceSize getBufferImageGranularity() const { return bufferImageGranularity; }
    inline VkDeviceSize getSparseAddressSpaceSize() const { return sparseAddressSpaceSize; }
    inline uint32_t getMaxBoundDescriptorSets() const { return maxBoundDescriptorSets; }
    inline uint32_t getMaxPerStageDescriptorSamplers() const { return maxPerStageDescriptorSamplers; }
    inline uint32_t getMaxPerStageDescriptorUniformBuffers() const { return maxPerStageDescriptorUniformBuffers; }
    inline uint32_t getMaxPerStageDescriptorStorageBuffers() const { return maxPerStageDescriptorStorageBuffers; }
    inline uint32_t getMaxPerStageDescriptorSampledImages() const { return maxPerStageDescriptorSampledImages; }
    inline uint32_t getMaxPerStageDescriptorStorageImages() const { return maxPerStageDescriptorStorageImages; }
    inline uint32_t getMaxPerStageDescriptorInputAttachments() const { return maxPerStageDescriptorInputAttachments; }
    inline uint32_t getMaxPerStageResources() const { return maxPerStageResources; }
    inline uint32_t getMaxDescriptorSetSamplers() const { return maxDescriptorSetSamplers; }
    inline uint32_t getMaxDescriptorSetUniformBuffers() const { return maxDescriptorSetUniformBuffers; }
    inline uint32_t getMaxDescriptorSetUniformBuffersDynamic() const { return maxDescriptorSetUniformBuffersDynamic; }
    inline uint32_t getMaxDescriptorSetStorageBuffers() const { return maxDescriptorSetStorageBuffers; }
    inline uint32_t getMaxDescriptorSetStorageBuffersDynamic() const { return maxDescriptorSetStorageBuffersDynamic; }
    inline uint32_t getMaxDescriptorSetSampledImages() const { return maxDescriptorSetSampledImages; }
    inline uint32_t getMaxDescriptorSetStorageImages() const { return maxDescriptorSetStorageImages; }
    inline uint32_t getMaxDescriptorSetInputAttachments() const { return maxDescriptorSetInputAttachments; }
    inline uint32_t getMaxVertexInputAttributes() const { return maxVertexInputAttributes; }
    inline uint32_t getMaxVertexInputBindings() const { return maxVertexInputBindings; }
    inline uint32_t getMaxVertexInputAttributeOffset() const { return maxVertexInputAttributeOffset; }
    inline uint32_t getMaxVertexInputBindingStride() const { return maxVertexInputBindingStride; }
    inline uint32_t getMaxVertexOutputComponents() const { return maxVertexOutputComponents; }
    inline uint32_t getMaxTessellationGenerationLevel() const { return maxTessellationGenerationLevel; }
    inline uint32_t getMaxTessellationPatchSize() const { return maxTessellationPatchSize; }
    inline uint32_t getMaxTessellationControlPerVertexInputComponents() const { return maxTessellationControlPerVertexInputComponents; }
    inline uint32_t getMaxTessellationControlPerVertexOutputComponents() const { return maxTessellationControlPerVertexOutputComponents; }
    inline uint32_t getMaxTessellationControlPerPatchOutputComponents() const { return maxTessellationControlPerPatchOutputComponents; }
    inline uint32_t getMaxTessellationControlTotalOutputComponents() const { return maxTessellationControlTotalOutputComponents; }
    inline uint32_t getMaxTessellationEvaluationInputComponents() const { return maxTessellationEvaluationInputComponents; }
    inline uint32_t getMaxTessellationEvaluationOutputComponents() const { return maxTessellationEvaluationOutputComponents; }
    inline uint32_t getMaxGeometryShaderInvocations() const { return maxGeometryShaderInvocations; }
    inline uint32_t getMaxGeometryInputComponents() const { return maxGeometryInputComponents; }
    inline uint32_t getMaxGeometryOutputComponents() const { return maxGeometryOutputComponents; }
    inline uint32_t getMaxGeometryOutputVertices() const { return maxGeometryOutputVertices; }
    inline uint32_t getMaxGeometryTotalOutputComponents() const { return maxGeometryTotalOutputComponents; }
    inline uint32_t getMaxFragmentInputComponents() const { return maxFragmentInputComponents; }
    inline uint32_t getMaxFragmentOutputAttachments() const { return maxFragmentOutputAttachments; }
    inline uint32_t getMaxFragmentDualSrcAttachments() const { return maxFragmentDualSrcAttachments; }
    inline uint32_t getMaxFragmentCombinedOutputResources() const { return maxFragmentCombinedOutputResources; }
    inline uint32_t getMaxComputeSharedMemorySize() const { return maxComputeSharedMemorySize; }
    inline const uint32_t* getMaxComputeWorkGroupCount() const { return maxComputeWorkGroupCount; }
    inline uint32_t getMaxComputeWorkGroupInvocations() const { return maxComputeWorkGroupInvocations; }
    inline const uint32_t* getMaxComputeWorkGroupSize() const { return maxComputeWorkGroupSize; }
    inline uint32_t getSubPixelPrecisionBits() const { return subPixelPrecisionBits; }
    inline uint32_t getSubTexelPrecisionBits() const { return subTexelPrecisionBits; }
    inline uint32_t getMipmapPrecisionBits() const { return mipmapPrecisionBits; }
    inline uint32_t getMaxDrawIndexedIndexValue() const { return maxDrawIndexedIndexValue; }
    inline uint32_t getMaxDrawIndirectCount() const { return maxDrawIndirectCount; }
    inline float getMaxSamplerLodBias() const { return maxSamplerLodBias; }
    inline float getMaxSamplerAnisotropy() const { return maxSamplerAnisotropy; }
    inline uint32_t getMaxViewports() const { return maxViewports; }
    inline const uint32_t* getMaxViewportDimensions() const { return maxViewportDimensions; }
    inline const float* getViewportBoundsRange() const { return viewportBoundsRange; }
    inline uint32_t getViewportSubPixelBits() const { return viewportSubPixelBits; }
    inline size_t getMinMemoryMapAlignment() const { return minMemoryMapAlignment; }
    inline VkDeviceSize getMinTexelBufferOffsetAlignment() const { return minTexelBufferOffsetAlignment; }
    inline VkDeviceSize getMinUniformBufferOffsetAlignment() const { return minUniformBufferOffsetAlignment; }
    inline VkDeviceSize getMinStorageBufferOffsetAlignment() const { return minStorageBufferOffsetAlignment; }
    inline int32_t getMinTexelOffset() const { return minTexelOffset; }
    inline uint32_t getMaxTexelOffset() const { return maxTexelOffset; }
    inline int32_t getMinTexelGatherOffset() const { return minTexelGatherOffset; }
    inline uint32_t getMaxTexelGatherOffset() const { return maxTexelGatherOffset; }
    inline float getMinInterpolationOffset() const { return minInterpolationOffset; }
    inline float getMaxInterpolationOffset() const { return maxInterpolationOffset; }
    inline uint32_t getSubPixelInterpolationOffsetBits() const { return subPixelInterpolationOffsetBits; }
    inline uint32_t getMaxFramebufferWidth() const { return maxFramebufferWidth; }
    inline uint32_t getMaxFramebufferHeight() const { return maxFramebufferHeight; }
    inline uint32_t getMaxFramebufferLayers() const { return maxFramebufferLayers; }
    inline SampleCountFlags getFramebufferColorSampleCounts() const { return (SampleCountFlags&)framebufferColorSampleCounts; }
    inline SampleCountFlags getFramebufferDepthSampleCounts() const { return (SampleCountFlags&)framebufferDepthSampleCounts; }
    inline SampleCountFlags getFramebufferStencilSampleCounts() const { return (SampleCountFlags&)framebufferStencilSampleCounts; }
    inline SampleCountFlags getFramebufferNoAttachmentsSampleCounts() const { return (SampleCountFlags&)framebufferNoAttachmentsSampleCounts; }
    inline uint32_t getMaxColorAttachments() const { return maxColorAttachments; }
    inline SampleCountFlags getSampledImageColorSampleCounts() const { return (SampleCountFlags&)sampledImageColorSampleCounts; }
    inline SampleCountFlags getSampledImageIntegerSampleCounts() const { return (SampleCountFlags&)sampledImageIntegerSampleCounts; }
    inline SampleCountFlags getSampledImageDepthSampleCounts() const { return (SampleCountFlags&)sampledImageDepthSampleCounts; }
    inline SampleCountFlags getSampledImageStencilSampleCounts() const { return (SampleCountFlags&)sampledImageStencilSampleCounts; }
    inline SampleCountFlags getStorageImageSampleCounts() const { return (SampleCountFlags&)storageImageSampleCounts; }
    inline uint32_t getMaxSampleMaskWords() const { return maxSampleMaskWords; }
    inline VkBool32 getTimestampComputeAndGraphics() const { return timestampComputeAndGraphics; }
    inline float getTimestampPeriod() const { return timestampPeriod; }
    inline uint32_t getMaxClipDistances() const { return maxClipDistances; }
    inline uint32_t getMaxCullDistances() const { return maxCullDistances; }
    inline uint32_t getMaxCombinedClipAndCullDistances() const { return maxCombinedClipAndCullDistances; }
    inline uint32_t getDiscreteQueuePriorities() const { return discreteQueuePriorities; }
    inline const float* getPointSizeRange() const { return pointSizeRange; }
    inline const float* getLineWidthRange() const { return lineWidthRange; }
    inline float getPointSizeGranularity() const { return pointSizeGranularity; }
    inline float getLineWidthGranularity() const { return lineWidthGranularity; }
    inline VkBool32 getStrictLines() const { return strictLines; }
    inline VkBool32 getStandardSampleLocations() const { return standardSampleLocations; }
    inline VkDeviceSize getOptimalBufferCopyOffsetAlignment() const { return optimalBufferCopyOffsetAlignment; }
    inline VkDeviceSize getOptimalBufferCopyRowPitchAlignment() const { return optimalBufferCopyRowPitchAlignment; }
    inline VkDeviceSize getNonCoherentAtomSize() const { return nonCoherentAtomSize; }
    inline VkPhysicalDeviceLimits& get() { return *this; }
    inline const VkPhysicalDeviceLimits& get() const { return *this; }
};

// PhysicalDeviceSparseProperties is a structure used only as a return type so only getters are defined
struct PhysicalDeviceSparseProperties : private VkPhysicalDeviceSparseProperties
{
    PhysicalDeviceSparseProperties() { }
    PhysicalDeviceSparseProperties(const VkPhysicalDeviceSparseProperties& vkType): VkPhysicalDeviceSparseProperties(vkType) { }
    inline VkBool32 getResidencyStandard2DBlockShape() const { return residencyStandard2DBlockShape; }
    inline VkBool32 getResidencyStandard2DMultisampleBlockShape() const { return residencyStandard2DMultisampleBlockShape; }
    inline VkBool32 getResidencyStandard3DBlockShape() const { return residencyStandard3DBlockShape; }
    inline VkBool32 getResidencyAlignedMipSize() const { return residencyAlignedMipSize; }
    inline VkBool32 getResidencyNonResidentStrict() const { return residencyNonResidentStrict; }
    inline VkPhysicalDeviceSparseProperties& get() { return *this; }
    inline const VkPhysicalDeviceSparseProperties& get() const { return *this; }
};

// PhysicalDeviceProperties is a structure used only as a return type so only getters are defined
struct PhysicalDeviceProperties : private VkPhysicalDeviceProperties
{
    PhysicalDeviceProperties() { }
    PhysicalDeviceProperties(const VkPhysicalDeviceProperties& vkType): VkPhysicalDeviceProperties(vkType) { }
    inline uint32_t getApiVersion() const { return apiVersion; }
    inline uint32_t getDriverVersion() const { return driverVersion; }
    inline uint32_t getVendorID() const { return vendorID; }
    inline uint32_t getDeviceID() const { return deviceID; }
    inline PhysicalDeviceType getDeviceType() const { return (PhysicalDeviceType&)deviceType; }
    inline const char* getDeviceName() const { return deviceName; }
    inline const uint8_t* getPipelineCacheUUID() const { return pipelineCacheUUID; }
    inline const PhysicalDeviceLimits& getLimits() const { return (PhysicalDeviceLimits&)limits; }
    inline const PhysicalDeviceSparseProperties& getSparseProperties() const { return (PhysicalDeviceSparseProperties&)sparseProperties; }
    inline VkPhysicalDeviceProperties& get() { return *this; }
    inline const VkPhysicalDeviceProperties& get() const { return *this; }
};

// QueueFamilyProperties is a structure used only as a return type so only getters are defined
struct QueueFamilyProperties : private VkQueueFamilyProperties
{
    QueueFamilyProperties() { }
    QueueFamilyProperties(const VkQueueFamilyProperties& vkType): VkQueueFamilyProperties(vkType) { }
    inline QueueFlags getQueueFlags() const { return (QueueFlags&)queueFlags; }
    inline uint32_t getQueueCount() const { return queueCount; }
    inline uint32_t getTimestampValidBits() const { return timestampValidBits; }
    inline const Extent3D& getMinImageTransferGranularity() const { return (Extent3D&)minImageTransferGranularity; }
    inline VkQueueFamilyProperties& get() { return *this; }
    inline const VkQueueFamilyProperties& get() const { return *this; }
};

// MemoryType is a structure used only as a return type so only getters are defined
struct MemoryType : private VkMemoryType
{
    MemoryType() { }
    MemoryType(const VkMemoryType& vkType): VkMemoryType(vkType) { }
    inline MemoryPropertyFlags getPropertyFlags() const { return (MemoryPropertyFlags&)propertyFlags; }
    inline uint32_t getHeapIndex() const { return heapIndex; }
    inline VkMemoryType& get() { return *this; }
    inline const VkMemoryType& get() const { return *this; }
};

// MemoryHeap is a structure used only as a return type so only getters are defined
struct MemoryHeap : private VkMemoryHeap
{
    MemoryHeap() { }
    MemoryHeap(const VkMemoryHeap& vkType): VkMemoryHeap(vkType) { }
    inline VkDeviceSize getSize() const { return size; }
    inline MemoryHeapFlags getFlags() const { return (MemoryHeapFlags&)flags; }
    inline VkMemoryHeap& get() { return *this; }
    inline const VkMemoryHeap& get() const { return *this; }
};

// PhysicalDeviceMemoryProperties is a structure used only as a return type so only getters are defined
struct PhysicalDeviceMemoryProperties : private VkPhysicalDeviceMemoryProperties
{
    PhysicalDeviceMemoryProperties() { }
    PhysicalDeviceMemoryProperties(const VkPhysicalDeviceMemoryProperties& vkType): VkPhysicalDeviceMemoryProperties(vkType) { }
    inline uint32_t getMemoryTypeCount() const { return memoryTypeCount; }
    inline const MemoryType* getMemoryTypes() const { return (MemoryType*)memoryTypes; }
    inline uint32_t getMemoryHeapCount() const { return memoryHeapCount; }
    inline const MemoryHeap* getMemoryHeaps() const { return (MemoryHeap*)memoryHeaps; }
    inline VkPhysicalDeviceMemoryProperties& get() { return *this; }
    inline const VkPhysicalDeviceMemoryProperties& get() const { return *this; }
};

// ExtensionProperties is a structure used only as a return type so only getters are defined
struct ExtensionProperties : private VkExtensionProperties
{
    ExtensionProperties() { }
    ExtensionProperties(const VkExtensionProperties& vkType): VkExtensionProperties(vkType) { }
    inline const char* getExtensionName() const { return extensionName; }
    inline uint32_t getSpecVersion() const { return specVersion; }
    inline VkExtensionProperties& get() { return *this; }
    inline const VkExtensionProperties& get() const { return *this; }
};

// LayerProperties is a structure used only as a return type so only getters are defined
struct LayerProperties : private VkLayerProperties
{
    LayerProperties() { }
    LayerProperties(const VkLayerProperties& vkType): VkLayerProperties(vkType) { }
    inline const char* getLayerName() const { return layerName; }
    inline uint32_t getSpecVersion() const { return specVersion; }
    inline uint32_t getImplementationVersion() const { return implementationVersion; }
    inline const char* getDescription() const { return description; }
    inline VkLayerProperties& get() { return *this; }
    inline const VkLayerProperties& get() const { return *this; }
};

// MemoryRequirements is a structure used only as a return type so only getters are defined
struct MemoryRequirements : private VkMemoryRequirements
{
    MemoryRequirements() { }
    MemoryRequirements(const VkMemoryRequirements& vkType): VkMemoryRequirements(vkType) { }
    inline VkDeviceSize getSize() const { return size; }
    inline VkDeviceSize getAlignment() const { return alignment; }
    inline uint32_t getMemoryTypeBits() const { return memoryTypeBits; }
    inline VkMemoryRequirements& get() { return *this; }
    inline const VkMemoryRequirements& get() const { return *this; }
};

// SparseImageFormatProperties is a structure used only as a return type so only getters are defined
struct SparseImageFormatProperties : private VkSparseImageFormatProperties
{
    SparseImageFormatProperties() { }
    SparseImageFormatProperties(const VkSparseImageFormatProperties& vkType): VkSparseImageFormatProperties(vkType) { }
    inline ImageAspectFlags getAspectMask() const { return (ImageAspectFlags&)aspectMask; }
    inline const Extent3D& getImageGranularity() const { return (Extent3D&)imageGranularity; }
    inline SparseImageFormatFlags getFlags() const { return (SparseImageFormatFlags&)flags; }
    inline VkSparseImageFormatProperties& get() { return *this; }
    inline const VkSparseImageFormatProperties& get() const { return *this; }
};

// SparseImageMemoryRequirements is a structure used only as a return type so only getters are defined
struct SparseImageMemoryRequirements : private VkSparseImageMemoryRequirements
{
    SparseImageMemoryRequirements() { }
    SparseImageMemoryRequirements(const VkSparseImageMemoryRequirements& vkType): VkSparseImageMemoryRequirements(vkType) { }
    inline const SparseImageFormatProperties& getFormatProperties() const { return (SparseImageFormatProperties&)formatProperties; }
    inline uint32_t getImageMipTailFirstLod() const { return imageMipTailFirstLod; }
    inline VkDeviceSize getImageMipTailSize() const { return imageMipTailSize; }
    inline VkDeviceSize getImageMipTailOffset() const { return imageMipTailOffset; }
    inline VkDeviceSize getImageMipTailStride() const { return imageMipTailStride; }
    inline VkSparseImageMemoryRequirements& get() { return *this; }
    inline const VkSparseImageMemoryRequirements& get() const { return *this; }
};

struct ImageSubresource : private VkImageSubresource
{
    ImageSubresource()
    {
        setAspectMask(ImageAspectFlags());
        setMipLevel(uint32_t());
        setArrayLayer(uint32_t());
    }
    ImageSubresource(const VkImageSubresource& vkType): VkImageSubresource(vkType) { }
    ImageSubresource(ImageAspectFlags aspectMask, uint32_t mipLevel, uint32_t arrayLayer)
    {
        setAspectMask(aspectMask);
        setMipLevel(mipLevel);
        setArrayLayer(arrayLayer);
    }
    inline ImageAspectFlags getAspectMask() const { return (ImageAspectFlags&)aspectMask; }
    inline void setAspectMask(ImageAspectFlags aspectMask) { this->aspectMask = (VkImageAspectFlags)aspectMask; }
    inline uint32_t getMipLevel() const { return mipLevel; }
    inline void setMipLevel(uint32_t mipLevel) { this->mipLevel = mipLevel; }
    inline uint32_t getArrayLayer() const { return arrayLayer; }
    inline void setArrayLayer(uint32_t arrayLayer) { this->arrayLayer = arrayLayer; }
    inline VkImageSubresource& get() { return *this; }
    inline const VkImageSubresource& get() const { return *this; }
};

struct Offset3D : private VkOffset3D
{
    Offset3D()
    {
        setX(int32_t());
        setY(int32_t());
        setZ(int32_t());
    }
    Offset3D(const VkOffset3D& vkType): VkOffset3D(vkType) { }
    Offset3D(int32_t x, int32_t y, int32_t z)
    {
        setX(x);
        setY(y);
        setZ(z);
    }
    inline int32_t getX() const { return x; }
    inline void setX(int32_t x) { this->x = x; }
    inline int32_t getY() const { return y; }
    inline void setY(int32_t y) { this->y = y; }
    inline int32_t getZ() const { return z; }
    inline void setZ(int32_t z) { this->z = z; }
    inline VkOffset3D& get() { return *this; }
    inline const VkOffset3D& get() const { return *this; }
};

// SubresourceLayout is a structure used only as a return type so only getters are defined
struct SubresourceLayout : private VkSubresourceLayout
{
    SubresourceLayout() { }
    SubresourceLayout(const VkSubresourceLayout& vkType): VkSubresourceLayout(vkType) { }
    inline VkDeviceSize getOffset() const { return offset; }
    inline VkDeviceSize getSize() const { return size; }
    inline VkDeviceSize getRowPitch() const { return rowPitch; }
    inline VkDeviceSize getArrayPitch() const { return arrayPitch; }
    inline VkDeviceSize getDepthPitch() const { return depthPitch; }
    inline VkSubresourceLayout& get() { return *this; }
    inline const VkSubresourceLayout& get() const { return *this; }
};

struct ComponentMapping : private VkComponentMapping
{
    ComponentMapping()
    {
        setR(ComponentSwizzle());
        setG(ComponentSwizzle());
        setB(ComponentSwizzle());
        setA(ComponentSwizzle());
    }
    ComponentMapping(const VkComponentMapping& vkType): VkComponentMapping(vkType) { }
    ComponentMapping(ComponentSwizzle r, ComponentSwizzle g, ComponentSwizzle b, ComponentSwizzle a)
    {
        setR(r);
        setG(g);
        setB(b);
        setA(a);
    }
    inline ComponentSwizzle getR() const { return (ComponentSwizzle&)r; }
    inline void setR(ComponentSwizzle r) { this->r = (VkComponentSwizzle)r; }
    inline ComponentSwizzle getG() const { return (ComponentSwizzle&)g; }
    inline void setG(ComponentSwizzle g) { this->g = (VkComponentSwizzle)g; }
    inline ComponentSwizzle getB() const { return (ComponentSwizzle&)b; }
    inline void setB(ComponentSwizzle b) { this->b = (VkComponentSwizzle)b; }
    inline ComponentSwizzle getA() const { return (ComponentSwizzle&)a; }
    inline void setA(ComponentSwizzle a) { this->a = (VkComponentSwizzle)a; }
    inline VkComponentMapping& get() { return *this; }
    inline const VkComponentMapping& get() const { return *this; }
};

struct ImageSubresourceRange : private VkImageSubresourceRange
{
    ImageSubresourceRange()
    {
        setAspectMask(ImageAspectFlags::e_MAX_ENUM);
        setBaseMipLevel(0);
        setLevelCount(1);
        setBaseArrayLayer(0);
        setLayerCount(1);
    }
    ImageSubresourceRange(const VkImageSubresourceRange& vkType): VkImageSubresourceRange(vkType) { }
    ImageSubresourceRange(ImageAspectFlags aspectMask, uint32_t baseMipLevel = 0, uint32_t levelCount = 1, uint32_t baseArrayLayer = 0, uint32_t layerCount = 1)
    {
        setAspectMask(aspectMask);
        setBaseMipLevel(baseMipLevel);
        setLevelCount(levelCount);
        setBaseArrayLayer(baseArrayLayer);
        setLayerCount(layerCount);
    }
    inline ImageAspectFlags getAspectMask() const { return (ImageAspectFlags&)aspectMask; }
    inline void setAspectMask(ImageAspectFlags aspectMask) { this->aspectMask = (VkImageAspectFlags)aspectMask; }
    inline uint32_t getBaseMipLevel() const { return baseMipLevel; }
    inline void setBaseMipLevel(uint32_t baseMipLevel) { this->baseMipLevel = baseMipLevel; }
    inline uint32_t getLevelCount() const { return levelCount; }
    inline void setLevelCount(uint32_t levelCount) { this->levelCount = levelCount; }
    inline uint32_t getBaseArrayLayer() const { return baseArrayLayer; }
    inline void setBaseArrayLayer(uint32_t baseArrayLayer) { this->baseArrayLayer = baseArrayLayer; }
    inline uint32_t getLayerCount() const { return layerCount; }
    inline void setLayerCount(uint32_t layerCount) { this->layerCount = layerCount; }
    inline VkImageSubresourceRange& get() { return *this; }
    inline const VkImageSubresourceRange& get() const { return *this; }
};

struct SpecializationMapEntry : private VkSpecializationMapEntry
{
    SpecializationMapEntry()
    {
        setConstantID(uint32_t());
        setOffset(uint32_t());
        setSize(size_t());
    }
    SpecializationMapEntry(const VkSpecializationMapEntry& vkType): VkSpecializationMapEntry(vkType) { }
    SpecializationMapEntry(uint32_t constantID, uint32_t offset, size_t size)
    {
        setConstantID(constantID);
        setOffset(offset);
        setSize(size);
    }
    inline uint32_t getConstantID() const { return constantID; }
    inline void setConstantID(uint32_t constantID) { this->constantID = constantID; }
    inline uint32_t getOffset() const { return offset; }
    inline void setOffset(uint32_t offset) { this->offset = offset; }
    inline size_t getSize() const { return size; }
    inline void setSize(size_t size) { this->size = size; }
    inline VkSpecializationMapEntry& get() { return *this; }
    inline const VkSpecializationMapEntry& get() const { return *this; }
};

struct SpecializationInfo : private VkSpecializationInfo
{
    SpecializationInfo()
    {
        setMapEntryCount(uint32_t());
        pMapEntries = nullptr;
        setDataSize(size_t());
        pData = nullptr;
    }
    SpecializationInfo(const VkSpecializationInfo& vkType): VkSpecializationInfo(vkType) { }
    SpecializationInfo(uint32_t mapEntryCount, SpecializationMapEntry* pMapEntries, size_t dataSize, void* pData)
    {
        setMapEntryCount(mapEntryCount);
        setPMapEntries(pMapEntries);
        setDataSize(dataSize);
        setPData(pData);
    }
    inline uint32_t getMapEntryCount() const { return mapEntryCount; }
    inline void setMapEntryCount(uint32_t mapEntryCount) { this->mapEntryCount = mapEntryCount; }
    inline const SpecializationMapEntry* getPMapEntries() const { return (SpecializationMapEntry*)pMapEntries; }
    inline void setPMapEntries(SpecializationMapEntry* pMapEntries) { this->pMapEntries = (VkSpecializationMapEntry*)pMapEntries; }
    inline size_t getDataSize() const { return dataSize; }
    inline void setDataSize(size_t dataSize) { this->dataSize = dataSize; }
    inline const void* getPData() const { return pData; }
    inline void setPData(void* pData) { this->pData = pData; }
    inline VkSpecializationInfo& get() { return *this; }
    inline const VkSpecializationInfo& get() const { return *this; }
};

struct VertexInputBindingDescription : private VkVertexInputBindingDescription
{
    VertexInputBindingDescription()
    {
        setBinding(0);
        setStride(0);
        setInputRate(VertexInputRate::e_VERTEX);
    }
    VertexInputBindingDescription(const VkVertexInputBindingDescription& vkType): VkVertexInputBindingDescription(vkType) { }
    VertexInputBindingDescription(uint32_t binding, uint32_t stride, VertexInputRate inputRate = VertexInputRate::e_VERTEX)
    {
        setBinding(binding);
        setStride(stride);
        setInputRate(inputRate);
    }
    inline uint32_t getBinding() const { return binding; }
    inline void setBinding(uint32_t binding) { this->binding = binding; }
    inline uint32_t getStride() const { return stride; }
    inline void setStride(uint32_t stride) { this->stride = stride; }
    inline VertexInputRate getInputRate() const { return (VertexInputRate&)inputRate; }
    inline void setInputRate(VertexInputRate inputRate) { this->inputRate = (VkVertexInputRate)inputRate; }
    inline VkVertexInputBindingDescription& get() { return *this; }
    inline const VkVertexInputBindingDescription& get() const { return *this; }
};

struct VertexInputAttributeDescription : private VkVertexInputAttributeDescription
{
    VertexInputAttributeDescription()
    {
        setLocation(uint32_t());
        setBinding(uint32_t());
        setFormat(Format());
        setOffset(uint32_t());
    }
    VertexInputAttributeDescription(const VkVertexInputAttributeDescription& vkType): VkVertexInputAttributeDescription(vkType) { }
    VertexInputAttributeDescription(uint32_t location, uint32_t binding, Format format, uint32_t offset)
    {
        setLocation(location);
        setBinding(binding);
        setFormat(format);
        setOffset(offset);
    }
    inline uint32_t getLocation() const { return location; }
    inline void setLocation(uint32_t location) { this->location = location; }
    inline uint32_t getBinding() const { return binding; }
    inline void setBinding(uint32_t binding) { this->binding = binding; }
    inline Format getFormat() const { return (Format&)format; }
    inline void setFormat(Format format) { this->format = (VkFormat)format; }
    inline uint32_t getOffset() const { return offset; }
    inline void setOffset(uint32_t offset) { this->offset = offset; }
    inline VkVertexInputAttributeDescription& get() { return *this; }
    inline const VkVertexInputAttributeDescription& get() const { return *this; }
};

struct Viewport : private VkViewport
{
    Viewport()
    {
        setX(0);
        setY(0);
        setWidth(1);
        setHeight(1);
        setMinDepth(0.f);
        setMaxDepth(1.f);
    }
    Viewport(const VkViewport& vkType): VkViewport(vkType) { }
    Viewport(float x, float y, float width, float height, float minDepth = 0.f, float maxDepth = 1.f)
    {
        setX(x);
        setY(y);
        setWidth(width);
        setHeight(height);
        setMinDepth(minDepth);
        setMaxDepth(maxDepth);
    }
    inline float getX() const { return x; }
    inline void setX(float x) { this->x = x; }
    inline float getY() const { return y; }
    inline void setY(float y) { this->y = y; }
    inline float getWidth() const { return width; }
    inline void setWidth(float width) { this->width = width; }
    inline float getHeight() const { return height; }
    inline void setHeight(float height) { this->height = height; }
    inline float getMinDepth() const { return minDepth; }
    inline void setMinDepth(float minDepth) { this->minDepth = minDepth; }
    inline float getMaxDepth() const { return maxDepth; }
    inline void setMaxDepth(float maxDepth) { this->maxDepth = maxDepth; }
    inline VkViewport& get() { return *this; }
    inline const VkViewport& get() const { return *this; }
};

struct Offset2D : private VkOffset2D
{
    Offset2D()
    {
        setX(int32_t());
        setY(int32_t());
    }
    Offset2D(const VkOffset2D& vkType): VkOffset2D(vkType) { }
    Offset2D(int32_t x, int32_t y)
    {
        setX(x);
        setY(y);
    }
    inline int32_t getX() const { return x; }
    inline void setX(int32_t x) { this->x = x; }
    inline int32_t getY() const { return y; }
    inline void setY(int32_t y) { this->y = y; }
    inline VkOffset2D& get() { return *this; }
    inline const VkOffset2D& get() const { return *this; }
};

struct Extent2D : private VkExtent2D
{
    Extent2D()
    {
        setWidth(uint32_t());
        setHeight(uint32_t());
    }
    Extent2D(const VkExtent2D& vkType): VkExtent2D(vkType) { }
    Extent2D(uint32_t width, uint32_t height)
    {
        setWidth(width);
        setHeight(height);
    }
    inline uint32_t getWidth() const { return width; }
    inline void setWidth(uint32_t width) { this->width = width; }
    inline uint32_t getHeight() const { return height; }
    inline void setHeight(uint32_t height) { this->height = height; }
    inline VkExtent2D& get() { return *this; }
    inline const VkExtent2D& get() const { return *this; }
};

struct Rect2D : private VkRect2D
{
    Rect2D()
    {
        setOffset(Offset2D());
        setExtent(Extent2D());
    }
    Rect2D(const VkRect2D& vkType): VkRect2D(vkType) { }
    Rect2D(const Offset2D& offset, const Extent2D& extent)
    {
        setOffset(offset);
        setExtent(extent);
    }
    Rect2D(int32_t x, int32_t y, uint32_t width, uint32_t height)
    {
        setOffset(pvrvk::Offset2D(x, y));
        setExtent(pvrvk::Extent2D(width, height));
    }
    inline const Offset2D& getOffset() const { return (Offset2D&)offset; }
    inline void setOffset(const Offset2D& offset) { memcpy(&this->offset, &offset, sizeof(this->offset)); }
    inline const Extent2D& getExtent() const { return (Extent2D&)extent; }
    inline void setExtent(const Extent2D& extent) { memcpy(&this->extent, &extent, sizeof(this->extent)); }
    inline VkRect2D& get() { return *this; }
    inline const VkRect2D& get() const { return *this; }
};

struct StencilOpState : private VkStencilOpState
{
    StencilOpState()
    {
        setFailOp(StencilOp::e_KEEP);
        setPassOp(StencilOp::e_KEEP);
        setDepthFailOp(StencilOp::e_KEEP);
        setCompareOp(CompareOp::e_ALWAYS);
        setCompareMask(0xff);
        setWriteMask(0xff);
        setReference(0);
    }
    StencilOpState(const VkStencilOpState& vkType): VkStencilOpState(vkType) { }
    StencilOpState(StencilOp failOp, StencilOp passOp, StencilOp depthFailOp, CompareOp compareOp, uint32_t compareMask, uint32_t writeMask, uint32_t reference)
    {
        setFailOp(failOp);
        setPassOp(passOp);
        setDepthFailOp(depthFailOp);
        setCompareOp(compareOp);
        setCompareMask(compareMask);
        setWriteMask(writeMask);
        setReference(reference);
    }
    inline StencilOp getFailOp() const { return (StencilOp&)failOp; }
    inline void setFailOp(StencilOp failOp) { this->failOp = (VkStencilOp)failOp; }
    inline StencilOp getPassOp() const { return (StencilOp&)passOp; }
    inline void setPassOp(StencilOp passOp) { this->passOp = (VkStencilOp)passOp; }
    inline StencilOp getDepthFailOp() const { return (StencilOp&)depthFailOp; }
    inline void setDepthFailOp(StencilOp depthFailOp) { this->depthFailOp = (VkStencilOp)depthFailOp; }
    inline CompareOp getCompareOp() const { return (CompareOp&)compareOp; }
    inline void setCompareOp(CompareOp compareOp) { this->compareOp = (VkCompareOp)compareOp; }
    inline uint32_t getCompareMask() const { return compareMask; }
    inline void setCompareMask(uint32_t compareMask) { this->compareMask = compareMask; }
    inline uint32_t getWriteMask() const { return writeMask; }
    inline void setWriteMask(uint32_t writeMask) { this->writeMask = writeMask; }
    inline uint32_t getReference() const { return reference; }
    inline void setReference(uint32_t reference) { this->reference = reference; }
    inline VkStencilOpState& get() { return *this; }
    inline const VkStencilOpState& get() const { return *this; }
};

struct PipelineColorBlendAttachmentState : private VkPipelineColorBlendAttachmentState
{
    PipelineColorBlendAttachmentState()
    {
        setBlendEnable(false);
        setSrcColorBlendFactor(BlendFactor::e_ONE);
        setDstColorBlendFactor(BlendFactor::e_ZERO);
        setColorBlendOp(BlendOp::e_ADD);
        setSrcAlphaBlendFactor(BlendFactor::e_ONE);
        setDstAlphaBlendFactor(BlendFactor::e_ZERO);
        setAlphaBlendOp(BlendOp::e_ADD);
        setColorWriteMask(ColorComponentFlags::e_ALL_BITS);
    }
    PipelineColorBlendAttachmentState(const VkPipelineColorBlendAttachmentState& vkType): VkPipelineColorBlendAttachmentState(vkType) { }
    PipelineColorBlendAttachmentState(VkBool32 blendEnable, BlendFactor srcColorBlendFactor = BlendFactor::e_ONE, BlendFactor dstColorBlendFactor = BlendFactor::e_ZERO, BlendOp colorBlendOp = BlendOp::e_ADD, BlendFactor srcAlphaBlendFactor = BlendFactor::e_ONE, BlendFactor dstAlphaBlendFactor = BlendFactor::e_ZERO, BlendOp alphaBlendOp = BlendOp::e_ADD, ColorComponentFlags colorWriteMask = ColorComponentFlags::e_ALL_BITS)
    {
        setBlendEnable(blendEnable);
        setSrcColorBlendFactor(srcColorBlendFactor);
        setDstColorBlendFactor(dstColorBlendFactor);
        setColorBlendOp(colorBlendOp);
        setSrcAlphaBlendFactor(srcAlphaBlendFactor);
        setDstAlphaBlendFactor(dstAlphaBlendFactor);
        setAlphaBlendOp(alphaBlendOp);
        setColorWriteMask(colorWriteMask);
    }
    inline VkBool32 getBlendEnable() const { return blendEnable; }
    inline void setBlendEnable(VkBool32 blendEnable) { this->blendEnable = blendEnable; }
    inline BlendFactor getSrcColorBlendFactor() const { return (BlendFactor&)srcColorBlendFactor; }
    inline void setSrcColorBlendFactor(BlendFactor srcColorBlendFactor) { this->srcColorBlendFactor = (VkBlendFactor)srcColorBlendFactor; }
    inline BlendFactor getDstColorBlendFactor() const { return (BlendFactor&)dstColorBlendFactor; }
    inline void setDstColorBlendFactor(BlendFactor dstColorBlendFactor) { this->dstColorBlendFactor = (VkBlendFactor)dstColorBlendFactor; }
    inline BlendOp getColorBlendOp() const { return (BlendOp&)colorBlendOp; }
    inline void setColorBlendOp(BlendOp colorBlendOp) { this->colorBlendOp = (VkBlendOp)colorBlendOp; }
    inline BlendFactor getSrcAlphaBlendFactor() const { return (BlendFactor&)srcAlphaBlendFactor; }
    inline void setSrcAlphaBlendFactor(BlendFactor srcAlphaBlendFactor) { this->srcAlphaBlendFactor = (VkBlendFactor)srcAlphaBlendFactor; }
    inline BlendFactor getDstAlphaBlendFactor() const { return (BlendFactor&)dstAlphaBlendFactor; }
    inline void setDstAlphaBlendFactor(BlendFactor dstAlphaBlendFactor) { this->dstAlphaBlendFactor = (VkBlendFactor)dstAlphaBlendFactor; }
    inline BlendOp getAlphaBlendOp() const { return (BlendOp&)alphaBlendOp; }
    inline void setAlphaBlendOp(BlendOp alphaBlendOp) { this->alphaBlendOp = (VkBlendOp)alphaBlendOp; }
    inline ColorComponentFlags getColorWriteMask() const { return (ColorComponentFlags&)colorWriteMask; }
    inline void setColorWriteMask(ColorComponentFlags colorWriteMask) { this->colorWriteMask = (VkColorComponentFlags)colorWriteMask; }
    inline VkPipelineColorBlendAttachmentState& get() { return *this; }
    inline const VkPipelineColorBlendAttachmentState& get() const { return *this; }
};

struct PushConstantRange : private VkPushConstantRange
{
    PushConstantRange()
    {
        setStageFlags(ShaderStageFlags::e_ALL);
        setOffset(0);
        setSize(0);
    }
    PushConstantRange(const VkPushConstantRange& vkType): VkPushConstantRange(vkType) { }
    PushConstantRange(ShaderStageFlags stageFlags, uint32_t offset, uint32_t size)
    {
        setStageFlags(stageFlags);
        setOffset(offset);
        setSize(size);
    }
    inline ShaderStageFlags getStageFlags() const { return (ShaderStageFlags&)stageFlags; }
    inline void setStageFlags(ShaderStageFlags stageFlags) { this->stageFlags = (VkShaderStageFlags)stageFlags; }
    inline uint32_t getOffset() const { return offset; }
    inline void setOffset(uint32_t offset) { this->offset = offset; }
    inline uint32_t getSize() const { return size; }
    inline void setSize(uint32_t size) { this->size = size; }
    inline VkPushConstantRange& get() { return *this; }
    inline const VkPushConstantRange& get() const { return *this; }
};

struct DescriptorPoolSize : private VkDescriptorPoolSize
{
    DescriptorPoolSize()
    {
        setType(DescriptorType());
        setDescriptorCount(uint32_t());
    }
    DescriptorPoolSize(const VkDescriptorPoolSize& vkType): VkDescriptorPoolSize(vkType) { }
    DescriptorPoolSize(DescriptorType type, uint32_t descriptorCount)
    {
        setType(type);
        setDescriptorCount(descriptorCount);
    }
    inline DescriptorType getType() const { return (DescriptorType&)type; }
    inline void setType(DescriptorType type) { this->type = (VkDescriptorType)type; }
    inline uint32_t getDescriptorCount() const { return descriptorCount; }
    inline void setDescriptorCount(uint32_t descriptorCount) { this->descriptorCount = descriptorCount; }
    inline VkDescriptorPoolSize& get() { return *this; }
    inline const VkDescriptorPoolSize& get() const { return *this; }
};

struct AttachmentReference : private VkAttachmentReference
{
    AttachmentReference()
    {
        setAttachment(static_cast<uint32_t>(-1));
        setLayout(ImageLayout::e_UNDEFINED);
    }
    AttachmentReference(const VkAttachmentReference& vkType): VkAttachmentReference(vkType) { }
    AttachmentReference(uint32_t attachment, ImageLayout layout)
    {
        setAttachment(attachment);
        setLayout(layout);
    }
    inline uint32_t getAttachment() const { return attachment; }
    inline void setAttachment(uint32_t attachment) { this->attachment = attachment; }
    inline ImageLayout getLayout() const { return (ImageLayout&)layout; }
    inline void setLayout(ImageLayout layout) { this->layout = (VkImageLayout)layout; }
    inline VkAttachmentReference& get() { return *this; }
    inline const VkAttachmentReference& get() const { return *this; }
};

struct SubpassDependency : private VkSubpassDependency
{
    SubpassDependency()
    {
        setSrcSubpass(uint32_t());
        setDstSubpass(uint32_t());
        setSrcStageMask(PipelineStageFlags());
        setDstStageMask(PipelineStageFlags());
        setSrcAccessMask(AccessFlags());
        setDstAccessMask(AccessFlags());
        setDependencyFlags(DependencyFlags());
    }
    SubpassDependency(const VkSubpassDependency& vkType): VkSubpassDependency(vkType) { }
    SubpassDependency(uint32_t srcSubpass, uint32_t dstSubpass, PipelineStageFlags srcStageMask, PipelineStageFlags dstStageMask, AccessFlags srcAccessMask, AccessFlags dstAccessMask, DependencyFlags dependencyFlags)
    {
        setSrcSubpass(srcSubpass);
        setDstSubpass(dstSubpass);
        setSrcStageMask(srcStageMask);
        setDstStageMask(dstStageMask);
        setSrcAccessMask(srcAccessMask);
        setDstAccessMask(dstAccessMask);
        setDependencyFlags(dependencyFlags);
    }
    inline uint32_t getSrcSubpass() const { return srcSubpass; }
    inline void setSrcSubpass(uint32_t srcSubpass) { this->srcSubpass = srcSubpass; }
    inline uint32_t getDstSubpass() const { return dstSubpass; }
    inline void setDstSubpass(uint32_t dstSubpass) { this->dstSubpass = dstSubpass; }
    inline PipelineStageFlags getSrcStageMask() const { return (PipelineStageFlags&)srcStageMask; }
    inline void setSrcStageMask(PipelineStageFlags srcStageMask) { this->srcStageMask = (VkPipelineStageFlags)srcStageMask; }
    inline PipelineStageFlags getDstStageMask() const { return (PipelineStageFlags&)dstStageMask; }
    inline void setDstStageMask(PipelineStageFlags dstStageMask) { this->dstStageMask = (VkPipelineStageFlags)dstStageMask; }
    inline AccessFlags getSrcAccessMask() const { return (AccessFlags&)srcAccessMask; }
    inline void setSrcAccessMask(AccessFlags srcAccessMask) { this->srcAccessMask = (VkAccessFlags)srcAccessMask; }
    inline AccessFlags getDstAccessMask() const { return (AccessFlags&)dstAccessMask; }
    inline void setDstAccessMask(AccessFlags dstAccessMask) { this->dstAccessMask = (VkAccessFlags)dstAccessMask; }
    inline DependencyFlags getDependencyFlags() const { return (DependencyFlags&)dependencyFlags; }
    inline void setDependencyFlags(DependencyFlags dependencyFlags) { this->dependencyFlags = (VkDependencyFlags)dependencyFlags; }
    inline VkSubpassDependency& get() { return *this; }
    inline const VkSubpassDependency& get() const { return *this; }
};

struct BufferCopy : private VkBufferCopy
{
    BufferCopy()
    {
        setSrcOffset(VkDeviceSize());
        setDstOffset(VkDeviceSize());
        setSize(VkDeviceSize());
    }
    BufferCopy(const VkBufferCopy& vkType): VkBufferCopy(vkType) { }
    BufferCopy(VkDeviceSize srcOffset, VkDeviceSize dstOffset, VkDeviceSize size)
    {
        setSrcOffset(srcOffset);
        setDstOffset(dstOffset);
        setSize(size);
    }
    inline VkDeviceSize getSrcOffset() const { return srcOffset; }
    inline void setSrcOffset(VkDeviceSize srcOffset) { this->srcOffset = srcOffset; }
    inline VkDeviceSize getDstOffset() const { return dstOffset; }
    inline void setDstOffset(VkDeviceSize dstOffset) { this->dstOffset = dstOffset; }
    inline VkDeviceSize getSize() const { return size; }
    inline void setSize(VkDeviceSize size) { this->size = size; }
    inline VkBufferCopy& get() { return *this; }
    inline const VkBufferCopy& get() const { return *this; }
};

struct ImageSubresourceLayers : private VkImageSubresourceLayers
{
    ImageSubresourceLayers()
    {
        setAspectMask(ImageAspectFlags::e_COLOR_BIT);
        setMipLevel(0);
        setBaseArrayLayer(0);
        setLayerCount(1);
    }
    ImageSubresourceLayers(const VkImageSubresourceLayers& vkType): VkImageSubresourceLayers(vkType) { }
    ImageSubresourceLayers(ImageAspectFlags aspectMask, uint32_t mipLevel, uint32_t baseArrayLayer, uint32_t layerCount)
    {
        setAspectMask(aspectMask);
        setMipLevel(mipLevel);
        setBaseArrayLayer(baseArrayLayer);
        setLayerCount(layerCount);
    }
    inline ImageAspectFlags getAspectMask() const { return (ImageAspectFlags&)aspectMask; }
    inline void setAspectMask(ImageAspectFlags aspectMask) { this->aspectMask = (VkImageAspectFlags)aspectMask; }
    inline uint32_t getMipLevel() const { return mipLevel; }
    inline void setMipLevel(uint32_t mipLevel) { this->mipLevel = mipLevel; }
    inline uint32_t getBaseArrayLayer() const { return baseArrayLayer; }
    inline void setBaseArrayLayer(uint32_t baseArrayLayer) { this->baseArrayLayer = baseArrayLayer; }
    inline uint32_t getLayerCount() const { return layerCount; }
    inline void setLayerCount(uint32_t layerCount) { this->layerCount = layerCount; }
    inline VkImageSubresourceLayers& get() { return *this; }
    inline const VkImageSubresourceLayers& get() const { return *this; }
};

struct ImageCopy : private VkImageCopy
{
    ImageCopy()
    {
        setSrcSubresource(ImageSubresourceLayers());
        setSrcOffset(Offset3D());
        setDstSubresource(ImageSubresourceLayers());
        setDstOffset(Offset3D());
        setExtent(Extent3D());
    }
    ImageCopy(const VkImageCopy& vkType): VkImageCopy(vkType) { }
    ImageCopy(const ImageSubresourceLayers& srcSubresource, const Offset3D& srcOffset, const ImageSubresourceLayers& dstSubresource, const Offset3D& dstOffset, const Extent3D& extent)
    {
        setSrcSubresource(srcSubresource);
        setSrcOffset(srcOffset);
        setDstSubresource(dstSubresource);
        setDstOffset(dstOffset);
        setExtent(extent);
    }
    inline const ImageSubresourceLayers& getSrcSubresource() const { return (ImageSubresourceLayers&)srcSubresource; }
    inline void setSrcSubresource(const ImageSubresourceLayers& srcSubresource) { memcpy(&this->srcSubresource, &srcSubresource, sizeof(this->srcSubresource)); }
    inline const Offset3D& getSrcOffset() const { return (Offset3D&)srcOffset; }
    inline void setSrcOffset(const Offset3D& srcOffset) { memcpy(&this->srcOffset, &srcOffset, sizeof(this->srcOffset)); }
    inline const ImageSubresourceLayers& getDstSubresource() const { return (ImageSubresourceLayers&)dstSubresource; }
    inline void setDstSubresource(const ImageSubresourceLayers& dstSubresource) { memcpy(&this->dstSubresource, &dstSubresource, sizeof(this->dstSubresource)); }
    inline const Offset3D& getDstOffset() const { return (Offset3D&)dstOffset; }
    inline void setDstOffset(const Offset3D& dstOffset) { memcpy(&this->dstOffset, &dstOffset, sizeof(this->dstOffset)); }
    inline const Extent3D& getExtent() const { return (Extent3D&)extent; }
    inline void setExtent(const Extent3D& extent) { memcpy(&this->extent, &extent, sizeof(this->extent)); }
    inline VkImageCopy& get() { return *this; }
    inline const VkImageCopy& get() const { return *this; }
};

struct ImageBlit : private VkImageBlit
{
    ImageBlit()
    {
        setSrcSubresource(ImageSubresourceLayers());
        memset(srcOffsets, 0, sizeof(srcOffsets));
        setDstSubresource(ImageSubresourceLayers());
        memset(dstOffsets, 0, sizeof(dstOffsets));
    }
    ImageBlit(const VkImageBlit& vkType): VkImageBlit(vkType) { }
    ImageBlit(const ImageSubresourceLayers& srcSubresource, const Offset3D* srcOffsets, const ImageSubresourceLayers& dstSubresource, const Offset3D* dstOffsets)
    {
        setSrcSubresource(srcSubresource);
        setSrcOffsets(srcOffsets);
        setDstSubresource(dstSubresource);
        setDstOffsets(dstOffsets);
    }
    inline const ImageSubresourceLayers& getSrcSubresource() const { return (ImageSubresourceLayers&)srcSubresource; }
    inline void setSrcSubresource(const ImageSubresourceLayers& srcSubresource) { memcpy(&this->srcSubresource, &srcSubresource, sizeof(this->srcSubresource)); }
    inline const Offset3D* getSrcOffsets() const { return (Offset3D*)srcOffsets; }
    inline void setSrcOffsets(const Offset3D* srcOffsets) { memcpy(this->srcOffsets, srcOffsets, sizeof(this->srcOffsets)); }
    inline void setSrcOffsets(const Offset3D& srcOffsets, const uint32_t index) { memcpy(this->srcOffsets + index, &srcOffsets + index, sizeof(srcOffsets)); }
    inline const ImageSubresourceLayers& getDstSubresource() const { return (ImageSubresourceLayers&)dstSubresource; }
    inline void setDstSubresource(const ImageSubresourceLayers& dstSubresource) { memcpy(&this->dstSubresource, &dstSubresource, sizeof(this->dstSubresource)); }
    inline const Offset3D* getDstOffsets() const { return (Offset3D*)dstOffsets; }
    inline void setDstOffsets(const Offset3D* dstOffsets) { memcpy(this->dstOffsets, dstOffsets, sizeof(this->dstOffsets)); }
    inline void setDstOffsets(const Offset3D& dstOffsets, const uint32_t index) { memcpy(this->dstOffsets + index, &dstOffsets + index, sizeof(dstOffsets)); }
    inline VkImageBlit& get() { return *this; }
    inline const VkImageBlit& get() const { return *this; }
};

struct BufferImageCopy : private VkBufferImageCopy
{
    BufferImageCopy()
    {
        setBufferOffset(VkDeviceSize());
        setBufferRowLength(uint32_t());
        setBufferImageHeight(uint32_t());
        setImageSubresource(ImageSubresourceLayers());
        setImageOffset(Offset3D());
        setImageExtent(Extent3D());
    }
    BufferImageCopy(const VkBufferImageCopy& vkType): VkBufferImageCopy(vkType) { }
    BufferImageCopy(VkDeviceSize bufferOffset, uint32_t bufferRowLength, uint32_t bufferImageHeight, const ImageSubresourceLayers& imageSubresource, const Offset3D& imageOffset, const Extent3D& imageExtent)
    {
        setBufferOffset(bufferOffset);
        setBufferRowLength(bufferRowLength);
        setBufferImageHeight(bufferImageHeight);
        setImageSubresource(imageSubresource);
        setImageOffset(imageOffset);
        setImageExtent(imageExtent);
    }
    inline VkDeviceSize getBufferOffset() const { return bufferOffset; }
    inline void setBufferOffset(VkDeviceSize bufferOffset) { this->bufferOffset = bufferOffset; }
    inline uint32_t getBufferRowLength() const { return bufferRowLength; }
    inline void setBufferRowLength(uint32_t bufferRowLength) { this->bufferRowLength = bufferRowLength; }
    inline uint32_t getBufferImageHeight() const { return bufferImageHeight; }
    inline void setBufferImageHeight(uint32_t bufferImageHeight) { this->bufferImageHeight = bufferImageHeight; }
    inline const ImageSubresourceLayers& getImageSubresource() const { return (ImageSubresourceLayers&)imageSubresource; }
    inline void setImageSubresource(const ImageSubresourceLayers& imageSubresource) { memcpy(&this->imageSubresource, &imageSubresource, sizeof(this->imageSubresource)); }
    inline const Offset3D& getImageOffset() const { return (Offset3D&)imageOffset; }
    inline void setImageOffset(const Offset3D& imageOffset) { memcpy(&this->imageOffset, &imageOffset, sizeof(this->imageOffset)); }
    inline const Extent3D& getImageExtent() const { return (Extent3D&)imageExtent; }
    inline void setImageExtent(const Extent3D& imageExtent) { memcpy(&this->imageExtent, &imageExtent, sizeof(this->imageExtent)); }
    inline VkBufferImageCopy& get() { return *this; }
    inline const VkBufferImageCopy& get() const { return *this; }
};

struct ClearDepthStencilValue : private VkClearDepthStencilValue
{
    ClearDepthStencilValue()
    {
        setDepth(float());
        setStencil(uint32_t());
    }
    ClearDepthStencilValue(const VkClearDepthStencilValue& vkType): VkClearDepthStencilValue(vkType) { }
    ClearDepthStencilValue(float depth, uint32_t stencil)
    {
        setDepth(depth);
        setStencil(stencil);
    }
    inline float getDepth() const { return depth; }
    inline void setDepth(float depth) { this->depth = depth; }
    inline uint32_t getStencil() const { return stencil; }
    inline void setStencil(uint32_t stencil) { this->stencil = stencil; }
    inline VkClearDepthStencilValue& get() { return *this; }
    inline const VkClearDepthStencilValue& get() const { return *this; }
};

struct ClearRect : private VkClearRect
{
    ClearRect()
    {
        setRect(Rect2D());
        setBaseArrayLayer(0);
        setLayerCount(1);
    }
    ClearRect(const VkClearRect& vkType): VkClearRect(vkType) { }
    ClearRect(const Rect2D& rect, uint32_t baseArrayLayer = 0, uint32_t layerCount = 1)
    {
        setRect(rect);
        setBaseArrayLayer(baseArrayLayer);
        setLayerCount(layerCount);
    }
    inline const Rect2D& getRect() const { return (Rect2D&)rect; }
    inline void setRect(const Rect2D& rect) { memcpy(&this->rect, &rect, sizeof(this->rect)); }
    inline uint32_t getBaseArrayLayer() const { return baseArrayLayer; }
    inline void setBaseArrayLayer(uint32_t baseArrayLayer) { this->baseArrayLayer = baseArrayLayer; }
    inline uint32_t getLayerCount() const { return layerCount; }
    inline void setLayerCount(uint32_t layerCount) { this->layerCount = layerCount; }
    inline VkClearRect& get() { return *this; }
    inline const VkClearRect& get() const { return *this; }
};

struct ImageResolve : private VkImageResolve
{
    ImageResolve()
    {
        setSrcSubresource(ImageSubresourceLayers());
        setSrcOffset(Offset3D());
        setDstSubresource(ImageSubresourceLayers());
        setDstOffset(Offset3D());
        setExtent(Extent3D());
    }
    ImageResolve(const VkImageResolve& vkType): VkImageResolve(vkType) { }
    ImageResolve(const ImageSubresourceLayers& srcSubresource, const Offset3D& srcOffset, const ImageSubresourceLayers& dstSubresource, const Offset3D& dstOffset, const Extent3D& extent)
    {
        setSrcSubresource(srcSubresource);
        setSrcOffset(srcOffset);
        setDstSubresource(dstSubresource);
        setDstOffset(dstOffset);
        setExtent(extent);
    }
    inline const ImageSubresourceLayers& getSrcSubresource() const { return (ImageSubresourceLayers&)srcSubresource; }
    inline void setSrcSubresource(const ImageSubresourceLayers& srcSubresource) { memcpy(&this->srcSubresource, &srcSubresource, sizeof(this->srcSubresource)); }
    inline const Offset3D& getSrcOffset() const { return (Offset3D&)srcOffset; }
    inline void setSrcOffset(const Offset3D& srcOffset) { memcpy(&this->srcOffset, &srcOffset, sizeof(this->srcOffset)); }
    inline const ImageSubresourceLayers& getDstSubresource() const { return (ImageSubresourceLayers&)dstSubresource; }
    inline void setDstSubresource(const ImageSubresourceLayers& dstSubresource) { memcpy(&this->dstSubresource, &dstSubresource, sizeof(this->dstSubresource)); }
    inline const Offset3D& getDstOffset() const { return (Offset3D&)dstOffset; }
    inline void setDstOffset(const Offset3D& dstOffset) { memcpy(&this->dstOffset, &dstOffset, sizeof(this->dstOffset)); }
    inline const Extent3D& getExtent() const { return (Extent3D&)extent; }
    inline void setExtent(const Extent3D& extent) { memcpy(&this->extent, &extent, sizeof(this->extent)); }
    inline VkImageResolve& get() { return *this; }
    inline const VkImageResolve& get() const { return *this; }
};

struct DispatchIndirectCommand : private VkDispatchIndirectCommand
{
    DispatchIndirectCommand()
    {
        setX(uint32_t());
        setY(uint32_t());
        setZ(uint32_t());
    }
    DispatchIndirectCommand(const VkDispatchIndirectCommand& vkType): VkDispatchIndirectCommand(vkType) { }
    DispatchIndirectCommand(uint32_t x, uint32_t y, uint32_t z)
    {
        setX(x);
        setY(y);
        setZ(z);
    }
    inline uint32_t getX() const { return x; }
    inline void setX(uint32_t x) { this->x = x; }
    inline uint32_t getY() const { return y; }
    inline void setY(uint32_t y) { this->y = y; }
    inline uint32_t getZ() const { return z; }
    inline void setZ(uint32_t z) { this->z = z; }
    inline VkDispatchIndirectCommand& get() { return *this; }
    inline const VkDispatchIndirectCommand& get() const { return *this; }
};

struct DrawIndexedIndirectCommand : private VkDrawIndexedIndirectCommand
{
    DrawIndexedIndirectCommand()
    {
        setIndexCount(uint32_t());
        setInstanceCount(uint32_t());
        setFirstIndex(uint32_t());
        setVertexOffset(int32_t());
        setFirstInstance(uint32_t());
    }
    DrawIndexedIndirectCommand(const VkDrawIndexedIndirectCommand& vkType): VkDrawIndexedIndirectCommand(vkType) { }
    DrawIndexedIndirectCommand(uint32_t indexCount, uint32_t instanceCount, uint32_t firstIndex, int32_t vertexOffset, uint32_t firstInstance)
    {
        setIndexCount(indexCount);
        setInstanceCount(instanceCount);
        setFirstIndex(firstIndex);
        setVertexOffset(vertexOffset);
        setFirstInstance(firstInstance);
    }
    inline uint32_t getIndexCount() const { return indexCount; }
    inline void setIndexCount(uint32_t indexCount) { this->indexCount = indexCount; }
    inline uint32_t getInstanceCount() const { return instanceCount; }
    inline void setInstanceCount(uint32_t instanceCount) { this->instanceCount = instanceCount; }
    inline uint32_t getFirstIndex() const { return firstIndex; }
    inline void setFirstIndex(uint32_t firstIndex) { this->firstIndex = firstIndex; }
    inline int32_t getVertexOffset() const { return vertexOffset; }
    inline void setVertexOffset(int32_t vertexOffset) { this->vertexOffset = vertexOffset; }
    inline uint32_t getFirstInstance() const { return firstInstance; }
    inline void setFirstInstance(uint32_t firstInstance) { this->firstInstance = firstInstance; }
    inline VkDrawIndexedIndirectCommand& get() { return *this; }
    inline const VkDrawIndexedIndirectCommand& get() const { return *this; }
};

struct DrawIndirectCommand : private VkDrawIndirectCommand
{
    DrawIndirectCommand()
    {
        setVertexCount(uint32_t());
        setInstanceCount(uint32_t());
        setFirstVertex(uint32_t());
        setFirstInstance(uint32_t());
    }
    DrawIndirectCommand(const VkDrawIndirectCommand& vkType): VkDrawIndirectCommand(vkType) { }
    DrawIndirectCommand(uint32_t vertexCount, uint32_t instanceCount, uint32_t firstVertex, uint32_t firstInstance)
    {
        setVertexCount(vertexCount);
        setInstanceCount(instanceCount);
        setFirstVertex(firstVertex);
        setFirstInstance(firstInstance);
    }
    inline uint32_t getVertexCount() const { return vertexCount; }
    inline void setVertexCount(uint32_t vertexCount) { this->vertexCount = vertexCount; }
    inline uint32_t getInstanceCount() const { return instanceCount; }
    inline void setInstanceCount(uint32_t instanceCount) { this->instanceCount = instanceCount; }
    inline uint32_t getFirstVertex() const { return firstVertex; }
    inline void setFirstVertex(uint32_t firstVertex) { this->firstVertex = firstVertex; }
    inline uint32_t getFirstInstance() const { return firstInstance; }
    inline void setFirstInstance(uint32_t firstInstance) { this->firstInstance = firstInstance; }
    inline VkDrawIndirectCommand& get() { return *this; }
    inline const VkDrawIndirectCommand& get() const { return *this; }
};

struct InputAttachmentAspectReference : private VkInputAttachmentAspectReference
{
    InputAttachmentAspectReference()
    {
        setSubpass(uint32_t());
        setInputAttachmentIndex(uint32_t());
        setAspectMask(ImageAspectFlags());
    }
    InputAttachmentAspectReference(const VkInputAttachmentAspectReference& vkType): VkInputAttachmentAspectReference(vkType) { }
    InputAttachmentAspectReference(uint32_t subpass, uint32_t inputAttachmentIndex, ImageAspectFlags aspectMask)
    {
        setSubpass(subpass);
        setInputAttachmentIndex(inputAttachmentIndex);
        setAspectMask(aspectMask);
    }
    inline uint32_t getSubpass() const { return subpass; }
    inline void setSubpass(uint32_t subpass) { this->subpass = subpass; }
    inline uint32_t getInputAttachmentIndex() const { return inputAttachmentIndex; }
    inline void setInputAttachmentIndex(uint32_t inputAttachmentIndex) { this->inputAttachmentIndex = inputAttachmentIndex; }
    inline ImageAspectFlags getAspectMask() const { return (ImageAspectFlags&)aspectMask; }
    inline void setAspectMask(ImageAspectFlags aspectMask) { this->aspectMask = (VkImageAspectFlags)aspectMask; }
    inline VkInputAttachmentAspectReference& get() { return *this; }
    inline const VkInputAttachmentAspectReference& get() const { return *this; }
};

struct DescriptorUpdateTemplateEntry : private VkDescriptorUpdateTemplateEntry
{
    DescriptorUpdateTemplateEntry()
    {
        setDstBinding(uint32_t());
        setDstArrayElement(uint32_t());
        setDescriptorCount(uint32_t());
        setDescriptorType(DescriptorType());
        setOffset(size_t());
        setStride(size_t());
    }
    DescriptorUpdateTemplateEntry(const VkDescriptorUpdateTemplateEntry& vkType): VkDescriptorUpdateTemplateEntry(vkType) { }
    DescriptorUpdateTemplateEntry(uint32_t dstBinding, uint32_t dstArrayElement, uint32_t descriptorCount, DescriptorType descriptorType, size_t offset, size_t stride)
    {
        setDstBinding(dstBinding);
        setDstArrayElement(dstArrayElement);
        setDescriptorCount(descriptorCount);
        setDescriptorType(descriptorType);
        setOffset(offset);
        setStride(stride);
    }
    inline uint32_t getDstBinding() const { return dstBinding; }
    inline void setDstBinding(uint32_t dstBinding) { this->dstBinding = dstBinding; }
    inline uint32_t getDstArrayElement() const { return dstArrayElement; }
    inline void setDstArrayElement(uint32_t dstArrayElement) { this->dstArrayElement = dstArrayElement; }
    inline uint32_t getDescriptorCount() const { return descriptorCount; }
    inline void setDescriptorCount(uint32_t descriptorCount) { this->descriptorCount = descriptorCount; }
    inline DescriptorType getDescriptorType() const { return (DescriptorType&)descriptorType; }
    inline void setDescriptorType(DescriptorType descriptorType) { this->descriptorType = (VkDescriptorType)descriptorType; }
    inline size_t getOffset() const { return offset; }
    inline void setOffset(size_t offset) { this->offset = offset; }
    inline size_t getStride() const { return stride; }
    inline void setStride(size_t stride) { this->stride = stride; }
    inline VkDescriptorUpdateTemplateEntry& get() { return *this; }
    inline const VkDescriptorUpdateTemplateEntry& get() const { return *this; }
};

// ExternalMemoryProperties is a structure used only as a return type so only getters are defined
struct ExternalMemoryProperties : private VkExternalMemoryProperties
{
    ExternalMemoryProperties() { }
    ExternalMemoryProperties(const VkExternalMemoryProperties& vkType): VkExternalMemoryProperties(vkType) { }
    inline ExternalMemoryFeatureFlags getExternalMemoryFeatures() const { return (ExternalMemoryFeatureFlags&)externalMemoryFeatures; }
    inline ExternalMemoryHandleTypeFlags getExportFromImportedHandleTypes() const { return (ExternalMemoryHandleTypeFlags&)exportFromImportedHandleTypes; }
    inline ExternalMemoryHandleTypeFlags getCompatibleHandleTypes() const { return (ExternalMemoryHandleTypeFlags&)compatibleHandleTypes; }
    inline VkExternalMemoryProperties& get() { return *this; }
    inline const VkExternalMemoryProperties& get() const { return *this; }
};

// SurfaceCapabilitiesKHR is a structure used only as a return type so only getters are defined
struct SurfaceCapabilitiesKHR : private VkSurfaceCapabilitiesKHR
{
    SurfaceCapabilitiesKHR() { }
    SurfaceCapabilitiesKHR(const VkSurfaceCapabilitiesKHR& vkType): VkSurfaceCapabilitiesKHR(vkType) { }
    inline uint32_t getMinImageCount() const { return minImageCount; }
    inline uint32_t getMaxImageCount() const { return maxImageCount; }
    inline const Extent2D& getCurrentExtent() const { return (Extent2D&)currentExtent; }
    inline const Extent2D& getMinImageExtent() const { return (Extent2D&)minImageExtent; }
    inline const Extent2D& getMaxImageExtent() const { return (Extent2D&)maxImageExtent; }
    inline uint32_t getMaxImageArrayLayers() const { return maxImageArrayLayers; }
    inline SurfaceTransformFlagsKHR getSupportedTransforms() const { return (SurfaceTransformFlagsKHR&)supportedTransforms; }
    inline SurfaceTransformFlagsKHR getCurrentTransform() const { return (SurfaceTransformFlagsKHR&)currentTransform; }
    inline CompositeAlphaFlagsKHR getSupportedCompositeAlpha() const { return (CompositeAlphaFlagsKHR&)supportedCompositeAlpha; }
    inline ImageUsageFlags getSupportedUsageFlags() const { return (ImageUsageFlags&)supportedUsageFlags; }
    inline VkSurfaceCapabilitiesKHR& get() { return *this; }
    inline const VkSurfaceCapabilitiesKHR& get() const { return *this; }
};

// SurfaceFormatKHR is a structure used only as a return type so only getters are defined
struct SurfaceFormatKHR : private VkSurfaceFormatKHR
{
    SurfaceFormatKHR() { }
    SurfaceFormatKHR(const VkSurfaceFormatKHR& vkType): VkSurfaceFormatKHR(vkType) { }
    inline Format getFormat() const { return (Format&)format; }
    inline ColorSpaceKHR getColorSpace() const { return (ColorSpaceKHR&)colorSpace; }
    inline VkSurfaceFormatKHR& get() { return *this; }
    inline const VkSurfaceFormatKHR& get() const { return *this; }
};

// DisplayPropertiesKHR is a structure used only as a return type so only getters are defined
struct DisplayPropertiesKHR : private VkDisplayPropertiesKHR
{
    DisplayPropertiesKHR() { }
    DisplayPropertiesKHR(const VkDisplayPropertiesKHR& vkType): VkDisplayPropertiesKHR(vkType) { }
    inline const VkDisplayKHR& getDisplay() const { return display; }
    inline const char* getDisplayName() const { return displayName; }
    inline const Extent2D& getPhysicalDimensions() const { return (Extent2D&)physicalDimensions; }
    inline const Extent2D& getPhysicalResolution() const { return (Extent2D&)physicalResolution; }
    inline SurfaceTransformFlagsKHR getSupportedTransforms() const { return (SurfaceTransformFlagsKHR&)supportedTransforms; }
    inline VkBool32 getPlaneReorderPossible() const { return planeReorderPossible; }
    inline VkBool32 getPersistentContent() const { return persistentContent; }
    inline VkDisplayPropertiesKHR& get() { return *this; }
    inline const VkDisplayPropertiesKHR& get() const { return *this; }
};

struct DisplayModeParametersKHR : private VkDisplayModeParametersKHR
{
    DisplayModeParametersKHR()
    {
        setVisibleRegion(Extent2D());
        setRefreshRate(uint32_t());
    }
    DisplayModeParametersKHR(const VkDisplayModeParametersKHR& vkType): VkDisplayModeParametersKHR(vkType) { }
    DisplayModeParametersKHR(const Extent2D& visibleRegion, uint32_t refreshRate)
    {
        setVisibleRegion(visibleRegion);
        setRefreshRate(refreshRate);
    }
    inline const Extent2D& getVisibleRegion() const { return (Extent2D&)visibleRegion; }
    inline void setVisibleRegion(const Extent2D& visibleRegion) { memcpy(&this->visibleRegion, &visibleRegion, sizeof(this->visibleRegion)); }
    inline uint32_t getRefreshRate() const { return refreshRate; }
    inline void setRefreshRate(uint32_t refreshRate) { this->refreshRate = refreshRate; }
    inline VkDisplayModeParametersKHR& get() { return *this; }
    inline const VkDisplayModeParametersKHR& get() const { return *this; }
};

// DisplayModePropertiesKHR is a structure used only as a return type so only getters are defined
struct DisplayModePropertiesKHR : private VkDisplayModePropertiesKHR
{
    DisplayModePropertiesKHR() { }
    DisplayModePropertiesKHR(const VkDisplayModePropertiesKHR& vkType): VkDisplayModePropertiesKHR(vkType) { }
    inline const VkDisplayModeKHR& getDisplayMode() const { return displayMode; }
    inline const DisplayModeParametersKHR& getParameters() const { return (DisplayModeParametersKHR&)parameters; }
    inline VkDisplayModePropertiesKHR& get() { return *this; }
    inline const VkDisplayModePropertiesKHR& get() const { return *this; }
};

// DisplayPlaneCapabilitiesKHR is a structure used only as a return type so only getters are defined
struct DisplayPlaneCapabilitiesKHR : private VkDisplayPlaneCapabilitiesKHR
{
    DisplayPlaneCapabilitiesKHR() { }
    DisplayPlaneCapabilitiesKHR(const VkDisplayPlaneCapabilitiesKHR& vkType): VkDisplayPlaneCapabilitiesKHR(vkType) { }
    inline DisplayPlaneAlphaFlagsKHR getSupportedAlpha() const { return (DisplayPlaneAlphaFlagsKHR&)supportedAlpha; }
    inline const Offset2D& getMinSrcPosition() const { return (Offset2D&)minSrcPosition; }
    inline const Offset2D& getMaxSrcPosition() const { return (Offset2D&)maxSrcPosition; }
    inline const Extent2D& getMinSrcExtent() const { return (Extent2D&)minSrcExtent; }
    inline const Extent2D& getMaxSrcExtent() const { return (Extent2D&)maxSrcExtent; }
    inline const Offset2D& getMinDstPosition() const { return (Offset2D&)minDstPosition; }
    inline const Offset2D& getMaxDstPosition() const { return (Offset2D&)maxDstPosition; }
    inline const Extent2D& getMinDstExtent() const { return (Extent2D&)minDstExtent; }
    inline const Extent2D& getMaxDstExtent() const { return (Extent2D&)maxDstExtent; }
    inline VkDisplayPlaneCapabilitiesKHR& get() { return *this; }
    inline const VkDisplayPlaneCapabilitiesKHR& get() const { return *this; }
};

// DisplayPlanePropertiesKHR is a structure used only as a return type so only getters are defined
struct DisplayPlanePropertiesKHR : private VkDisplayPlanePropertiesKHR
{
    DisplayPlanePropertiesKHR() { }
    DisplayPlanePropertiesKHR(const VkDisplayPlanePropertiesKHR& vkType): VkDisplayPlanePropertiesKHR(vkType) { }
    inline const VkDisplayKHR& getCurrentDisplay() const { return currentDisplay; }
    inline uint32_t getCurrentStackIndex() const { return currentStackIndex; }
    inline VkDisplayPlanePropertiesKHR& get() { return *this; }
    inline const VkDisplayPlanePropertiesKHR& get() const { return *this; }
};

struct RectLayerKHR : private VkRectLayerKHR
{
    RectLayerKHR()
    {
        setOffset(Offset2D());
        setExtent(Extent2D());
        setLayer(uint32_t());
    }
    RectLayerKHR(const VkRectLayerKHR& vkType): VkRectLayerKHR(vkType) { }
    RectLayerKHR(const Offset2D& offset, const Extent2D& extent, uint32_t layer)
    {
        setOffset(offset);
        setExtent(extent);
        setLayer(layer);
    }
    inline const Offset2D& getOffset() const { return (Offset2D&)offset; }
    inline void setOffset(const Offset2D& offset) { memcpy(&this->offset, &offset, sizeof(this->offset)); }
    inline const Extent2D& getExtent() const { return (Extent2D&)extent; }
    inline void setExtent(const Extent2D& extent) { memcpy(&this->extent, &extent, sizeof(this->extent)); }
    inline uint32_t getLayer() const { return layer; }
    inline void setLayer(uint32_t layer) { this->layer = layer; }
    inline VkRectLayerKHR& get() { return *this; }
    inline const VkRectLayerKHR& get() const { return *this; }
};

struct PresentRegionKHR : private VkPresentRegionKHR
{
    PresentRegionKHR()
    {
        setRectangleCount(uint32_t());
        pRectangles = nullptr;
    }
    PresentRegionKHR(const VkPresentRegionKHR& vkType): VkPresentRegionKHR(vkType) { }
    PresentRegionKHR(uint32_t rectangleCount, RectLayerKHR* pRectangles)
    {
        setRectangleCount(rectangleCount);
        setPRectangles(pRectangles);
    }
    inline uint32_t getRectangleCount() const { return rectangleCount; }
    inline void setRectangleCount(uint32_t rectangleCount) { this->rectangleCount = rectangleCount; }
    inline const RectLayerKHR* getPRectangles() const { return (RectLayerKHR*)pRectangles; }
    inline void setPRectangles(RectLayerKHR* pRectangles) { this->pRectangles = (VkRectLayerKHR*)pRectangles; }
    inline VkPresentRegionKHR& get() { return *this; }
    inline const VkPresentRegionKHR& get() const { return *this; }
};

struct ConformanceVersionKHR : private VkConformanceVersionKHR
{
    ConformanceVersionKHR()
    {
        setMajor(uint8_t());
        setMinor(uint8_t());
        setSubminor(uint8_t());
        setPatch(uint8_t());
    }
    ConformanceVersionKHR(const VkConformanceVersionKHR& vkType): VkConformanceVersionKHR(vkType) { }
    ConformanceVersionKHR(uint8_t major, uint8_t minor, uint8_t subminor, uint8_t patch)
    {
        setMajor(major);
        setMinor(minor);
        setSubminor(subminor);
        setPatch(patch);
    }
    inline uint8_t getMajor() const { return major; }
    inline void setMajor(uint8_t major) { this->major = major; }
    inline uint8_t getMinor() const { return minor; }
    inline void setMinor(uint8_t minor) { this->minor = minor; }
    inline uint8_t getSubminor() const { return subminor; }
    inline void setSubminor(uint8_t subminor) { this->subminor = subminor; }
    inline uint8_t getPatch() const { return patch; }
    inline void setPatch(uint8_t patch) { this->patch = patch; }
    inline VkConformanceVersionKHR& get() { return *this; }
    inline const VkConformanceVersionKHR& get() const { return *this; }
};

// ShaderResourceUsageAMD is a structure used only as a return type so only getters are defined
struct ShaderResourceUsageAMD : private VkShaderResourceUsageAMD
{
    ShaderResourceUsageAMD() { }
    ShaderResourceUsageAMD(const VkShaderResourceUsageAMD& vkType): VkShaderResourceUsageAMD(vkType) { }
    inline uint32_t getNumUsedVgprs() const { return numUsedVgprs; }
    inline uint32_t getNumUsedSgprs() const { return numUsedSgprs; }
    inline uint32_t getLdsSizePerLocalWorkGroup() const { return ldsSizePerLocalWorkGroup; }
    inline size_t getLdsUsageSizeInBytes() const { return ldsUsageSizeInBytes; }
    inline size_t getScratchMemUsageInBytes() const { return scratchMemUsageInBytes; }
    inline VkShaderResourceUsageAMD& get() { return *this; }
    inline const VkShaderResourceUsageAMD& get() const { return *this; }
};

// ShaderStatisticsInfoAMD is a structure used only as a return type so only getters are defined
struct ShaderStatisticsInfoAMD : private VkShaderStatisticsInfoAMD
{
    ShaderStatisticsInfoAMD() { }
    ShaderStatisticsInfoAMD(const VkShaderStatisticsInfoAMD& vkType): VkShaderStatisticsInfoAMD(vkType) { }
    inline ShaderStageFlags getShaderStageMask() const { return (ShaderStageFlags&)shaderStageMask; }
    inline const ShaderResourceUsageAMD& getResourceUsage() const { return (ShaderResourceUsageAMD&)resourceUsage; }
    inline uint32_t getNumPhysicalVgprs() const { return numPhysicalVgprs; }
    inline uint32_t getNumPhysicalSgprs() const { return numPhysicalSgprs; }
    inline uint32_t getNumAvailableVgprs() const { return numAvailableVgprs; }
    inline uint32_t getNumAvailableSgprs() const { return numAvailableSgprs; }
    inline const uint32_t* getComputeWorkGroupSize() const { return computeWorkGroupSize; }
    inline VkShaderStatisticsInfoAMD& get() { return *this; }
    inline const VkShaderStatisticsInfoAMD& get() const { return *this; }
};

// ExternalImageFormatPropertiesNV is a structure used only as a return type so only getters are defined
struct ExternalImageFormatPropertiesNV : private VkExternalImageFormatPropertiesNV
{
    ExternalImageFormatPropertiesNV() { }
    ExternalImageFormatPropertiesNV(const VkExternalImageFormatPropertiesNV& vkType): VkExternalImageFormatPropertiesNV(vkType) { }
    inline const ImageFormatProperties& getImageFormatProperties() const { return (ImageFormatProperties&)imageFormatProperties; }
    inline ExternalMemoryFeatureFlagsNV getExternalMemoryFeatures() const { return (ExternalMemoryFeatureFlagsNV&)externalMemoryFeatures; }
    inline ExternalMemoryHandleTypeFlagsNV getExportFromImportedHandleTypes() const { return (ExternalMemoryHandleTypeFlagsNV&)exportFromImportedHandleTypes; }
    inline ExternalMemoryHandleTypeFlagsNV getCompatibleHandleTypes() const { return (ExternalMemoryHandleTypeFlagsNV&)compatibleHandleTypes; }
    inline VkExternalImageFormatPropertiesNV& get() { return *this; }
    inline const VkExternalImageFormatPropertiesNV& get() const { return *this; }
};

struct IndirectCommandsTokenNVX : private VkIndirectCommandsTokenNVX
{
    IndirectCommandsTokenNVX()
    {
        setTokenType(IndirectCommandsTokenTypeNVX());
        setBuffer(VkBuffer());
        setOffset(VkDeviceSize());
    }
    IndirectCommandsTokenNVX(const VkIndirectCommandsTokenNVX& vkType): VkIndirectCommandsTokenNVX(vkType) { }
    IndirectCommandsTokenNVX(IndirectCommandsTokenTypeNVX tokenType, const VkBuffer& buffer, VkDeviceSize offset)
    {
        setTokenType(tokenType);
        setBuffer(buffer);
        setOffset(offset);
    }
    inline IndirectCommandsTokenTypeNVX getTokenType() const { return (IndirectCommandsTokenTypeNVX&)tokenType; }
    inline void setTokenType(IndirectCommandsTokenTypeNVX tokenType) { this->tokenType = (VkIndirectCommandsTokenTypeNVX)tokenType; }
    inline const VkBuffer& getBuffer() const { return buffer; }
    inline void setBuffer(const VkBuffer& buffer) { this->buffer = buffer; }
    inline VkDeviceSize getOffset() const { return offset; }
    inline void setOffset(VkDeviceSize offset) { this->offset = offset; }
    inline VkIndirectCommandsTokenNVX& get() { return *this; }
    inline const VkIndirectCommandsTokenNVX& get() const { return *this; }
};

struct IndirectCommandsLayoutTokenNVX : private VkIndirectCommandsLayoutTokenNVX
{
    IndirectCommandsLayoutTokenNVX()
    {
        setTokenType(IndirectCommandsTokenTypeNVX());
        setBindingUnit(uint32_t());
        setDynamicCount(uint32_t());
        setDivisor(uint32_t());
    }
    IndirectCommandsLayoutTokenNVX(const VkIndirectCommandsLayoutTokenNVX& vkType): VkIndirectCommandsLayoutTokenNVX(vkType) { }
    IndirectCommandsLayoutTokenNVX(IndirectCommandsTokenTypeNVX tokenType, uint32_t bindingUnit, uint32_t dynamicCount, uint32_t divisor)
    {
        setTokenType(tokenType);
        setBindingUnit(bindingUnit);
        setDynamicCount(dynamicCount);
        setDivisor(divisor);
    }
    inline IndirectCommandsTokenTypeNVX getTokenType() const { return (IndirectCommandsTokenTypeNVX&)tokenType; }
    inline void setTokenType(IndirectCommandsTokenTypeNVX tokenType) { this->tokenType = (VkIndirectCommandsTokenTypeNVX)tokenType; }
    inline uint32_t getBindingUnit() const { return bindingUnit; }
    inline void setBindingUnit(uint32_t bindingUnit) { this->bindingUnit = bindingUnit; }
    inline uint32_t getDynamicCount() const { return dynamicCount; }
    inline void setDynamicCount(uint32_t dynamicCount) { this->dynamicCount = dynamicCount; }
    inline uint32_t getDivisor() const { return divisor; }
    inline void setDivisor(uint32_t divisor) { this->divisor = divisor; }
    inline VkIndirectCommandsLayoutTokenNVX& get() { return *this; }
    inline const VkIndirectCommandsLayoutTokenNVX& get() const { return *this; }
};

struct ObjectTableEntryNVX : private VkObjectTableEntryNVX
{
    ObjectTableEntryNVX()
    {
        setType(ObjectEntryTypeNVX());
        setFlags(ObjectEntryUsageFlagsNVX());
    }
    ObjectTableEntryNVX(const VkObjectTableEntryNVX& vkType): VkObjectTableEntryNVX(vkType) { }
    ObjectTableEntryNVX(ObjectEntryTypeNVX type, ObjectEntryUsageFlagsNVX flags)
    {
        setType(type);
        setFlags(flags);
    }
    inline ObjectEntryTypeNVX getType() const { return (ObjectEntryTypeNVX&)type; }
    inline void setType(ObjectEntryTypeNVX type) { this->type = (VkObjectEntryTypeNVX)type; }
    inline ObjectEntryUsageFlagsNVX getFlags() const { return (ObjectEntryUsageFlagsNVX&)flags; }
    inline void setFlags(ObjectEntryUsageFlagsNVX flags) { this->flags = (VkObjectEntryUsageFlagsNVX)flags; }
    inline VkObjectTableEntryNVX& get() { return *this; }
    inline const VkObjectTableEntryNVX& get() const { return *this; }
};

struct ObjectTablePipelineEntryNVX : private VkObjectTablePipelineEntryNVX
{
    ObjectTablePipelineEntryNVX()
    {
        setType(ObjectEntryTypeNVX());
        setFlags(ObjectEntryUsageFlagsNVX());
        setPipeline(VkPipeline());
    }
    ObjectTablePipelineEntryNVX(const VkObjectTablePipelineEntryNVX& vkType): VkObjectTablePipelineEntryNVX(vkType) { }
    ObjectTablePipelineEntryNVX(ObjectEntryTypeNVX type, ObjectEntryUsageFlagsNVX flags, const VkPipeline& pipeline)
    {
        setType(type);
        setFlags(flags);
        setPipeline(pipeline);
    }
    inline ObjectEntryTypeNVX getType() const { return (ObjectEntryTypeNVX&)type; }
    inline void setType(ObjectEntryTypeNVX type) { this->type = (VkObjectEntryTypeNVX)type; }
    inline ObjectEntryUsageFlagsNVX getFlags() const { return (ObjectEntryUsageFlagsNVX&)flags; }
    inline void setFlags(ObjectEntryUsageFlagsNVX flags) { this->flags = (VkObjectEntryUsageFlagsNVX)flags; }
    inline const VkPipeline& getPipeline() const { return pipeline; }
    inline void setPipeline(const VkPipeline& pipeline) { this->pipeline = pipeline; }
    inline VkObjectTablePipelineEntryNVX& get() { return *this; }
    inline const VkObjectTablePipelineEntryNVX& get() const { return *this; }
};

struct ObjectTableDescriptorSetEntryNVX : private VkObjectTableDescriptorSetEntryNVX
{
    ObjectTableDescriptorSetEntryNVX()
    {
        setType(ObjectEntryTypeNVX());
        setFlags(ObjectEntryUsageFlagsNVX());
        setPipelineLayout(VkPipelineLayout());
        setDescriptorSet(VkDescriptorSet());
    }
    ObjectTableDescriptorSetEntryNVX(const VkObjectTableDescriptorSetEntryNVX& vkType): VkObjectTableDescriptorSetEntryNVX(vkType) { }
    ObjectTableDescriptorSetEntryNVX(ObjectEntryTypeNVX type, ObjectEntryUsageFlagsNVX flags, const VkPipelineLayout& pipelineLayout, const VkDescriptorSet& descriptorSet)
    {
        setType(type);
        setFlags(flags);
        setPipelineLayout(pipelineLayout);
        setDescriptorSet(descriptorSet);
    }
    inline ObjectEntryTypeNVX getType() const { return (ObjectEntryTypeNVX&)type; }
    inline void setType(ObjectEntryTypeNVX type) { this->type = (VkObjectEntryTypeNVX)type; }
    inline ObjectEntryUsageFlagsNVX getFlags() const { return (ObjectEntryUsageFlagsNVX&)flags; }
    inline void setFlags(ObjectEntryUsageFlagsNVX flags) { this->flags = (VkObjectEntryUsageFlagsNVX)flags; }
    inline const VkPipelineLayout& getPipelineLayout() const { return pipelineLayout; }
    inline void setPipelineLayout(const VkPipelineLayout& pipelineLayout) { this->pipelineLayout = pipelineLayout; }
    inline const VkDescriptorSet& getDescriptorSet() const { return descriptorSet; }
    inline void setDescriptorSet(const VkDescriptorSet& descriptorSet) { this->descriptorSet = descriptorSet; }
    inline VkObjectTableDescriptorSetEntryNVX& get() { return *this; }
    inline const VkObjectTableDescriptorSetEntryNVX& get() const { return *this; }
};

struct ObjectTableVertexBufferEntryNVX : private VkObjectTableVertexBufferEntryNVX
{
    ObjectTableVertexBufferEntryNVX()
    {
        setType(ObjectEntryTypeNVX());
        setFlags(ObjectEntryUsageFlagsNVX());
        setBuffer(VkBuffer());
    }
    ObjectTableVertexBufferEntryNVX(const VkObjectTableVertexBufferEntryNVX& vkType): VkObjectTableVertexBufferEntryNVX(vkType) { }
    ObjectTableVertexBufferEntryNVX(ObjectEntryTypeNVX type, ObjectEntryUsageFlagsNVX flags, const VkBuffer& buffer)
    {
        setType(type);
        setFlags(flags);
        setBuffer(buffer);
    }
    inline ObjectEntryTypeNVX getType() const { return (ObjectEntryTypeNVX&)type; }
    inline void setType(ObjectEntryTypeNVX type) { this->type = (VkObjectEntryTypeNVX)type; }
    inline ObjectEntryUsageFlagsNVX getFlags() const { return (ObjectEntryUsageFlagsNVX&)flags; }
    inline void setFlags(ObjectEntryUsageFlagsNVX flags) { this->flags = (VkObjectEntryUsageFlagsNVX)flags; }
    inline const VkBuffer& getBuffer() const { return buffer; }
    inline void setBuffer(const VkBuffer& buffer) { this->buffer = buffer; }
    inline VkObjectTableVertexBufferEntryNVX& get() { return *this; }
    inline const VkObjectTableVertexBufferEntryNVX& get() const { return *this; }
};

struct ObjectTableIndexBufferEntryNVX : private VkObjectTableIndexBufferEntryNVX
{
    ObjectTableIndexBufferEntryNVX()
    {
        setType(ObjectEntryTypeNVX());
        setFlags(ObjectEntryUsageFlagsNVX());
        setBuffer(VkBuffer());
        setIndexType(IndexType());
    }
    ObjectTableIndexBufferEntryNVX(const VkObjectTableIndexBufferEntryNVX& vkType): VkObjectTableIndexBufferEntryNVX(vkType) { }
    ObjectTableIndexBufferEntryNVX(ObjectEntryTypeNVX type, ObjectEntryUsageFlagsNVX flags, const VkBuffer& buffer, IndexType indexType)
    {
        setType(type);
        setFlags(flags);
        setBuffer(buffer);
        setIndexType(indexType);
    }
    inline ObjectEntryTypeNVX getType() const { return (ObjectEntryTypeNVX&)type; }
    inline void setType(ObjectEntryTypeNVX type) { this->type = (VkObjectEntryTypeNVX)type; }
    inline ObjectEntryUsageFlagsNVX getFlags() const { return (ObjectEntryUsageFlagsNVX&)flags; }
    inline void setFlags(ObjectEntryUsageFlagsNVX flags) { this->flags = (VkObjectEntryUsageFlagsNVX)flags; }
    inline const VkBuffer& getBuffer() const { return buffer; }
    inline void setBuffer(const VkBuffer& buffer) { this->buffer = buffer; }
    inline IndexType getIndexType() const { return (IndexType&)indexType; }
    inline void setIndexType(IndexType indexType) { this->indexType = (VkIndexType)indexType; }
    inline VkObjectTableIndexBufferEntryNVX& get() { return *this; }
    inline const VkObjectTableIndexBufferEntryNVX& get() const { return *this; }
};

struct ObjectTablePushConstantEntryNVX : private VkObjectTablePushConstantEntryNVX
{
    ObjectTablePushConstantEntryNVX()
    {
        setType(ObjectEntryTypeNVX());
        setFlags(ObjectEntryUsageFlagsNVX());
        setPipelineLayout(VkPipelineLayout());
        setStageFlags(ShaderStageFlags());
    }
    ObjectTablePushConstantEntryNVX(const VkObjectTablePushConstantEntryNVX& vkType): VkObjectTablePushConstantEntryNVX(vkType) { }
    ObjectTablePushConstantEntryNVX(ObjectEntryTypeNVX type, ObjectEntryUsageFlagsNVX flags, const VkPipelineLayout& pipelineLayout, ShaderStageFlags stageFlags)
    {
        setType(type);
        setFlags(flags);
        setPipelineLayout(pipelineLayout);
        setStageFlags(stageFlags);
    }
    inline ObjectEntryTypeNVX getType() const { return (ObjectEntryTypeNVX&)type; }
    inline void setType(ObjectEntryTypeNVX type) { this->type = (VkObjectEntryTypeNVX)type; }
    inline ObjectEntryUsageFlagsNVX getFlags() const { return (ObjectEntryUsageFlagsNVX&)flags; }
    inline void setFlags(ObjectEntryUsageFlagsNVX flags) { this->flags = (VkObjectEntryUsageFlagsNVX)flags; }
    inline const VkPipelineLayout& getPipelineLayout() const { return pipelineLayout; }
    inline void setPipelineLayout(const VkPipelineLayout& pipelineLayout) { this->pipelineLayout = pipelineLayout; }
    inline ShaderStageFlags getStageFlags() const { return (ShaderStageFlags&)stageFlags; }
    inline void setStageFlags(ShaderStageFlags stageFlags) { this->stageFlags = (VkShaderStageFlags)stageFlags; }
    inline VkObjectTablePushConstantEntryNVX& get() { return *this; }
    inline const VkObjectTablePushConstantEntryNVX& get() const { return *this; }
};

struct ViewportWScalingNV : private VkViewportWScalingNV
{
    ViewportWScalingNV()
    {
        setXcoeff(float());
        setYcoeff(float());
    }
    ViewportWScalingNV(const VkViewportWScalingNV& vkType): VkViewportWScalingNV(vkType) { }
    ViewportWScalingNV(float xcoeff, float ycoeff)
    {
        setXcoeff(xcoeff);
        setYcoeff(ycoeff);
    }
    inline float getXcoeff() const { return xcoeff; }
    inline void setXcoeff(float xcoeff) { this->xcoeff = xcoeff; }
    inline float getYcoeff() const { return ycoeff; }
    inline void setYcoeff(float ycoeff) { this->ycoeff = ycoeff; }
    inline VkViewportWScalingNV& get() { return *this; }
    inline const VkViewportWScalingNV& get() const { return *this; }
};

// RefreshCycleDurationGOOGLE is a structure used only as a return type so only getters are defined
struct RefreshCycleDurationGOOGLE : private VkRefreshCycleDurationGOOGLE
{
    RefreshCycleDurationGOOGLE() { }
    RefreshCycleDurationGOOGLE(const VkRefreshCycleDurationGOOGLE& vkType): VkRefreshCycleDurationGOOGLE(vkType) { }
    inline uint64_t getRefreshDuration() const { return refreshDuration; }
    inline VkRefreshCycleDurationGOOGLE& get() { return *this; }
    inline const VkRefreshCycleDurationGOOGLE& get() const { return *this; }
};

// PastPresentationTimingGOOGLE is a structure used only as a return type so only getters are defined
struct PastPresentationTimingGOOGLE : private VkPastPresentationTimingGOOGLE
{
    PastPresentationTimingGOOGLE() { }
    PastPresentationTimingGOOGLE(const VkPastPresentationTimingGOOGLE& vkType): VkPastPresentationTimingGOOGLE(vkType) { }
    inline uint32_t getPresentID() const { return presentID; }
    inline uint64_t getDesiredPresentTime() const { return desiredPresentTime; }
    inline uint64_t getActualPresentTime() const { return actualPresentTime; }
    inline uint64_t getEarliestPresentTime() const { return earliestPresentTime; }
    inline uint64_t getPresentMargin() const { return presentMargin; }
    inline VkPastPresentationTimingGOOGLE& get() { return *this; }
    inline const VkPastPresentationTimingGOOGLE& get() const { return *this; }
};

struct PresentTimeGOOGLE : private VkPresentTimeGOOGLE
{
    PresentTimeGOOGLE()
    {
        setPresentID(uint32_t());
        setDesiredPresentTime(uint64_t());
    }
    PresentTimeGOOGLE(const VkPresentTimeGOOGLE& vkType): VkPresentTimeGOOGLE(vkType) { }
    PresentTimeGOOGLE(uint32_t presentID, uint64_t desiredPresentTime)
    {
        setPresentID(presentID);
        setDesiredPresentTime(desiredPresentTime);
    }
    inline uint32_t getPresentID() const { return presentID; }
    inline void setPresentID(uint32_t presentID) { this->presentID = presentID; }
    inline uint64_t getDesiredPresentTime() const { return desiredPresentTime; }
    inline void setDesiredPresentTime(uint64_t desiredPresentTime) { this->desiredPresentTime = desiredPresentTime; }
    inline VkPresentTimeGOOGLE& get() { return *this; }
    inline const VkPresentTimeGOOGLE& get() const { return *this; }
};

struct ViewportSwizzleNV : private VkViewportSwizzleNV
{
    ViewportSwizzleNV()
    {
        setX(ViewportCoordinateSwizzleNV());
        setY(ViewportCoordinateSwizzleNV());
        setZ(ViewportCoordinateSwizzleNV());
        setW(ViewportCoordinateSwizzleNV());
    }
    ViewportSwizzleNV(const VkViewportSwizzleNV& vkType): VkViewportSwizzleNV(vkType) { }
    ViewportSwizzleNV(ViewportCoordinateSwizzleNV x, ViewportCoordinateSwizzleNV y, ViewportCoordinateSwizzleNV z, ViewportCoordinateSwizzleNV w)
    {
        setX(x);
        setY(y);
        setZ(z);
        setW(w);
    }
    inline ViewportCoordinateSwizzleNV getX() const { return (ViewportCoordinateSwizzleNV&)x; }
    inline void setX(ViewportCoordinateSwizzleNV x) { this->x = (VkViewportCoordinateSwizzleNV)x; }
    inline ViewportCoordinateSwizzleNV getY() const { return (ViewportCoordinateSwizzleNV&)y; }
    inline void setY(ViewportCoordinateSwizzleNV y) { this->y = (VkViewportCoordinateSwizzleNV)y; }
    inline ViewportCoordinateSwizzleNV getZ() const { return (ViewportCoordinateSwizzleNV&)z; }
    inline void setZ(ViewportCoordinateSwizzleNV z) { this->z = (VkViewportCoordinateSwizzleNV)z; }
    inline ViewportCoordinateSwizzleNV getW() const { return (ViewportCoordinateSwizzleNV&)w; }
    inline void setW(ViewportCoordinateSwizzleNV w) { this->w = (VkViewportCoordinateSwizzleNV)w; }
    inline VkViewportSwizzleNV& get() { return *this; }
    inline const VkViewportSwizzleNV& get() const { return *this; }
};

struct XYColorEXT : private VkXYColorEXT
{
    XYColorEXT()
    {
        setX(float());
        setY(float());
    }
    XYColorEXT(const VkXYColorEXT& vkType): VkXYColorEXT(vkType) { }
    XYColorEXT(float x, float y)
    {
        setX(x);
        setY(y);
    }
    inline float getX() const { return x; }
    inline void setX(float x) { this->x = x; }
    inline float getY() const { return y; }
    inline void setY(float y) { this->y = y; }
    inline VkXYColorEXT& get() { return *this; }
    inline const VkXYColorEXT& get() const { return *this; }
};

struct SampleLocationEXT : private VkSampleLocationEXT
{
    SampleLocationEXT()
    {
        setX(float());
        setY(float());
    }
    SampleLocationEXT(const VkSampleLocationEXT& vkType): VkSampleLocationEXT(vkType) { }
    SampleLocationEXT(float x, float y)
    {
        setX(x);
        setY(y);
    }
    inline float getX() const { return x; }
    inline void setX(float x) { this->x = x; }
    inline float getY() const { return y; }
    inline void setY(float y) { this->y = y; }
    inline VkSampleLocationEXT& get() { return *this; }
    inline const VkSampleLocationEXT& get() const { return *this; }
};

struct AttachmentSampleLocationsEXT : private VkAttachmentSampleLocationsEXT
{
    AttachmentSampleLocationsEXT()
    {
        setAttachmentIndex(uint32_t());
        setSampleLocationsInfo(VkSampleLocationsInfoEXT());
    }
    AttachmentSampleLocationsEXT(const VkAttachmentSampleLocationsEXT& vkType): VkAttachmentSampleLocationsEXT(vkType) { }
    AttachmentSampleLocationsEXT(uint32_t attachmentIndex, const VkSampleLocationsInfoEXT& sampleLocationsInfo)
    {
        setAttachmentIndex(attachmentIndex);
        setSampleLocationsInfo(sampleLocationsInfo);
    }
    inline uint32_t getAttachmentIndex() const { return attachmentIndex; }
    inline void setAttachmentIndex(uint32_t attachmentIndex) { this->attachmentIndex = attachmentIndex; }
    inline const VkSampleLocationsInfoEXT& getSampleLocationsInfo() const { return sampleLocationsInfo; }
    inline void setSampleLocationsInfo(const VkSampleLocationsInfoEXT& sampleLocationsInfo) { this->sampleLocationsInfo = sampleLocationsInfo; }
    inline VkAttachmentSampleLocationsEXT& get() { return *this; }
    inline const VkAttachmentSampleLocationsEXT& get() const { return *this; }
};

struct SubpassSampleLocationsEXT : private VkSubpassSampleLocationsEXT
{
    SubpassSampleLocationsEXT()
    {
        setSubpassIndex(uint32_t());
        setSampleLocationsInfo(VkSampleLocationsInfoEXT());
    }
    SubpassSampleLocationsEXT(const VkSubpassSampleLocationsEXT& vkType): VkSubpassSampleLocationsEXT(vkType) { }
    SubpassSampleLocationsEXT(uint32_t subpassIndex, const VkSampleLocationsInfoEXT& sampleLocationsInfo)
    {
        setSubpassIndex(subpassIndex);
        setSampleLocationsInfo(sampleLocationsInfo);
    }
    inline uint32_t getSubpassIndex() const { return subpassIndex; }
    inline void setSubpassIndex(uint32_t subpassIndex) { this->subpassIndex = subpassIndex; }
    inline const VkSampleLocationsInfoEXT& getSampleLocationsInfo() const { return sampleLocationsInfo; }
    inline void setSampleLocationsInfo(const VkSampleLocationsInfoEXT& sampleLocationsInfo) { this->sampleLocationsInfo = sampleLocationsInfo; }
    inline VkSubpassSampleLocationsEXT& get() { return *this; }
    inline const VkSubpassSampleLocationsEXT& get() const { return *this; }
};

// DrmFormatModifierPropertiesEXT is a structure used only as a return type so only getters are defined
struct DrmFormatModifierPropertiesEXT : private VkDrmFormatModifierPropertiesEXT
{
    DrmFormatModifierPropertiesEXT() { }
    DrmFormatModifierPropertiesEXT(const VkDrmFormatModifierPropertiesEXT& vkType): VkDrmFormatModifierPropertiesEXT(vkType) { }
    inline uint64_t getDrmFormatModifier() const { return drmFormatModifier; }
    inline uint32_t getDrmFormatModifierPlaneCount() const { return drmFormatModifierPlaneCount; }
    inline FormatFeatureFlags getDrmFormatModifierTilingFeatures() const { return (FormatFeatureFlags&)drmFormatModifierTilingFeatures; }
    inline VkDrmFormatModifierPropertiesEXT& get() { return *this; }
    inline const VkDrmFormatModifierPropertiesEXT& get() const { return *this; }
};

struct ShadingRatePaletteNV : private VkShadingRatePaletteNV
{
    ShadingRatePaletteNV()
    {
        setShadingRatePaletteEntryCount(uint32_t());
        pShadingRatePaletteEntries = nullptr;
    }
    ShadingRatePaletteNV(const VkShadingRatePaletteNV& vkType): VkShadingRatePaletteNV(vkType) { }
    ShadingRatePaletteNV(uint32_t shadingRatePaletteEntryCount, ShadingRatePaletteEntryNV* pShadingRatePaletteEntries)
    {
        setShadingRatePaletteEntryCount(shadingRatePaletteEntryCount);
        setPShadingRatePaletteEntries(pShadingRatePaletteEntries);
    }
    inline uint32_t getShadingRatePaletteEntryCount() const { return shadingRatePaletteEntryCount; }
    inline void setShadingRatePaletteEntryCount(uint32_t shadingRatePaletteEntryCount) { this->shadingRatePaletteEntryCount = shadingRatePaletteEntryCount; }
    inline const ShadingRatePaletteEntryNV* getPShadingRatePaletteEntries() const { return (ShadingRatePaletteEntryNV*)pShadingRatePaletteEntries; }
    inline void setPShadingRatePaletteEntries(ShadingRatePaletteEntryNV* pShadingRatePaletteEntries) { this->pShadingRatePaletteEntries = (VkShadingRatePaletteEntryNV*)pShadingRatePaletteEntries; }
    inline VkShadingRatePaletteNV& get() { return *this; }
    inline const VkShadingRatePaletteNV& get() const { return *this; }
};

struct CoarseSampleLocationNV : private VkCoarseSampleLocationNV
{
    CoarseSampleLocationNV()
    {
        setPixelX(uint32_t());
        setPixelY(uint32_t());
        setSample(uint32_t());
    }
    CoarseSampleLocationNV(const VkCoarseSampleLocationNV& vkType): VkCoarseSampleLocationNV(vkType) { }
    CoarseSampleLocationNV(uint32_t pixelX, uint32_t pixelY, uint32_t sample)
    {
        setPixelX(pixelX);
        setPixelY(pixelY);
        setSample(sample);
    }
    inline uint32_t getPixelX() const { return pixelX; }
    inline void setPixelX(uint32_t pixelX) { this->pixelX = pixelX; }
    inline uint32_t getPixelY() const { return pixelY; }
    inline void setPixelY(uint32_t pixelY) { this->pixelY = pixelY; }
    inline uint32_t getSample() const { return sample; }
    inline void setSample(uint32_t sample) { this->sample = sample; }
    inline VkCoarseSampleLocationNV& get() { return *this; }
    inline const VkCoarseSampleLocationNV& get() const { return *this; }
};

struct CoarseSampleOrderCustomNV : private VkCoarseSampleOrderCustomNV
{
    CoarseSampleOrderCustomNV()
    {
        setShadingRate(ShadingRatePaletteEntryNV());
        setSampleCount(uint32_t());
        setSampleLocationCount(uint32_t());
        pSampleLocations = nullptr;
    }
    CoarseSampleOrderCustomNV(const VkCoarseSampleOrderCustomNV& vkType): VkCoarseSampleOrderCustomNV(vkType) { }
    CoarseSampleOrderCustomNV(ShadingRatePaletteEntryNV shadingRate, uint32_t sampleCount, uint32_t sampleLocationCount, CoarseSampleLocationNV* pSampleLocations)
    {
        setShadingRate(shadingRate);
        setSampleCount(sampleCount);
        setSampleLocationCount(sampleLocationCount);
        setPSampleLocations(pSampleLocations);
    }
    inline ShadingRatePaletteEntryNV getShadingRate() const { return (ShadingRatePaletteEntryNV&)shadingRate; }
    inline void setShadingRate(ShadingRatePaletteEntryNV shadingRate) { this->shadingRate = (VkShadingRatePaletteEntryNV)shadingRate; }
    inline uint32_t getSampleCount() const { return sampleCount; }
    inline void setSampleCount(uint32_t sampleCount) { this->sampleCount = sampleCount; }
    inline uint32_t getSampleLocationCount() const { return sampleLocationCount; }
    inline void setSampleLocationCount(uint32_t sampleLocationCount) { this->sampleLocationCount = sampleLocationCount; }
    inline const CoarseSampleLocationNV* getPSampleLocations() const { return (CoarseSampleLocationNV*)pSampleLocations; }
    inline void setPSampleLocations(CoarseSampleLocationNV* pSampleLocations) { this->pSampleLocations = (VkCoarseSampleLocationNV*)pSampleLocations; }
    inline VkCoarseSampleOrderCustomNV& get() { return *this; }
    inline const VkCoarseSampleOrderCustomNV& get() const { return *this; }
};

struct GeometryDataNV : private VkGeometryDataNV
{
    GeometryDataNV()
    {
        setTriangles(VkGeometryTrianglesNV());
        setAabbs(VkGeometryAABBNV());
    }
    GeometryDataNV(const VkGeometryDataNV& vkType): VkGeometryDataNV(vkType) { }
    GeometryDataNV(const VkGeometryTrianglesNV& triangles, const VkGeometryAABBNV& aabbs)
    {
        setTriangles(triangles);
        setAabbs(aabbs);
    }
    inline const VkGeometryTrianglesNV& getTriangles() const { return triangles; }
    inline void setTriangles(const VkGeometryTrianglesNV& triangles) { this->triangles = triangles; }
    inline const VkGeometryAABBNV& getAabbs() const { return aabbs; }
    inline void setAabbs(const VkGeometryAABBNV& aabbs) { this->aabbs = aabbs; }
    inline VkGeometryDataNV& get() { return *this; }
    inline const VkGeometryDataNV& get() const { return *this; }
};

struct VertexInputBindingDivisorDescriptionEXT : private VkVertexInputBindingDivisorDescriptionEXT
{
    VertexInputBindingDivisorDescriptionEXT()
    {
        setBinding(uint32_t());
        setDivisor(uint32_t());
    }
    VertexInputBindingDivisorDescriptionEXT(const VkVertexInputBindingDivisorDescriptionEXT& vkType): VkVertexInputBindingDivisorDescriptionEXT(vkType) { }
    VertexInputBindingDivisorDescriptionEXT(uint32_t binding, uint32_t divisor)
    {
        setBinding(binding);
        setDivisor(divisor);
    }
    inline uint32_t getBinding() const { return binding; }
    inline void setBinding(uint32_t binding) { this->binding = binding; }
    inline uint32_t getDivisor() const { return divisor; }
    inline void setDivisor(uint32_t divisor) { this->divisor = divisor; }
    inline VkVertexInputBindingDivisorDescriptionEXT& get() { return *this; }
    inline const VkVertexInputBindingDivisorDescriptionEXT& get() const { return *this; }
};

struct DrawMeshTasksIndirectCommandNV : private VkDrawMeshTasksIndirectCommandNV
{
    DrawMeshTasksIndirectCommandNV()
    {
        setTaskCount(uint32_t());
        setFirstTask(uint32_t());
    }
    DrawMeshTasksIndirectCommandNV(const VkDrawMeshTasksIndirectCommandNV& vkType): VkDrawMeshTasksIndirectCommandNV(vkType) { }
    DrawMeshTasksIndirectCommandNV(uint32_t taskCount, uint32_t firstTask)
    {
        setTaskCount(taskCount);
        setFirstTask(firstTask);
    }
    inline uint32_t getTaskCount() const { return taskCount; }
    inline void setTaskCount(uint32_t taskCount) { this->taskCount = taskCount; }
    inline uint32_t getFirstTask() const { return firstTask; }
    inline void setFirstTask(uint32_t firstTask) { this->firstTask = firstTask; }
    inline VkDrawMeshTasksIndirectCommandNV& get() { return *this; }
    inline const VkDrawMeshTasksIndirectCommandNV& get() const { return *this; }
};




// PVRVk Errors

namespace impl {

	/// <summary>Checks whether a debugger can be found for the current running process (on Windows and Linux only).
	/// The prescene of a debugger can be used to provide additional helpful functionality for debugging application issues one of which could be to break in the
	/// debugger when an exception is thrown. Being able to have the debugger break on such a thrown exception provides by far the most seamless and constructive environment for
	/// fixing an issue causing the exception to be thrown due to the full state and stack trace being present at the point in which the issue has occurred rather
	/// than relying on error logic handling.</summary>
	/// <returns>True if a debugger can be found for the current running process else False.</returns>
	inline static bool isDebuggerPresent()
	{
		// only check once for whether the debugger is present as this may not be efficient to determine
		static bool isUsingDebugger = false;
		static bool haveCheckedForDebugger = false;
		if (!haveCheckedForDebugger)
		{
#if defined(_MSC_VER)
			if (IsDebuggerPresent())
			{
				isUsingDebugger = true;
			}
#elif defined(__linux__)
			// reference implementation taken from: https://stackoverflow.com/a/24969863
			char buf[1024];

			int status_fd = open("/proc/self/status", O_RDONLY);
			if (status_fd == -1)
			{
				isUsingDebugger = false;
			}
			else
			{
				ssize_t num_read = read(status_fd, buf, sizeof(buf) - 1);
				if (num_read > 0)
				{
					static const char TracerPid[] = "TracerPid:";
					char* tracer_pid;

					buf[num_read] = 0;
					tracer_pid = strstr(buf, TracerPid);
					if (tracer_pid)
					{
						isUsingDebugger = !!atoi(tracer_pid + sizeof(TracerPid) - 1);
					}
				}
			}
#endif
			haveCheckedForDebugger = true;
		}

		return isUsingDebugger;
	}

	/// <summary>If supported on the platform, makes the debugger break at this line. Used for Assertions on Visual Studio</summary>
	inline void debuggerBreak()
	{
		if (isDebuggerPresent())
		{
#if defined(__linux__)
			{
				raise(SIGTRAP);
			}
#elif defined(_MSC_VER)
			__debugbreak();
#endif
		}
	}
}
/// <summary>Convert Vulkan error code to string</summary>
/// <param name="errorCode">Vulkan error</param>
/// <returns>Error string</returns>
inline char const* vkErrorToStr(Result errorCode)
{
    switch (errorCode)
    {
    case Result::e_SUCCESS: return "VK_SUCCESS";
    case Result::e_NOT_READY: return "VK_NOT_READY";
    case Result::e_TIMEOUT: return "VK_TIMEOUT";
    case Result::e_EVENT_SET: return "VK_EVENT_SET";
    case Result::e_EVENT_RESET: return "VK_EVENT_RESET";
    case Result::e_INCOMPLETE: return "VK_INCOMPLETE";
    case Result::e_ERROR_OUT_OF_HOST_MEMORY: return "VK_ERROR_OUT_OF_HOST_MEMORY";
    case Result::e_ERROR_OUT_OF_DEVICE_MEMORY: return "VK_ERROR_OUT_OF_DEVICE_MEMORY";
    case Result::e_ERROR_INITIALIZATION_FAILED: return "VK_ERROR_INITIALIZATION_FAILED";
    case Result::e_ERROR_DEVICE_LOST: return "VK_ERROR_DEVICE_LOST";
    case Result::e_ERROR_MEMORY_MAP_FAILED: return "VK_ERROR_MEMORY_MAP_FAILED";
    case Result::e_ERROR_LAYER_NOT_PRESENT: return "VK_ERROR_LAYER_NOT_PRESENT";
    case Result::e_ERROR_EXTENSION_NOT_PRESENT: return "VK_ERROR_EXTENSION_NOT_PRESENT";
    case Result::e_ERROR_FEATURE_NOT_PRESENT: return "VK_ERROR_FEATURE_NOT_PRESENT";
    case Result::e_ERROR_INCOMPATIBLE_DRIVER: return "VK_ERROR_INCOMPATIBLE_DRIVER";
    case Result::e_ERROR_TOO_MANY_OBJECTS: return "VK_ERROR_TOO_MANY_OBJECTS";
    case Result::e_ERROR_FORMAT_NOT_SUPPORTED: return "VK_ERROR_FORMAT_NOT_SUPPORTED";
    case Result::e_ERROR_FRAGMENTED_POOL: return "VK_ERROR_FRAGMENTED_POOL";
    case Result::e_ERROR_OUT_OF_POOL_MEMORY: return "VK_ERROR_OUT_OF_POOL_MEMORY";
    case Result::e_ERROR_INVALID_EXTERNAL_HANDLE: return "VK_ERROR_INVALID_EXTERNAL_HANDLE";
    case Result::e_ERROR_SURFACE_LOST_KHR: return "VK_ERROR_SURFACE_LOST_KHR";
    case Result::e_ERROR_NATIVE_WINDOW_IN_USE_KHR: return "VK_ERROR_NATIVE_WINDOW_IN_USE_KHR";
    case Result::e_SUBOPTIMAL_KHR: return "VK_SUBOPTIMAL_KHR";
    case Result::e_ERROR_OUT_OF_DATE_KHR: return "VK_ERROR_OUT_OF_DATE_KHR";
    case Result::e_ERROR_INCOMPATIBLE_DISPLAY_KHR: return "VK_ERROR_INCOMPATIBLE_DISPLAY_KHR";
    case Result::e_ERROR_VALIDATION_FAILED_EXT: return "VK_ERROR_VALIDATION_FAILED_EXT";
    case Result::e_ERROR_INVALID_SHADER_NV: return "VK_ERROR_INVALID_SHADER_NV";
    case Result::e_ERROR_INVALID_DRM_FORMAT_MODIFIER_PLANE_LAYOUT_EXT: return "VK_ERROR_INVALID_DRM_FORMAT_MODIFIER_PLANE_LAYOUT_EXT";
    case Result::e_ERROR_FRAGMENTATION_EXT: return "VK_ERROR_FRAGMENTATION_EXT";
    case Result::e_ERROR_NOT_PERMITTED_EXT: return "VK_ERROR_NOT_PERMITTED_EXT";
    default: return ("-- Result::UNKNOWN ERROR CODE--");
        break;
    }
}

class Error : public std::runtime_error
{
protected:
	Result _result;
public:
	virtual ~Error() {}
	Error(Result result, const std::string& errorMessage) :
		runtime_error(std::string("[") + vkErrorToStr(result) + ("] : ") + errorMessage), _result(result)
	{
#ifdef DEBUG
		impl::debuggerBreak();
#endif
	}
	Error(Result result, const char* errorMessage = NULL) :
		runtime_error((std::string("[") + vkErrorToStr(result) + "] : ") + (errorMessage ? errorMessage : "")), _result(result)
	{
#ifdef DEBUG
		impl::debuggerBreak();
#endif
	}
	const char* getErrorMessage() const { return what(); }
	Result getResult() const { return _result; }
	const char* getResultCode() const { return vkErrorToStr(_result); }
};
#define ResultUnknownError Result(-934598375)

class ErrorUnknown : public Error
{
public:
	virtual ~ErrorUnknown() {}
	ErrorUnknown(const char* errorMessage = NULL) : Error(ResultUnknownError, errorMessage) {}
	explicit ErrorUnknown(const std::string& errorMessage) : Error(ResultUnknownError, errorMessage) {}
};
class Success: public Error
{
public:
    virtual ~Success() {}
    Success(const char* errorMessage = NULL) : Error(Result::e_SUCCESS, errorMessage) {}
    explicit Success(const std::string& errorMessage) : Error(Result::e_SUCCESS, errorMessage) {}
};
class NotReady: public Error
{
public:
    virtual ~NotReady() {}
    NotReady(const char* errorMessage = NULL) : Error(Result::e_NOT_READY, errorMessage) {}
    explicit NotReady(const std::string& errorMessage) : Error(Result::e_NOT_READY, errorMessage) {}
};
class Timeout: public Error
{
public:
    virtual ~Timeout() {}
    Timeout(const char* errorMessage = NULL) : Error(Result::e_TIMEOUT, errorMessage) {}
    explicit Timeout(const std::string& errorMessage) : Error(Result::e_TIMEOUT, errorMessage) {}
};
class EventSet: public Error
{
public:
    virtual ~EventSet() {}
    EventSet(const char* errorMessage = NULL) : Error(Result::e_EVENT_SET, errorMessage) {}
    explicit EventSet(const std::string& errorMessage) : Error(Result::e_EVENT_SET, errorMessage) {}
};
class EventReset: public Error
{
public:
    virtual ~EventReset() {}
    EventReset(const char* errorMessage = NULL) : Error(Result::e_EVENT_RESET, errorMessage) {}
    explicit EventReset(const std::string& errorMessage) : Error(Result::e_EVENT_RESET, errorMessage) {}
};
class Incomplete: public Error
{
public:
    virtual ~Incomplete() {}
    Incomplete(const char* errorMessage = NULL) : Error(Result::e_INCOMPLETE, errorMessage) {}
    explicit Incomplete(const std::string& errorMessage) : Error(Result::e_INCOMPLETE, errorMessage) {}
};
class ErrorOutOfHostMemory: public Error
{
public:
    virtual ~ErrorOutOfHostMemory() {}
    ErrorOutOfHostMemory(const char* errorMessage = NULL) : Error(Result::e_ERROR_OUT_OF_HOST_MEMORY, errorMessage) {}
    explicit ErrorOutOfHostMemory(const std::string& errorMessage) : Error(Result::e_ERROR_OUT_OF_HOST_MEMORY, errorMessage) {}
};
class ErrorOutOfDeviceMemory: public Error
{
public:
    virtual ~ErrorOutOfDeviceMemory() {}
    ErrorOutOfDeviceMemory(const char* errorMessage = NULL) : Error(Result::e_ERROR_OUT_OF_DEVICE_MEMORY, errorMessage) {}
    explicit ErrorOutOfDeviceMemory(const std::string& errorMessage) : Error(Result::e_ERROR_OUT_OF_DEVICE_MEMORY, errorMessage) {}
};
class ErrorInitializationFailed: public Error
{
public:
    virtual ~ErrorInitializationFailed() {}
    ErrorInitializationFailed(const char* errorMessage = NULL) : Error(Result::e_ERROR_INITIALIZATION_FAILED, errorMessage) {}
    explicit ErrorInitializationFailed(const std::string& errorMessage) : Error(Result::e_ERROR_INITIALIZATION_FAILED, errorMessage) {}
};
class ErrorDeviceLost: public Error
{
public:
    virtual ~ErrorDeviceLost() {}
    ErrorDeviceLost(const char* errorMessage = NULL) : Error(Result::e_ERROR_DEVICE_LOST, errorMessage) {}
    explicit ErrorDeviceLost(const std::string& errorMessage) : Error(Result::e_ERROR_DEVICE_LOST, errorMessage) {}
};
class ErrorMemoryMapFailed: public Error
{
public:
    virtual ~ErrorMemoryMapFailed() {}
    ErrorMemoryMapFailed(const char* errorMessage = NULL) : Error(Result::e_ERROR_MEMORY_MAP_FAILED, errorMessage) {}
    explicit ErrorMemoryMapFailed(const std::string& errorMessage) : Error(Result::e_ERROR_MEMORY_MAP_FAILED, errorMessage) {}
};
class ErrorLayerNotPresent: public Error
{
public:
    virtual ~ErrorLayerNotPresent() {}
    ErrorLayerNotPresent(const char* errorMessage = NULL) : Error(Result::e_ERROR_LAYER_NOT_PRESENT, errorMessage) {}
    explicit ErrorLayerNotPresent(const std::string& errorMessage) : Error(Result::e_ERROR_LAYER_NOT_PRESENT, errorMessage) {}
};
class ErrorExtensionNotPresent: public Error
{
public:
    virtual ~ErrorExtensionNotPresent() {}
    ErrorExtensionNotPresent(const char* errorMessage = NULL) : Error(Result::e_ERROR_EXTENSION_NOT_PRESENT, errorMessage) {}
    explicit ErrorExtensionNotPresent(const std::string& errorMessage) : Error(Result::e_ERROR_EXTENSION_NOT_PRESENT, errorMessage) {}
};
class ErrorFeatureNotPresent: public Error
{
public:
    virtual ~ErrorFeatureNotPresent() {}
    ErrorFeatureNotPresent(const char* errorMessage = NULL) : Error(Result::e_ERROR_FEATURE_NOT_PRESENT, errorMessage) {}
    explicit ErrorFeatureNotPresent(const std::string& errorMessage) : Error(Result::e_ERROR_FEATURE_NOT_PRESENT, errorMessage) {}
};
class ErrorIncompatibleDriver: public Error
{
public:
    virtual ~ErrorIncompatibleDriver() {}
    ErrorIncompatibleDriver(const char* errorMessage = NULL) : Error(Result::e_ERROR_INCOMPATIBLE_DRIVER, errorMessage) {}
    explicit ErrorIncompatibleDriver(const std::string& errorMessage) : Error(Result::e_ERROR_INCOMPATIBLE_DRIVER, errorMessage) {}
};
class ErrorTooManyObjects: public Error
{
public:
    virtual ~ErrorTooManyObjects() {}
    ErrorTooManyObjects(const char* errorMessage = NULL) : Error(Result::e_ERROR_TOO_MANY_OBJECTS, errorMessage) {}
    explicit ErrorTooManyObjects(const std::string& errorMessage) : Error(Result::e_ERROR_TOO_MANY_OBJECTS, errorMessage) {}
};
class ErrorFormatNotSupported: public Error
{
public:
    virtual ~ErrorFormatNotSupported() {}
    ErrorFormatNotSupported(const char* errorMessage = NULL) : Error(Result::e_ERROR_FORMAT_NOT_SUPPORTED, errorMessage) {}
    explicit ErrorFormatNotSupported(const std::string& errorMessage) : Error(Result::e_ERROR_FORMAT_NOT_SUPPORTED, errorMessage) {}
};
class ErrorFragmentedPool: public Error
{
public:
    virtual ~ErrorFragmentedPool() {}
    ErrorFragmentedPool(const char* errorMessage = NULL) : Error(Result::e_ERROR_FRAGMENTED_POOL, errorMessage) {}
    explicit ErrorFragmentedPool(const std::string& errorMessage) : Error(Result::e_ERROR_FRAGMENTED_POOL, errorMessage) {}
};
class ErrorOutOfPoolMemory: public Error
{
public:
    virtual ~ErrorOutOfPoolMemory() {}
    ErrorOutOfPoolMemory(const char* errorMessage = NULL) : Error(Result::e_ERROR_OUT_OF_POOL_MEMORY, errorMessage) {}
    explicit ErrorOutOfPoolMemory(const std::string& errorMessage) : Error(Result::e_ERROR_OUT_OF_POOL_MEMORY, errorMessage) {}
};
class ErrorInvalidExternalHandle: public Error
{
public:
    virtual ~ErrorInvalidExternalHandle() {}
    ErrorInvalidExternalHandle(const char* errorMessage = NULL) : Error(Result::e_ERROR_INVALID_EXTERNAL_HANDLE, errorMessage) {}
    explicit ErrorInvalidExternalHandle(const std::string& errorMessage) : Error(Result::e_ERROR_INVALID_EXTERNAL_HANDLE, errorMessage) {}
};
class ErrorSurfaceLostKHR: public Error
{
public:
    virtual ~ErrorSurfaceLostKHR() {}
    ErrorSurfaceLostKHR(const char* errorMessage = NULL) : Error(Result::e_ERROR_SURFACE_LOST_KHR, errorMessage) {}
    explicit ErrorSurfaceLostKHR(const std::string& errorMessage) : Error(Result::e_ERROR_SURFACE_LOST_KHR, errorMessage) {}
};
class ErrorNativeWindowInUseKHR: public Error
{
public:
    virtual ~ErrorNativeWindowInUseKHR() {}
    ErrorNativeWindowInUseKHR(const char* errorMessage = NULL) : Error(Result::e_ERROR_NATIVE_WINDOW_IN_USE_KHR, errorMessage) {}
    explicit ErrorNativeWindowInUseKHR(const std::string& errorMessage) : Error(Result::e_ERROR_NATIVE_WINDOW_IN_USE_KHR, errorMessage) {}
};
class SuboptimalKHR: public Error
{
public:
    virtual ~SuboptimalKHR() {}
    SuboptimalKHR(const char* errorMessage = NULL) : Error(Result::e_SUBOPTIMAL_KHR, errorMessage) {}
    explicit SuboptimalKHR(const std::string& errorMessage) : Error(Result::e_SUBOPTIMAL_KHR, errorMessage) {}
};
class ErrorOutOfDateKHR: public Error
{
public:
    virtual ~ErrorOutOfDateKHR() {}
    ErrorOutOfDateKHR(const char* errorMessage = NULL) : Error(Result::e_ERROR_OUT_OF_DATE_KHR, errorMessage) {}
    explicit ErrorOutOfDateKHR(const std::string& errorMessage) : Error(Result::e_ERROR_OUT_OF_DATE_KHR, errorMessage) {}
};
class ErrorIncompatibleDisplayKHR: public Error
{
public:
    virtual ~ErrorIncompatibleDisplayKHR() {}
    ErrorIncompatibleDisplayKHR(const char* errorMessage = NULL) : Error(Result::e_ERROR_INCOMPATIBLE_DISPLAY_KHR, errorMessage) {}
    explicit ErrorIncompatibleDisplayKHR(const std::string& errorMessage) : Error(Result::e_ERROR_INCOMPATIBLE_DISPLAY_KHR, errorMessage) {}
};
class ErrorValidationFailedEXT: public Error
{
public:
    virtual ~ErrorValidationFailedEXT() {}
    ErrorValidationFailedEXT(const char* errorMessage = NULL) : Error(Result::e_ERROR_VALIDATION_FAILED_EXT, errorMessage) {}
    explicit ErrorValidationFailedEXT(const std::string& errorMessage) : Error(Result::e_ERROR_VALIDATION_FAILED_EXT, errorMessage) {}
};
class ErrorInvalidShaderNV: public Error
{
public:
    virtual ~ErrorInvalidShaderNV() {}
    ErrorInvalidShaderNV(const char* errorMessage = NULL) : Error(Result::e_ERROR_INVALID_SHADER_NV, errorMessage) {}
    explicit ErrorInvalidShaderNV(const std::string& errorMessage) : Error(Result::e_ERROR_INVALID_SHADER_NV, errorMessage) {}
};
class ErrorOutOfPoolMemoryKHR: public Error
{
public:
    virtual ~ErrorOutOfPoolMemoryKHR() {}
    ErrorOutOfPoolMemoryKHR(const char* errorMessage = NULL) : Error(Result::e_ERROR_OUT_OF_POOL_MEMORY_KHR, errorMessage) {}
    explicit ErrorOutOfPoolMemoryKHR(const std::string& errorMessage) : Error(Result::e_ERROR_OUT_OF_POOL_MEMORY_KHR, errorMessage) {}
};
class ErrorInvalidExternalHandleKHR: public Error
{
public:
    virtual ~ErrorInvalidExternalHandleKHR() {}
    ErrorInvalidExternalHandleKHR(const char* errorMessage = NULL) : Error(Result::e_ERROR_INVALID_EXTERNAL_HANDLE_KHR, errorMessage) {}
    explicit ErrorInvalidExternalHandleKHR(const std::string& errorMessage) : Error(Result::e_ERROR_INVALID_EXTERNAL_HANDLE_KHR, errorMessage) {}
};
class ErrorInvalidDrmFormatModifierPlaneLayoutEXT: public Error
{
public:
    virtual ~ErrorInvalidDrmFormatModifierPlaneLayoutEXT() {}
    ErrorInvalidDrmFormatModifierPlaneLayoutEXT(const char* errorMessage = NULL) : Error(Result::e_ERROR_INVALID_DRM_FORMAT_MODIFIER_PLANE_LAYOUT_EXT, errorMessage) {}
    explicit ErrorInvalidDrmFormatModifierPlaneLayoutEXT(const std::string& errorMessage) : Error(Result::e_ERROR_INVALID_DRM_FORMAT_MODIFIER_PLANE_LAYOUT_EXT, errorMessage) {}
};
class ErrorFragmentationEXT: public Error
{
public:
    virtual ~ErrorFragmentationEXT() {}
    ErrorFragmentationEXT(const char* errorMessage = NULL) : Error(Result::e_ERROR_FRAGMENTATION_EXT, errorMessage) {}
    explicit ErrorFragmentationEXT(const std::string& errorMessage) : Error(Result::e_ERROR_FRAGMENTATION_EXT, errorMessage) {}
};
class ErrorNotPermittedEXT: public Error
{
public:
    virtual ~ErrorNotPermittedEXT() {}
    ErrorNotPermittedEXT(const char* errorMessage = NULL) : Error(Result::e_ERROR_NOT_PERMITTED_EXT, errorMessage) {}
    explicit ErrorNotPermittedEXT(const std::string& errorMessage) : Error(Result::e_ERROR_NOT_PERMITTED_EXT, errorMessage) {}
};

namespace impl {
/// <summary>Throw a Vulkan exception if the result is not successful.</summary>
/// <param name="result">A vulkan result code</param>
/// <param name="msg">Throw a corresponding exception if the error code is not success</param>
inline void vkThrowIfFailed(Result result, const char* message = 0)
{
    switch (result)
    {
    case Result::e_NOT_READY: throw NotReady(message);
    case Result::e_TIMEOUT: throw Timeout(message);
    case Result::e_EVENT_SET: throw EventSet(message);
    case Result::e_EVENT_RESET: throw EventReset(message);
    case Result::e_INCOMPLETE: throw Incomplete(message);
    case Result::e_SUBOPTIMAL_KHR: throw SuboptimalKHR(message);
    case Result::e_ERROR_OUT_OF_HOST_MEMORY: throw ErrorOutOfHostMemory(message);
    case Result::e_ERROR_OUT_OF_DEVICE_MEMORY: throw ErrorOutOfDeviceMemory(message);
    case Result::e_ERROR_INITIALIZATION_FAILED: throw ErrorInitializationFailed(message);
    case Result::e_ERROR_DEVICE_LOST: throw ErrorDeviceLost(message);
    case Result::e_ERROR_MEMORY_MAP_FAILED: throw ErrorMemoryMapFailed(message);
    case Result::e_ERROR_LAYER_NOT_PRESENT: throw ErrorLayerNotPresent(message);
    case Result::e_ERROR_EXTENSION_NOT_PRESENT: throw ErrorExtensionNotPresent(message);
    case Result::e_ERROR_FEATURE_NOT_PRESENT: throw ErrorFeatureNotPresent(message);
    case Result::e_ERROR_INCOMPATIBLE_DRIVER: throw ErrorIncompatibleDriver(message);
    case Result::e_ERROR_TOO_MANY_OBJECTS: throw ErrorTooManyObjects(message);
    case Result::e_ERROR_FORMAT_NOT_SUPPORTED: throw ErrorFormatNotSupported(message);
    case Result::e_ERROR_FRAGMENTED_POOL: throw ErrorFragmentedPool(message);
    case Result::e_ERROR_OUT_OF_POOL_MEMORY: throw ErrorOutOfPoolMemory(message);
    case Result::e_ERROR_INVALID_EXTERNAL_HANDLE: throw ErrorInvalidExternalHandle(message);
    case Result::e_ERROR_SURFACE_LOST_KHR: throw ErrorSurfaceLostKHR(message);
    case Result::e_ERROR_NATIVE_WINDOW_IN_USE_KHR: throw ErrorNativeWindowInUseKHR(message);
    case Result::e_ERROR_OUT_OF_DATE_KHR: throw ErrorOutOfDateKHR(message);
    case Result::e_ERROR_INCOMPATIBLE_DISPLAY_KHR: throw ErrorIncompatibleDisplayKHR(message);
    case Result::e_ERROR_VALIDATION_FAILED_EXT: throw ErrorValidationFailedEXT(message);
    case Result::e_ERROR_INVALID_SHADER_NV: throw ErrorInvalidShaderNV(message);
    case Result::e_ERROR_INVALID_DRM_FORMAT_MODIFIER_PLANE_LAYOUT_EXT: throw ErrorInvalidDrmFormatModifierPlaneLayoutEXT(message);
    case Result::e_ERROR_FRAGMENTATION_EXT: throw ErrorFragmentationEXT(message);
    case Result::e_ERROR_NOT_PERMITTED_EXT: throw ErrorNotPermittedEXT(message);
    case Result::e_SUCCESS:
        break;
    default: throw ErrorUnknown(message);
    }
}

/// <summary>Throw a Vulkan exception if the result is not successful.</summary>
/// <param name="result">A vulkan result code</param>
/// <param name="msg">Throw a corresponding exception if the error code is not success</param>
inline void vkThrowIfFailed(VkResult result, const char* message = 0)
{
    vkThrowIfFailed(static_cast<pvrvk::Result>(result), message);
}

/// <summary>Throw a Vulkan exception if the result is not successful.</summary>
/// <param name="result">A vulkan result code</param>
/// <param name="msg">Throw a corresponding exception if the error code is an error</param>
inline void vkThrowIfError(Result result, const char* message = 0)
{
    switch (result)
    {
    case Result::e_ERROR_OUT_OF_HOST_MEMORY: throw ErrorOutOfHostMemory(message);
    case Result::e_ERROR_OUT_OF_DEVICE_MEMORY: throw ErrorOutOfDeviceMemory(message);
    case Result::e_ERROR_INITIALIZATION_FAILED: throw ErrorInitializationFailed(message);
    case Result::e_ERROR_DEVICE_LOST: throw ErrorDeviceLost(message);
    case Result::e_ERROR_MEMORY_MAP_FAILED: throw ErrorMemoryMapFailed(message);
    case Result::e_ERROR_LAYER_NOT_PRESENT: throw ErrorLayerNotPresent(message);
    case Result::e_ERROR_EXTENSION_NOT_PRESENT: throw ErrorExtensionNotPresent(message);
    case Result::e_ERROR_FEATURE_NOT_PRESENT: throw ErrorFeatureNotPresent(message);
    case Result::e_ERROR_INCOMPATIBLE_DRIVER: throw ErrorIncompatibleDriver(message);
    case Result::e_ERROR_TOO_MANY_OBJECTS: throw ErrorTooManyObjects(message);
    case Result::e_ERROR_FORMAT_NOT_SUPPORTED: throw ErrorFormatNotSupported(message);
    case Result::e_ERROR_FRAGMENTED_POOL: throw ErrorFragmentedPool(message);
    case Result::e_ERROR_OUT_OF_POOL_MEMORY: throw ErrorOutOfPoolMemory(message);
    case Result::e_ERROR_INVALID_EXTERNAL_HANDLE: throw ErrorInvalidExternalHandle(message);
    case Result::e_ERROR_SURFACE_LOST_KHR: throw ErrorSurfaceLostKHR(message);
    case Result::e_ERROR_NATIVE_WINDOW_IN_USE_KHR: throw ErrorNativeWindowInUseKHR(message);
    case Result::e_ERROR_OUT_OF_DATE_KHR: throw ErrorOutOfDateKHR(message);
    case Result::e_ERROR_INCOMPATIBLE_DISPLAY_KHR: throw ErrorIncompatibleDisplayKHR(message);
    case Result::e_ERROR_VALIDATION_FAILED_EXT: throw ErrorValidationFailedEXT(message);
    case Result::e_ERROR_INVALID_SHADER_NV: throw ErrorInvalidShaderNV(message);
    case Result::e_ERROR_INVALID_DRM_FORMAT_MODIFIER_PLANE_LAYOUT_EXT: throw ErrorInvalidDrmFormatModifierPlaneLayoutEXT(message);
    case Result::e_ERROR_FRAGMENTATION_EXT: throw ErrorFragmentationEXT(message);
    case Result::e_ERROR_NOT_PERMITTED_EXT: throw ErrorNotPermittedEXT(message);
    case Result::e_SUCCESS:
    case Result::e_NOT_READY:
    case Result::e_TIMEOUT:
    case Result::e_EVENT_SET:
    case Result::e_EVENT_RESET:
    case Result::e_INCOMPLETE:
    case Result::e_SUBOPTIMAL_KHR:
        break;
    default: throw ErrorUnknown(message);
    }
}

}// namespace impl


} // namespace pvrvk
// clang-format on
//!\endcond
