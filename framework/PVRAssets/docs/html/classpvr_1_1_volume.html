<!-- HTML header for doxygen 1.8.4-->
<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="generator" content="Doxygen 1.8.6"/>
<title>PVRAssets: pvr::Volume Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="IMGdoxygen.css" rel="stylesheet" type="text/css"/>
<link rel="shortcut icon" href="http://www.imgtec.com/images/img.ico">
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
  <div class="headercontent">
    <div class="PVRlogo">
      <a href="http://www.powervrinsider.com" target="_blank"><img src="PVRlogo.png" width="40%" height="40%"  border="none" /></a>
    </div>
    <a class="SiteTitle"><span id="projectname">PVRAssets</span> Documentation</a>
   <tbody>
  </div>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="inherits.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacepvr.html">pvr</a></li><li class="navelem"><a class="el" href="classpvr_1_1_volume.html">Volume</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="classpvr_1_1_volume-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">pvr::Volume Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Represents data for handling volumes of a single Mesh. 
 <a href="classpvr_1_1_volume.html#details">More...</a></p>
<div class="dynheader">
Inheritance diagram for pvr::Volume:</div>
<div class="dyncontent">
<div class="center"><img src="classpvr_1_1_volume__inherit__graph.png" border="0" usemap="#pvr_1_1_volume_inherit__map" alt="Inheritance graph"/></div>
<map name="pvr_1_1_volume_inherit__map" id="pvr_1_1_volume_inherit__map">
<area shape="rect" id="node2" href="classpvr_1_1_shadow_volume.html" title="Represents data for handling Shadow volumes of a single Mesh." alt="" coords="5,80,144,107"/></map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpvr_1_1_volume_1_1_volume_edge.html">VolumeEdge</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents an edge. <a href="structpvr_1_1_volume_1_1_volume_edge.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpvr_1_1_volume_1_1_volume_mesh.html">VolumeMesh</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Preprocessed data needed to create volumes out of a mesh <a href="structpvr_1_1_volume_1_1_volume_mesh.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpvr_1_1_volume_1_1_volume_triangle.html">VolumeTriangle</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents an face (triangle). <a href="structpvr_1_1_volume_1_1_volume_triangle.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a7429aefda094acec0bdd90d60df77c74"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1_volume.html#a7429aefda094acec0bdd90d60df77c74">~Volume</a> ()</td></tr>
<tr class="memdesc:a7429aefda094acec0bdd90d60df77c74"><td class="mdescLeft">&#160;</td><td class="mdescRight">dtor, releases all resources held by the <a class="el" href="classpvr_1_1_volume.html" title="Represents data for handling volumes of a single Mesh.">Volume</a>. <a href="#a7429aefda094acec0bdd90d60df77c74">More...</a><br/></td></tr>
<tr class="separator:a7429aefda094acec0bdd90d60df77c74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a894e9d0050d4fce44dd9903cc21d9cf3"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1_volume.html#a894e9d0050d4fce44dd9903cc21d9cf3">getIndexDataSize</a> ()</td></tr>
<tr class="memdesc:a894e9d0050d4fce44dd9903cc21d9cf3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the size of the Index data, in bytes. <a href="#a894e9d0050d4fce44dd9903cc21d9cf3">More...</a><br/></td></tr>
<tr class="separator:a894e9d0050d4fce44dd9903cc21d9cf3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13a0ecadd29849f13633e8ef89a4dda2"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1_volume.html#a13a0ecadd29849f13633e8ef89a4dda2">getIndexDataStride</a> ()</td></tr>
<tr class="memdesc:a13a0ecadd29849f13633e8ef89a4dda2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the stride of the Index data, in bytes. Is sizeof(IndexType). <a href="#a13a0ecadd29849f13633e8ef89a4dda2">More...</a><br/></td></tr>
<tr class="separator:a13a0ecadd29849f13633e8ef89a4dda2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1385a976b59da81d71bc27058307c2a0"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1_volume.html#a1385a976b59da81d71bc27058307c2a0">getTriangleCount</a> ()</td></tr>
<tr class="memdesc:a1385a976b59da81d71bc27058307c2a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of triangles in the volume. <a href="#a1385a976b59da81d71bc27058307c2a0">More...</a><br/></td></tr>
<tr class="separator:a1385a976b59da81d71bc27058307c2a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab33e63d9336f382efd92d07195aefcb1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structpvr_1_1_volume_1_1_volume_triangle.html">VolumeTriangle</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1_volume.html#ab33e63d9336f382efd92d07195aefcb1">getTriangleData</a> (uint32_t triangleIndex)</td></tr>
<tr class="memdesc:ab33e63d9336f382efd92d07195aefcb1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the triangle data at a particular index in the volume. <a href="#ab33e63d9336f382efd92d07195aefcb1">More...</a><br/></td></tr>
<tr class="separator:ab33e63d9336f382efd92d07195aefcb1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5dfcd860f12326eacd3f3a7e9e688e4b"><td class="memItemLeft" align="right" valign="top">uint8_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1_volume.html#a5dfcd860f12326eacd3f3a7e9e688e4b">getVertexData</a> ()</td></tr>
<tr class="memdesc:a5dfcd860f12326eacd3f3a7e9e688e4b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a pointer to the raw vertex data. Use to bind vertex buffer. <a href="#a5dfcd860f12326eacd3f3a7e9e688e4b">More...</a><br/></td></tr>
<tr class="separator:a5dfcd860f12326eacd3f3a7e9e688e4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84be15b69591d7d70a5b84e79ce24b90"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1_volume.html#a84be15b69591d7d70a5b84e79ce24b90">getVertexDataExtrudeOffset</a> ()</td></tr>
<tr class="memdesc:a84be15b69591d7d70a5b84e79ce24b90"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the extrude offset. Is 3. <a href="#a84be15b69591d7d70a5b84e79ce24b90">More...</a><br/></td></tr>
<tr class="separator:a84be15b69591d7d70a5b84e79ce24b90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31c5b96f3f6bb0d623e126516765cf6f"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1_volume.html#a31c5b96f3f6bb0d623e126516765cf6f">getVertexDataPositionOffset</a> ()</td></tr>
<tr class="memdesc:a31c5b96f3f6bb0d623e126516765cf6f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the offset of the Position vertex attribute in bytes. Is 0. <a href="#a31c5b96f3f6bb0d623e126516765cf6f">More...</a><br/></td></tr>
<tr class="separator:a31c5b96f3f6bb0d623e126516765cf6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02fd603c4a8f313d1d8948fc5ec36826"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1_volume.html#a02fd603c4a8f313d1d8948fc5ec36826">getVertexDataSize</a> ()</td></tr>
<tr class="memdesc:a02fd603c4a8f313d1d8948fc5ec36826"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the size of the vertex attributes in bytes. Is 2 * numVertices * stride. <a href="#a02fd603c4a8f313d1d8948fc5ec36826">More...</a><br/></td></tr>
<tr class="separator:a02fd603c4a8f313d1d8948fc5ec36826"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c61d7e175a9c9c4bb7158a1fb6aec19"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1_volume.html#a2c61d7e175a9c9c4bb7158a1fb6aec19">getVertexDataStride</a> ()</td></tr>
<tr class="memdesc:a2c61d7e175a9c9c4bb7158a1fb6aec19"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the stride of the vertex attributes, in bytes. Is 3 * 4 + 4 = 16 . <a href="#a2c61d7e175a9c9c4bb7158a1fb6aec19">More...</a><br/></td></tr>
<tr class="separator:a2c61d7e175a9c9c4bb7158a1fb6aec19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a250cbda6ab7de356d04facb0aea93322"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1_volume.html#a250cbda6ab7de356d04facb0aea93322">getVerticesForTriangle</a> (const <a class="el" href="structpvr_1_1_volume_1_1_volume_triangle.html">VolumeTriangle</a> &amp;triangle, glm::vec3 &amp;vertex0, glm::vec3 &amp;vertex1, glm::vec3 &amp;vertex2)</td></tr>
<tr class="memdesc:a250cbda6ab7de356d04facb0aea93322"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the vertices of a particular triangle <a href="#a250cbda6ab7de356d04facb0aea93322">More...</a><br/></td></tr>
<tr class="separator:a250cbda6ab7de356d04facb0aea93322"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae80873027751376e7192aa34a361a160"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1_volume.html#ae80873027751376e7192aa34a361a160">init</a> (const <a class="el" href="classpvr_1_1assets_1_1_mesh.html">assets::Mesh</a> &amp;mesh)</td></tr>
<tr class="memdesc:ae80873027751376e7192aa34a361a160"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize a volume from the data of a Mesh. <a href="#ae80873027751376e7192aa34a361a160">More...</a><br/></td></tr>
<tr class="separator:ae80873027751376e7192aa34a361a160"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28b487c1342dbad16b7e8bdc465c2fe6"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1_volume.html#a28b487c1342dbad16b7e8bdc465c2fe6">init</a> (const uint8_t *const data, uint32_t numVertices, uint32_t verticesStride, DataType vertexType, const uint8_t *const faceData, uint32_t numFaces, IndexType indexType)</td></tr>
<tr class="memdesc:a28b487c1342dbad16b7e8bdc465c2fe6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize a volume from raw data. <a href="#a28b487c1342dbad16b7e8bdc465c2fe6">More...</a><br/></td></tr>
<tr class="separator:a28b487c1342dbad16b7e8bdc465c2fe6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97c3eb5371cc06eb040ff88935616218"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1_volume.html#a97c3eb5371cc06eb040ff88935616218">isVolumeClosed</a> ()</td></tr>
<tr class="memdesc:a97c3eb5371cc06eb040ff88935616218"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get if a volume is closed <a href="#a97c3eb5371cc06eb040ff88935616218">More...</a><br/></td></tr>
<tr class="separator:a97c3eb5371cc06eb040ff88935616218"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:ae6cc654966f92552c741d78ebfe8ff06"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1_volume.html#ae6cc654966f92552c741d78ebfe8ff06">findOrCreateEdge</a> (const glm::vec3 &amp;v0, const glm::vec3 &amp;v1, bool &amp;existed)</td></tr>
<tr class="memdesc:ae6cc654966f92552c741d78ebfe8ff06"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve the index of an edge by vertex coordinates. If it does not exist, create a new one. <a href="#ae6cc654966f92552c741d78ebfe8ff06">More...</a><br/></td></tr>
<tr class="separator:ae6cc654966f92552c741d78ebfe8ff06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a422ab7ebb84f8df264841ea1f4e0cd7b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1_volume.html#a422ab7ebb84f8df264841ea1f4e0cd7b">findOrCreateTriangle</a> (const glm::vec3 &amp;v0, const glm::vec3 &amp;v1, const glm::vec3 &amp;v2)</td></tr>
<tr class="memdesc:a422ab7ebb84f8df264841ea1f4e0cd7b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a triangle of given coordinates if one does not exist. <a href="#a422ab7ebb84f8df264841ea1f4e0cd7b">More...</a><br/></td></tr>
<tr class="separator:a422ab7ebb84f8df264841ea1f4e0cd7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66305ee6f8e45ee4ed68448ec2b3e1d5"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1_volume.html#a66305ee6f8e45ee4ed68448ec2b3e1d5">findOrCreateVertex</a> (const glm::vec3 &amp;vertex, bool &amp;existed)</td></tr>
<tr class="memdesc:a66305ee6f8e45ee4ed68448ec2b3e1d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve the index of a vertex by coordinates. If it does not exist, create a new one. <a href="#a66305ee6f8e45ee4ed68448ec2b3e1d5">More...</a><br/></td></tr>
<tr class="separator:a66305ee6f8e45ee4ed68448ec2b3e1d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:a16b941109dc16216f71965fbcb859874"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a16b941109dc16216f71965fbcb859874"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1_volume.html#a16b941109dc16216f71965fbcb859874">_isClosed</a></td></tr>
<tr class="memdesc:a16b941109dc16216f71965fbcb859874"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is the mesh closed. <br/></td></tr>
<tr class="separator:a16b941109dc16216f71965fbcb859874"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ebe94853d63a993d2c3eea8e5bda494"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8ebe94853d63a993d2c3eea8e5bda494"></a>
<a class="el" href="structpvr_1_1_volume_1_1_volume_mesh.html">VolumeMesh</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1_volume.html#a8ebe94853d63a993d2c3eea8e5bda494">_volumeMesh</a></td></tr>
<tr class="memdesc:a8ebe94853d63a993d2c3eea8e5bda494"><td class="mdescLeft">&#160;</td><td class="mdescRight">The internal data of the mesh. <br/></td></tr>
<tr class="separator:a8ebe94853d63a993d2c3eea8e5bda494"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Represents data for handling volumes of a single Mesh.</p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a7429aefda094acec0bdd90d60df77c74"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual pvr::Volume::~Volume </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>dtor, releases all resources held by the <a class="el" href="classpvr_1_1_volume.html" title="Represents data for handling volumes of a single Mesh.">Volume</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="ae6cc654966f92552c741d78ebfe8ff06"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t pvr::Volume::findOrCreateEdge </td>
          <td>(</td>
          <td class="paramtype">const glm::vec3 &amp;&#160;</td>
          <td class="paramname"><em>v0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const glm::vec3 &amp;&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &amp;&#160;</td>
          <td class="paramname"><em>existed</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieve the index of an edge by vertex coordinates. If it does not exist, create a new one.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v0</td><td>The coordinates of the first vertex of the edge</td></tr>
    <tr><td class="paramname">v1</td><td>The coordinates of the second vertex of the edge</td></tr>
    <tr><td class="paramname">existed</td><td>Output: Is set to true if the edge already existed, otherwise will be set to false</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The index of the edge (existing or new)</dd></dl>

</div>
</div>
<a class="anchor" id="a422ab7ebb84f8df264841ea1f4e0cd7b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pvr::Volume::findOrCreateTriangle </td>
          <td>(</td>
          <td class="paramtype">const glm::vec3 &amp;&#160;</td>
          <td class="paramname"><em>v0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const glm::vec3 &amp;&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const glm::vec3 &amp;&#160;</td>
          <td class="paramname"><em>v2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a triangle of given coordinates if one does not exist.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v0</td><td>The coordinates of the first vertex of the edge</td></tr>
    <tr><td class="paramname">v1</td><td>The coordinates of the second vertex of the edge</td></tr>
    <tr><td class="paramname">v2</td><td>The coordinates of the third vertex of the edge</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a66305ee6f8e45ee4ed68448ec2b3e1d5"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t pvr::Volume::findOrCreateVertex </td>
          <td>(</td>
          <td class="paramtype">const glm::vec3 &amp;&#160;</td>
          <td class="paramname"><em>vertex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &amp;&#160;</td>
          <td class="paramname"><em>existed</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieve the index of a vertex by coordinates. If it does not exist, create a new one.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vertex</td><td>The coordinates of a vertex</td></tr>
    <tr><td class="paramname">existed</td><td>Output: Is set to true if the vertex already existed, otherwise will be set to false</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The index of the vertex (existing or new)</dd></dl>

</div>
</div>
<a class="anchor" id="a894e9d0050d4fce44dd9903cc21d9cf3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t pvr::Volume::getIndexDataSize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the size of the Index data, in bytes.</p>
<dl class="section return"><dt>Returns</dt><dd>The index data size</dd></dl>

</div>
</div>
<a class="anchor" id="a13a0ecadd29849f13633e8ef89a4dda2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t pvr::Volume::getIndexDataStride </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the stride of the Index data, in bytes. Is sizeof(IndexType).</p>
<dl class="section return"><dt>Returns</dt><dd>The index data stride </dd></dl>

</div>
</div>
<a class="anchor" id="a1385a976b59da81d71bc27058307c2a0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t pvr::Volume::getTriangleCount </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the number of triangles in the volume.</p>
<dl class="section return"><dt>Returns</dt><dd>The number of triangles</dd></dl>

</div>
</div>
<a class="anchor" id="ab33e63d9336f382efd92d07195aefcb1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structpvr_1_1_volume_1_1_volume_triangle.html">VolumeTriangle</a> pvr::Volume::getTriangleData </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>triangleIndex</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the triangle data at a particular index in the volume.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">triangleIndex</td><td>The index of the triangle to retrieve</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The triangle data</dd></dl>

</div>
</div>
<a class="anchor" id="a5dfcd860f12326eacd3f3a7e9e688e4b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t* pvr::Volume::getVertexData </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a pointer to the raw vertex data. Use to bind vertex buffer.</p>
<dl class="section return"><dt>Returns</dt><dd>The vertex data</dd></dl>

</div>
</div>
<a class="anchor" id="a84be15b69591d7d70a5b84e79ce24b90"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t pvr::Volume::getVertexDataExtrudeOffset </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the extrude offset. Is 3.</p>
<dl class="section return"><dt>Returns</dt><dd>The size of each vertex attribute</dd></dl>

</div>
</div>
<a class="anchor" id="a31c5b96f3f6bb0d623e126516765cf6f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t pvr::Volume::getVertexDataPositionOffset </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the offset of the Position vertex attribute in bytes. Is 0.</p>
<dl class="section return"><dt>Returns</dt><dd>The offset of the Position attribute</dd></dl>

</div>
</div>
<a class="anchor" id="a02fd603c4a8f313d1d8948fc5ec36826"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t pvr::Volume::getVertexDataSize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the size of the vertex attributes in bytes. Is 2 * numVertices * stride.</p>
<dl class="section return"><dt>Returns</dt><dd>The size of the vertex data</dd></dl>

</div>
</div>
<a class="anchor" id="a2c61d7e175a9c9c4bb7158a1fb6aec19"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t pvr::Volume::getVertexDataStride </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the stride of the vertex attributes, in bytes. Is 3 * 4 + 4 = 16 .</p>
<dl class="section return"><dt>Returns</dt><dd>The stride of the vertex attributes</dd></dl>

</div>
</div>
<a class="anchor" id="a250cbda6ab7de356d04facb0aea93322"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pvr::Volume::getVerticesForTriangle </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structpvr_1_1_volume_1_1_volume_triangle.html">VolumeTriangle</a> &amp;&#160;</td>
          <td class="paramname"><em>triangle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">glm::vec3 &amp;&#160;</td>
          <td class="paramname"><em>vertex0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">glm::vec3 &amp;&#160;</td>
          <td class="paramname"><em>vertex1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">glm::vec3 &amp;&#160;</td>
          <td class="paramname"><em>vertex2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the vertices of a particular triangle</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">triangle</td><td>The triangle from which to return the vertices</td></tr>
    <tr><td class="paramname">vertex0</td><td>Output: The first vertex</td></tr>
    <tr><td class="paramname">vertex1</td><td>Output: The second vertex</td></tr>
    <tr><td class="paramname">vertex2</td><td>Output: The third vertex</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ae80873027751376e7192aa34a361a160"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool pvr::Volume::init </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpvr_1_1assets_1_1_mesh.html">assets::Mesh</a> &amp;&#160;</td>
          <td class="paramname"><em>mesh</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize a volume from the data of a Mesh.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mesh</td><td>A mesh whose vertex data is used to initialize this <a class="el" href="classpvr_1_1_volume.html" title="Represents data for handling volumes of a single Mesh.">Volume</a> instance. The POSITION semantic must be present in the mesh.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if successfully initialized, otherwise false</dd></dl>
<p>This method will pre-process the data in the mesh, to calculate all vertices, edges and faces of the mesh as required. In effect it will extract the POSITION semantic data and the face data and use it to create a "light" and cleaned up version of the mesh that will be then used to calculate extruded volumes as required. </p>

</div>
</div>
<a class="anchor" id="a28b487c1342dbad16b7e8bdc465c2fe6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool pvr::Volume::init </td>
          <td>(</td>
          <td class="paramtype">const uint8_t *const&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>numVertices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>verticesStride</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DataType&#160;</td>
          <td class="paramname"><em>vertexType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *const&#160;</td>
          <td class="paramname"><em>faceData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>numFaces</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IndexType&#160;</td>
          <td class="paramname"><em>indexType</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize a volume from raw data.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>Pointer to the first POSITION attribute of vertex data (so buffer_start + offset)</td></tr>
    <tr><td class="paramname">numVertices</td><td>Number of vertices in (data)</td></tr>
    <tr><td class="paramname">verticesStride</td><td>Stride between each vertex attribute</td></tr>
    <tr><td class="paramname">vertexType</td><td>The DataType of each position coordinate</td></tr>
    <tr><td class="paramname">faceData</td><td>Pointer to index data</td></tr>
    <tr><td class="paramname">numFaces</td><td>Number of Faces contained in (faceData)</td></tr>
    <tr><td class="paramname">indexType</td><td>Type of indices in faceData (16/32 bit)</td></tr>
  </table>
  </dd>
</dl>
<p>This method will pre-process the data in the mesh, to calculate all vertices, edges and faces of the mesh as required</p>
<dl class="section return"><dt>Returns</dt><dd>True if successfully initialized, otherwise false</dd></dl>

</div>
</div>
<a class="anchor" id="a97c3eb5371cc06eb040ff88935616218"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool pvr::Volume::isVolumeClosed </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get if a volume is closed</p>
<dl class="section return"><dt>Returns</dt><dd>True if voluem is closed, otherwise false</dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>/usr/buildxl/buildroot/sdk/branch/SDK/framework/PVRAssets/<a class="el" href="_volume_8h_source.html">Volume.h</a></li>
</ul>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.4-->
<!-- start footer part (NON TREEVIEW ONLY!!) -->
<!--BEGIN GENERATE_TREEVIEW-->
<div id="FooterMainContainer">
	<div id="FooterContainer">
		<div class="footerlogo">
			<a href="http://www.imgtec.com" target="_blank"><img src="img-footer-logo-grey.png" width="100%" height="100%" border="none" /></a>
		</div>
		<div class="copyright"><p>&copy; Imagination Technologies Limited<br> All rights reserved</p></div>
	</div>
</div>
</body>
</html>
