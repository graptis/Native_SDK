<!-- HTML header for doxygen 1.8.4-->
<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="generator" content="Doxygen 1.8.6"/>
<title>PVRAssets: pvr::assets::Model Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="IMGdoxygen.css" rel="stylesheet" type="text/css"/>
<link rel="shortcut icon" href="http://www.imgtec.com/images/img.ico">
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
  <div class="headercontent">
    <div class="PVRlogo">
      <a href="http://www.powervrinsider.com" target="_blank"><img src="PVRlogo.png" width="40%" height="40%"  border="none" /></a>
    </div>
    <a class="SiteTitle"><span id="projectname">PVRAssets</span> Documentation</a>
   <tbody>
  </div>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="inherits.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacepvr.html">pvr</a></li><li class="navelem"><a class="el" href="namespacepvr_1_1assets.html">assets</a></li><li class="navelem"><a class="el" href="classpvr_1_1assets_1_1_model.html">Model</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classpvr_1_1assets_1_1_model-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">pvr::assets::Model Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>The <a class="el" href="classpvr_1_1assets_1_1_model.html" title="The Model class represents an entire Scene, or Model. It is mainly a Node structure, allowing various different kinds of data to be stored in the Nodes. The class contains a tree-like structure of Nodes. Each Node can be a Mesh node (containing a Mesh), Camera node or Light node. The tree-structure assumes transformational hierarchy (as usual). Transformations are expressed through Animation objects (a static transform is an animation with a single frame) There is an implicit order in the nodes - First in the array the Mesh nodes will be laid out, then Camera and Light nodes.">Model</a> class represents an entire Scene, or <a class="el" href="classpvr_1_1assets_1_1_model.html" title="The Model class represents an entire Scene, or Model. It is mainly a Node structure, allowing various different kinds of data to be stored in the Nodes. The class contains a tree-like structure of Nodes. Each Node can be a Mesh node (containing a Mesh), Camera node or Light node. The tree-structure assumes transformational hierarchy (as usual). Transformations are expressed through Animation objects (a static transform is an animation with a single frame) There is an implicit order in the nodes - First in the array the Mesh nodes will be laid out, then Camera and Light nodes.">Model</a>. It is mainly a <a class="el" href="classpvr_1_1assets_1_1_model_1_1_node.html" title="The Node represents a Mesh, Camera or Light. A Node has its own parenting, material, animation and custom user data. The tree-structure assumes transformational hierarchy (as usual), so parent transformations should be applied to children. Transformations are expressed through Animation objects (a static transform is an animation with a single frame). Note: Node ID and MeshID can sometimes be confusing: They will always be the same (when a MeshID makes sense) because Meshes are always laid out first in the internal list of Nodes. ">Node</a> structure, allowing various different kinds of data to be stored in the Nodes. The class contains a tree-like structure of Nodes. Each <a class="el" href="classpvr_1_1assets_1_1_model_1_1_node.html" title="The Node represents a Mesh, Camera or Light. A Node has its own parenting, material, animation and custom user data. The tree-structure assumes transformational hierarchy (as usual), so parent transformations should be applied to children. Transformations are expressed through Animation objects (a static transform is an animation with a single frame). Note: Node ID and MeshID can sometimes be confusing: They will always be the same (when a MeshID makes sense) because Meshes are always laid out first in the internal list of Nodes. ">Node</a> can be a <a class="el" href="classpvr_1_1assets_1_1_mesh.html" title="Mesh class. Represent a Mesh, a collection of primitives (usually, but not necessarily, triangles) together with their per-vertex information. A mesh&#39;s is a grouping where all vertices/primitives will have the same basic transformation (but can then be skinned) and material applied.">Mesh</a> node (containing a <a class="el" href="classpvr_1_1assets_1_1_mesh.html" title="Mesh class. Represent a Mesh, a collection of primitives (usually, but not necessarily, triangles) together with their per-vertex information. A mesh&#39;s is a grouping where all vertices/primitives will have the same basic transformation (but can then be skinned) and material applied.">Mesh</a>), <a class="el" href="classpvr_1_1assets_1_1_camera.html" title="Contains all information necessary to recreate a Camera in the scene.">Camera</a> node or <a class="el" href="classpvr_1_1assets_1_1_light.html" title="Represents a Light source in the scene.">Light</a> node. The tree-structure assumes transformational hierarchy (as usual). Transformations are expressed through <a class="el" href="classpvr_1_1assets_1_1_animation.html" title="Represents an Animation that can be applied to different objects.">Animation</a> objects (a static transform is an animation with a single frame) There is an implicit order in the nodes - First in the array the <a class="el" href="classpvr_1_1assets_1_1_mesh.html" title="Mesh class. Represent a Mesh, a collection of primitives (usually, but not necessarily, triangles) together with their per-vertex information. A mesh&#39;s is a grouping where all vertices/primitives will have the same basic transformation (but can then be skinned) and material applied.">Mesh</a> nodes will be laid out, then <a class="el" href="classpvr_1_1assets_1_1_camera.html" title="Contains all information necessary to recreate a Camera in the scene.">Camera</a> and <a class="el" href="classpvr_1_1assets_1_1_light.html" title="Represents a Light source in the scene.">Light</a> nodes. 
 <a href="classpvr_1_1assets_1_1_model.html#details">More...</a></p>
<div class="dynheader">
Inheritance diagram for pvr::assets::Model:</div>
<div class="dyncontent">
<div class="center"><img src="classpvr_1_1assets_1_1_model__inherit__graph.png" border="0" usemap="#pvr_1_1assets_1_1_model_inherit__map" alt="Inheritance graph"/></div>
<map name="pvr_1_1assets_1_1_model_inherit__map" id="pvr_1_1assets_1_1_model_inherit__map">
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpvr_1_1assets_1_1_model_1_1_internal_data.html">InternalData</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Struct containing the internal data of the <a class="el" href="classpvr_1_1assets_1_1_model.html" title="The Model class represents an entire Scene, or Model. It is mainly a Node structure, allowing various different kinds of data to be stored in the Nodes. The class contains a tree-like structure of Nodes. Each Node can be a Mesh node (containing a Mesh), Camera node or Light node. The tree-structure assumes transformational hierarchy (as usual). Transformations are expressed through Animation objects (a static transform is an animation with a single frame) There is an implicit order in the nodes - First in the array the Mesh nodes will be laid out, then Camera and Light nodes.">Model</a>. <a href="structpvr_1_1assets_1_1_model_1_1_internal_data.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1assets_1_1_model_1_1_material.html">Material</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class which stores model material info. <a href="classpvr_1_1assets_1_1_model_1_1_material.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1assets_1_1_model_1_1_node.html">Node</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="classpvr_1_1assets_1_1_model_1_1_node.html" title="The Node represents a Mesh, Camera or Light. A Node has its own parenting, material, animation and custom user data. The tree-structure assumes transformational hierarchy (as usual), so parent transformations should be applied to children. Transformations are expressed through Animation objects (a static transform is an animation with a single frame). Note: Node ID and MeshID can sometimes be confusing: They will always be the same (when a MeshID makes sense) because Meshes are always laid out first in the internal list of Nodes. ">Node</a> represents a <a class="el" href="classpvr_1_1assets_1_1_mesh.html" title="Mesh class. Represent a Mesh, a collection of primitives (usually, but not necessarily, triangles) together with their per-vertex information. A mesh&#39;s is a grouping where all vertices/primitives will have the same basic transformation (but can then be skinned) and material applied.">Mesh</a>, <a class="el" href="classpvr_1_1assets_1_1_camera.html" title="Contains all information necessary to recreate a Camera in the scene.">Camera</a> or <a class="el" href="classpvr_1_1assets_1_1_light.html" title="Represents a Light source in the scene.">Light</a>. A <a class="el" href="classpvr_1_1assets_1_1_model_1_1_node.html" title="The Node represents a Mesh, Camera or Light. A Node has its own parenting, material, animation and custom user data. The tree-structure assumes transformational hierarchy (as usual), so parent transformations should be applied to children. Transformations are expressed through Animation objects (a static transform is an animation with a single frame). Note: Node ID and MeshID can sometimes be confusing: They will always be the same (when a MeshID makes sense) because Meshes are always laid out first in the internal list of Nodes. ">Node</a> has its own parenting, material, animation and custom user data. The tree-structure assumes transformational hierarchy (as usual), so parent transformations should be applied to children. Transformations are expressed through <a class="el" href="classpvr_1_1assets_1_1_animation.html" title="Represents an Animation that can be applied to different objects.">Animation</a> objects (a static transform is an animation with a single frame). Note: <a class="el" href="classpvr_1_1assets_1_1_model_1_1_node.html" title="The Node represents a Mesh, Camera or Light. A Node has its own parenting, material, animation and custom user data. The tree-structure assumes transformational hierarchy (as usual), so parent transformations should be applied to children. Transformations are expressed through Animation objects (a static transform is an animation with a single frame). Note: Node ID and MeshID can sometimes be confusing: They will always be the same (when a MeshID makes sense) because Meshes are always laid out first in the internal list of Nodes. ">Node</a> ID and MeshID can sometimes be confusing: They will always be the same (when a MeshID makes sense) because Meshes are always laid out first in the internal list of Nodes.  <a href="classpvr_1_1assets_1_1_model_1_1_node.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1assets_1_1_model_1_1_texture.html">Texture</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Internal class which stores <a class="el" href="classpvr_1_1assets_1_1_model_1_1_texture.html" title="Internal class which stores Texture information of the model (name).">Texture</a> information of the model (name). <a href="classpvr_1_1assets_1_1_model_1_1_texture.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:ad98800186b5dcf34a6807288b27476f4"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classpvr_1_1assets_1_1_mesh.html">assets::Mesh</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1assets_1_1_model.html#ad98800186b5dcf34a6807288b27476f4">Mesh</a></td></tr>
<tr class="memdesc:ad98800186b5dcf34a6807288b27476f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Brings the <a class="el" href="classpvr_1_1assets_1_1_mesh.html" title="Mesh class. Represent a Mesh, a collection of primitives (usually, but not necessarily, triangles) together with their per-vertex information. A mesh&#39;s is a grouping where all vertices/primitives will have the same basic transformation (but can then be skinned) and material applied.">Mesh</a> class name into this class. <a href="#ad98800186b5dcf34a6807288b27476f4">More...</a><br/></td></tr>
<tr class="separator:ad98800186b5dcf34a6807288b27476f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a301d22c036319c2e43b866b81088e657"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1assets_1_1_model.html#a301d22c036319c2e43b866b81088e657">addMaterial</a> (const <a class="el" href="classpvr_1_1assets_1_1_model_1_1_material.html">Material</a> &amp;material)</td></tr>
<tr class="memdesc:a301d22c036319c2e43b866b81088e657"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a material to this model, and gets its (just created) material id <a href="#a301d22c036319c2e43b866b81088e657">More...</a><br/></td></tr>
<tr class="separator:a301d22c036319c2e43b866b81088e657"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41beb96f05aa13116e21d9af2d3d551c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1assets_1_1_model.html#a41beb96f05aa13116e21d9af2d3d551c">allocCameras</a> (uint32_t count)</td></tr>
<tr class="memdesc:a41beb96f05aa13116e21d9af2d3d551c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Only used for custom model creation. Allocate an number of cameras. <a href="#a41beb96f05aa13116e21d9af2d3d551c">More...</a><br/></td></tr>
<tr class="separator:a41beb96f05aa13116e21d9af2d3d551c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65879a38dae393d21684db25edba3439"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1assets_1_1_model.html#a65879a38dae393d21684db25edba3439">allocLights</a> (uint32_t count)</td></tr>
<tr class="memdesc:a65879a38dae393d21684db25edba3439"><td class="mdescLeft">&#160;</td><td class="mdescRight">Only used for custom model creation. Allocate a number of lights. <a href="#a65879a38dae393d21684db25edba3439">More...</a><br/></td></tr>
<tr class="separator:a65879a38dae393d21684db25edba3439"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71e5905e5fde8c859418c8fd3ba54991"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1assets_1_1_model.html#a71e5905e5fde8c859418c8fd3ba54991">allocMeshes</a> (uint32_t count)</td></tr>
<tr class="memdesc:a71e5905e5fde8c859418c8fd3ba54991"><td class="mdescLeft">&#160;</td><td class="mdescRight">Only used for custom model creation. Allocate a number of meshes. <a href="#a71e5905e5fde8c859418c8fd3ba54991">More...</a><br/></td></tr>
<tr class="separator:a71e5905e5fde8c859418c8fd3ba54991"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab02b0939e78dafbe15cc5d95763025ba"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1assets_1_1_model.html#ab02b0939e78dafbe15cc5d95763025ba">allocMeshNodes</a> (uint32_t no)</td></tr>
<tr class="memdesc:ab02b0939e78dafbe15cc5d95763025ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate the specified number of mesh nodes. <a href="#ab02b0939e78dafbe15cc5d95763025ba">More...</a><br/></td></tr>
<tr class="separator:ab02b0939e78dafbe15cc5d95763025ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5c8addf2ffc6c786af1aaee81770594"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1assets_1_1_model.html#ac5c8addf2ffc6c786af1aaee81770594">allocNodes</a> (uint32_t count)</td></tr>
<tr class="memdesc:ac5c8addf2ffc6c786af1aaee81770594"><td class="mdescLeft">&#160;</td><td class="mdescRight">Only used for custom model creation. Allocate a number of nodes. <a href="#ac5c8addf2ffc6c786af1aaee81770594">More...</a><br/></td></tr>
<tr class="separator:ac5c8addf2ffc6c786af1aaee81770594"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbe16ccc3591a586d80a14af8d5dd994"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1assets_1_1_model.html#adbe16ccc3591a586d80a14af8d5dd994">assignMaterialToMeshNodes</a> (uint32_t materialIndex, uint32_t beginMeshNodeId, uint32_t endMeshNodeId)</td></tr>
<tr class="memdesc:adbe16ccc3591a586d80a14af8d5dd994"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assign material id to number of mesh nodes <a href="#adbe16ccc3591a586d80a14af8d5dd994">More...</a><br/></td></tr>
<tr class="separator:adbe16ccc3591a586d80a14af8d5dd994"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8eff76a532c44f6dc1b9b0a5a1c38c4a"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classpvr_1_1assets_1_1_model.html#ad98800186b5dcf34a6807288b27476f4">Mesh</a> &gt;::iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1assets_1_1_model.html#a8eff76a532c44f6dc1b9b0a5a1c38c4a">beginMeshes</a> ()</td></tr>
<tr class="memdesc:a8eff76a532c44f6dc1b9b0a5a1c38c4a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get an iterator to the beginning of the meshes. <a href="#a8eff76a532c44f6dc1b9b0a5a1c38c4a">More...</a><br/></td></tr>
<tr class="separator:a8eff76a532c44f6dc1b9b0a5a1c38c4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb0a2f65a40d2f9b9e3b84afd95f431d"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classpvr_1_1assets_1_1_model.html#ad98800186b5dcf34a6807288b27476f4">Mesh</a> &gt;::const_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1assets_1_1_model.html#acb0a2f65a40d2f9b9e3b84afd95f431d">beginMeshes</a> () const </td></tr>
<tr class="memdesc:acb0a2f65a40d2f9b9e3b84afd95f431d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a const_iterator to the beginning of the meshes. <a href="#acb0a2f65a40d2f9b9e3b84afd95f431d">More...</a><br/></td></tr>
<tr class="separator:acb0a2f65a40d2f9b9e3b84afd95f431d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb904613cbaf195f7fd8528e917b63ed"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1assets_1_1_model.html#afb904613cbaf195f7fd8528e917b63ed">connectMeshWithMeshNode</a> (uint32_t meshId, uint32_t meshNodeId)</td></tr>
<tr class="memdesc:afb904613cbaf195f7fd8528e917b63ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Connect mesh to a mesh node (i.e. set the node's mesh to the mesh <a href="#afb904613cbaf195f7fd8528e917b63ed">More...</a><br/></td></tr>
<tr class="separator:afb904613cbaf195f7fd8528e917b63ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47584729b21739c25c0479d8d4713160"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1assets_1_1_model.html#a47584729b21739c25c0479d8d4713160">connectMeshWithMeshNodes</a> (uint32_t meshId, uint32_t beginMeshNodeId, uint32_t endMeshNodeId)</td></tr>
<tr class="memdesc:a47584729b21739c25c0479d8d4713160"><td class="mdescLeft">&#160;</td><td class="mdescRight">Connect mesh to number of mesh nodes <a href="#a47584729b21739c25c0479d8d4713160">More...</a><br/></td></tr>
<tr class="separator:a47584729b21739c25c0479d8d4713160"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc81369c3ebc723a7ba82f122753f2c4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1assets_1_1_model.html#abc81369c3ebc723a7ba82f122753f2c4">destroy</a> ()</td></tr>
<tr class="memdesc:abc81369c3ebc723a7ba82f122753f2c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Free the resources of this model. <a href="#abc81369c3ebc723a7ba82f122753f2c4">More...</a><br/></td></tr>
<tr class="separator:abc81369c3ebc723a7ba82f122753f2c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3aafc1e3dac0fe88ab6615b94e80efb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1assets_1_1_model.html#af3aafc1e3dac0fe88ab6615b94e80efb">destroyCache</a> ()</td></tr>
<tr class="memdesc:af3aafc1e3dac0fe88ab6615b94e80efb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Release the memory of the cache. <a href="#af3aafc1e3dac0fe88ab6615b94e80efb">More...</a><br/></td></tr>
<tr class="separator:af3aafc1e3dac0fe88ab6615b94e80efb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60dfb1ff94b791bd1b6372c69616468f"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classpvr_1_1assets_1_1_model.html#ad98800186b5dcf34a6807288b27476f4">Mesh</a> &gt;::iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1assets_1_1_model.html#a60dfb1ff94b791bd1b6372c69616468f">endMeshes</a> ()</td></tr>
<tr class="memdesc:a60dfb1ff94b791bd1b6372c69616468f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get an iterator past the end of the meshes. <a href="#a60dfb1ff94b791bd1b6372c69616468f">More...</a><br/></td></tr>
<tr class="separator:a60dfb1ff94b791bd1b6372c69616468f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b49a9866a99113358744701066a6821"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classpvr_1_1assets_1_1_model.html#ad98800186b5dcf34a6807288b27476f4">Mesh</a> &gt;::const_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1assets_1_1_model.html#a7b49a9866a99113358744701066a6821">endMeshes</a> () const </td></tr>
<tr class="memdesc:a7b49a9866a99113358744701066a6821"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a const_iterator past the end of the meshes. <a href="#a7b49a9866a99113358744701066a6821">More...</a><br/></td></tr>
<tr class="separator:a7b49a9866a99113358744701066a6821"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6829a4d9579d6c9c27d07e6f6d58081a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1assets_1_1_model.html#a6829a4d9579d6c9c27d07e6f6d58081a">flushCache</a> ()</td></tr>
<tr class="memdesc:a6829a4d9579d6c9c27d07e6f6d58081a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Modify a node's transformation then flush the cache. No effect if cache is uninitialized <a href="#a6829a4d9579d6c9c27d07e6f6d58081a">More...</a><br/></td></tr>
<tr class="separator:a6829a4d9579d6c9c27d07e6f6d58081a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15b0773f7189af3aebe6c83b0fdf7091"><td class="memItemLeft" align="right" valign="top">const float *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1assets_1_1_model.html#a15b0773f7189af3aebe6c83b0fdf7091">getBackgroundColor</a> () const </td></tr>
<tr class="memdesc:a15b0773f7189af3aebe6c83b0fdf7091"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the clear color (background) (float array R,G,B,A). <a href="#a15b0773f7189af3aebe6c83b0fdf7091">More...</a><br/></td></tr>
<tr class="separator:a15b0773f7189af3aebe6c83b0fdf7091"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a069289e29284e82908b3df480c0cf52a"><td class="memItemLeft" align="right" valign="top">glm::mat4x4&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1assets_1_1_model.html#a069289e29284e82908b3df480c0cf52a">getBoneWorldMatrix</a> (uint32_t skinNodeID, uint32_t boneId) const </td></tr>
<tr class="memdesc:a069289e29284e82908b3df480c0cf52a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the model-to-world matrix of a specified bone. Corresponds to the <a class="el" href="classpvr_1_1assets_1_1_model.html" title="The Model class represents an entire Scene, or Model. It is mainly a Node structure, allowing various different kinds of data to be stored in the Nodes. The class contains a tree-like structure of Nodes. Each Node can be a Mesh node (containing a Mesh), Camera node or Light node. The tree-structure assumes transformational hierarchy (as usual). Transformations are expressed through Animation objects (a static transform is an animation with a single frame) There is an implicit order in the nodes - First in the array the Mesh nodes will be laid out, then Camera and Light nodes.">Model</a>'s current frame of animation. This version will use caching. <a href="#a069289e29284e82908b3df480c0cf52a">More...</a><br/></td></tr>
<tr class="separator:a069289e29284e82908b3df480c0cf52a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f0e36dc6c0b9c6fe92f9f3415a0f78c"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classpvr_1_1assets_1_1_camera.html">Camera</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1assets_1_1_model.html#a4f0e36dc6c0b9c6fe92f9f3415a0f78c">getCamera</a> (uint32_t cameraIndex) const </td></tr>
<tr class="memdesc:a4f0e36dc6c0b9c6fe92f9f3415a0f78c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a <a class="el" href="classpvr_1_1assets_1_1_camera.html" title="Contains all information necessary to recreate a Camera in the scene.">Camera</a> from this model <a href="#a4f0e36dc6c0b9c6fe92f9f3415a0f78c">More...</a><br/></td></tr>
<tr class="separator:a4f0e36dc6c0b9c6fe92f9f3415a0f78c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a881d8601a42510ffcc4afebe2f0c07ca"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpvr_1_1assets_1_1_camera.html">Camera</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1assets_1_1_model.html#a881d8601a42510ffcc4afebe2f0c07ca">getCamera</a> (uint32_t cameraIndex)</td></tr>
<tr class="memdesc:a881d8601a42510ffcc4afebe2f0c07ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a <a class="el" href="classpvr_1_1assets_1_1_camera.html" title="Contains all information necessary to recreate a Camera in the scene.">Camera</a> from this model <a href="#a881d8601a42510ffcc4afebe2f0c07ca">More...</a><br/></td></tr>
<tr class="separator:a881d8601a42510ffcc4afebe2f0c07ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d07a585385e6c1e5c5256862f539626"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classpvr_1_1assets_1_1_model_1_1_node.html">Node</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1assets_1_1_model.html#a6d07a585385e6c1e5c5256862f539626">getCameraNode</a> (uint32_t cameraNodeIndex) const </td></tr>
<tr class="memdesc:a6d07a585385e6c1e5c5256862f539626"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a specific CameraNode. <a href="#a6d07a585385e6c1e5c5256862f539626">More...</a><br/></td></tr>
<tr class="separator:a6d07a585385e6c1e5c5256862f539626"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ded46344803376d4a41182625279007"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1assets_1_1_model.html#a6ded46344803376d4a41182625279007">getCameraProperties</a> (int32_t cameraIdx, float &amp;fov, glm::vec3 &amp;from, glm::vec3 &amp;to, glm::vec3 &amp;up) const </td></tr>
<tr class="memdesc:a6ded46344803376d4a41182625279007"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the properties of a camera. This is additional info on the class (remarks or documentation).  <a href="#a6ded46344803376d4a41182625279007">More...</a><br/></td></tr>
<tr class="separator:a6ded46344803376d4a41182625279007"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad9753133ed1dcfcdb58b744911c44d4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1assets_1_1_model.html#aad9753133ed1dcfcdb58b744911c44d4">getCameraProperties</a> (int32_t cameraIdx, float &amp;fov, glm::vec3 &amp;from, glm::vec3 &amp;to, glm::vec3 &amp;up, float &amp;nearClip, float &amp;farClip) const </td></tr>
<tr class="memdesc:aad9753133ed1dcfcdb58b744911c44d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the properties of a camera. <a href="#aad9753133ed1dcfcdb58b744911c44d4">More...</a><br/></td></tr>
<tr class="separator:aad9753133ed1dcfcdb58b744911c44d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22ea6d36fa661ea815e51cc3f0adfe48"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1assets_1_1_model.html#a22ea6d36fa661ea815e51cc3f0adfe48">getCurrentFrame</a> ()</td></tr>
<tr class="memdesc:a22ea6d36fa661ea815e51cc3f0adfe48"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the current frame of the scene. <a href="#a22ea6d36fa661ea815e51cc3f0adfe48">More...</a><br/></td></tr>
<tr class="separator:a22ea6d36fa661ea815e51cc3f0adfe48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12d7ee81da048d7a70f095cae7e9fe68"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1assets_1_1_model.html#a12d7ee81da048d7a70f095cae7e9fe68">getFPS</a> () const </td></tr>
<tr class="memdesc:a12d7ee81da048d7a70f095cae7e9fe68"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the FPS this animation was created for. <a href="#a12d7ee81da048d7a70f095cae7e9fe68">More...</a><br/></td></tr>
<tr class="separator:a12d7ee81da048d7a70f095cae7e9fe68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a3f8d53b699918178ee6496e1a2e5c7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structpvr_1_1assets_1_1_model_1_1_internal_data.html">InternalData</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1assets_1_1_model.html#a9a3f8d53b699918178ee6496e1a2e5c7">getInternalData</a> ()</td></tr>
<tr class="memdesc:a9a3f8d53b699918178ee6496e1a2e5c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a reference to the internal data of this <a class="el" href="classpvr_1_1assets_1_1_model.html" title="The Model class represents an entire Scene, or Model. It is mainly a Node structure, allowing various different kinds of data to be stored in the Nodes. The class contains a tree-like structure of Nodes. Each Node can be a Mesh node (containing a Mesh), Camera node or Light node. The tree-structure assumes transformational hierarchy (as usual). Transformations are expressed through Animation objects (a static transform is an animation with a single frame) There is an implicit order in the nodes - First in the array the Mesh nodes will be laid out, then Camera and Light nodes.">Model</a>. Handle with care. <a href="#a9a3f8d53b699918178ee6496e1a2e5c7">More...</a><br/></td></tr>
<tr class="separator:a9a3f8d53b699918178ee6496e1a2e5c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab74b010a10012bf79ea741fa68881bfb"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classpvr_1_1assets_1_1_light.html">Light</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1assets_1_1_model.html#ab74b010a10012bf79ea741fa68881bfb">getLight</a> (uint32_t lightIndex) const </td></tr>
<tr class="memdesc:ab74b010a10012bf79ea741fa68881bfb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the light object with the specific <a class="el" href="classpvr_1_1assets_1_1_light.html" title="Represents a Light source in the scene.">Light</a> Index. <a href="#ab74b010a10012bf79ea741fa68881bfb">More...</a><br/></td></tr>
<tr class="separator:ab74b010a10012bf79ea741fa68881bfb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7da6aca33de1fe11d5640ebe7b9dcb8e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpvr_1_1assets_1_1_light.html">Light</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1assets_1_1_model.html#a7da6aca33de1fe11d5640ebe7b9dcb8e">getLight</a> (uint32_t lightIndex)</td></tr>
<tr class="memdesc:a7da6aca33de1fe11d5640ebe7b9dcb8e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the light object with the specific <a class="el" href="classpvr_1_1assets_1_1_light.html" title="Represents a Light source in the scene.">Light</a> Index. <a href="#a7da6aca33de1fe11d5640ebe7b9dcb8e">More...</a><br/></td></tr>
<tr class="separator:a7da6aca33de1fe11d5640ebe7b9dcb8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3e973e2aa01ee6d991bb310c4ebe3d8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1assets_1_1_model.html#ab3e973e2aa01ee6d991bb310c4ebe3d8">getLightDirection</a> (int32_t lightIdx, glm::vec3 &amp;direction) const </td></tr>
<tr class="memdesc:ab3e973e2aa01ee6d991bb310c4ebe3d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the direction of a spot or directional light. <a href="#ab3e973e2aa01ee6d991bb310c4ebe3d8">More...</a><br/></td></tr>
<tr class="separator:ab3e973e2aa01ee6d991bb310c4ebe3d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b0daeb0f25ec83cb61dd6bd66692442"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classpvr_1_1assets_1_1_model_1_1_node.html">Node</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1assets_1_1_model.html#a1b0daeb0f25ec83cb61dd6bd66692442">getLightNode</a> (uint32_t lightNodeIndex) const </td></tr>
<tr class="memdesc:a1b0daeb0f25ec83cb61dd6bd66692442"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a specific <a class="el" href="classpvr_1_1assets_1_1_light.html" title="Represents a Light source in the scene.">Light</a> <a class="el" href="classpvr_1_1assets_1_1_model_1_1_node.html" title="The Node represents a Mesh, Camera or Light. A Node has its own parenting, material, animation and custom user data. The tree-structure assumes transformational hierarchy (as usual), so parent transformations should be applied to children. Transformations are expressed through Animation objects (a static transform is an animation with a single frame). Note: Node ID and MeshID can sometimes be confusing: They will always be the same (when a MeshID makes sense) because Meshes are always laid out first in the internal list of Nodes. ">Node</a>. <a href="#a1b0daeb0f25ec83cb61dd6bd66692442">More...</a><br/></td></tr>
<tr class="separator:a1b0daeb0f25ec83cb61dd6bd66692442"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad41d9b69669954aad67a4ae780c27a03"><td class="memItemLeft" align="right" valign="top">glm::vec3&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1assets_1_1_model.html#ad41d9b69669954aad67a4ae780c27a03">getLightPosition</a> (uint32_t lightId) const </td></tr>
<tr class="memdesc:ad41d9b69669954aad67a4ae780c27a03"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the world-space position of a light. Corresponds to the <a class="el" href="classpvr_1_1assets_1_1_model.html" title="The Model class represents an entire Scene, or Model. It is mainly a Node structure, allowing various different kinds of data to be stored in the Nodes. The class contains a tree-like structure of Nodes. Each Node can be a Mesh node (containing a Mesh), Camera node or Light node. The tree-structure assumes transformational hierarchy (as usual). Transformations are expressed through Animation objects (a static transform is an animation with a single frame) There is an implicit order in the nodes - First in the array the Mesh nodes will be laid out, then Camera and Light nodes.">Model</a>'s current frame of animation.  <a href="#ad41d9b69669954aad67a4ae780c27a03">More...</a><br/></td></tr>
<tr class="separator:ad41d9b69669954aad67a4ae780c27a03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0f1987162edb8a5a08360f5761ff382"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1assets_1_1_model.html#ae0f1987162edb8a5a08360f5761ff382">getLightPosition</a> (int32_t lightIdx, glm::vec3 &amp;position) const </td></tr>
<tr class="memdesc:ae0f1987162edb8a5a08360f5761ff382"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the position of a point or spot light. <a href="#ae0f1987162edb8a5a08360f5761ff382">More...</a><br/></td></tr>
<tr class="separator:ae0f1987162edb8a5a08360f5761ff382"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5141d7fd48c21c903041bfb721b10c8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1assets_1_1_model.html#af5141d7fd48c21c903041bfb721b10c8">getLightPosition</a> (int32_t lightIdx, glm::vec4 &amp;position) const </td></tr>
<tr class="memdesc:af5141d7fd48c21c903041bfb721b10c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the position of a point or spot light. <a href="#af5141d7fd48c21c903041bfb721b10c8">More...</a><br/></td></tr>
<tr class="separator:af5141d7fd48c21c903041bfb721b10c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7f2a31ba42a0bed44240eb1fccf558f"><td class="memItemLeft" align="right" valign="top">glm::mat4x4&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1assets_1_1_model.html#ae7f2a31ba42a0bed44240eb1fccf558f">getLocalMatrix</a> (uint32_t nodeId) const </td></tr>
<tr class="memdesc:ae7f2a31ba42a0bed44240eb1fccf558f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the model-to-world matrix of a node, <b>relative to its parent node</b>. In order to get the actual model-to-world matrix of the node, call getWorldMatrix (which will multiply the local matrix by the parent't matrix). <a href="#ae7f2a31ba42a0bed44240eb1fccf558f">More...</a><br/></td></tr>
<tr class="separator:ae7f2a31ba42a0bed44240eb1fccf558f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a364492fc8bd3faa425e0465e9e50644a"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classpvr_1_1assets_1_1_model_1_1_material.html">Material</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1assets_1_1_model.html#a364492fc8bd3faa425e0465e9e50644a">getMaterial</a> (uint32_t index) const </td></tr>
<tr class="memdesc:a364492fc8bd3faa425e0465e9e50644a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the material with the specified index. <a href="#a364492fc8bd3faa425e0465e9e50644a">More...</a><br/></td></tr>
<tr class="separator:a364492fc8bd3faa425e0465e9e50644a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45bb6901a69d75fd05c9b29ab8973fad"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpvr_1_1assets_1_1_model_1_1_material.html">Material</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1assets_1_1_model.html#a45bb6901a69d75fd05c9b29ab8973fad">getMaterial</a> (uint32_t index)</td></tr>
<tr class="memdesc:a45bb6901a69d75fd05c9b29ab8973fad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the material with the specified index. <a href="#a45bb6901a69d75fd05c9b29ab8973fad">More...</a><br/></td></tr>
<tr class="separator:a45bb6901a69d75fd05c9b29ab8973fad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5779d9219541ed6d3c7a978e5f15c1e"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classpvr_1_1assets_1_1_model.html#ad98800186b5dcf34a6807288b27476f4">Mesh</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1assets_1_1_model.html#ae5779d9219541ed6d3c7a978e5f15c1e">getMesh</a> (uint32_t meshIndex) const </td></tr>
<tr class="memdesc:ae5779d9219541ed6d3c7a978e5f15c1e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the <a class="el" href="classpvr_1_1assets_1_1_mesh.html" title="Mesh class. Represent a Mesh, a collection of primitives (usually, but not necessarily, triangles) together with their per-vertex information. A mesh&#39;s is a grouping where all vertices/primitives will have the same basic transformation (but can then be skinned) and material applied.">Mesh</a> object with the specific <a class="el" href="classpvr_1_1assets_1_1_mesh.html" title="Mesh class. Represent a Mesh, a collection of primitives (usually, but not necessarily, triangles) together with their per-vertex information. A mesh&#39;s is a grouping where all vertices/primitives will have the same basic transformation (but can then be skinned) and material applied.">Mesh</a> Index. Constant overload. <a href="#ae5779d9219541ed6d3c7a978e5f15c1e">More...</a><br/></td></tr>
<tr class="separator:ae5779d9219541ed6d3c7a978e5f15c1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37b3473994c003a5cf9ec477bfd58c13"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpvr_1_1assets_1_1_model.html#ad98800186b5dcf34a6807288b27476f4">Mesh</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1assets_1_1_model.html#a37b3473994c003a5cf9ec477bfd58c13">getMesh</a> (uint32_t index)</td></tr>
<tr class="memdesc:a37b3473994c003a5cf9ec477bfd58c13"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the <a class="el" href="classpvr_1_1assets_1_1_mesh.html" title="Mesh class. Represent a Mesh, a collection of primitives (usually, but not necessarily, triangles) together with their per-vertex information. A mesh&#39;s is a grouping where all vertices/primitives will have the same basic transformation (but can then be skinned) and material applied.">Mesh</a> object with the specific <a class="el" href="classpvr_1_1assets_1_1_mesh.html" title="Mesh class. Represent a Mesh, a collection of primitives (usually, but not necessarily, triangles) together with their per-vertex information. A mesh&#39;s is a grouping where all vertices/primitives will have the same basic transformation (but can then be skinned) and material applied.">Mesh</a> Index. <a href="#a37b3473994c003a5cf9ec477bfd58c13">More...</a><br/></td></tr>
<tr class="separator:a37b3473994c003a5cf9ec477bfd58c13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aabf78d0c58641478cd2af9acd348f1b0"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classpvr_1_1assets_1_1_model_1_1_node.html">Node</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1assets_1_1_model.html#aabf78d0c58641478cd2af9acd348f1b0">getMeshNode</a> (uint32_t meshIndex) const </td></tr>
<tr class="memdesc:aabf78d0c58641478cd2af9acd348f1b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a specific <a class="el" href="classpvr_1_1assets_1_1_mesh.html" title="Mesh class. Represent a Mesh, a collection of primitives (usually, but not necessarily, triangles) together with their per-vertex information. A mesh&#39;s is a grouping where all vertices/primitives will have the same basic transformation (but can then be skinned) and material applied.">Mesh</a> <a class="el" href="classpvr_1_1assets_1_1_model_1_1_node.html" title="The Node represents a Mesh, Camera or Light. A Node has its own parenting, material, animation and custom user data. The tree-structure assumes transformational hierarchy (as usual), so parent transformations should be applied to children. Transformations are expressed through Animation objects (a static transform is an animation with a single frame). Note: Node ID and MeshID can sometimes be confusing: They will always be the same (when a MeshID makes sense) because Meshes are always laid out first in the internal list of Nodes. ">Node</a>. <a href="#aabf78d0c58641478cd2af9acd348f1b0">More...</a><br/></td></tr>
<tr class="separator:aabf78d0c58641478cd2af9acd348f1b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20c3976bc46796cf13b77c85fe751dc2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpvr_1_1assets_1_1_model_1_1_node.html">Node</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1assets_1_1_model.html#a20c3976bc46796cf13b77c85fe751dc2">getMeshNode</a> (uint32_t meshIndex)</td></tr>
<tr class="memdesc:a20c3976bc46796cf13b77c85fe751dc2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a specific <a class="el" href="classpvr_1_1assets_1_1_mesh.html" title="Mesh class. Represent a Mesh, a collection of primitives (usually, but not necessarily, triangles) together with their per-vertex information. A mesh&#39;s is a grouping where all vertices/primitives will have the same basic transformation (but can then be skinned) and material applied.">Mesh</a> <a class="el" href="classpvr_1_1assets_1_1_model_1_1_node.html" title="The Node represents a Mesh, Camera or Light. A Node has its own parenting, material, animation and custom user data. The tree-structure assumes transformational hierarchy (as usual), so parent transformations should be applied to children. Transformations are expressed through Animation objects (a static transform is an animation with a single frame). Note: Node ID and MeshID can sometimes be confusing: They will always be the same (when a MeshID makes sense) because Meshes are always laid out first in the internal list of Nodes. ">Node</a>. <a href="#a20c3976bc46796cf13b77c85fe751dc2">More...</a><br/></td></tr>
<tr class="separator:a20c3976bc46796cf13b77c85fe751dc2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab858c39b40a2cff649c4e61b94f4bd71"><td class="memItemLeft" align="right" valign="top">const FreeValue *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1assets_1_1_model.html#ab858c39b40a2cff649c4e61b94f4bd71">getModelSemantic</a> (const StringHash &amp;semantic) const </td></tr>
<tr class="memdesc:ab858c39b40a2cff649c4e61b94f4bd71"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the value of a Model-wide semantic as a FreeValue, null if it does not exist. <a href="#ab858c39b40a2cff649c4e61b94f4bd71">More...</a><br/></td></tr>
<tr class="separator:ab858c39b40a2cff649c4e61b94f4bd71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acaeec93405e8c181888e20e90b415854"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classpvr_1_1assets_1_1_model_1_1_node.html">Node</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1assets_1_1_model.html#acaeec93405e8c181888e20e90b415854">getNode</a> (uint32_t index) const </td></tr>
<tr class="memdesc:acaeec93405e8c181888e20e90b415854"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the node with the specified index. <a href="#acaeec93405e8c181888e20e90b415854">More...</a><br/></td></tr>
<tr class="separator:acaeec93405e8c181888e20e90b415854"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4892e2b2e33b855b77ef8c1983305052"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpvr_1_1assets_1_1_model_1_1_node.html">Node</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1assets_1_1_model.html#a4892e2b2e33b855b77ef8c1983305052">getNode</a> (uint32_t index)</td></tr>
<tr class="memdesc:a4892e2b2e33b855b77ef8c1983305052"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the node with the specified index. <a href="#a4892e2b2e33b855b77ef8c1983305052">More...</a><br/></td></tr>
<tr class="separator:a4892e2b2e33b855b77ef8c1983305052"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5cafe0bcfc92d76a20760fa81783be16"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1assets_1_1_model.html#a5cafe0bcfc92d76a20760fa81783be16">getNodeIdForMeshNodeId</a> (uint32_t meshNodeIndex) const </td></tr>
<tr class="memdesc:a5cafe0bcfc92d76a20760fa81783be16"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the (global) <a class="el" href="classpvr_1_1assets_1_1_model_1_1_node.html" title="The Node represents a Mesh, Camera or Light. A Node has its own parenting, material, animation and custom user data. The tree-structure assumes transformational hierarchy (as usual), so parent transformations should be applied to children. Transformations are expressed through Animation objects (a static transform is an animation with a single frame). Note: Node ID and MeshID can sometimes be confusing: They will always be the same (when a MeshID makes sense) because Meshes are always laid out first in the internal list of Nodes. ">Node</a> Index of a specific MeshNode. This function is provided for completion, as NodeID == MeshNodeID <a href="#a5cafe0bcfc92d76a20760fa81783be16">More...</a><br/></td></tr>
<tr class="separator:a5cafe0bcfc92d76a20760fa81783be16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46f62093decf4605d30b2542c23dd2c0"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1assets_1_1_model.html#a46f62093decf4605d30b2542c23dd2c0">getNodeIdFromCameraId</a> (uint32_t cameraNodeIndex) const </td></tr>
<tr class="memdesc:a46f62093decf4605d30b2542c23dd2c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the (global) <a class="el" href="classpvr_1_1assets_1_1_model_1_1_node.html" title="The Node represents a Mesh, Camera or Light. A Node has its own parenting, material, animation and custom user data. The tree-structure assumes transformational hierarchy (as usual), so parent transformations should be applied to children. Transformations are expressed through Animation objects (a static transform is an animation with a single frame). Note: Node ID and MeshID can sometimes be confusing: They will always be the same (when a MeshID makes sense) because Meshes are always laid out first in the internal list of Nodes. ">Node</a> Index of a specific CameraNode. <a href="#a46f62093decf4605d30b2542c23dd2c0">More...</a><br/></td></tr>
<tr class="separator:a46f62093decf4605d30b2542c23dd2c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81cb20eb28f4d9c36dba318407d2398a"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1assets_1_1_model.html#a81cb20eb28f4d9c36dba318407d2398a">getNodeIdFromLightNodeId</a> (uint32_t lightNodeIndex) const </td></tr>
<tr class="memdesc:a81cb20eb28f4d9c36dba318407d2398a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the GLOBAL index of a specific <a class="el" href="classpvr_1_1assets_1_1_light.html" title="Represents a Light source in the scene.">Light</a> <a class="el" href="classpvr_1_1assets_1_1_model_1_1_node.html" title="The Node represents a Mesh, Camera or Light. A Node has its own parenting, material, animation and custom user data. The tree-structure assumes transformational hierarchy (as usual), so parent transformations should be applied to children. Transformations are expressed through Animation objects (a static transform is an animation with a single frame). Note: Node ID and MeshID can sometimes be confusing: They will always be the same (when a MeshID makes sense) because Meshes are always laid out first in the internal list of Nodes. ">Node</a>. <a href="#a81cb20eb28f4d9c36dba318407d2398a">More...</a><br/></td></tr>
<tr class="separator:a81cb20eb28f4d9c36dba318407d2398a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0003d61180296bfabbb6a8a07b1c9da4"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1assets_1_1_model.html#a0003d61180296bfabbb6a8a07b1c9da4">getNumCameraNodes</a> () const </td></tr>
<tr class="memdesc:a0003d61180296bfabbb6a8a07b1c9da4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of <a class="el" href="classpvr_1_1assets_1_1_camera.html" title="Contains all information necessary to recreate a Camera in the scene.">Camera</a> nodes in this model <a href="#a0003d61180296bfabbb6a8a07b1c9da4">More...</a><br/></td></tr>
<tr class="separator:a0003d61180296bfabbb6a8a07b1c9da4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3802bae6a18e007be0f183d624d6559b"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1assets_1_1_model.html#a3802bae6a18e007be0f183d624d6559b">getNumCameras</a> () const </td></tr>
<tr class="memdesc:a3802bae6a18e007be0f183d624d6559b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of distinct camera objects. May be different than the actual number of <a class="el" href="classpvr_1_1assets_1_1_camera.html" title="Contains all information necessary to recreate a Camera in the scene.">Camera</a> Instances (Nodes). <a href="#a3802bae6a18e007be0f183d624d6559b">More...</a><br/></td></tr>
<tr class="separator:a3802bae6a18e007be0f183d624d6559b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8ed16f4427021bd9949119e8b5f9bce"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1assets_1_1_model.html#ab8ed16f4427021bd9949119e8b5f9bce">getNumFrames</a> () const </td></tr>
<tr class="memdesc:ab8ed16f4427021bd9949119e8b5f9bce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the total number of frames in the scene. The total number of usable animated frames is limited to exclude (numFrames - 1) but include any partial number up to (numFrames - 1). Example: If there are 100 frames of animation, the highest frame number allowed is 98, since that will blend between frames 98 and 99. (99 being of course the 100th frame.) <a href="#ab8ed16f4427021bd9949119e8b5f9bce">More...</a><br/></td></tr>
<tr class="separator:ab8ed16f4427021bd9949119e8b5f9bce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2ab52f7c2f8f5204462cb4a3abd9ce9"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1assets_1_1_model.html#af2ab52f7c2f8f5204462cb4a3abd9ce9">getNumLightNodes</a> () const </td></tr>
<tr class="memdesc:af2ab52f7c2f8f5204462cb4a3abd9ce9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of <a class="el" href="classpvr_1_1assets_1_1_light.html" title="Represents a Light source in the scene.">Light</a> nodes. <a href="#af2ab52f7c2f8f5204462cb4a3abd9ce9">More...</a><br/></td></tr>
<tr class="separator:af2ab52f7c2f8f5204462cb4a3abd9ce9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29ea95d70455b4b1cac633f0eeab6c02"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1assets_1_1_model.html#a29ea95d70455b4b1cac633f0eeab6c02">getNumLights</a> () const </td></tr>
<tr class="memdesc:a29ea95d70455b4b1cac633f0eeab6c02"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of distinct <a class="el" href="classpvr_1_1assets_1_1_light.html" title="Represents a Light source in the scene.">Light</a> objects. May be different than the actual number of <a class="el" href="classpvr_1_1assets_1_1_light.html" title="Represents a Light source in the scene.">Light</a> Instances (Nodes). <a href="#a29ea95d70455b4b1cac633f0eeab6c02">More...</a><br/></td></tr>
<tr class="separator:a29ea95d70455b4b1cac633f0eeab6c02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a802b53d5550cbc78b2e127506d3b2e49"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1assets_1_1_model.html#a802b53d5550cbc78b2e127506d3b2e49">getNumMaterials</a> () const </td></tr>
<tr class="memdesc:a802b53d5550cbc78b2e127506d3b2e49"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of distinct Materials in the scene. <a href="#a802b53d5550cbc78b2e127506d3b2e49">More...</a><br/></td></tr>
<tr class="separator:a802b53d5550cbc78b2e127506d3b2e49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92f556300ba21d37df0087a08c6b3b2c"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1assets_1_1_model.html#a92f556300ba21d37df0087a08c6b3b2c">getNumMeshes</a> () const </td></tr>
<tr class="memdesc:a92f556300ba21d37df0087a08c6b3b2c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of distinct <a class="el" href="classpvr_1_1assets_1_1_mesh.html" title="Mesh class. Represent a Mesh, a collection of primitives (usually, but not necessarily, triangles) together with their per-vertex information. A mesh&#39;s is a grouping where all vertices/primitives will have the same basic transformation (but can then be skinned) and material applied.">Mesh</a> objects. Unless each <a class="el" href="classpvr_1_1assets_1_1_mesh.html" title="Mesh class. Represent a Mesh, a collection of primitives (usually, but not necessarily, triangles) together with their per-vertex information. A mesh&#39;s is a grouping where all vertices/primitives will have the same basic transformation (but can then be skinned) and material applied.">Mesh</a> appears at exactly one <a class="el" href="classpvr_1_1assets_1_1_model_1_1_node.html" title="The Node represents a Mesh, Camera or Light. A Node has its own parenting, material, animation and custom user data. The tree-structure assumes transformational hierarchy (as usual), so parent transformations should be applied to children. Transformations are expressed through Animation objects (a static transform is an animation with a single frame). Note: Node ID and MeshID can sometimes be confusing: They will always be the same (when a MeshID makes sense) because Meshes are always laid out first in the internal list of Nodes. ">Node</a>, may be different than the actual number of <a class="el" href="classpvr_1_1assets_1_1_mesh.html" title="Mesh class. Represent a Mesh, a collection of primitives (usually, but not necessarily, triangles) together with their per-vertex information. A mesh&#39;s is a grouping where all vertices/primitives will have the same basic transformation (but can then be skinned) and material applied.">Mesh</a> instances. <a href="#a92f556300ba21d37df0087a08c6b3b2c">More...</a><br/></td></tr>
<tr class="separator:a92f556300ba21d37df0087a08c6b3b2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a414dcb482f95a3a58edea4204efc3bf4"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1assets_1_1_model.html#a414dcb482f95a3a58edea4204efc3bf4">getNumMeshNodes</a> () const </td></tr>
<tr class="memdesc:a414dcb482f95a3a58edea4204efc3bf4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of <a class="el" href="classpvr_1_1assets_1_1_mesh.html" title="Mesh class. Represent a Mesh, a collection of primitives (usually, but not necessarily, triangles) together with their per-vertex information. A mesh&#39;s is a grouping where all vertices/primitives will have the same basic transformation (but can then be skinned) and material applied.">Mesh</a> nodes. <a href="#a414dcb482f95a3a58edea4204efc3bf4">More...</a><br/></td></tr>
<tr class="separator:a414dcb482f95a3a58edea4204efc3bf4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a405e68cae24790197bf54c78d429853c"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1assets_1_1_model.html#a405e68cae24790197bf54c78d429853c">getNumNodes</a> () const </td></tr>
<tr class="memdesc:a405e68cae24790197bf54c78d429853c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the total number of nodes (Meshes, Cameras, Lights, others (helpers etc)). <a href="#a405e68cae24790197bf54c78d429853c">More...</a><br/></td></tr>
<tr class="separator:a405e68cae24790197bf54c78d429853c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac370fba2790604de19128721fc1d0c13"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1assets_1_1_model.html#ac370fba2790604de19128721fc1d0c13">getNumTextures</a> () const </td></tr>
<tr class="memdesc:ac370fba2790604de19128721fc1d0c13"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of distinct Textures in the scene. <a href="#ac370fba2790604de19128721fc1d0c13">More...</a><br/></td></tr>
<tr class="separator:ac370fba2790604de19128721fc1d0c13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23f22ae3ab5f15ec9d128681c78fdb23"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classpvr_1_1assets_1_1_model_1_1_texture.html">Texture</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1assets_1_1_model.html#a23f22ae3ab5f15ec9d128681c78fdb23">getTexture</a> (uint32_t index) const </td></tr>
<tr class="memdesc:a23f22ae3ab5f15ec9d128681c78fdb23"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the texture with the specified index. <a href="#a23f22ae3ab5f15ec9d128681c78fdb23">More...</a><br/></td></tr>
<tr class="separator:a23f22ae3ab5f15ec9d128681c78fdb23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab968167cfb5ced37b0e91060a534988a"><td class="memItemLeft" align="right" valign="top">const RefCountedResource&lt; void &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1assets_1_1_model.html#ab968167cfb5ced37b0e91060a534988a">getUserDataPtr</a> () const </td></tr>
<tr class="memdesc:ab968167cfb5ced37b0e91060a534988a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a pointer to the UserData of this model, if such data exist. <a href="#ab968167cfb5ced37b0e91060a534988a">More...</a><br/></td></tr>
<tr class="separator:ab968167cfb5ced37b0e91060a534988a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99b0a6fd73f1a428b3b43758eb823598"><td class="memItemLeft" align="right" valign="top">RefCountedResource&lt; void &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1assets_1_1_model.html#a99b0a6fd73f1a428b3b43758eb823598">getUserDataPtr</a> ()</td></tr>
<tr class="memdesc:a99b0a6fd73f1a428b3b43758eb823598"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a pointer to the UserData of this model. <a href="#a99b0a6fd73f1a428b3b43758eb823598">More...</a><br/></td></tr>
<tr class="separator:a99b0a6fd73f1a428b3b43758eb823598"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a687bbb8981a6941612474df3fc0270a8"><td class="memItemLeft" align="right" valign="top">glm::mat4x4&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1assets_1_1_model.html#a687bbb8981a6941612474df3fc0270a8">getWorldMatrix</a> (uint32_t nodeId) const </td></tr>
<tr class="memdesc:a687bbb8981a6941612474df3fc0270a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the model-to-world matrix of a node. Corresponds to the <a class="el" href="classpvr_1_1assets_1_1_model.html" title="The Model class represents an entire Scene, or Model. It is mainly a Node structure, allowing various different kinds of data to be stored in the Nodes. The class contains a tree-like structure of Nodes. Each Node can be a Mesh node (containing a Mesh), Camera node or Light node. The tree-structure assumes transformational hierarchy (as usual). Transformations are expressed through Animation objects (a static transform is an animation with a single frame) There is an implicit order in the nodes - First in the array the Mesh nodes will be laid out, then Camera and Light nodes.">Model</a>'s current frame of animation. This version will store a copy of the matrix in an internal cache so that repeated calls for it will use the cached copy of it. Will also store the cached versions of all parents of this node, or use cached versions of them if they exist. Use this if you have long hierarchies and/or repeated calls per frame. <a href="#a687bbb8981a6941612474df3fc0270a8">More...</a><br/></td></tr>
<tr class="separator:a687bbb8981a6941612474df3fc0270a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6d1db751886747ed6c89d114351d4cf"><td class="memItemLeft" align="right" valign="top">glm::mat4x4&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1assets_1_1_model.html#af6d1db751886747ed6c89d114351d4cf">getWorldMatrixNoCache</a> (uint32_t nodeId) const </td></tr>
<tr class="memdesc:af6d1db751886747ed6c89d114351d4cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the model-to-world matrix of a node. Corresponds to the <a class="el" href="classpvr_1_1assets_1_1_model.html" title="The Model class represents an entire Scene, or Model. It is mainly a Node structure, allowing various different kinds of data to be stored in the Nodes. The class contains a tree-like structure of Nodes. Each Node can be a Mesh node (containing a Mesh), Camera node or Light node. The tree-structure assumes transformational hierarchy (as usual). Transformations are expressed through Animation objects (a static transform is an animation with a single frame) There is an implicit order in the nodes - First in the array the Mesh nodes will be laid out, then Camera and Light nodes.">Model</a>'s current frame of animation. This version will not use caching and will recalculate the matrix. Faster if the matrix is only used a few times.  <a href="#af6d1db751886747ed6c89d114351d4cf">More...</a><br/></td></tr>
<tr class="separator:af6d1db751886747ed6c89d114351d4cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab78c62c58d34db54afab9b9349bb29b7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1assets_1_1_model.html#ab78c62c58d34db54afab9b9349bb29b7">initCache</a> ()</td></tr>
<tr class="memdesc:ab78c62c58d34db54afab9b9349bb29b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize the cache. Call this after changing the model data. It is automatically called by <a class="el" href="classpvr_1_1assets_1_1_p_o_d_reader.html" title="This class creates pvr::assets::Model object from Streams of POD Model data. Use the readAsset method...">PODReader</a> when reading a POD file. <a href="#ab78c62c58d34db54afab9b9349bb29b7">More...</a><br/></td></tr>
<tr class="separator:ab78c62c58d34db54afab9b9349bb29b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c8ecaa16bf1b9544d460227dd7492b2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1assets_1_1_model.html#a3c8ecaa16bf1b9544d460227dd7492b2">releaseVertexData</a> ()</td></tr>
<tr class="memdesc:a3c8ecaa16bf1b9544d460227dd7492b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Free the vertex data (Vertex attribute values, Vertex Index values) of all meshes to free memory. Usually called after VBOs/IBOs have been created. Any other data of the <a class="el" href="classpvr_1_1assets_1_1_mesh.html" title="Mesh class. Represent a Mesh, a collection of primitives (usually, but not necessarily, triangles) together with their per-vertex information. A mesh&#39;s is a grouping where all vertices/primitives will have the same basic transformation (but can then be skinned) and material applied.">Mesh</a> are unaffected. <a href="#a3c8ecaa16bf1b9544d460227dd7492b2">More...</a><br/></td></tr>
<tr class="separator:a3c8ecaa16bf1b9544d460227dd7492b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1298c521df10bdb803e0fbdf7a7ac654"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1assets_1_1_model.html#a1298c521df10bdb803e0fbdf7a7ac654">releaseVertexData</a> (uint32_t meshId)</td></tr>
<tr class="memdesc:a1298c521df10bdb803e0fbdf7a7ac654"><td class="mdescLeft">&#160;</td><td class="mdescRight">Free the vertex data (Vertex attribute values, Vertex Index values) of a single mesh to free memory. Usually called after VBOs/IBOs have been created. Any other data of the <a class="el" href="classpvr_1_1assets_1_1_mesh.html" title="Mesh class. Represent a Mesh, a collection of primitives (usually, but not necessarily, triangles) together with their per-vertex information. A mesh&#39;s is a grouping where all vertices/primitives will have the same basic transformation (but can then be skinned) and material applied.">Mesh</a> are unaffected. <a href="#a1298c521df10bdb803e0fbdf7a7ac654">More...</a><br/></td></tr>
<tr class="separator:a1298c521df10bdb803e0fbdf7a7ac654"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a465e371910aa620e9a6e8e01097a1cdf"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1assets_1_1_model.html#a465e371910aa620e9a6e8e01097a1cdf">setCurrentFrame</a> (float frame)</td></tr>
<tr class="memdesc:a465e371910aa620e9a6e8e01097a1cdf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the current frame. Affects future animation calls (getWorldMatrix etc.). <a href="#a465e371910aa620e9a6e8e01097a1cdf">More...</a><br/></td></tr>
<tr class="separator:a465e371910aa620e9a6e8e01097a1cdf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a144960d55c875412235282e12ee8ac32"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1assets_1_1_model.html#a144960d55c875412235282e12ee8ac32">setFPS</a> (uint32_t fps)</td></tr>
<tr class="memdesc:a144960d55c875412235282e12ee8ac32"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the expected FPS of the animation. <a href="#a144960d55c875412235282e12ee8ac32">More...</a><br/></td></tr>
<tr class="separator:a144960d55c875412235282e12ee8ac32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa80335b9a56a8946681482aa26365658"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1assets_1_1_model.html#aa80335b9a56a8946681482aa26365658">setUserData</a> (uint32_t size, const char *data)</td></tr>
<tr class="memdesc:aa80335b9a56a8946681482aa26365658"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set custom user data. <a href="#aa80335b9a56a8946681482aa26365658">More...</a><br/></td></tr>
<tr class="separator:aa80335b9a56a8946681482aa26365658"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43e54d4b06da4471fc1a72a05605944e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1assets_1_1_model.html#a43e54d4b06da4471fc1a72a05605944e">setUserDataPtr</a> (const RefCountedResource&lt; void &gt; &amp;ptr)</td></tr>
<tr class="memdesc:a43e54d4b06da4471fc1a72a05605944e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the UserData of this model (wrap the data into a RefCountedResource and cast to Ref Counted void pointer. <a href="#a43e54d4b06da4471fc1a72a05605944e">More...</a><br/></td></tr>
<tr class="separator:a43e54d4b06da4471fc1a72a05605944e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12448e1f020a38195dc4bc2675776064"><td class="memItemLeft" align="right" valign="top">glm::mat4x4&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1assets_1_1_model.html#a12448e1f020a38195dc4bc2675776064">toWorldMatrix</a> (uint32_t nodeId, const glm::mat4 &amp;localMatrix) const </td></tr>
<tr class="memdesc:a12448e1f020a38195dc4bc2675776064"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transform a custom matrix with a node's parent's transformation. Allows a custom matrix to be applied to a node, while honoring the hierarchical transformations applied by its parent hierarchy. <a href="#a12448e1f020a38195dc4bc2675776064">More...</a><br/></td></tr>
<tr class="separator:a12448e1f020a38195dc4bc2675776064"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>The <a class="el" href="classpvr_1_1assets_1_1_model.html" title="The Model class represents an entire Scene, or Model. It is mainly a Node structure, allowing various different kinds of data to be stored in the Nodes. The class contains a tree-like structure of Nodes. Each Node can be a Mesh node (containing a Mesh), Camera node or Light node. The tree-structure assumes transformational hierarchy (as usual). Transformations are expressed through Animation objects (a static transform is an animation with a single frame) There is an implicit order in the nodes - First in the array the Mesh nodes will be laid out, then Camera and Light nodes.">Model</a> class represents an entire Scene, or <a class="el" href="classpvr_1_1assets_1_1_model.html" title="The Model class represents an entire Scene, or Model. It is mainly a Node structure, allowing various different kinds of data to be stored in the Nodes. The class contains a tree-like structure of Nodes. Each Node can be a Mesh node (containing a Mesh), Camera node or Light node. The tree-structure assumes transformational hierarchy (as usual). Transformations are expressed through Animation objects (a static transform is an animation with a single frame) There is an implicit order in the nodes - First in the array the Mesh nodes will be laid out, then Camera and Light nodes.">Model</a>. It is mainly a <a class="el" href="classpvr_1_1assets_1_1_model_1_1_node.html" title="The Node represents a Mesh, Camera or Light. A Node has its own parenting, material, animation and custom user data. The tree-structure assumes transformational hierarchy (as usual), so parent transformations should be applied to children. Transformations are expressed through Animation objects (a static transform is an animation with a single frame). Note: Node ID and MeshID can sometimes be confusing: They will always be the same (when a MeshID makes sense) because Meshes are always laid out first in the internal list of Nodes. ">Node</a> structure, allowing various different kinds of data to be stored in the Nodes. The class contains a tree-like structure of Nodes. Each <a class="el" href="classpvr_1_1assets_1_1_model_1_1_node.html" title="The Node represents a Mesh, Camera or Light. A Node has its own parenting, material, animation and custom user data. The tree-structure assumes transformational hierarchy (as usual), so parent transformations should be applied to children. Transformations are expressed through Animation objects (a static transform is an animation with a single frame). Note: Node ID and MeshID can sometimes be confusing: They will always be the same (when a MeshID makes sense) because Meshes are always laid out first in the internal list of Nodes. ">Node</a> can be a <a class="el" href="classpvr_1_1assets_1_1_mesh.html" title="Mesh class. Represent a Mesh, a collection of primitives (usually, but not necessarily, triangles) together with their per-vertex information. A mesh&#39;s is a grouping where all vertices/primitives will have the same basic transformation (but can then be skinned) and material applied.">Mesh</a> node (containing a <a class="el" href="classpvr_1_1assets_1_1_mesh.html" title="Mesh class. Represent a Mesh, a collection of primitives (usually, but not necessarily, triangles) together with their per-vertex information. A mesh&#39;s is a grouping where all vertices/primitives will have the same basic transformation (but can then be skinned) and material applied.">Mesh</a>), <a class="el" href="classpvr_1_1assets_1_1_camera.html" title="Contains all information necessary to recreate a Camera in the scene.">Camera</a> node or <a class="el" href="classpvr_1_1assets_1_1_light.html" title="Represents a Light source in the scene.">Light</a> node. The tree-structure assumes transformational hierarchy (as usual). Transformations are expressed through <a class="el" href="classpvr_1_1assets_1_1_animation.html" title="Represents an Animation that can be applied to different objects.">Animation</a> objects (a static transform is an animation with a single frame) There is an implicit order in the nodes - First in the array the <a class="el" href="classpvr_1_1assets_1_1_mesh.html" title="Mesh class. Represent a Mesh, a collection of primitives (usually, but not necessarily, triangles) together with their per-vertex information. A mesh&#39;s is a grouping where all vertices/primitives will have the same basic transformation (but can then be skinned) and material applied.">Mesh</a> nodes will be laid out, then <a class="el" href="classpvr_1_1assets_1_1_camera.html" title="Contains all information necessary to recreate a Camera in the scene.">Camera</a> and <a class="el" href="classpvr_1_1assets_1_1_light.html" title="Represents a Light source in the scene.">Light</a> nodes.</p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a class="anchor" id="ad98800186b5dcf34a6807288b27476f4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classpvr_1_1assets_1_1_mesh.html">assets::Mesh</a> <a class="el" href="classpvr_1_1assets_1_1_model.html#ad98800186b5dcf34a6807288b27476f4">pvr::assets::Model::Mesh</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Brings the <a class="el" href="classpvr_1_1assets_1_1_mesh.html" title="Mesh class. Represent a Mesh, a collection of primitives (usually, but not necessarily, triangles) together with their per-vertex information. A mesh&#39;s is a grouping where all vertices/primitives will have the same basic transformation (but can then be skinned) and material applied.">Mesh</a> class name into this class.</p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a301d22c036319c2e43b866b81088e657"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t pvr::assets::Model::addMaterial </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpvr_1_1assets_1_1_model_1_1_material.html">Material</a> &amp;&#160;</td>
          <td class="paramname"><em>material</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add a material to this model, and gets its (just created) material id</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">material</td><td>The the material to add to the materials of this model</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The material id generated for the new material.</dd></dl>

</div>
</div>
<a class="anchor" id="a41beb96f05aa13116e21d9af2d3d551c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pvr::assets::Model::allocCameras </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>count</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Only used for custom model creation. Allocate an number of cameras.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">count</td><td>Number of camera to allocate in this scene</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a65879a38dae393d21684db25edba3439"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pvr::assets::Model::allocLights </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>count</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Only used for custom model creation. Allocate a number of lights.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">count</td><td>number of lights to allocate in this scene</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a71e5905e5fde8c859418c8fd3ba54991"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pvr::assets::Model::allocMeshes </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>count</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Only used for custom model creation. Allocate a number of meshes.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">count</td><td>number of meshes to allocate in this scene</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ab02b0939e78dafbe15cc5d95763025ba"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pvr::assets::Model::allocMeshNodes </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>no</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocate the specified number of mesh nodes.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">no</td><td>The number of mesh nodes to allocate</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ac5c8addf2ffc6c786af1aaee81770594"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pvr::assets::Model::allocNodes </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>count</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Only used for custom model creation. Allocate a number of nodes.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">count</td><td>number of nodes to allocate in this scene</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="adbe16ccc3591a586d80a14af8d5dd994"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pvr::assets::Model::assignMaterialToMeshNodes </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>materialIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>beginMeshNodeId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>endMeshNodeId</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Assign material id to number of mesh nodes</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">materialIndex</td><td><a class="el" href="classpvr_1_1assets_1_1_model_1_1_material.html" title="Class which stores model material info.">Material</a> id</td></tr>
    <tr><td class="paramname">beginMeshNodeId</td><td>Begin mesh node id (inclusive)</td></tr>
    <tr><td class="paramname">endMeshNodeId</td><td>end mesh node id (inclusive)</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a8eff76a532c44f6dc1b9b0a5a1c38c4a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="classpvr_1_1assets_1_1_model.html#ad98800186b5dcf34a6807288b27476f4">Mesh</a>&gt;::iterator pvr::assets::Model::beginMeshes </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get an iterator to the beginning of the meshes.</p>
<dl class="section return"><dt>Returns</dt><dd>Return an iterator</dd></dl>

</div>
</div>
<a class="anchor" id="acb0a2f65a40d2f9b9e3b84afd95f431d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="classpvr_1_1assets_1_1_model.html#ad98800186b5dcf34a6807288b27476f4">Mesh</a>&gt;::const_iterator pvr::assets::Model::beginMeshes </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a const_iterator to the beginning of the meshes.</p>
<dl class="section return"><dt>Returns</dt><dd>Iterator to the start of the mesh array</dd></dl>

</div>
</div>
<a class="anchor" id="afb904613cbaf195f7fd8528e917b63ed"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pvr::assets::Model::connectMeshWithMeshNode </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>meshId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>meshNodeId</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Connect mesh to a mesh node (i.e. set the node's mesh to the mesh</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">meshId</td><td>The mesh id</td></tr>
    <tr><td class="paramname">meshNodeId</td><td>The mesh node id to connect to</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a47584729b21739c25c0479d8d4713160"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pvr::assets::Model::connectMeshWithMeshNodes </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>meshId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>beginMeshNodeId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>endMeshNodeId</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Connect mesh to number of mesh nodes</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">meshId</td><td>The mesh id</td></tr>
    <tr><td class="paramname">beginMeshNodeId</td><td>Begin mesh node id (inclusive)</td></tr>
    <tr><td class="paramname">endMeshNodeId</td><td>End mesh node id (inclusive)</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="abc81369c3ebc723a7ba82f122753f2c4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pvr::assets::Model::destroy </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Free the resources of this model.</p>

</div>
</div>
<a class="anchor" id="af3aafc1e3dac0fe88ab6615b94e80efb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pvr::assets::Model::destroyCache </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Release the memory of the cache.</p>

</div>
</div>
<a class="anchor" id="a60dfb1ff94b791bd1b6372c69616468f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="classpvr_1_1assets_1_1_model.html#ad98800186b5dcf34a6807288b27476f4">Mesh</a>&gt;::iterator pvr::assets::Model::endMeshes </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get an iterator past the end of the meshes.</p>
<dl class="section return"><dt>Returns</dt><dd>Iterator to one past the last item of the mesh array</dd></dl>

</div>
</div>
<a class="anchor" id="a7b49a9866a99113358744701066a6821"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="classpvr_1_1assets_1_1_model.html#ad98800186b5dcf34a6807288b27476f4">Mesh</a>&gt;::const_iterator pvr::assets::Model::endMeshes </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a const_iterator past the end of the meshes.</p>
<dl class="section return"><dt>Returns</dt><dd>Iterator to one past the last item of the mesh array</dd></dl>

</div>
</div>
<a class="anchor" id="a6829a4d9579d6c9c27d07e6f6d58081a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pvr::assets::Model::flushCache </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Modify a node's transformation then flush the cache. No effect if cache is uninitialized</p>

</div>
</div>
<a class="anchor" id="a15b0773f7189af3aebe6c83b0fdf7091"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const float* pvr::assets::Model::getBackgroundColor </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the clear color (background) (float array R,G,B,A).</p>
<dl class="section return"><dt>Returns</dt><dd>The clear color (float array R,G,B,A).</dd></dl>

</div>
</div>
<a class="anchor" id="a069289e29284e82908b3df480c0cf52a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">glm::mat4x4 pvr::assets::Model::getBoneWorldMatrix </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>skinNodeID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>boneId</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the model-to-world matrix of a specified bone. Corresponds to the <a class="el" href="classpvr_1_1assets_1_1_model.html" title="The Model class represents an entire Scene, or Model. It is mainly a Node structure, allowing various different kinds of data to be stored in the Nodes. The class contains a tree-like structure of Nodes. Each Node can be a Mesh node (containing a Mesh), Camera node or Light node. The tree-structure assumes transformational hierarchy (as usual). Transformations are expressed through Animation objects (a static transform is an animation with a single frame) There is an implicit order in the nodes - First in the array the Mesh nodes will be laid out, then Camera and Light nodes.">Model</a>'s current frame of animation. This version will use caching.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">skinNodeID</td><td>The node for which to return the world matrix</td></tr>
    <tr><td class="paramname">boneId</td><td>The bone for which to return the world matrix</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Return The world matrix of (nodeId, boneID)</dd></dl>

</div>
</div>
<a class="anchor" id="a4f0e36dc6c0b9c6fe92f9f3415a0f78c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classpvr_1_1assets_1_1_camera.html">Camera</a>&amp; pvr::assets::Model::getCamera </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>cameraIndex</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a <a class="el" href="classpvr_1_1assets_1_1_camera.html" title="Contains all information necessary to recreate a Camera in the scene.">Camera</a> from this model</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cameraIndex</td><td>The index of the camera. Valid values (0 to <a class="el" href="classpvr_1_1assets_1_1_model.html#a3802bae6a18e007be0f183d624d6559b" title="Get the number of distinct camera objects. May be different than the actual number of Camera Instance...">getNumCameras()</a>-1)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Return the camera</dd></dl>

</div>
</div>
<a class="anchor" id="a881d8601a42510ffcc4afebe2f0c07ca"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpvr_1_1assets_1_1_camera.html">Camera</a>&amp; pvr::assets::Model::getCamera </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>cameraIndex</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a <a class="el" href="classpvr_1_1assets_1_1_camera.html" title="Contains all information necessary to recreate a Camera in the scene.">Camera</a> from this model</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cameraIndex</td><td>The index of the camera. Valid values (0 to <a class="el" href="classpvr_1_1assets_1_1_model.html#a3802bae6a18e007be0f183d624d6559b" title="Get the number of distinct camera objects. May be different than the actual number of Camera Instance...">getNumCameras()</a>-1)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Return the camera</dd></dl>

</div>
</div>
<a class="anchor" id="a6d07a585385e6c1e5c5256862f539626"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classpvr_1_1assets_1_1_model_1_1_node.html">Node</a>&amp; pvr::assets::Model::getCameraNode </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>cameraNodeIndex</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a specific CameraNode.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cameraNodeIndex</td><td>The Index of a <a class="el" href="classpvr_1_1assets_1_1_camera.html" title="Contains all information necessary to recreate a Camera in the scene.">Camera</a> <a class="el" href="classpvr_1_1assets_1_1_model_1_1_node.html" title="The Node represents a Mesh, Camera or Light. A Node has its own parenting, material, animation and custom user data. The tree-structure assumes transformational hierarchy (as usual), so parent transformations should be applied to children. Transformations are expressed through Animation objects (a static transform is an animation with a single frame). Note: Node ID and MeshID can sometimes be confusing: They will always be the same (when a MeshID makes sense) because Meshes are always laid out first in the internal list of Nodes. ">Node</a>. It is not the same as the NodeID. Valid values: (0 .. <a class="el" href="classpvr_1_1assets_1_1_model.html#a0003d61180296bfabbb6a8a07b1c9da4" title="Get the number of Camera nodes in this model">getNumCameraNodes()</a>-1)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Return The <a class="el" href="classpvr_1_1assets_1_1_camera.html" title="Contains all information necessary to recreate a Camera in the scene.">Camera</a> <a class="el" href="classpvr_1_1assets_1_1_model_1_1_node.html" title="The Node represents a Mesh, Camera or Light. A Node has its own parenting, material, animation and custom user data. The tree-structure assumes transformational hierarchy (as usual), so parent transformations should be applied to children. Transformations are expressed through Animation objects (a static transform is an animation with a single frame). Note: Node ID and MeshID can sometimes be confusing: They will always be the same (when a MeshID makes sense) because Meshes are always laid out first in the internal list of Nodes. ">Node</a></dd></dl>

</div>
</div>
<a class="anchor" id="a6ded46344803376d4a41182625279007"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pvr::assets::Model::getCameraProperties </td>
          <td>(</td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>cameraIdx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float &amp;&#160;</td>
          <td class="paramname"><em>fov</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">glm::vec3 &amp;&#160;</td>
          <td class="paramname"><em>from</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">glm::vec3 &amp;&#160;</td>
          <td class="paramname"><em>to</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">glm::vec3 &amp;&#160;</td>
          <td class="paramname"><em>up</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the properties of a camera. This is additional info on the class (remarks or documentation). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cameraIdx</td><td>The index of the camera.</td></tr>
    <tr><td class="paramname">fov</td><td><a class="el" href="classpvr_1_1assets_1_1_camera.html" title="Contains all information necessary to recreate a Camera in the scene.">Camera</a> field of view.</td></tr>
    <tr><td class="paramname">from</td><td><a class="el" href="classpvr_1_1assets_1_1_camera.html" title="Contains all information necessary to recreate a Camera in the scene.">Camera</a> position in world.</td></tr>
    <tr><td class="paramname">to</td><td><a class="el" href="classpvr_1_1assets_1_1_camera.html" title="Contains all information necessary to recreate a Camera in the scene.">Camera</a> target point in world.</td></tr>
    <tr><td class="paramname">up</td><td><a class="el" href="classpvr_1_1assets_1_1_camera.html" title="Contains all information necessary to recreate a Camera in the scene.">Camera</a> tilt up (roll) vector in world.</td></tr>
  </table>
  </dd>
</dl>
<p>If cameraIdx &gt;= number of cameras, an error will be logged and this function will have no effect. </p>

</div>
</div>
<a class="anchor" id="aad9753133ed1dcfcdb58b744911c44d4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pvr::assets::Model::getCameraProperties </td>
          <td>(</td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>cameraIdx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float &amp;&#160;</td>
          <td class="paramname"><em>fov</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">glm::vec3 &amp;&#160;</td>
          <td class="paramname"><em>from</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">glm::vec3 &amp;&#160;</td>
          <td class="paramname"><em>to</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">glm::vec3 &amp;&#160;</td>
          <td class="paramname"><em>up</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float &amp;&#160;</td>
          <td class="paramname"><em>nearClip</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float &amp;&#160;</td>
          <td class="paramname"><em>farClip</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the properties of a camera.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cameraIdx</td><td>The index of the camera.</td></tr>
    <tr><td class="paramname">fov</td><td><a class="el" href="classpvr_1_1assets_1_1_camera.html" title="Contains all information necessary to recreate a Camera in the scene.">Camera</a> field of view in world.</td></tr>
    <tr><td class="paramname">from</td><td><a class="el" href="classpvr_1_1assets_1_1_camera.html" title="Contains all information necessary to recreate a Camera in the scene.">Camera</a> position in world.</td></tr>
    <tr><td class="paramname">to</td><td><a class="el" href="classpvr_1_1assets_1_1_camera.html" title="Contains all information necessary to recreate a Camera in the scene.">Camera</a> target point in world.</td></tr>
    <tr><td class="paramname">up</td><td><a class="el" href="classpvr_1_1assets_1_1_camera.html" title="Contains all information necessary to recreate a Camera in the scene.">Camera</a> tilt up (roll) vector in world.</td></tr>
    <tr><td class="paramname">nearClip</td><td><a class="el" href="classpvr_1_1assets_1_1_camera.html" title="Contains all information necessary to recreate a Camera in the scene.">Camera</a> near clipping plane distance</td></tr>
    <tr><td class="paramname">farClip</td><td><a class="el" href="classpvr_1_1assets_1_1_camera.html" title="Contains all information necessary to recreate a Camera in the scene.">Camera</a> far clipping plane distance</td></tr>
  </table>
  </dd>
</dl>
<p>If cameraIdx &gt;= number of cameras, an error will be logged and this function will have no effect. </p>

</div>
</div>
<a class="anchor" id="a22ea6d36fa661ea815e51cc3f0adfe48"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float pvr::assets::Model::getCurrentFrame </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the current frame of the scene.</p>
<dl class="section return"><dt>Returns</dt><dd>Return the current frame</dd></dl>

</div>
</div>
<a class="anchor" id="a12d7ee81da048d7a70f095cae7e9fe68"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t pvr::assets::Model::getFPS </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the FPS this animation was created for.</p>
<dl class="section return"><dt>Returns</dt><dd>Get the expected FPS of the animation.</dd></dl>

</div>
</div>
<a class="anchor" id="a9a3f8d53b699918178ee6496e1a2e5c7"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structpvr_1_1assets_1_1_model_1_1_internal_data.html">InternalData</a>&amp; pvr::assets::Model::getInternalData </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a reference to the internal data of this <a class="el" href="classpvr_1_1assets_1_1_model.html" title="The Model class represents an entire Scene, or Model. It is mainly a Node structure, allowing various different kinds of data to be stored in the Nodes. The class contains a tree-like structure of Nodes. Each Node can be a Mesh node (containing a Mesh), Camera node or Light node. The tree-structure assumes transformational hierarchy (as usual). Transformations are expressed through Animation objects (a static transform is an animation with a single frame) There is an implicit order in the nodes - First in the array the Mesh nodes will be laid out, then Camera and Light nodes.">Model</a>. Handle with care.</p>
<dl class="section return"><dt>Returns</dt><dd>Return internal data</dd></dl>

</div>
</div>
<a class="anchor" id="ab74b010a10012bf79ea741fa68881bfb"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classpvr_1_1assets_1_1_light.html">Light</a>&amp; pvr::assets::Model::getLight </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>lightIndex</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the light object with the specific <a class="el" href="classpvr_1_1assets_1_1_light.html" title="Represents a Light source in the scene.">Light</a> Index.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lightIndex</td><td>The index of the light. Valid values (0..<a class="el" href="classpvr_1_1assets_1_1_model.html#a29ea95d70455b4b1cac633f0eeab6c02" title="Get the number of distinct Light objects. May be different than the actual number of Light Instances ...">getNumLights()</a>-1)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Return the light</dd></dl>

</div>
</div>
<a class="anchor" id="a7da6aca33de1fe11d5640ebe7b9dcb8e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpvr_1_1assets_1_1_light.html">Light</a>&amp; pvr::assets::Model::getLight </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>lightIndex</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the light object with the specific <a class="el" href="classpvr_1_1assets_1_1_light.html" title="Represents a Light source in the scene.">Light</a> Index.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lightIndex</td><td>The index of the light. Valid values (0..<a class="el" href="classpvr_1_1assets_1_1_model.html#a29ea95d70455b4b1cac633f0eeab6c02" title="Get the number of distinct Light objects. May be different than the actual number of Light Instances ...">getNumLights()</a>-1)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Return the light</dd></dl>

</div>
</div>
<a class="anchor" id="ab3e973e2aa01ee6d991bb310c4ebe3d8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pvr::assets::Model::getLightDirection </td>
          <td>(</td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>lightIdx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">glm::vec3 &amp;&#160;</td>
          <td class="paramname"><em>direction</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the direction of a spot or directional light.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lightIdx</td><td>index of the light.</td></tr>
    <tr><td class="paramname">direction</td><td>The direction of the light.</td></tr>
  </table>
  </dd>
</dl>
<p>If lightIdx &gt;= number of lights, an error will be logged and this function will have no effect. </p>

</div>
</div>
<a class="anchor" id="a1b0daeb0f25ec83cb61dd6bd66692442"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classpvr_1_1assets_1_1_model_1_1_node.html">Node</a>&amp; pvr::assets::Model::getLightNode </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>lightNodeIndex</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a specific <a class="el" href="classpvr_1_1assets_1_1_light.html" title="Represents a Light source in the scene.">Light</a> <a class="el" href="classpvr_1_1assets_1_1_model_1_1_node.html" title="The Node represents a Mesh, Camera or Light. A Node has its own parenting, material, animation and custom user data. The tree-structure assumes transformational hierarchy (as usual), so parent transformations should be applied to children. Transformations are expressed through Animation objects (a static transform is an animation with a single frame). Note: Node ID and MeshID can sometimes be confusing: They will always be the same (when a MeshID makes sense) because Meshes are always laid out first in the internal list of Nodes. ">Node</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lightNodeIndex</td><td>The Index of the <a class="el" href="classpvr_1_1assets_1_1_light.html" title="Represents a Light source in the scene.">Light</a> <a class="el" href="classpvr_1_1assets_1_1_model_1_1_node.html" title="The Node represents a Mesh, Camera or Light. A Node has its own parenting, material, animation and custom user data. The tree-structure assumes transformational hierarchy (as usual), so parent transformations should be applied to children. Transformations are expressed through Animation objects (a static transform is an animation with a single frame). Note: Node ID and MeshID can sometimes be confusing: They will always be the same (when a MeshID makes sense) because Meshes are always laid out first in the internal list of Nodes. ">Node</a>. It is not the same as the NodeID. Valid values: (0 to <a class="el" href="classpvr_1_1assets_1_1_model.html#af2ab52f7c2f8f5204462cb4a3abd9ce9" title="Get the number of Light nodes.">getNumLightNodes()</a>-1)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Return the light node</dd></dl>

</div>
</div>
<a class="anchor" id="ad41d9b69669954aad67a4ae780c27a03"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">glm::vec3 pvr::assets::Model::getLightPosition </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>lightId</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the world-space position of a light. Corresponds to the <a class="el" href="classpvr_1_1assets_1_1_model.html" title="The Model class represents an entire Scene, or Model. It is mainly a Node structure, allowing various different kinds of data to be stored in the Nodes. The class contains a tree-like structure of Nodes. Each Node can be a Mesh node (containing a Mesh), Camera node or Light node. The tree-structure assumes transformational hierarchy (as usual). Transformations are expressed through Animation objects (a static transform is an animation with a single frame) There is an implicit order in the nodes - First in the array the Mesh nodes will be laid out, then Camera and Light nodes.">Model</a>'s current frame of animation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lightId</td><td>The node for which to return the world matrix.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Return The world matrix of (nodeId).</dd></dl>

</div>
</div>
<a class="anchor" id="ae0f1987162edb8a5a08360f5761ff382"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pvr::assets::Model::getLightPosition </td>
          <td>(</td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>lightIdx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">glm::vec3 &amp;&#160;</td>
          <td class="paramname"><em>position</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the position of a point or spot light.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lightIdx</td><td>light index.</td></tr>
    <tr><td class="paramname">position</td><td>The position of the light.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>False if <em>lightIdx</em> does not exist</dd></dl>
<p>If lightIdx &gt;= number of lights, an error will be logged and this function will have no effect. </p>

</div>
</div>
<a class="anchor" id="af5141d7fd48c21c903041bfb721b10c8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pvr::assets::Model::getLightPosition </td>
          <td>(</td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>lightIdx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">glm::vec4 &amp;&#160;</td>
          <td class="paramname"><em>position</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the position of a point or spot light.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lightIdx</td><td>light index.</td></tr>
    <tr><td class="paramname">position</td><td>The position of the light.</td></tr>
  </table>
  </dd>
</dl>
<p>If lightIdx &gt;= number of lights, an error will be logged and this function will have no effect. </p>

</div>
</div>
<a class="anchor" id="ae7f2a31ba42a0bed44240eb1fccf558f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">glm::mat4x4 pvr::assets::Model::getLocalMatrix </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>nodeId</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the model-to-world matrix of a node, <b>relative to its parent node</b>. In order to get the actual model-to-world matrix of the node, call getWorldMatrix (which will multiply the local matrix by the parent't matrix).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nodeId</td><td>The node for which to return the local matrix.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Return The locatmatrix of (nodeId).</dd></dl>
<p>You can use this to get the transformation of a node relative to its parent hierarchies. May be useful for implementing custom (e.g. procedural) animation/kinematics.</p>

</div>
</div>
<a class="anchor" id="a364492fc8bd3faa425e0465e9e50644a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classpvr_1_1assets_1_1_model_1_1_material.html">Material</a>&amp; pvr::assets::Model::getMaterial </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the material with the specified index.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>The index of material to get</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Return a material from this scene</dd></dl>

</div>
</div>
<a class="anchor" id="a45bb6901a69d75fd05c9b29ab8973fad"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpvr_1_1assets_1_1_model_1_1_material.html">Material</a>&amp; pvr::assets::Model::getMaterial </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the material with the specified index.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>The index of material to get</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Return a material from this scene</dd></dl>

</div>
</div>
<a class="anchor" id="ae5779d9219541ed6d3c7a978e5f15c1e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classpvr_1_1assets_1_1_model.html#ad98800186b5dcf34a6807288b27476f4">Mesh</a>&amp; pvr::assets::Model::getMesh </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>meshIndex</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the <a class="el" href="classpvr_1_1assets_1_1_mesh.html" title="Mesh class. Represent a Mesh, a collection of primitives (usually, but not necessarily, triangles) together with their per-vertex information. A mesh&#39;s is a grouping where all vertices/primitives will have the same basic transformation (but can then be skinned) and material applied.">Mesh</a> object with the specific <a class="el" href="classpvr_1_1assets_1_1_mesh.html" title="Mesh class. Represent a Mesh, a collection of primitives (usually, but not necessarily, triangles) together with their per-vertex information. A mesh&#39;s is a grouping where all vertices/primitives will have the same basic transformation (but can then be skinned) and material applied.">Mesh</a> Index. Constant overload.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">meshIndex</td><td>The index of the <a class="el" href="classpvr_1_1assets_1_1_mesh.html" title="Mesh class. Represent a Mesh, a collection of primitives (usually, but not necessarily, triangles) together with their per-vertex information. A mesh&#39;s is a grouping where all vertices/primitives will have the same basic transformation (but can then be skinned) and material applied.">Mesh</a>. Valid values (0..<a class="el" href="classpvr_1_1assets_1_1_model.html#a92f556300ba21d37df0087a08c6b3b2c" title="Get the number of distinct Mesh objects. Unless each Mesh appears at exactly one Node, may be different than the actual number of Mesh instances.">getNumMeshes()</a>-1)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The mesh with id <em>meshIndex.</em> Const ref.</dd></dl>

</div>
</div>
<a class="anchor" id="a37b3473994c003a5cf9ec477bfd58c13"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpvr_1_1assets_1_1_model.html#ad98800186b5dcf34a6807288b27476f4">Mesh</a>&amp; pvr::assets::Model::getMesh </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the <a class="el" href="classpvr_1_1assets_1_1_mesh.html" title="Mesh class. Represent a Mesh, a collection of primitives (usually, but not necessarily, triangles) together with their per-vertex information. A mesh&#39;s is a grouping where all vertices/primitives will have the same basic transformation (but can then be skinned) and material applied.">Mesh</a> object with the specific <a class="el" href="classpvr_1_1assets_1_1_mesh.html" title="Mesh class. Represent a Mesh, a collection of primitives (usually, but not necessarily, triangles) together with their per-vertex information. A mesh&#39;s is a grouping where all vertices/primitives will have the same basic transformation (but can then be skinned) and material applied.">Mesh</a> Index.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>The index of the <a class="el" href="classpvr_1_1assets_1_1_mesh.html" title="Mesh class. Represent a Mesh, a collection of primitives (usually, but not necessarily, triangles) together with their per-vertex information. A mesh&#39;s is a grouping where all vertices/primitives will have the same basic transformation (but can then be skinned) and material applied.">Mesh</a>. Valid values (0..<a class="el" href="classpvr_1_1assets_1_1_model.html#a92f556300ba21d37df0087a08c6b3b2c" title="Get the number of distinct Mesh objects. Unless each Mesh appears at exactly one Node, may be different than the actual number of Mesh instances.">getNumMeshes()</a>-1)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Return the mesh from this model</dd></dl>

</div>
</div>
<a class="anchor" id="aabf78d0c58641478cd2af9acd348f1b0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classpvr_1_1assets_1_1_model_1_1_node.html">Node</a>&amp; pvr::assets::Model::getMeshNode </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>meshIndex</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a specific <a class="el" href="classpvr_1_1assets_1_1_mesh.html" title="Mesh class. Represent a Mesh, a collection of primitives (usually, but not necessarily, triangles) together with their per-vertex information. A mesh&#39;s is a grouping where all vertices/primitives will have the same basic transformation (but can then be skinned) and material applied.">Mesh</a> <a class="el" href="classpvr_1_1assets_1_1_model_1_1_node.html" title="The Node represents a Mesh, Camera or Light. A Node has its own parenting, material, animation and custom user data. The tree-structure assumes transformational hierarchy (as usual), so parent transformations should be applied to children. Transformations are expressed through Animation objects (a static transform is an animation with a single frame). Note: Node ID and MeshID can sometimes be confusing: They will always be the same (when a MeshID makes sense) because Meshes are always laid out first in the internal list of Nodes. ">Node</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">meshIndex</td><td>The Index of the <a class="el" href="classpvr_1_1assets_1_1_mesh.html" title="Mesh class. Represent a Mesh, a collection of primitives (usually, but not necessarily, triangles) together with their per-vertex information. A mesh&#39;s is a grouping where all vertices/primitives will have the same basic transformation (but can then be skinned) and material applied.">Mesh</a> <a class="el" href="classpvr_1_1assets_1_1_model_1_1_node.html" title="The Node represents a Mesh, Camera or Light. A Node has its own parenting, material, animation and custom user data. The tree-structure assumes transformational hierarchy (as usual), so parent transformations should be applied to children. Transformations are expressed through Animation objects (a static transform is an animation with a single frame). Note: Node ID and MeshID can sometimes be confusing: They will always be the same (when a MeshID makes sense) because Meshes are always laid out first in the internal list of Nodes. ">Node</a>. For meshes, it is the same as the NodeID. Valid values: (0 to <a class="el" href="classpvr_1_1assets_1_1_model.html#a414dcb482f95a3a58edea4204efc3bf4" title="Get the number of Mesh nodes.">getNumMeshNodes()</a>-1)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Return he <a class="el" href="classpvr_1_1assets_1_1_mesh.html" title="Mesh class. Represent a Mesh, a collection of primitives (usually, but not necessarily, triangles) together with their per-vertex information. A mesh&#39;s is a grouping where all vertices/primitives will have the same basic transformation (but can then be skinned) and material applied.">Mesh</a> <a class="el" href="classpvr_1_1assets_1_1_model_1_1_node.html" title="The Node represents a Mesh, Camera or Light. A Node has its own parenting, material, animation and custom user data. The tree-structure assumes transformational hierarchy (as usual), so parent transformations should be applied to children. Transformations are expressed through Animation objects (a static transform is an animation with a single frame). Note: Node ID and MeshID can sometimes be confusing: They will always be the same (when a MeshID makes sense) because Meshes are always laid out first in the internal list of Nodes. ">Node</a> from this model</dd></dl>

</div>
</div>
<a class="anchor" id="a20c3976bc46796cf13b77c85fe751dc2"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpvr_1_1assets_1_1_model_1_1_node.html">Node</a>&amp; pvr::assets::Model::getMeshNode </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>meshIndex</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a specific <a class="el" href="classpvr_1_1assets_1_1_mesh.html" title="Mesh class. Represent a Mesh, a collection of primitives (usually, but not necessarily, triangles) together with their per-vertex information. A mesh&#39;s is a grouping where all vertices/primitives will have the same basic transformation (but can then be skinned) and material applied.">Mesh</a> <a class="el" href="classpvr_1_1assets_1_1_model_1_1_node.html" title="The Node represents a Mesh, Camera or Light. A Node has its own parenting, material, animation and custom user data. The tree-structure assumes transformational hierarchy (as usual), so parent transformations should be applied to children. Transformations are expressed through Animation objects (a static transform is an animation with a single frame). Note: Node ID and MeshID can sometimes be confusing: They will always be the same (when a MeshID makes sense) because Meshes are always laid out first in the internal list of Nodes. ">Node</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">meshIndex</td><td>The Index of the <a class="el" href="classpvr_1_1assets_1_1_mesh.html" title="Mesh class. Represent a Mesh, a collection of primitives (usually, but not necessarily, triangles) together with their per-vertex information. A mesh&#39;s is a grouping where all vertices/primitives will have the same basic transformation (but can then be skinned) and material applied.">Mesh</a> <a class="el" href="classpvr_1_1assets_1_1_model_1_1_node.html" title="The Node represents a Mesh, Camera or Light. A Node has its own parenting, material, animation and custom user data. The tree-structure assumes transformational hierarchy (as usual), so parent transformations should be applied to children. Transformations are expressed through Animation objects (a static transform is an animation with a single frame). Note: Node ID and MeshID can sometimes be confusing: They will always be the same (when a MeshID makes sense) because Meshes are always laid out first in the internal list of Nodes. ">Node</a>. For meshes, it is the same as the NodeID. Valid values: (0 to <a class="el" href="classpvr_1_1assets_1_1_model.html#a414dcb482f95a3a58edea4204efc3bf4" title="Get the number of Mesh nodes.">getNumMeshNodes()</a>-1)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Return he <a class="el" href="classpvr_1_1assets_1_1_mesh.html" title="Mesh class. Represent a Mesh, a collection of primitives (usually, but not necessarily, triangles) together with their per-vertex information. A mesh&#39;s is a grouping where all vertices/primitives will have the same basic transformation (but can then be skinned) and material applied.">Mesh</a> <a class="el" href="classpvr_1_1assets_1_1_model_1_1_node.html" title="The Node represents a Mesh, Camera or Light. A Node has its own parenting, material, animation and custom user data. The tree-structure assumes transformational hierarchy (as usual), so parent transformations should be applied to children. Transformations are expressed through Animation objects (a static transform is an animation with a single frame). Note: Node ID and MeshID can sometimes be confusing: They will always be the same (when a MeshID makes sense) because Meshes are always laid out first in the internal list of Nodes. ">Node</a> from this model</dd></dl>

</div>
</div>
<a class="anchor" id="ab858c39b40a2cff649c4e61b94f4bd71"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const FreeValue* pvr::assets::Model::getModelSemantic </td>
          <td>(</td>
          <td class="paramtype">const StringHash &amp;&#160;</td>
          <td class="paramname"><em>semantic</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the value of a Model-wide semantic as a FreeValue, null if it does not exist.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">semantic</td><td>The semantic name to retrieve</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to a FreeValue containing the value of the semantic. If the semantic does not exist, return NULL</dd></dl>

</div>
</div>
<a class="anchor" id="acaeec93405e8c181888e20e90b415854"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classpvr_1_1assets_1_1_model_1_1_node.html">Node</a>&amp; pvr::assets::Model::getNode </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the node with the specified index.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>The index of the node to get</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Return The <a class="el" href="classpvr_1_1assets_1_1_model_1_1_node.html" title="The Node represents a Mesh, Camera or Light. A Node has its own parenting, material, animation and custom user data. The tree-structure assumes transformational hierarchy (as usual), so parent transformations should be applied to children. Transformations are expressed through Animation objects (a static transform is an animation with a single frame). Note: Node ID and MeshID can sometimes be confusing: They will always be the same (when a MeshID makes sense) because Meshes are always laid out first in the internal list of Nodes. ">Node</a> from this scene</dd></dl>

</div>
</div>
<a class="anchor" id="a4892e2b2e33b855b77ef8c1983305052"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpvr_1_1assets_1_1_model_1_1_node.html">Node</a>&amp; pvr::assets::Model::getNode </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the node with the specified index.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>The index of the node to get</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Return The <a class="el" href="classpvr_1_1assets_1_1_model_1_1_node.html" title="The Node represents a Mesh, Camera or Light. A Node has its own parenting, material, animation and custom user data. The tree-structure assumes transformational hierarchy (as usual), so parent transformations should be applied to children. Transformations are expressed through Animation objects (a static transform is an animation with a single frame). Note: Node ID and MeshID can sometimes be confusing: They will always be the same (when a MeshID makes sense) because Meshes are always laid out first in the internal list of Nodes. ">Node</a> from this scene</dd></dl>

</div>
</div>
<a class="anchor" id="a5cafe0bcfc92d76a20760fa81783be16"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t pvr::assets::Model::getNodeIdForMeshNodeId </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>meshNodeIndex</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the (global) <a class="el" href="classpvr_1_1assets_1_1_model_1_1_node.html" title="The Node represents a Mesh, Camera or Light. A Node has its own parenting, material, animation and custom user data. The tree-structure assumes transformational hierarchy (as usual), so parent transformations should be applied to children. Transformations are expressed through Animation objects (a static transform is an animation with a single frame). Note: Node ID and MeshID can sometimes be confusing: They will always be the same (when a MeshID makes sense) because Meshes are always laid out first in the internal list of Nodes. ">Node</a> Index of a specific MeshNode. This function is provided for completion, as NodeID == MeshNodeID</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">meshNodeIndex</td><td>The Index of a <a class="el" href="classpvr_1_1assets_1_1_mesh.html" title="Mesh class. Represent a Mesh, a collection of primitives (usually, but not necessarily, triangles) together with their per-vertex information. A mesh&#39;s is a grouping where all vertices/primitives will have the same basic transformation (but can then be skinned) and material applied.">Mesh</a> <a class="el" href="classpvr_1_1assets_1_1_model_1_1_node.html" title="The Node represents a Mesh, Camera or Light. A Node has its own parenting, material, animation and custom user data. The tree-structure assumes transformational hierarchy (as usual), so parent transformations should be applied to children. Transformations are expressed through Animation objects (a static transform is an animation with a single frame). Note: Node ID and MeshID can sometimes be confusing: They will always be the same (when a MeshID makes sense) because Meshes are always laid out first in the internal list of Nodes. ">Node</a> that will be used to calculate the NodeID. Valid values: (0 to <a class="el" href="classpvr_1_1assets_1_1_model.html#a414dcb482f95a3a58edea4204efc3bf4" title="Get the number of Mesh nodes.">getNumMeshNodes()</a>-1)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Return the <a class="el" href="classpvr_1_1assets_1_1_model_1_1_node.html" title="The Node represents a Mesh, Camera or Light. A Node has its own parenting, material, animation and custom user data. The tree-structure assumes transformational hierarchy (as usual), so parent transformations should be applied to children. Transformations are expressed through Animation objects (a static transform is an animation with a single frame). Note: Node ID and MeshID can sometimes be confusing: They will always be the same (when a MeshID makes sense) because Meshes are always laid out first in the internal list of Nodes. ">Node</a> index of the specified <a class="el" href="classpvr_1_1assets_1_1_mesh.html" title="Mesh class. Represent a Mesh, a collection of primitives (usually, but not necessarily, triangles) together with their per-vertex information. A mesh&#39;s is a grouping where all vertices/primitives will have the same basic transformation (but can then be skinned) and material applied.">Mesh</a> node. This function just returns the meshNodeIndex (but is harmless and inlined).</dd></dl>

</div>
</div>
<a class="anchor" id="a46f62093decf4605d30b2542c23dd2c0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t pvr::assets::Model::getNodeIdFromCameraId </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>cameraNodeIndex</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the (global) <a class="el" href="classpvr_1_1assets_1_1_model_1_1_node.html" title="The Node represents a Mesh, Camera or Light. A Node has its own parenting, material, animation and custom user data. The tree-structure assumes transformational hierarchy (as usual), so parent transformations should be applied to children. Transformations are expressed through Animation objects (a static transform is an animation with a single frame). Note: Node ID and MeshID can sometimes be confusing: They will always be the same (when a MeshID makes sense) because Meshes are always laid out first in the internal list of Nodes. ">Node</a> Index of a specific CameraNode.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cameraNodeIndex</td><td>The Index of a <a class="el" href="classpvr_1_1assets_1_1_camera.html" title="Contains all information necessary to recreate a Camera in the scene.">Camera</a> <a class="el" href="classpvr_1_1assets_1_1_model_1_1_node.html" title="The Node represents a Mesh, Camera or Light. A Node has its own parenting, material, animation and custom user data. The tree-structure assumes transformational hierarchy (as usual), so parent transformations should be applied to children. Transformations are expressed through Animation objects (a static transform is an animation with a single frame). Note: Node ID and MeshID can sometimes be confusing: They will always be the same (when a MeshID makes sense) because Meshes are always laid out first in the internal list of Nodes. ">Node</a> that will be used to calculate the NodeID. Valid values: (0 to <a class="el" href="classpvr_1_1assets_1_1_model.html#a0003d61180296bfabbb6a8a07b1c9da4" title="Get the number of Camera nodes in this model">getNumCameraNodes()</a>-1)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Retunr The <a class="el" href="classpvr_1_1assets_1_1_model_1_1_node.html" title="The Node represents a Mesh, Camera or Light. A Node has its own parenting, material, animation and custom user data. The tree-structure assumes transformational hierarchy (as usual), so parent transformations should be applied to children. Transformations are expressed through Animation objects (a static transform is an animation with a single frame). Note: Node ID and MeshID can sometimes be confusing: They will always be the same (when a MeshID makes sense) because Meshes are always laid out first in the internal list of Nodes. ">Node</a> index of the specified camera node. Normally, it is the same as getNumMeshes + getNumLights + cameraNodeIndex</dd></dl>

</div>
</div>
<a class="anchor" id="a81cb20eb28f4d9c36dba318407d2398a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t pvr::assets::Model::getNodeIdFromLightNodeId </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>lightNodeIndex</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the GLOBAL index of a specific <a class="el" href="classpvr_1_1assets_1_1_light.html" title="Represents a Light source in the scene.">Light</a> <a class="el" href="classpvr_1_1assets_1_1_model_1_1_node.html" title="The Node represents a Mesh, Camera or Light. A Node has its own parenting, material, animation and custom user data. The tree-structure assumes transformational hierarchy (as usual), so parent transformations should be applied to children. Transformations are expressed through Animation objects (a static transform is an animation with a single frame). Note: Node ID and MeshID can sometimes be confusing: They will always be the same (when a MeshID makes sense) because Meshes are always laid out first in the internal list of Nodes. ">Node</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lightNodeIndex</td><td>The Index of the <a class="el" href="classpvr_1_1assets_1_1_light.html" title="Represents a Light source in the scene.">Light</a> <a class="el" href="classpvr_1_1assets_1_1_model_1_1_node.html" title="The Node represents a Mesh, Camera or Light. A Node has its own parenting, material, animation and custom user data. The tree-structure assumes transformational hierarchy (as usual), so parent transformations should be applied to children. Transformations are expressed through Animation objects (a static transform is an animation with a single frame). Note: Node ID and MeshID can sometimes be confusing: They will always be the same (when a MeshID makes sense) because Meshes are always laid out first in the internal list of Nodes. ">Node</a>. It is not the same as the NodeID. Valid values: (0 to <a class="el" href="classpvr_1_1assets_1_1_model.html#af2ab52f7c2f8f5204462cb4a3abd9ce9" title="Get the number of Light nodes.">getNumLightNodes()</a>-1)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Return the <a class="el" href="classpvr_1_1assets_1_1_model_1_1_node.html" title="The Node represents a Mesh, Camera or Light. A Node has its own parenting, material, animation and custom user data. The tree-structure assumes transformational hierarchy (as usual), so parent transformations should be applied to children. Transformations are expressed through Animation objects (a static transform is an animation with a single frame). Note: Node ID and MeshID can sometimes be confusing: They will always be the same (when a MeshID makes sense) because Meshes are always laid out first in the internal list of Nodes. ">Node</a> index of the same index. It is the same as <a class="el" href="classpvr_1_1assets_1_1_model.html#a414dcb482f95a3a58edea4204efc3bf4" title="Get the number of Mesh nodes.">getNumMeshNodes()</a> + lightNodeIndex. </dd></dl>

</div>
</div>
<a class="anchor" id="a0003d61180296bfabbb6a8a07b1c9da4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t pvr::assets::Model::getNumCameraNodes </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the number of <a class="el" href="classpvr_1_1assets_1_1_camera.html" title="Contains all information necessary to recreate a Camera in the scene.">Camera</a> nodes in this model</p>
<dl class="section return"><dt>Returns</dt><dd>Return The number of <a class="el" href="classpvr_1_1assets_1_1_camera.html" title="Contains all information necessary to recreate a Camera in the scene.">Camera</a> instances (Nodes) in this <a class="el" href="classpvr_1_1assets_1_1_model.html" title="The Model class represents an entire Scene, or Model. It is mainly a Node structure, allowing various different kinds of data to be stored in the Nodes. The class contains a tree-like structure of Nodes. Each Node can be a Mesh node (containing a Mesh), Camera node or Light node. The tree-structure assumes transformational hierarchy (as usual). Transformations are expressed through Animation objects (a static transform is an animation with a single frame) There is an implicit order in the nodes - First in the array the Mesh nodes will be laid out, then Camera and Light nodes.">Model</a>.</dd></dl>

</div>
</div>
<a class="anchor" id="a3802bae6a18e007be0f183d624d6559b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t pvr::assets::Model::getNumCameras </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the number of distinct camera objects. May be different than the actual number of <a class="el" href="classpvr_1_1assets_1_1_camera.html" title="Contains all information necessary to recreate a Camera in the scene.">Camera</a> Instances (Nodes).</p>
<dl class="section return"><dt>Returns</dt><dd>Return The number of distinct camera objects.</dd></dl>

</div>
</div>
<a class="anchor" id="ab8ed16f4427021bd9949119e8b5f9bce"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t pvr::assets::Model::getNumFrames </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the total number of frames in the scene. The total number of usable animated frames is limited to exclude (numFrames - 1) but include any partial number up to (numFrames - 1). Example: If there are 100 frames of animation, the highest frame number allowed is 98, since that will blend between frames 98 and 99. (99 being of course the 100th frame.)</p>
<dl class="section return"><dt>Returns</dt><dd>Return the number of frames in this model</dd></dl>

</div>
</div>
<a class="anchor" id="af2ab52f7c2f8f5204462cb4a3abd9ce9"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t pvr::assets::Model::getNumLightNodes </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the number of <a class="el" href="classpvr_1_1assets_1_1_light.html" title="Represents a Light source in the scene.">Light</a> nodes.</p>
<dl class="section return"><dt>Returns</dt><dd>Return The number of <a class="el" href="classpvr_1_1assets_1_1_light.html" title="Represents a Light source in the scene.">Light</a> instances (Nodes) in this <a class="el" href="classpvr_1_1assets_1_1_model.html" title="The Model class represents an entire Scene, or Model. It is mainly a Node structure, allowing various different kinds of data to be stored in the Nodes. The class contains a tree-like structure of Nodes. Each Node can be a Mesh node (containing a Mesh), Camera node or Light node. The tree-structure assumes transformational hierarchy (as usual). Transformations are expressed through Animation objects (a static transform is an animation with a single frame) There is an implicit order in the nodes - First in the array the Mesh nodes will be laid out, then Camera and Light nodes.">Model</a>.</dd></dl>

</div>
</div>
<a class="anchor" id="a29ea95d70455b4b1cac633f0eeab6c02"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t pvr::assets::Model::getNumLights </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the number of distinct <a class="el" href="classpvr_1_1assets_1_1_light.html" title="Represents a Light source in the scene.">Light</a> objects. May be different than the actual number of <a class="el" href="classpvr_1_1assets_1_1_light.html" title="Represents a Light source in the scene.">Light</a> Instances (Nodes).</p>
<dl class="section return"><dt>Returns</dt><dd>Return The number of distinct <a class="el" href="classpvr_1_1assets_1_1_light.html" title="Represents a Light source in the scene.">Light</a> objects in this <a class="el" href="classpvr_1_1assets_1_1_model.html" title="The Model class represents an entire Scene, or Model. It is mainly a Node structure, allowing various different kinds of data to be stored in the Nodes. The class contains a tree-like structure of Nodes. Each Node can be a Mesh node (containing a Mesh), Camera node or Light node. The tree-structure assumes transformational hierarchy (as usual). Transformations are expressed through Animation objects (a static transform is an animation with a single frame) There is an implicit order in the nodes - First in the array the Mesh nodes will be laid out, then Camera and Light nodes.">Model</a>.</dd></dl>

</div>
</div>
<a class="anchor" id="a802b53d5550cbc78b2e127506d3b2e49"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t pvr::assets::Model::getNumMaterials </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the number of distinct Materials in the scene.</p>
<dl class="section return"><dt>Returns</dt><dd>Return number of materials in this scene</dd></dl>

</div>
</div>
<a class="anchor" id="a92f556300ba21d37df0087a08c6b3b2c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t pvr::assets::Model::getNumMeshes </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the number of distinct <a class="el" href="classpvr_1_1assets_1_1_mesh.html" title="Mesh class. Represent a Mesh, a collection of primitives (usually, but not necessarily, triangles) together with their per-vertex information. A mesh&#39;s is a grouping where all vertices/primitives will have the same basic transformation (but can then be skinned) and material applied.">Mesh</a> objects. Unless each <a class="el" href="classpvr_1_1assets_1_1_mesh.html" title="Mesh class. Represent a Mesh, a collection of primitives (usually, but not necessarily, triangles) together with their per-vertex information. A mesh&#39;s is a grouping where all vertices/primitives will have the same basic transformation (but can then be skinned) and material applied.">Mesh</a> appears at exactly one <a class="el" href="classpvr_1_1assets_1_1_model_1_1_node.html" title="The Node represents a Mesh, Camera or Light. A Node has its own parenting, material, animation and custom user data. The tree-structure assumes transformational hierarchy (as usual), so parent transformations should be applied to children. Transformations are expressed through Animation objects (a static transform is an animation with a single frame). Note: Node ID and MeshID can sometimes be confusing: They will always be the same (when a MeshID makes sense) because Meshes are always laid out first in the internal list of Nodes. ">Node</a>, may be different than the actual number of <a class="el" href="classpvr_1_1assets_1_1_mesh.html" title="Mesh class. Represent a Mesh, a collection of primitives (usually, but not necessarily, triangles) together with their per-vertex information. A mesh&#39;s is a grouping where all vertices/primitives will have the same basic transformation (but can then be skinned) and material applied.">Mesh</a> instances.</p>
<dl class="section return"><dt>Returns</dt><dd>Return The number of different <a class="el" href="classpvr_1_1assets_1_1_mesh.html" title="Mesh class. Represent a Mesh, a collection of primitives (usually, but not necessarily, triangles) together with their per-vertex information. A mesh&#39;s is a grouping where all vertices/primitives will have the same basic transformation (but can then be skinned) and material applied.">Mesh</a> objects in this <a class="el" href="classpvr_1_1assets_1_1_model.html" title="The Model class represents an entire Scene, or Model. It is mainly a Node structure, allowing various different kinds of data to be stored in the Nodes. The class contains a tree-like structure of Nodes. Each Node can be a Mesh node (containing a Mesh), Camera node or Light node. The tree-structure assumes transformational hierarchy (as usual). Transformations are expressed through Animation objects (a static transform is an animation with a single frame) There is an implicit order in the nodes - First in the array the Mesh nodes will be laid out, then Camera and Light nodes.">Model</a>.</dd></dl>

</div>
</div>
<a class="anchor" id="a414dcb482f95a3a58edea4204efc3bf4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t pvr::assets::Model::getNumMeshNodes </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the number of <a class="el" href="classpvr_1_1assets_1_1_mesh.html" title="Mesh class. Represent a Mesh, a collection of primitives (usually, but not necessarily, triangles) together with their per-vertex information. A mesh&#39;s is a grouping where all vertices/primitives will have the same basic transformation (but can then be skinned) and material applied.">Mesh</a> nodes.</p>
<dl class="section return"><dt>Returns</dt><dd>Return The number of <a class="el" href="classpvr_1_1assets_1_1_mesh.html" title="Mesh class. Represent a Mesh, a collection of primitives (usually, but not necessarily, triangles) together with their per-vertex information. A mesh&#39;s is a grouping where all vertices/primitives will have the same basic transformation (but can then be skinned) and material applied.">Mesh</a> instances (Nodes) in this <a class="el" href="classpvr_1_1assets_1_1_model.html" title="The Model class represents an entire Scene, or Model. It is mainly a Node structure, allowing various different kinds of data to be stored in the Nodes. The class contains a tree-like structure of Nodes. Each Node can be a Mesh node (containing a Mesh), Camera node or Light node. The tree-structure assumes transformational hierarchy (as usual). Transformations are expressed through Animation objects (a static transform is an animation with a single frame) There is an implicit order in the nodes - First in the array the Mesh nodes will be laid out, then Camera and Light nodes.">Model</a>.</dd></dl>

</div>
</div>
<a class="anchor" id="a405e68cae24790197bf54c78d429853c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t pvr::assets::Model::getNumNodes </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the total number of nodes (Meshes, Cameras, Lights, others (helpers etc)).</p>
<dl class="section return"><dt>Returns</dt><dd>Return number of nodes in this model</dd></dl>

</div>
</div>
<a class="anchor" id="ac370fba2790604de19128721fc1d0c13"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t pvr::assets::Model::getNumTextures </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the number of distinct Textures in the scene.</p>
<dl class="section return"><dt>Returns</dt><dd>Return number of distinct textures</dd></dl>

</div>
</div>
<a class="anchor" id="a23f22ae3ab5f15ec9d128681c78fdb23"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classpvr_1_1assets_1_1_model_1_1_texture.html">Texture</a>&amp; pvr::assets::Model::getTexture </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the texture with the specified index.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>The index of the texture to get</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Return a texture from this scene</dd></dl>

</div>
</div>
<a class="anchor" id="ab968167cfb5ced37b0e91060a534988a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const RefCountedResource&lt;void&gt;&amp; pvr::assets::Model::getUserDataPtr </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a pointer to the UserData of this model, if such data exist.</p>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the UserData, as a Reference Counted Void pointer. Cast to appropriate (ref counted)type</dd></dl>

</div>
</div>
<a class="anchor" id="a99b0a6fd73f1a428b3b43758eb823598"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">RefCountedResource&lt;void&gt; pvr::assets::Model::getUserDataPtr </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a pointer to the UserData of this model.</p>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the UserData, as a Reference Counted Void pointer. Cast to appropriate (ref counted)type</dd></dl>

</div>
</div>
<a class="anchor" id="a687bbb8981a6941612474df3fc0270a8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">glm::mat4x4 pvr::assets::Model::getWorldMatrix </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>nodeId</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the model-to-world matrix of a node. Corresponds to the <a class="el" href="classpvr_1_1assets_1_1_model.html" title="The Model class represents an entire Scene, or Model. It is mainly a Node structure, allowing various different kinds of data to be stored in the Nodes. The class contains a tree-like structure of Nodes. Each Node can be a Mesh node (containing a Mesh), Camera node or Light node. The tree-structure assumes transformational hierarchy (as usual). Transformations are expressed through Animation objects (a static transform is an animation with a single frame) There is an implicit order in the nodes - First in the array the Mesh nodes will be laid out, then Camera and Light nodes.">Model</a>'s current frame of animation. This version will store a copy of the matrix in an internal cache so that repeated calls for it will use the cached copy of it. Will also store the cached versions of all parents of this node, or use cached versions of them if they exist. Use this if you have long hierarchies and/or repeated calls per frame.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nodeId</td><td>The node for which to return the world matrix.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Return The world matrix of (nodeId).</dd></dl>

</div>
</div>
<a class="anchor" id="af6d1db751886747ed6c89d114351d4cf"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">glm::mat4x4 pvr::assets::Model::getWorldMatrixNoCache </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>nodeId</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the model-to-world matrix of a node. Corresponds to the <a class="el" href="classpvr_1_1assets_1_1_model.html" title="The Model class represents an entire Scene, or Model. It is mainly a Node structure, allowing various different kinds of data to be stored in the Nodes. The class contains a tree-like structure of Nodes. Each Node can be a Mesh node (containing a Mesh), Camera node or Light node. The tree-structure assumes transformational hierarchy (as usual). Transformations are expressed through Animation objects (a static transform is an animation with a single frame) There is an implicit order in the nodes - First in the array the Mesh nodes will be laid out, then Camera and Light nodes.">Model</a>'s current frame of animation. This version will not use caching and will recalculate the matrix. Faster if the matrix is only used a few times. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nodeId</td><td>The node for which to return the world matrix</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>return The world matrix of (nodeId)</dd></dl>

</div>
</div>
<a class="anchor" id="ab78c62c58d34db54afab9b9349bb29b7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pvr::assets::Model::initCache </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize the cache. Call this after changing the model data. It is automatically called by <a class="el" href="classpvr_1_1assets_1_1_p_o_d_reader.html" title="This class creates pvr::assets::Model object from Streams of POD Model data. Use the readAsset method...">PODReader</a> when reading a POD file.</p>

</div>
</div>
<a class="anchor" id="a3c8ecaa16bf1b9544d460227dd7492b2"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pvr::assets::Model::releaseVertexData </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Free the vertex data (Vertex attribute values, Vertex Index values) of all meshes to free memory. Usually called after VBOs/IBOs have been created. Any other data of the <a class="el" href="classpvr_1_1assets_1_1_mesh.html" title="Mesh class. Represent a Mesh, a collection of primitives (usually, but not necessarily, triangles) together with their per-vertex information. A mesh&#39;s is a grouping where all vertices/primitives will have the same basic transformation (but can then be skinned) and material applied.">Mesh</a> are unaffected.</p>

</div>
</div>
<a class="anchor" id="a1298c521df10bdb803e0fbdf7a7ac654"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pvr::assets::Model::releaseVertexData </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>meshId</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Free the vertex data (Vertex attribute values, Vertex Index values) of a single mesh to free memory. Usually called after VBOs/IBOs have been created. Any other data of the <a class="el" href="classpvr_1_1assets_1_1_mesh.html" title="Mesh class. Represent a Mesh, a collection of primitives (usually, but not necessarily, triangles) together with their per-vertex information. A mesh&#39;s is a grouping where all vertices/primitives will have the same basic transformation (but can then be skinned) and material applied.">Mesh</a> are unaffected.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">meshId</td><td>The meshId of the mesh whose vertex data to free</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a465e371910aa620e9a6e8e01097a1cdf"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool pvr::assets::Model::setCurrentFrame </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>frame</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the current frame. Affects future animation calls (getWorldMatrix etc.).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">frame</td><td>The current frame. Can be fractional, in which case interpolation will normally be performed</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Return true on success, false if out of bounds.</dd></dl>

</div>
</div>
<a class="anchor" id="a144960d55c875412235282e12ee8ac32"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pvr::assets::Model::setFPS </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>fps</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the expected FPS of the animation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fps</td><td>FPS of the animation</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aa80335b9a56a8946681482aa26365658"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pvr::assets::Model::setUserData </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set custom user data.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">size</td><td>The size, in bytes, of the data.</td></tr>
    <tr><td class="paramname">data</td><td>Pointer to the raw data. (size) bytes will be copied as-is from this pointer.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a43e54d4b06da4471fc1a72a05605944e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pvr::assets::Model::setUserDataPtr </td>
          <td>(</td>
          <td class="paramtype">const RefCountedResource&lt; void &gt; &amp;&#160;</td>
          <td class="paramname"><em>ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the UserData of this model (wrap the data into a RefCountedResource and cast to Ref Counted void pointer.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptr</td><td>The UserData. Must be wrapped in an appropriate RefCountedResource, and then cast into a RefCountedResource to void</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a12448e1f020a38195dc4bc2675776064"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">glm::mat4x4 pvr::assets::Model::toWorldMatrix </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>nodeId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const glm::mat4 &amp;&#160;</td>
          <td class="paramname"><em>localMatrix</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Transform a custom matrix with a node's parent's transformation. Allows a custom matrix to be applied to a node, while honoring the hierarchical transformations applied by its parent hierarchy.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nodeId</td><td>The node whose parents will be applied to the transformation.</td></tr>
    <tr><td class="paramname">localMatrix</td><td>The matrix to transform</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Return The localMatrix transformation, modified by the hierarchical transformations of the node. </dd></dl>
<p>This function can be used to implement custom procedural animation/kinematics schemes, in which case some nodes may need to have their animations customly defined, but must still honor their parents' transformations.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>/usr/buildxl/buildroot/sdk/branch/SDK/framework/PVRAssets/<a class="el" href="_model_8h_source.html">Model.h</a></li>
</ul>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.4-->
<!-- start footer part (NON TREEVIEW ONLY!!) -->
<!--BEGIN GENERATE_TREEVIEW-->
<div id="FooterMainContainer">
	<div id="FooterContainer">
		<div class="footerlogo">
			<a href="http://www.imgtec.com" target="_blank"><img src="img-footer-logo-grey.png" width="100%" height="100%" border="none" /></a>
		</div>
		<div class="copyright"><p>&copy; Imagination Technologies Limited<br> All rights reserved</p></div>
	</div>
</div>
</body>
</html>
