<!-- HTML header for doxygen 1.8.4-->
<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="generator" content="Doxygen 1.8.6"/>
<title>PVRCore: pvr Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="IMGdoxygen.css" rel="stylesheet" type="text/css"/>
<link rel="shortcut icon" href="http://www.imgtec.com/images/img.ico">
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
  <div class="headercontent">
    <div class="PVRlogo">
      <a href="http://www.powervrinsider.com" target="_blank"><img src="PVRlogo.png" width="40%" height="40%"  border="none" /></a>
    </div>
    <a class="SiteTitle"><span id="projectname">PVRCore</span> Documentation</a>
   <tbody>
  </div>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="inherits.html"><span>Class&#160;Hierarchy</span></a></li>
      <li class="current"><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Macros</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">pvr Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Main PowerVR Framework Namespace 
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespacepvr_1_1_gpu_datatypes_helper"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1_gpu_datatypes_helper.html">GpuDatatypesHelper</a></td></tr>
<tr class="memdesc:namespacepvr_1_1_gpu_datatypes_helper"><td class="mdescLeft">&#160;</td><td class="mdescRight">Groups functionality that has to do with bit calculations/sizes/offsets of glsl types<br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacepvr_1_1math"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1math.html">math</a></td></tr>
<tr class="memdesc:namespacepvr_1_1math"><td class="mdescLeft">&#160;</td><td class="mdescRight">Contains mathematical functionality and classes, such as bounding box calculations, intersections etc. <br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacepvr_1_1strings"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1strings.html">strings</a></td></tr>
<tr class="memdesc:namespacepvr_1_1strings"><td class="mdescLeft">&#160;</td><td class="mdescRight">Contains several valuable helpers to assist with common std::string operations: Starts with, ends with, create with printf-style formatting and others.<br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacepvr_1_1utils"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1utils.html">utils</a></td></tr>
<tr class="memdesc:namespacepvr_1_1utils"><td class="mdescLeft">&#160;</td><td class="mdescRight">Contains assorted utility functions (test endianness, unicode conversions etc.)<br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1_android_asset_stream.html">AndroidAssetStream</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A <a class="el" href="classpvr_1_1_stream.html" title="This class is used to abstract streams of data (files, blocks of memory, resources etc...">Stream</a> implementation that is used to access resources built in an Android package (apk).  <a href="classpvr_1_1_android_asset_stream.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1_asset.html">Asset</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An <a class="el" href="classpvr_1_1_asset.html" title="An Asset represents an object that can be stored and loaded. Models, Textures, Effects and similar al...">Asset</a> represents an object that can be stored and loaded. Models, Textures, Effects and similar all inherit from <a class="el" href="classpvr_1_1_asset.html" title="An Asset represents an object that can be stored and loaded. Models, Textures, Effects and similar al...">Asset</a>. The class provides a Handle typedef for convenience, which is a reference-counted PVR Framework object type. Provides convenience functions for loading assets with assetReaders. <a href="classpvr_1_1_asset.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1_asset_reader.html">AssetReader</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for an <a class="el" href="classpvr_1_1_asset_reader.html" title="Base class for an AssetReader, a class that can read Assets from a provided Stream.">AssetReader</a>, a class that can read Assets from a provided <a class="el" href="classpvr_1_1_stream.html" title="This class is used to abstract streams of data (files, blocks of memory, resources etc...">Stream</a>. <a href="classpvr_1_1_asset_reader.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1_asset_writer.html">AssetWriter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for Classes that can be used to write back effects to disk. <a href="classpvr_1_1_asset_writer.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1_bitfield.html">Bitfield</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class wrapping an arithmetic type and providing bitwise operation for its bits <a href="classpvr_1_1_bitfield.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpvr_1_1_blending_config.html">BlendingConfig</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add blending configuration for a color attachment. Some API's only support one blending state for all attachments, in which case the 1st such configuration will be used for all. <a href="structpvr_1_1_blending_config.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1_buffer_stream.html">BufferStream</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class is used to access a block of memory as a <a class="el" href="classpvr_1_1_stream.html" title="This class is used to abstract streams of data (files, blocks of memory, resources etc...">Stream</a>. <a href="classpvr_1_1_buffer_stream.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpvr_1_1_camera_animation_controller.html">CameraAnimationController</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A simple structure for controlling camera animations <a href="structpvr_1_1_camera_animation_controller.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpvr_1_1_camera_key_frame.html">CameraKeyFrame</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A simple structure for handling key camera frames <a href="structpvr_1_1_camera_key_frame.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpvr_1_1_cmd_draw_indexed_indirect.html">CmdDrawIndexedIndirect</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The DrawIndexedIndirectCmd struct. The structure contains the data for drawIndexedInsdirect command buffer <a href="structpvr_1_1_cmd_draw_indexed_indirect.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpvr_1_1_cmd_draw_indirect.html">CmdDrawIndirect</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The DrawIndirectCmd struct. The structure contains the data for drawIndirect command buffer  <a href="structpvr_1_1_cmd_draw_indirect.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpvr_1_1_compressed_image_data_format.html">CompressedImageDataFormat</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Describes a Compressed format. Compressed formats provide less information than the uncompressed format, as they can only be accessed "black box". <a href="structpvr_1_1_compressed_image_data_format.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1_contiguous_map.html">ContiguousMap</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A map that uses a std::vector as an underlying sparse storage and uses binary search for logarithmic time key lookup or indexing for constant time lookup. a) it can be indexed either by index in constant time, or by key in logarithmic time. b) Guaranteed to have contiguous storage c) If items are removed, iterators are invalidated. <a href="classpvr_1_1_contiguous_map.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1_display_attributes.html">DisplayAttributes</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Contains display configuration information (width, height, position, title, bpp etc.). <a href="classpvr_1_1_display_attributes.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1_file_i_o_error.html">FileIOError</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A simple std::runtime_error wrapper for throwing exceptions when undertaking File IO operations <a href="classpvr_1_1_file_i_o_error.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1_file_not_found_error.html">FileNotFoundError</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A simple std::runtime_error wrapper for throwing exceptions when file not found errors occur <a href="classpvr_1_1_file_not_found_error.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1_file_path.html">FilePath</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Filepath represents a Path + Filename + Extension. <a href="classpvr_1_1_file_path.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1_file_stream.html">FileStream</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A <a class="el" href="classpvr_1_1_file_stream.html" title="A FileStream is a Stream that is used to access a File in the filesystem of the platform.">FileStream</a> is a <a class="el" href="classpvr_1_1_stream.html" title="This class is used to abstract streams of data (files, blocks of memory, resources etc...">Stream</a> that is used to access a File in the filesystem of the platform. <a href="classpvr_1_1_file_stream.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1_f_p_s_camera.html">FPSCamera</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A simple first person camera implementation <a href="classpvr_1_1_f_p_s_camera.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpvr_1_1_free_value.html">FreeValue</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A Free Value View that is backed by a 64-byte statically allocated array: Enough to hold one item of any GPU-datatype, up to a mat4x4 <a href="structpvr_1_1_free_value.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1_free_value_view.html">FreeValueView</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a runtime-known number of elements of a runtime-known type, with functions to handle and convert them. Very commonly used to dynamically represent data that will eventually need to be used by the GPU, such as uniforms, vectors and matrices. Does not contain methods to actually be populated, as this should be done through subclasses. <a href="classpvr_1_1_free_value_view.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1_generate_pixel_type1.html">GeneratePixelType1</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Use this template class to generate a 1 channel PixelID. <a href="classpvr_1_1_generate_pixel_type1.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1_generate_pixel_type2.html">GeneratePixelType2</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Use this template class to generate a 2 channel PixelID. <a href="classpvr_1_1_generate_pixel_type2.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1_generate_pixel_type3.html">GeneratePixelType3</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Use this template class to generate a 3 channel PixelID. <a href="classpvr_1_1_generate_pixel_type3.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1_generate_pixel_type4.html">GeneratePixelType4</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Use this template class to generate a 4 channel PixelID. <a href="classpvr_1_1_generate_pixel_type4.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpvr_1_1_generic_extent2_d.html">GenericExtent2D</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Contains a 2d Integer size (width, height) <a href="structpvr_1_1_generic_extent2_d.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpvr_1_1_generic_extent3_d.html">GenericExtent3D</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Contains a 3D Integer size (width, height, depth) <a href="structpvr_1_1_generic_extent3_d.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpvr_1_1_generic_offset2_d.html">GenericOffset2D</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="structpvr_1_1_generic_offset2_d.html" title="The GenericOffset2D contains a 16-bit 2D offset (offsetX, offsetY)">GenericOffset2D</a> contains a 16-bit 2D offset (offsetX, offsetY) <a href="structpvr_1_1_generic_offset2_d.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpvr_1_1_generic_offset3_d.html">GenericOffset3D</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="structpvr_1_1_generic_offset3_d.html" title="The GenericOffset3D contains the offsets in 3 dimension (offsetX, offsetY, offsetZ)">GenericOffset3D</a> contains the offsets in 3 dimension (offsetX, offsetY, offsetZ) <a href="structpvr_1_1_generic_offset3_d.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpvr_1_1hash.html">hash</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class template denoting a hash. Specializations only - no default implementation. (int32_t/int64_t/uint32_t/uint64_t/string) <a href="structpvr_1_1hash.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1_i_asset_provider.html">IAssetProvider</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="classpvr_1_1_i_asset_provider.html" title="The IAssetProvider interface marks a class that provides the getAssetStream and getGraphicsContext me...">IAssetProvider</a> interface marks a class that provides the getAssetStream and getGraphicsContext methods. <a href="classpvr_1_1_i_asset_provider.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpvr_1_1_image_data_format.html">ImageDataFormat</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents an image format, including pixel format(channels/bits per channel), datatype and colorspace.  <a href="structpvr_1_1_image_data_format.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpvr_1_1_image_layers_size.html">ImageLayersSize</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Structure describes the number of array levels and mip levels an image contains <a href="structpvr_1_1_image_layers_size.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpvr_1_1_image_range.html">ImageRange</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a specific 3-D range in an image (an orthogonal cuboid anywhere in the image) <a href="structpvr_1_1_image_range.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpvr_1_1_image_resolve_range.html">ImageResolveRange</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents an image resolve operation <a href="structpvr_1_1_image_resolve_range.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpvr_1_1_image_storage_format.html">ImageStorageFormat</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extends the <a class="el" href="structpvr_1_1_image_data_format.html" title="Represents an image format, including pixel format(channels/bits per channel), datatype and colorspac...">ImageDataFormat</a> with mipmaps and number of Samples. <a href="structpvr_1_1_image_storage_format.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpvr_1_1_image_storage_format_compressed.html">ImageStorageFormatCompressed</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Describes a Compressed format. Compressed formats provide less information than the uncompressed format, as they can only be accessed "black box". <a href="structpvr_1_1_image_storage_format_compressed.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpvr_1_1_image_subresource.html">ImageSubresource</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Describes a single "layer" of an image: a single array layer of a single mip level, or the offset of a layer range. <a href="structpvr_1_1_image_subresource.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpvr_1_1_image_subresource_layers.html">ImageSubresourceLayers</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a specific subresource layer: A specified Array Layer and Mipmap level of specific aspect of an image <a href="structpvr_1_1_image_subresource_layers.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpvr_1_1_image_subresource_range.html">ImageSubresourceRange</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a subresource range: A specified range of Array Layers and Mipmap levels of specific aspect of an image <a href="structpvr_1_1_image_subresource_range.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1_indexed_array.html">IndexedArray</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A combination of array (std::vector) with associative container (std::map). Supports association of names with values, and retrieval by index. <a href="classpvr_1_1_indexed_array.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1_index_out_of_range.html">IndexOutOfRange</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A simple std::runtime_error wrapper for throwing exceptions when attempting to use index out of range <a href="classpvr_1_1_index_out_of_range.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1_invalid_argument_error.html">InvalidArgumentError</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A simple std::runtime_error wrapper for throwing exceptions when invalid arguments are provided <a href="classpvr_1_1_invalid_argument_error.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1_invalid_data_error.html">InvalidDataError</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A simple std::runtime_error wrapper for throwing exceptions when invalid data is provided <a href="classpvr_1_1_invalid_data_error.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1_invalid_operation_error.html">InvalidOperationError</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A simple std::runtime_error wrapper for throwing exceptions when invalid operations are attempted <a href="classpvr_1_1_invalid_operation_error.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1_locked_queue.html">LockedQueue</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A simple adapter for the BlockingConcurrentQueue that just simplifies the common case <a href="classpvr_1_1_locked_queue.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1_multi.html">Multi</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A small statically allocated array This class represents a small array of items. The array is statically allocated, and has at most 255 items, usually 8. It is not meant to (and cannot) be used to store large numbers of items (use a std::vector instead), rather it is meant to hold small tuples of items. The PowerVR framework utilizes this class to store tuples of one-per-swap-image items <a href="classpvr_1_1_multi.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1_operation_failed_error.html">OperationFailedError</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A simple std::runtime_error wrapper for throwing exceptions when operations fail <a href="classpvr_1_1_operation_failed_error.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1_pixel_format.html">PixelFormat</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="classpvr_1_1_pixel_format.html" title="The PixelFormat class fully defines a Pixel Format (channels, format, compression, bit width etc.). ">PixelFormat</a> class fully defines a Pixel Format (channels, format, compression, bit width etc.).  <a href="classpvr_1_1_pixel_format.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1_plane3d.html">Plane3d</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Uses the plane equation Ax + By + Cz + D = 0, where A B C are plane normal, xyz are position on the plane and D is distance to the plane. <a href="classpvr_1_1_plane3d.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1_pvr_error.html">PvrError</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A simple std::runtime_error wrapper for throwing generic PVR exceptions <a href="classpvr_1_1_pvr_error.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpvr_1_1_rectangle.html">Rectangle</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A class representing an axis-aligned rectangle. Internal representation TopLeft and size.  <a href="structpvr_1_1_rectangle.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpvr_1_1_rectangle3_d.html">Rectangle3D</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A class representing an Axis-Aligned cuboidal region of 3D space. Internal representation offset defined as the absolute coordinates of one corner of the bounding region and extent which defines the second corner of the bounding region relative to the offset. <a href="structpvr_1_1_rectangle3_d.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1_ring_buffer.html">RingBuffer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A classic, templated, efficient <a class="el" href="classpvr_1_1_ring_buffer.html" title="A classic, templated, efficient RingBuffer implementation. Supports operations at both ends (front...">RingBuffer</a> implementation. Supports operations at both ends (front, back) and dynamic resizing when full. Does not at current implementations support iterators. <a href="classpvr_1_1_ring_buffer.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpvr_1_1_stencil_state.html">StencilState</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pipeline Stencil state <a href="structpvr_1_1_stencil_state.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1_stream.html">Stream</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class is used to abstract streams of data (files, blocks of memory, resources etc.). In general a stream is considered something that can be read or written from. Specializations for many different types of streams are provided by the PowerVR Framework, the most commonly used ones being Files and Memory. The common interface and pointer types allow the <a class="el" href="classpvr_1_1_stream.html" title="This class is used to abstract streams of data (files, blocks of memory, resources etc...">Stream</a> to abstract data in a very useful manner. Use the <a class="el" href="classpvr_1_1_stream.html#aa0cecaaaa443ce5895d8c3d69dcdeec2" title="The pointer type of the stream. This is the main handle used to pass nullable streams around...">Stream::ptr_type</a> to pass abstract streams around (it is actually an std::unique_ptr) <a href="classpvr_1_1_stream.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1_strided_buffer.html">StridedBuffer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Representation of raw data. Used to store raw data that is logically grouped in blocks with a stride. <a href="classpvr_1_1_strided_buffer.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1_string_hash.html">StringHash</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementation of a hashed std::string with functionality for fast compares. <a href="classpvr_1_1_string_hash.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpvr_1_1_swizzle_channels.html">SwizzleChannels</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="structpvr_1_1_swizzle_channels.html" title="The SwizzleChannels struct">SwizzleChannels</a> struct <a href="structpvr_1_1_swizzle_channels.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1_texture.html">Texture</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A 2D <a class="el" href="classpvr_1_1_texture.html" title="A 2D Texture asset, together with Information, Metadata and actual Pixel data. Only represents the ac...">Texture</a> asset, together with Information, Metadata and actual Pixel data. Only represents the actual data, not the API objects that may be created from it. <a href="classpvr_1_1_texture.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpvr_1_1_texture_area.html">TextureArea</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class used by texture update functions. Represents an area of the texture to be updated. Default value: width=1, height=1, (depth=1), offsetx=0,offsety=0,offsetz=0, arrayslice=0, cubeface=0, miplevel=0 <a href="structpvr_1_1_texture_area.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1_texture_header.html">TextureHeader</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A class mirroring the PVR <a class="el" href="classpvr_1_1_texture.html" title="A 2D Texture asset, together with Information, Metadata and actual Pixel data. Only represents the ac...">Texture</a> container format header, and which can in general represent any <a class="el" href="classpvr_1_1_texture.html" title="A 2D Texture asset, together with Information, Metadata and actual Pixel data. Only represents the ac...">Texture</a> asset. Contains accessors functions to facilitate using the <a class="el" href="classpvr_1_1_texture.html" title="A 2D Texture asset, together with Information, Metadata and actual Pixel data. Only represents the ac...">Texture</a> data in application code.  <a href="classpvr_1_1_texture_header.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1_texture_meta_data.html">TextureMetaData</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="classpvr_1_1_texture_meta_data.html" title="The TextureMetaData class contains metadata of a texture. Metadata is any information that a texture ...">TextureMetaData</a> class contains metadata of a texture. Metadata is any information that a texture could be correctly loaded from file without. In most cases, metadata may still be necessary to actually USE the texture, such as winding orders, paddings, atlas information and others. <a href="classpvr_1_1_texture_meta_data.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1_time.html">Time</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class provides functions for measuring time: current time, elapsed time etc. High performance timers are used if available by the platform. <a href="classpvr_1_1_time.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1_t_p_s_camera.html">TPSCamera</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A simple third person camera implementation <a href="classpvr_1_1_t_p_s_camera.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpvr_1_1_typed_mem.html">TypedMem</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents Free Value View that is backed by a (usually small) dynamically allocated block. <a href="structpvr_1_1_typed_mem.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1_unsupported_operation_error.html">UnsupportedOperationError</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A simple std::runtime_error wrapper for throwing exceptions when unsupported operations are attempted <a href="classpvr_1_1_unsupported_operation_error.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpvr_1_1_vertex_attribute_info.html">VertexAttributeInfo</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Contains a full description of a Vertex Attribute: Index, format, number of elements, offset in the buffer, optionally name. All values (except attributeName) must be set explicitly. <a href="structpvr_1_1_vertex_attribute_info.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpvr_1_1_vertex_attribute_info_with_binding.html">VertexAttributeInfoWithBinding</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A container struct carrying Vertex Attribute information (vertex layout, plus binding point) <a href="structpvr_1_1_vertex_attribute_info_with_binding.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpvr_1_1_vertex_attribute_layout.html">VertexAttributeLayout</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class contains all the information of a Vertex Attribute's layout inside a block of memory, typically a Vertex Buffer Object. This informations is normally the DataType of the attribute, the Offset (from the beginning of the array) and the width (how many values of type DataType form an attribute). <a href="structpvr_1_1_vertex_attribute_layout.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpvr_1_1_vertex_input_binding_info.html">VertexInputBindingInfo</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Information about a Buffer binding: Binding index, stride, (instance) step rate. <a href="structpvr_1_1_vertex_input_binding_info.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1_windows_resource_stream.html">WindowsResourceStream</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A <a class="el" href="classpvr_1_1_stream.html" title="This class is used to abstract streams of data (files, blocks of memory, resources etc...">Stream</a> implementation that is used to access resources built in a MS Windows executable.  <a href="classpvr_1_1_windows_resource_stream.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a04c7a237dd1eb5c7ab24a7895f06d9fd"><td class="memItemLeft" align="right" valign="top">typedef ::std::vector&lt; char &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr.html#a04c7a237dd1eb5c7ab24a7895f06d9fd">CharBuffer</a></td></tr>
<tr class="memdesc:a04c7a237dd1eb5c7ab24a7895f06d9fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a buffer of Unsigned Bytes. Used to store raw data. <a href="#a04c7a237dd1eb5c7ab24a7895f06d9fd">More...</a><br/></td></tr>
<tr class="separator:a04c7a237dd1eb5c7ab24a7895f06d9fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a065d965f04c53d6e94e0e56a34289090"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="structpvr_1_1_generic_extent2_d.html">GenericExtent2D</a>&lt; uint32_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr.html#a065d965f04c53d6e94e0e56a34289090">Extent2D</a></td></tr>
<tr class="memdesc:a065d965f04c53d6e94e0e56a34289090"><td class="mdescLeft">&#160;</td><td class="mdescRight">A 2D, integer Extent typically used for Images <a href="#a065d965f04c53d6e94e0e56a34289090">More...</a><br/></td></tr>
<tr class="separator:a065d965f04c53d6e94e0e56a34289090"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc7deef434e373b18abd3b929c31e9aa"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="structpvr_1_1_generic_extent3_d.html">GenericExtent3D</a><br class="typebreak"/>
&lt; uint32_t, uint32_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr.html#abc7deef434e373b18abd3b929c31e9aa">Extent3D</a></td></tr>
<tr class="memdesc:abc7deef434e373b18abd3b929c31e9aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">A 3D, integer Extent typically used for 3D Images <a href="#abc7deef434e373b18abd3b929c31e9aa">More...</a><br/></td></tr>
<tr class="separator:abc7deef434e373b18abd3b929c31e9aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c68f9a2f58eb4afee65dee64a84ec60"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="structpvr_1_1_generic_offset2_d.html">GenericOffset2D</a>&lt; int32_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr.html#a3c68f9a2f58eb4afee65dee64a84ec60">Offset2D</a></td></tr>
<tr class="memdesc:a3c68f9a2f58eb4afee65dee64a84ec60"><td class="mdescLeft">&#160;</td><td class="mdescRight">A 2D, integer Offset typically used for Images <a href="#a3c68f9a2f58eb4afee65dee64a84ec60">More...</a><br/></td></tr>
<tr class="separator:a3c68f9a2f58eb4afee65dee64a84ec60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c82b565cdd75fbf396893a67ce24f4d"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="structpvr_1_1_generic_offset3_d.html">GenericOffset3D</a><br class="typebreak"/>
&lt; int32_t, int32_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr.html#a9c82b565cdd75fbf396893a67ce24f4d">Offset3D</a></td></tr>
<tr class="memdesc:a9c82b565cdd75fbf396893a67ce24f4d"><td class="mdescLeft">&#160;</td><td class="mdescRight">A 3D, integer Offset typically used for 3D Images <a href="#a9c82b565cdd75fbf396893a67ce24f4d">More...</a><br/></td></tr>
<tr class="separator:a9c82b565cdd75fbf396893a67ce24f4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aedeecfbbd5f300d790a94b7f47277582"><td class="memItemLeft" align="right" valign="top">typedef void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr.html#aedeecfbbd5f300d790a94b7f47277582">OSApplication</a></td></tr>
<tr class="memdesc:aedeecfbbd5f300d790a94b7f47277582"><td class="mdescLeft">&#160;</td><td class="mdescRight">Native application type. <a href="#aedeecfbbd5f300d790a94b7f47277582">More...</a><br/></td></tr>
<tr class="separator:aedeecfbbd5f300d790a94b7f47277582"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6f2b93a38b04d593e40fb33ac919de9"><td class="memItemLeft" align="right" valign="top">typedef void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr.html#ac6f2b93a38b04d593e40fb33ac919de9">OSDATA</a></td></tr>
<tr class="memdesc:ac6f2b93a38b04d593e40fb33ac919de9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Native application data type. <a href="#ac6f2b93a38b04d593e40fb33ac919de9">More...</a><br/></td></tr>
<tr class="separator:ac6f2b93a38b04d593e40fb33ac919de9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb92095259cdb0e0a5013d243b8cdcad"><td class="memItemLeft" align="right" valign="top">typedef void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr.html#aeb92095259cdb0e0a5013d243b8cdcad">OSDisplay</a></td></tr>
<tr class="memdesc:aeb92095259cdb0e0a5013d243b8cdcad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Native display type. <a href="#aeb92095259cdb0e0a5013d243b8cdcad">More...</a><br/></td></tr>
<tr class="separator:aeb92095259cdb0e0a5013d243b8cdcad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a3c2268d5e5b11e1bc9cf97d7c337e8"><td class="memItemLeft" align="right" valign="top">typedef void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr.html#a4a3c2268d5e5b11e1bc9cf97d7c337e8">OSWindow</a></td></tr>
<tr class="memdesc:a4a3c2268d5e5b11e1bc9cf97d7c337e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Native window type. <a href="#a4a3c2268d5e5b11e1bc9cf97d7c337e8">More...</a><br/></td></tr>
<tr class="separator:a4a3c2268d5e5b11e1bc9cf97d7c337e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc19de2d5b6952c2d5471033aa4f2563"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="structpvr_1_1_rectangle3_d.html">Rectangle3D</a>&lt; float &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr.html#afc19de2d5b6952c2d5471033aa4f2563">Rectangle3Df</a></td></tr>
<tr class="memdesc:afc19de2d5b6952c2d5471033aa4f2563"><td class="mdescLeft">&#160;</td><td class="mdescRight">A float 3D rectangle <a href="#afc19de2d5b6952c2d5471033aa4f2563">More...</a><br/></td></tr>
<tr class="separator:afc19de2d5b6952c2d5471033aa4f2563"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a799b34b4c6caf281d54db6a9756dc39d"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="structpvr_1_1_rectangle3_d.html">Rectangle3D</a>&lt; int32_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr.html#a799b34b4c6caf281d54db6a9756dc39d">Rectangle3Di</a></td></tr>
<tr class="memdesc:a799b34b4c6caf281d54db6a9756dc39d"><td class="mdescLeft">&#160;</td><td class="mdescRight">An integer 3D rectangle <a href="#a799b34b4c6caf281d54db6a9756dc39d">More...</a><br/></td></tr>
<tr class="separator:a799b34b4c6caf281d54db6a9756dc39d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba0728db2b6aa21ad82b263a102fec44"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="structpvr_1_1_rectangle.html">Rectangle</a>&lt; float &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr.html#aba0728db2b6aa21ad82b263a102fec44">Rectanglef</a></td></tr>
<tr class="memdesc:aba0728db2b6aa21ad82b263a102fec44"><td class="mdescLeft">&#160;</td><td class="mdescRight">A floating point 2D rectangle <a href="#aba0728db2b6aa21ad82b263a102fec44">More...</a><br/></td></tr>
<tr class="separator:aba0728db2b6aa21ad82b263a102fec44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a779802ae077693e9183007cfbedf47d4"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="structpvr_1_1_rectangle.html">Rectangle</a>&lt; int32_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr.html#a779802ae077693e9183007cfbedf47d4">Rectanglei</a></td></tr>
<tr class="memdesc:a779802ae077693e9183007cfbedf47d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">An integer 2D rectangle <a href="#a779802ae077693e9183007cfbedf47d4">More...</a><br/></td></tr>
<tr class="separator:a779802ae077693e9183007cfbedf47d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d599bef48e61e7de820debff386447e"><td class="memItemLeft" align="right" valign="top">typedef ::std::vector&lt; uint8_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr.html#a6d599bef48e61e7de820debff386447e">UInt8Buffer</a></td></tr>
<tr class="memdesc:a6d599bef48e61e7de820debff386447e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a buffer of Unsigned Bytes. Used to store raw data. <a href="#a6d599bef48e61e7de820debff386447e">More...</a><br/></td></tr>
<tr class="separator:a6d599bef48e61e7de820debff386447e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f1b3a4b714cc874e267883662058a19"><td class="memItemLeft" align="right" valign="top">typedef unsigned short&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr.html#a2f1b3a4b714cc874e267883662058a19">utf16</a></td></tr>
<tr class="memdesc:a2f1b3a4b714cc874e267883662058a19"><td class="mdescLeft">&#160;</td><td class="mdescRight">A UTF-16 (unsigned) character. 16-bit unsigned Integer. <a href="#a2f1b3a4b714cc874e267883662058a19">More...</a><br/></td></tr>
<tr class="separator:a2f1b3a4b714cc874e267883662058a19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae281450f4795e25d5ce35d674b17249b"><td class="memItemLeft" align="right" valign="top">typedef unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr.html#ae281450f4795e25d5ce35d674b17249b">utf32</a></td></tr>
<tr class="memdesc:ae281450f4795e25d5ce35d674b17249b"><td class="mdescLeft">&#160;</td><td class="mdescRight">A UTF-32 (unsigned) character. 32-bit unsigned Integer. <a href="#ae281450f4795e25d5ce35d674b17249b">More...</a><br/></td></tr>
<tr class="separator:ae281450f4795e25d5ce35d674b17249b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ee58768dfb56ed9216c98178d572e17"><td class="memItemLeft" align="right" valign="top">typedef unsigned char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr.html#a9ee58768dfb56ed9216c98178d572e17">utf8</a></td></tr>
<tr class="memdesc:a9ee58768dfb56ed9216c98178d572e17"><td class="mdescLeft">&#160;</td><td class="mdescRight">A UTF-8 (unsigned) character. 8-bit unsigned Integer. <a href="#a9ee58768dfb56ed9216c98178d572e17">More...</a><br/></td></tr>
<tr class="separator:a9ee58768dfb56ed9216c98178d572e17"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:aa46a7b909f63be7b061dd6fedbc66dfc"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom">{ <b>pvrTextureAllMipMaps</b> = -1
 }</td></tr>
<tr class="memdesc:aa46a7b909f63be7b061dd6fedbc66dfc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flag interpreted as All mipmap levels. <a href="namespacepvr.html#aa46a7b909f63be7b061dd6fedbc66dfc">More...</a><br/></td></tr>
<tr class="separator:aa46a7b909f63be7b061dd6fedbc66dfc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74c5d1afa51512f076dd8e5844b171c8"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr.html#a74c5d1afa51512f076dd8e5844b171c8">Api</a> { <br/>
&#160;&#160;<b>Unspecified</b> = 0, 
<b>OpenGLES2</b>, 
<b>OpenGLES3</b>, 
<b>OpenGLES31</b>, 
<br/>
&#160;&#160;<b>OpenGLESMaxVersion</b> = OpenGLES31, 
<b>Vulkan</b>, 
<b>NumApis</b>
<br/>
 }</td></tr>
<tr class="memdesc:a74c5d1afa51512f076dd8e5844b171c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enumeration of all API types supported by this implementation <a href="namespacepvr.html#a74c5d1afa51512f076dd8e5844b171c8">More...</a><br/></td></tr>
<tr class="separator:a74c5d1afa51512f076dd8e5844b171c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc560f133c0bcec5adff02183b4a9386"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr.html#afc560f133c0bcec5adff02183b4a9386">BlendFactor</a> : uint8_t { <br/>
&#160;&#160;<a class="el" href="namespacepvr.html#afc560f133c0bcec5adff02183b4a9386ad7ed4ee1df437474d005188535f74875">BlendFactor::Zero</a>, 
<a class="el" href="namespacepvr.html#afc560f133c0bcec5adff02183b4a9386a06c2cea18679d64399783748fa367bdd">BlendFactor::One</a>, 
<a class="el" href="namespacepvr.html#afc560f133c0bcec5adff02183b4a9386a2ad714e29d37896d79187312086bc6fe">BlendFactor::SrcColor</a>, 
<a class="el" href="namespacepvr.html#afc560f133c0bcec5adff02183b4a9386a09d3240b4e2481b1a729da24e9bfddf7">BlendFactor::OneMinusSrcColor</a>, 
<br/>
&#160;&#160;<a class="el" href="namespacepvr.html#afc560f133c0bcec5adff02183b4a9386afaedf511c99a5461048fd6a3b73da26c">BlendFactor::DstColor</a>, 
<a class="el" href="namespacepvr.html#afc560f133c0bcec5adff02183b4a9386a09f1a054ebd4d3850fd248bd2fa7b325">BlendFactor::OneMinusDstColor</a>, 
<a class="el" href="namespacepvr.html#afc560f133c0bcec5adff02183b4a9386ad5c7b7f0102df3f7305c43f73fc3a498">BlendFactor::SrcAlpha</a>, 
<a class="el" href="namespacepvr.html#afc560f133c0bcec5adff02183b4a9386ac00a6016489cff63d50d489ce52254cc">BlendFactor::OneMinusSrcAlpha</a>, 
<br/>
&#160;&#160;<a class="el" href="namespacepvr.html#afc560f133c0bcec5adff02183b4a9386af72dbe2436b38a39e5927ed644e6818b">BlendFactor::DstAlpha</a>, 
<a class="el" href="namespacepvr.html#afc560f133c0bcec5adff02183b4a9386a4132e4b87a8d461be2c6ee8fc620cfb2">BlendFactor::OneMinusDstAlpha</a>, 
<a class="el" href="namespacepvr.html#afc560f133c0bcec5adff02183b4a9386aeb8eb99f8eea9079c0e76d5ce7301dd3">BlendFactor::ConstantColor</a>, 
<a class="el" href="namespacepvr.html#afc560f133c0bcec5adff02183b4a9386a13ab8deb1c606ab17745354b4e92f43a">BlendFactor::OneMinusConstantColor</a>, 
<br/>
&#160;&#160;<a class="el" href="namespacepvr.html#afc560f133c0bcec5adff02183b4a9386a6f0229db491c3b01860363456dc57288">BlendFactor::ConstantAlpha</a>, 
<a class="el" href="namespacepvr.html#afc560f133c0bcec5adff02183b4a9386a9a1874144125c69e93ec99f17e985e41">BlendFactor::OneMinusConstantAlpha</a>, 
<a class="el" href="namespacepvr.html#afc560f133c0bcec5adff02183b4a9386a87c65d6ae5c79e8a05482365776bd959">BlendFactor::Src1Color</a>, 
<a class="el" href="namespacepvr.html#afc560f133c0bcec5adff02183b4a9386ac1686472488cf32c06cc257f4e8ac04f">BlendFactor::OneMinusSrc1Color</a>, 
<br/>
&#160;&#160;<a class="el" href="namespacepvr.html#afc560f133c0bcec5adff02183b4a9386aa69d96453c025ed62b3276e892e59e39">BlendFactor::Src1Alpha</a>, 
<a class="el" href="namespacepvr.html#afc560f133c0bcec5adff02183b4a9386a88dfdcc65a80f412d0330f00579ab7f2">BlendFactor::OneMinusSrc1Alpha</a>, 
<b>NumBlendFactor</b>, 
<b>DefaultSrcRgba</b> = One, 
<br/>
&#160;&#160;<b>DefaultDestRgba</b> = Zero
<br/>
 }</td></tr>
<tr class="memdesc:afc560f133c0bcec5adff02183b4a9386"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specfies how the rgba blending facors are computed for source and destination fragments. <a href="namespacepvr.html#afc560f133c0bcec5adff02183b4a9386">More...</a><br/></td></tr>
<tr class="separator:afc560f133c0bcec5adff02183b4a9386"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78be6b6f15903b90d6a9d575ebf6d353"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr.html#a78be6b6f15903b90d6a9d575ebf6d353">BlendOp</a> : uint32_t { <br/>
&#160;&#160;<a class="el" href="namespacepvr.html#a78be6b6f15903b90d6a9d575ebf6d353aec211f7c20af43e742bf2570c3cb84f9">BlendOp::Add</a>, 
<a class="el" href="namespacepvr.html#a78be6b6f15903b90d6a9d575ebf6d353a1d9baf077ee87921f57a8fe42d510b65">BlendOp::Subtract</a>, 
<a class="el" href="namespacepvr.html#a78be6b6f15903b90d6a9d575ebf6d353abd5458190996e76988cb2f27a820c685">BlendOp::ReverseSubtract</a>, 
<a class="el" href="namespacepvr.html#a78be6b6f15903b90d6a9d575ebf6d353a78d811e98514cd165dda532286610fd2">BlendOp::Min</a>, 
<br/>
&#160;&#160;<a class="el" href="namespacepvr.html#a78be6b6f15903b90d6a9d575ebf6d353a6a061313d22e51e0f25b7cd4dc065233">BlendOp::Max</a>, 
<b>NumBlendFunc</b>, 
<b>Default</b> = Add
<br/>
 }</td></tr>
<tr class="memdesc:a78be6b6f15903b90d6a9d575ebf6d353"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enumeration of the blend operations (determine how a new pixel (source color) is combined with a pixel already in the framebuffer (destination color). <a href="namespacepvr.html#a78be6b6f15903b90d6a9d575ebf6d353">More...</a><br/></td></tr>
<tr class="separator:a78be6b6f15903b90d6a9d575ebf6d353"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6ac287ad32e4b14937cee7ac81fb85e"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr.html#aa6ac287ad32e4b14937cee7ac81fb85e">BufferUsageFlags</a> : uint32_t { <br/>
&#160;&#160;<a class="el" href="namespacepvr.html#aa6ac287ad32e4b14937cee7ac81fb85eac1b703f2c13fac2fff3e72d3e307d4c0">BufferUsageFlags::TransferSrc</a> = 0x00000001, 
<a class="el" href="namespacepvr.html#aa6ac287ad32e4b14937cee7ac81fb85ea155895f4426d6fc97295ca2de160fd20">BufferUsageFlags::TransferDest</a> = 0x00000002, 
<a class="el" href="namespacepvr.html#aa6ac287ad32e4b14937cee7ac81fb85ea4b43da703340c8273da56cf3445c6754">BufferUsageFlags::UniformTexelBuffer</a> = 0x00000004, 
<a class="el" href="namespacepvr.html#aa6ac287ad32e4b14937cee7ac81fb85eaae1f93780c3073aeadaf118d550f0c65">BufferUsageFlags::StorageTexelBuffer</a> = 0x00000008, 
<br/>
&#160;&#160;<a class="el" href="namespacepvr.html#aa6ac287ad32e4b14937cee7ac81fb85ea88f133adfed6c854e5731cdffbf208cf">BufferUsageFlags::UniformBuffer</a> = 0x00000010, 
<a class="el" href="namespacepvr.html#aa6ac287ad32e4b14937cee7ac81fb85ea439f57c2c466c89db942b3de48298b2b">BufferUsageFlags::StorageBuffer</a> = 0x00000020, 
<a class="el" href="namespacepvr.html#aa6ac287ad32e4b14937cee7ac81fb85ea7c3895116254ff0417e58b6286de27c0">BufferUsageFlags::IndexBuffer</a> = 0x00000040, 
<a class="el" href="namespacepvr.html#aa6ac287ad32e4b14937cee7ac81fb85ea10461f19cdb5aadba2fc9986be6400bd">BufferUsageFlags::VertexBuffer</a> = 0x00000080, 
<br/>
&#160;&#160;<a class="el" href="namespacepvr.html#aa6ac287ad32e4b14937cee7ac81fb85ea7e5abafe55b7f7e20d417fe9c967d69e">BufferUsageFlags::IndirectBuffer</a> = 0x00000100, 
<b>Count</b> = 10
<br/>
 }</td></tr>
<tr class="memdesc:aa6ac287ad32e4b14937cee7ac81fb85e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enumeration of all supported buffer use types. <a href="namespacepvr.html#aa6ac287ad32e4b14937cee7ac81fb85e">More...</a><br/></td></tr>
<tr class="separator:aa6ac287ad32e4b14937cee7ac81fb85e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9ca1aead0a3149b0af3842d03bc6cd4"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr.html#af9ca1aead0a3149b0af3842d03bc6cd4">Capability</a> : uint8_t { <a class="el" href="namespacepvr.html#af9ca1aead0a3149b0af3842d03bc6cd4ab4080bdf74febf04d578ff105cce9d3f">Capability::Unsupported</a>, 
<a class="el" href="namespacepvr.html#af9ca1aead0a3149b0af3842d03bc6cd4a11efd9ae6f76e706e3f1b34d97584ebc">Capability::Immutable</a>, 
<a class="el" href="namespacepvr.html#af9ca1aead0a3149b0af3842d03bc6cd4ad924522d30d6615e9f71e91504364a9d">Capability::Mutable</a>
 }</td></tr>
<tr class="memdesc:af9ca1aead0a3149b0af3842d03bc6cd4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Capability supported values. <a href="namespacepvr.html#af9ca1aead0a3149b0af3842d03bc6cd4">More...</a><br/></td></tr>
<tr class="separator:af9ca1aead0a3149b0af3842d03bc6cd4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a675b14a2f2079f7f72e7f2ad35d13de7"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr.html#a675b14a2f2079f7f72e7f2ad35d13de7">ColorChannelFlags</a> : uint32_t { <br/>
&#160;&#160;<a class="el" href="namespacepvr.html#a675b14a2f2079f7f72e7f2ad35d13de7ae1e1d3d40573127e9ee0480caf1283d6">ColorChannelFlags::R</a> = 0x01, 
<a class="el" href="namespacepvr.html#a675b14a2f2079f7f72e7f2ad35d13de7adfcf28d0734569a6a693bc8194de62bf">ColorChannelFlags::G</a> = 0x02, 
<a class="el" href="namespacepvr.html#a675b14a2f2079f7f72e7f2ad35d13de7a9d5ed678fe57bcca610140957afab571">ColorChannelFlags::B</a> = 0x04, 
<a class="el" href="namespacepvr.html#a675b14a2f2079f7f72e7f2ad35d13de7a7fc56270e7a70fa81a5935b72eacbe29">ColorChannelFlags::A</a> = 0x08, 
<br/>
&#160;&#160;<a class="el" href="namespacepvr.html#a675b14a2f2079f7f72e7f2ad35d13de7a6adf97f83acf6453d4a6a4b1070f3754">ColorChannelFlags::None</a> = 0, 
<b>All</b> = R | G | B | A
<br/>
 }</td></tr>
<tr class="memdesc:a675b14a2f2079f7f72e7f2ad35d13de7"><td class="mdescLeft">&#160;</td><td class="mdescRight">ChannelWriteMask enable/ disable writting to channel bits. <a href="namespacepvr.html#a675b14a2f2079f7f72e7f2ad35d13de7">More...</a><br/></td></tr>
<tr class="separator:a675b14a2f2079f7f72e7f2ad35d13de7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b94afe6b8a7c21e8f8ddee1f7b5cb91"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr.html#a1b94afe6b8a7c21e8f8ddee1f7b5cb91">ColorSpace</a> { <a class="el" href="namespacepvr.html#a1b94afe6b8a7c21e8f8ddee1f7b5cb91a4c8bf835da6d934b50f620cdd0cc3913">ColorSpace::lRGB</a>, 
<a class="el" href="namespacepvr.html#a1b94afe6b8a7c21e8f8ddee1f7b5cb91a9ed33d9be17d174aeb4393a989586ed9">ColorSpace::sRGB</a>, 
<b>NumSpaces</b>
 }</td></tr>
<tr class="memdesc:a1b94afe6b8a7c21e8f8ddee1f7b5cb91"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enumeration of Colorspaces (Linear, SRGB). <a href="namespacepvr.html#a1b94afe6b8a7c21e8f8ddee1f7b5cb91">More...</a><br/></td></tr>
<tr class="separator:a1b94afe6b8a7c21e8f8ddee1f7b5cb91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24a87498f839b45b6e1bc3c8b2ca20fc"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr.html#a24a87498f839b45b6e1bc3c8b2ca20fc">CompareOp</a> : uint32_t { <br/>
&#160;&#160;<a class="el" href="namespacepvr.html#a24a87498f839b45b6e1bc3c8b2ca20fca6e7b34fa59e1bd229b207892956dc41c">CompareOp::Never</a> = 0, 
<a class="el" href="namespacepvr.html#a24a87498f839b45b6e1bc3c8b2ca20fca1cfdf0e8d0c87a228c1f40d9bee7888b">CompareOp::Less</a> = 1, 
<a class="el" href="namespacepvr.html#a24a87498f839b45b6e1bc3c8b2ca20fcaf5f286e73bda105e538310b3190f75c5">CompareOp::Equal</a> = 2, 
<a class="el" href="namespacepvr.html#a24a87498f839b45b6e1bc3c8b2ca20fcad3e6fdac55bb7b0edd7834c968ba1f38">CompareOp::LessEqual</a> = 3, 
<br/>
&#160;&#160;<a class="el" href="namespacepvr.html#a24a87498f839b45b6e1bc3c8b2ca20fca8768a6821cd735aea4f5b0df88c1fc6a">CompareOp::Greater</a> = 4, 
<a class="el" href="namespacepvr.html#a24a87498f839b45b6e1bc3c8b2ca20fca19bb0af2c3c530538cb41aff7f235b96">CompareOp::NotEqual</a> = 5, 
<a class="el" href="namespacepvr.html#a24a87498f839b45b6e1bc3c8b2ca20fca758b05d899def79c9eb864ad4f96be1f">CompareOp::GreaterEqual</a> = 6, 
<a class="el" href="namespacepvr.html#a24a87498f839b45b6e1bc3c8b2ca20fca68eec46437c384d8dad18d5464ebc35c">CompareOp::Always</a> = 7, 
<br/>
&#160;&#160;<b>NumComparisonMode</b>, 
<b>DefaultDepthFunc</b> = Less, 
<b>DefaultStencilFunc</b> = Always
<br/>
 }</td></tr>
<tr class="memdesc:a24a87498f839b45b6e1bc3c8b2ca20fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">An enumeration that defines Comparison operations (equal, less or equal etc.). Especially used in API classes for functions like depth testing. <a href="namespacepvr.html#a24a87498f839b45b6e1bc3c8b2ca20fc">More...</a><br/></td></tr>
<tr class="separator:a24a87498f839b45b6e1bc3c8b2ca20fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7cfc7d042b44f46e4d5dfbb32d0f16b1"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr.html#a7cfc7d042b44f46e4d5dfbb32d0f16b1">CompressedPixelFormat</a> { <br/>
&#160;&#160;<b>PVRTCI_2bpp_RGB</b>, 
<b>PVRTCI_2bpp_RGBA</b>, 
<b>PVRTCI_4bpp_RGB</b>, 
<b>PVRTCI_4bpp_RGBA</b>, 
<br/>
&#160;&#160;<b>PVRTCII_2bpp</b>, 
<b>PVRTCII_4bpp</b>, 
<b>ETC1</b>, 
<b>DXT1</b>, 
<br/>
&#160;&#160;<b>DXT2</b>, 
<b>DXT3</b>, 
<b>DXT4</b>, 
<b>DXT5</b>, 
<br/>
&#160;&#160;<b>BC1</b> = DXT1, 
<b>BC2</b> = DXT3, 
<b>BC3</b> = DXT5, 
<b>BC4</b>, 
<br/>
&#160;&#160;<b>BC5</b>, 
<b>BC6</b>, 
<b>BC7</b>, 
<b>UYVY</b>, 
<br/>
&#160;&#160;<b>YUY2</b>, 
<b>BW1bpp</b>, 
<b>SharedExponentR9G9B9E5</b>, 
<b>RGBG8888</b>, 
<br/>
&#160;&#160;<b>GRGB8888</b>, 
<b>ETC2_RGB</b>, 
<b>ETC2_RGBA</b>, 
<b>ETC2_RGB_A1</b>, 
<br/>
&#160;&#160;<b>EAC_R11</b>, 
<b>EAC_RG11</b>, 
<b>ASTC_4x4</b>, 
<b>ASTC_5x4</b>, 
<br/>
&#160;&#160;<b>ASTC_5x5</b>, 
<b>ASTC_6x5</b>, 
<b>ASTC_6x6</b>, 
<b>ASTC_8x5</b>, 
<br/>
&#160;&#160;<b>ASTC_8x6</b>, 
<b>ASTC_8x8</b>, 
<b>ASTC_10x5</b>, 
<b>ASTC_10x6</b>, 
<br/>
&#160;&#160;<b>ASTC_10x8</b>, 
<b>ASTC_10x10</b>, 
<b>ASTC_12x10</b>, 
<b>ASTC_12x12</b>, 
<br/>
&#160;&#160;<b>ASTC_3x3x3</b>, 
<b>ASTC_4x3x3</b>, 
<b>ASTC_4x4x3</b>, 
<b>ASTC_4x4x4</b>, 
<br/>
&#160;&#160;<b>ASTC_5x4x4</b>, 
<b>ASTC_5x5x4</b>, 
<b>ASTC_5x5x5</b>, 
<b>ASTC_6x5x5</b>, 
<br/>
&#160;&#160;<b>ASTC_6x6x5</b>, 
<b>ASTC_6x6x6</b>, 
<b>NumCompressedPFs</b>
<br/>
 }</td></tr>
<tr class="memdesc:a7cfc7d042b44f46e4d5dfbb32d0f16b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enumeration of all known Compressed pixel formats. <a href="namespacepvr.html#a7cfc7d042b44f46e4d5dfbb32d0f16b1">More...</a><br/></td></tr>
<tr class="separator:a7cfc7d042b44f46e4d5dfbb32d0f16b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e463dd072d8bc9dd455491d1a663668"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr.html#a0e463dd072d8bc9dd455491d1a663668">Constants</a> { <br/>
&#160;&#160;<b>PVRTEX_MIPMAP</b> = (1 &lt;&lt; 8), 
<a class="el" href="namespacepvr.html#a0e463dd072d8bc9dd455491d1a663668a23671adbbb6b36b70a41c08602e2564f">PVRTEX_TWIDDLE</a> = (1 &lt;&lt; 9), 
<a class="el" href="namespacepvr.html#a0e463dd072d8bc9dd455491d1a663668ab99b95a8d3e3a09915f701ebd11669e0">PVRTEX_BUMPMAP</a> = (1 &lt;&lt; 10), 
<a class="el" href="namespacepvr.html#a0e463dd072d8bc9dd455491d1a663668a5e73cc8fec9a5861208b97999f1cd0b2">PVRTEX_TILING</a> = (1 &lt;&lt; 11), 
<br/>
&#160;&#160;<a class="el" href="namespacepvr.html#a0e463dd072d8bc9dd455491d1a663668a80424d056ec65d5439dc169f1d35b625">PVRTEX_CUBEMAP</a> = (1 &lt;&lt; 12), 
<a class="el" href="namespacepvr.html#a0e463dd072d8bc9dd455491d1a663668aad5d7bfcceebb69cd04ae90c0d908d5b">PVRTEX_FALSEMIPCOL</a> = (1 &lt;&lt; 13), 
<a class="el" href="namespacepvr.html#a0e463dd072d8bc9dd455491d1a663668aaa409129950b394648312efe10d36586">PVRTEX_VOLUME</a> = (1 &lt;&lt; 14), 
<a class="el" href="namespacepvr.html#a0e463dd072d8bc9dd455491d1a663668a572250b03ef82171e377f9c87fa5e25f">PVRTEX_ALPHA</a> = (1 &lt;&lt; 15), 
<br/>
&#160;&#160;<a class="el" href="namespacepvr.html#a0e463dd072d8bc9dd455491d1a663668aab9c48c3d41c2cc10f01442e1856b77c">PVRTEX_VERTICAL_FLIP</a> = (1 &lt;&lt; 16), 
<a class="el" href="namespacepvr.html#a0e463dd072d8bc9dd455491d1a663668a691f6acd2426ef4b6dfbecaec8600b13">PVRTEX_PIXELTYPE</a> = 0xff, 
<a class="el" href="namespacepvr.html#a0e463dd072d8bc9dd455491d1a663668a365c121026e2901f535781d41d93d3da">PVRTEX_IDENTIFIER</a> = 0x21525650, 
<a class="el" href="namespacepvr.html#a0e463dd072d8bc9dd455491d1a663668aff34d9bbfcc9a6c42a07476cf6661cd9">PVRTEX_V1_HEADER_SIZE</a> = 44, 
<br/>
&#160;&#160;<a class="el" href="namespacepvr.html#a0e463dd072d8bc9dd455491d1a663668a7ec982a2d890d48cae143c5970765ecf">PVRTC2_MIN_TEXWIDTH</a> = 16, 
<a class="el" href="namespacepvr.html#a0e463dd072d8bc9dd455491d1a663668ae3decd2de15588863ccea790249edc0a">PVRTC2_MIN_TEXHEIGHT</a> = 8, 
<a class="el" href="namespacepvr.html#a0e463dd072d8bc9dd455491d1a663668a997b74fc5e403a09bdb4faf5b352f7b4">PVRTC4_MIN_TEXWIDTH</a> = 8, 
<a class="el" href="namespacepvr.html#a0e463dd072d8bc9dd455491d1a663668a1a04f251581dd946893556f0dce39d1a">PVRTC4_MIN_TEXHEIGHT</a> = 8
<br/>
 }</td></tr>
<tr class="memdesc:a0e463dd072d8bc9dd455491d1a663668"><td class="mdescLeft">&#160;</td><td class="mdescRight">Legacy constants (V1/V2) <a href="namespacepvr.html#a0e463dd072d8bc9dd455491d1a663668">More...</a><br/></td></tr>
<tr class="separator:a0e463dd072d8bc9dd455491d1a663668"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87b409df225dee78541eb74988f4e20c"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr.html#a87b409df225dee78541eb74988f4e20c">CubeFace</a> : uint32_t { <br/>
&#160;&#160;<a class="el" href="namespacepvr.html#a87b409df225dee78541eb74988f4e20ca9f082d04c481aab268b9f614d2ffd129">CubeFace::PositiveX</a> = 0, 
<a class="el" href="namespacepvr.html#a87b409df225dee78541eb74988f4e20ca963a8a64a09d54efc81b136ca6be21b2">CubeFace::NegativeX</a>, 
<a class="el" href="namespacepvr.html#a87b409df225dee78541eb74988f4e20cac53c385ced96bd629c0f45a902aceba3">CubeFace::PositiveY</a>, 
<a class="el" href="namespacepvr.html#a87b409df225dee78541eb74988f4e20cae4d5f02ceecd15caf66e9f0b2393c86b">CubeFace::NegativeY</a>, 
<br/>
&#160;&#160;<a class="el" href="namespacepvr.html#a87b409df225dee78541eb74988f4e20ca1921c16ffdafaf04e378ca1b6774c0ce">CubeFace::PositiveZ</a>, 
<a class="el" href="namespacepvr.html#a87b409df225dee78541eb74988f4e20cada76df034cd139bd515761c8bb8e3090">CubeFace::NegativeZ</a>
<br/>
 }</td></tr>
<tr class="memdesc:a87b409df225dee78541eb74988f4e20c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enumeration of the six faces of a Cube <a href="namespacepvr.html#a87b409df225dee78541eb74988f4e20c">More...</a><br/></td></tr>
<tr class="separator:a87b409df225dee78541eb74988f4e20c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7924324f96dc973225ad3c532cc72309"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr.html#a7924324f96dc973225ad3c532cc72309">DataType</a> { <br/>
&#160;&#160;<a class="el" href="namespacepvr.html#a7924324f96dc973225ad3c532cc72309a6adf97f83acf6453d4a6a4b1070f3754">DataType::None</a>, 
<a class="el" href="namespacepvr.html#a7924324f96dc973225ad3c532cc72309a166495adc0d0f53bee6baecc577f5204">DataType::Float32</a>, 
<a class="el" href="namespacepvr.html#a7924324f96dc973225ad3c532cc72309ac06129f6e6e15c09328365e553f1dc31">DataType::Int32</a>, 
<a class="el" href="namespacepvr.html#a7924324f96dc973225ad3c532cc72309a8bd950a9d7779b83f5c30046c9aaf1cf">DataType::UInt16</a>, 
<br/>
&#160;&#160;<a class="el" href="namespacepvr.html#a7924324f96dc973225ad3c532cc72309aea3495a278957dc58165e48a8945469f">DataType::RGBA</a>, 
<a class="el" href="namespacepvr.html#a7924324f96dc973225ad3c532cc72309ae192297ecf3602fabbec5f0a38ede758">DataType::ARGB</a>, 
<a class="el" href="namespacepvr.html#a7924324f96dc973225ad3c532cc72309a67cb8b94254acbfda2cdf7a916421298">DataType::D3DCOLOR</a>, 
<a class="el" href="namespacepvr.html#a7924324f96dc973225ad3c532cc72309aa061360f8e01902202f21849c40a1105">DataType::UBYTE4</a>, 
<br/>
&#160;&#160;<a class="el" href="namespacepvr.html#a7924324f96dc973225ad3c532cc72309aff4e3dcc2ead0fa54993ccbf4eda1ae8">DataType::DEC3N</a>, 
<a class="el" href="namespacepvr.html#a7924324f96dc973225ad3c532cc72309a32e326bf2ef732551075db8987a1408c">DataType::Fixed16_16</a>, 
<a class="el" href="namespacepvr.html#a7924324f96dc973225ad3c532cc72309ab31df9c476d20e85ff898121efe11b5a">DataType::UInt8</a>, 
<a class="el" href="namespacepvr.html#a7924324f96dc973225ad3c532cc72309a39bc2ae44b184207f560ff8619823208">DataType::Int16</a>, 
<br/>
&#160;&#160;<a class="el" href="namespacepvr.html#a7924324f96dc973225ad3c532cc72309a0f224678669aa9f1b9e9dee8c544912a">DataType::Int16Norm</a>, 
<a class="el" href="namespacepvr.html#a7924324f96dc973225ad3c532cc72309a7d839b2c12bfd40ac121b4cc9e81c539">DataType::Int8</a>, 
<a class="el" href="namespacepvr.html#a7924324f96dc973225ad3c532cc72309a74f0eeb95bdbf29bcc7eb2b6431c13f2">DataType::Int8Norm</a>, 
<a class="el" href="namespacepvr.html#a7924324f96dc973225ad3c532cc72309a784d359bf21cc07236f54855d9aab91a">DataType::UInt8Norm</a>, 
<br/>
&#160;&#160;<a class="el" href="namespacepvr.html#a7924324f96dc973225ad3c532cc72309ab296ec5fbf49139c807bd99ba7f7dee8">DataType::UInt16Norm</a>, 
<a class="el" href="namespacepvr.html#a7924324f96dc973225ad3c532cc72309ae7956ed7be1c5025a27ed3cb42a396bd">DataType::UInt32</a>, 
<a class="el" href="namespacepvr.html#a7924324f96dc973225ad3c532cc72309adce7d10c2f9ffc8ed9e7b6a3f7d8ba6c">DataType::ABGR</a>, 
<a class="el" href="namespacepvr.html#a7924324f96dc973225ad3c532cc72309a26e6ed77470c6f2f830ecf874e6c0d55">DataType::Float16</a>, 
<br/>
&#160;&#160;<b>Custom</b> = 1000
<br/>
 }</td></tr>
<tr class="memdesc:a7924324f96dc973225ad3c532cc72309"><td class="mdescLeft">&#160;</td><td class="mdescRight">An enumeration that defines data types used throughout the Framework. Commonly used in places where raw data are used to define the types actually contained. <a href="namespacepvr.html#a7924324f96dc973225ad3c532cc72309">More...</a><br/></td></tr>
<tr class="separator:a7924324f96dc973225ad3c532cc72309"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3283c5c9822ac5135fefd45a7cdd5932"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr.html#a3283c5c9822ac5135fefd45a7cdd5932">DescriptorType</a> : uint32_t { <br/>
&#160;&#160;<a class="el" href="namespacepvr.html#a3283c5c9822ac5135fefd45a7cdd5932a5bca2f066df1fe641b2b779db2a63c0a">DescriptorType::Sampler</a>, 
<a class="el" href="namespacepvr.html#a3283c5c9822ac5135fefd45a7cdd5932a8cfe077ac9aea5235b0c3fda85914029">DescriptorType::CombinedImageSampler</a>, 
<a class="el" href="namespacepvr.html#a3283c5c9822ac5135fefd45a7cdd5932a4520c597ce328c250d1ca5192047d71d">DescriptorType::SampledImage</a>, 
<a class="el" href="namespacepvr.html#a3283c5c9822ac5135fefd45a7cdd5932aa078fa7ad769f9e7b53b8c42e3b7bbab">DescriptorType::StorageImage</a>, 
<br/>
&#160;&#160;<a class="el" href="namespacepvr.html#a3283c5c9822ac5135fefd45a7cdd5932a4b43da703340c8273da56cf3445c6754">DescriptorType::UniformTexelBuffer</a>, 
<a class="el" href="namespacepvr.html#a3283c5c9822ac5135fefd45a7cdd5932aae1f93780c3073aeadaf118d550f0c65">DescriptorType::StorageTexelBuffer</a>, 
<a class="el" href="namespacepvr.html#a3283c5c9822ac5135fefd45a7cdd5932a88f133adfed6c854e5731cdffbf208cf">DescriptorType::UniformBuffer</a>, 
<a class="el" href="namespacepvr.html#a3283c5c9822ac5135fefd45a7cdd5932a439f57c2c466c89db942b3de48298b2b">DescriptorType::StorageBuffer</a>, 
<br/>
&#160;&#160;<a class="el" href="namespacepvr.html#a3283c5c9822ac5135fefd45a7cdd5932a517b91f0588b3bf6c80ff3b19b2a7f57">DescriptorType::UniformBufferDynamic</a>, 
<a class="el" href="namespacepvr.html#a3283c5c9822ac5135fefd45a7cdd5932ada8c94227ee0e3b5cd40da12d594ad55">DescriptorType::StorageBufferDynamic</a>, 
<a class="el" href="namespacepvr.html#a3283c5c9822ac5135fefd45a7cdd5932a261d965f5dd43c6873489b68730dbe57">DescriptorType::InputAttachment</a>, 
<b>Count</b> = 12, 
<br/>
&#160;&#160;<b>NumBits</b> = 4
<br/>
 }</td></tr>
<tr class="memdesc:a3283c5c9822ac5135fefd45a7cdd5932"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enumeration of all the different descriptor types. <a href="namespacepvr.html#a3283c5c9822ac5135fefd45a7cdd5932">More...</a><br/></td></tr>
<tr class="separator:a3283c5c9822ac5135fefd45a7cdd5932"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ca56afd652113209f2535e7688a4189"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr.html#a1ca56afd652113209f2535e7688a4189">Face</a> : uint32_t { <br/>
&#160;&#160;<a class="el" href="namespacepvr.html#a1ca56afd652113209f2535e7688a4189a6adf97f83acf6453d4a6a4b1070f3754">Face::None</a> = 0, 
<a class="el" href="namespacepvr.html#a1ca56afd652113209f2535e7688a4189a5835bab1ade0060909e31a06af2e2cde">Face::Front</a> = 1, 
<a class="el" href="namespacepvr.html#a1ca56afd652113209f2535e7688a4189a0557fa923dcee4d0f86b1409f5c2167f">Face::Back</a> = 2, 
<a class="el" href="namespacepvr.html#a1ca56afd652113209f2535e7688a4189a8be41da9b58e32ece35a2b5751f6aeb9">Face::FrontAndBack</a> = 3, 
<br/>
&#160;&#160;<b>Default</b> = None
<br/>
 }</td></tr>
<tr class="memdesc:a1ca56afd652113209f2535e7688a4189"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enumeration of Face facing (front, back...). <a href="namespacepvr.html#a1ca56afd652113209f2535e7688a4189">More...</a><br/></td></tr>
<tr class="separator:a1ca56afd652113209f2535e7688a4189"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84d320093e1561f82e57776aafd947d7"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr.html#a84d320093e1561f82e57776aafd947d7">Filter</a> : uint8_t { <br/>
&#160;&#160;<a class="el" href="namespacepvr.html#a84d320093e1561f82e57776aafd947d7a60494f02d440f316319dd0fad40ad007">Filter::Nearest</a>, 
<b>Linear</b>, 
<a class="el" href="namespacepvr.html#a84d320093e1561f82e57776aafd947d7a6adf97f83acf6453d4a6a4b1070f3754">Filter::None</a>, 
<a class="el" href="namespacepvr.html#a84d320093e1561f82e57776aafd947d7aec6b5414eb175379ff9efc9b3eef5814">Filter::Cubic</a>, 
<br/>
&#160;&#160;<b>Default</b> = Linear, 
<b>MipDefault</b> = Linear, 
<b>Size</b> = 4
<br/>
 }</td></tr>
<tr class="memdesc:a84d320093e1561f82e57776aafd947d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enumeration describing a filtering type of a specific dimension. In order to describe the filtering mode properly, you would have to define a Minification filter, a Magnification filter and a Mipmapping minification filter. Possible values: Nearest, Linear, Cubic, None. <a href="namespacepvr.html#a84d320093e1561f82e57776aafd947d7">More...</a><br/></td></tr>
<tr class="separator:a84d320093e1561f82e57776aafd947d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4440f5fd1256889bd3b3822002208b6"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr.html#aa4440f5fd1256889bd3b3822002208b6">GpuDatatypes</a> : uint32_t { <br/>
&#160;&#160;<b>Integer</b>, 
<b>uinteger</b> = Integer, 
<b>boolean</b> = Integer, 
<b>Float</b>, 
<br/>
&#160;&#160;<b>ivec2</b>, 
<b>uvec2</b> = ivec2, 
<b>bvec2</b> = ivec2, 
<b>ivec3</b>, 
<br/>
&#160;&#160;<b>uvec3</b> = ivec3, 
<b>bvec3</b> = ivec3, 
<b>ivec4</b>, 
<b>uvec4</b> = ivec4, 
<br/>
&#160;&#160;<b>bvec4</b> = ivec4, 
<b>vec2</b>, 
<b>vec3</b>, 
<b>vec4</b>, 
<br/>
&#160;&#160;<b>mat2x2</b>, 
<b>mat2x3</b>, 
<b>mat2x4</b>, 
<b>mat3x2</b>, 
<br/>
&#160;&#160;<b>mat3x3</b>, 
<b>mat3x4</b>, 
<b>mat4x2</b>, 
<b>mat4x3</b>, 
<br/>
&#160;&#160;<b>mat4x4</b>, 
<b>none</b> = 0xFFFFFFFF, 
<b>structure</b> = none
<br/>
 }</td></tr>
<tr class="memdesc:aa4440f5fd1256889bd3b3822002208b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">A (normally hardware-supported) GPU datatype (e.g. vec4 etc.) <a href="namespacepvr.html#aa4440f5fd1256889bd3b3822002208b6">More...</a><br/></td></tr>
<tr class="separator:aa4440f5fd1256889bd3b3822002208b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee12f61a84bee4c4513c6bfad5b042d2"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr.html#aee12f61a84bee4c4513c6bfad5b042d2">ImageAspectFlags</a> : uint32_t { <br/>
&#160;&#160;<b>Color</b> = 0x1, 
<b>Depth</b> = 0x2, 
<b>Stencil</b> = 0x4, 
<b>Metadata</b> = 0x8, 
<br/>
&#160;&#160;<b>DepthAndStencil</b> = Depth | Stencil
<br/>
 }</td></tr>
<tr class="memdesc:aee12f61a84bee4c4513c6bfad5b042d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enumeration of the "aspect" (or "semantics") of an image: Color, Depth, Stencil. <a href="namespacepvr.html#aee12f61a84bee4c4513c6bfad5b042d2">More...</a><br/></td></tr>
<tr class="separator:aee12f61a84bee4c4513c6bfad5b042d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab98ea90165357c2f9030218c337f90bf"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr.html#ab98ea90165357c2f9030218c337f90bf">ImageType</a> { <br/>
&#160;&#160;<a class="el" href="namespacepvr.html#ab98ea90165357c2f9030218c337f90bfa4be6a4b9c4d4594764eb625d5c146fff">ImageType::Image1D</a>, 
<a class="el" href="namespacepvr.html#ab98ea90165357c2f9030218c337f90bfab696e5f895616f606a8be85892c374a9">ImageType::Image2D</a>, 
<a class="el" href="namespacepvr.html#ab98ea90165357c2f9030218c337f90bfa2d4c32ae3db71aee7bf3a801d15f5075">ImageType::Image3D</a>, 
<a class="el" href="namespacepvr.html#ab98ea90165357c2f9030218c337f90bfa9aeb35984c497717cce0044620fc964a">ImageType::Unallocated</a>, 
<br/>
&#160;&#160;<a class="el" href="namespacepvr.html#ab98ea90165357c2f9030218c337f90bfa88183b946cc5f0e8c96b2e66e1c74a7e">ImageType::Unknown</a>, 
<b>Count</b> = Image3D + 1
<br/>
 }</td></tr>
<tr class="memdesc:ab98ea90165357c2f9030218c337f90bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">The dimension of an image. <a href="namespacepvr.html#ab98ea90165357c2f9030218c337f90bf">More...</a><br/></td></tr>
<tr class="separator:ab98ea90165357c2f9030218c337f90bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43f03a43047f737186d5b90b19dcaca2"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr.html#a43f03a43047f737186d5b90b19dcaca2">ImageViewType</a> { <br/>
&#160;&#160;<a class="el" href="namespacepvr.html#a43f03a43047f737186d5b90b19dcaca2a882bc3b744cc0702640a7bacf0bbcfec">ImageViewType::ImageView1D</a>, 
<a class="el" href="namespacepvr.html#a43f03a43047f737186d5b90b19dcaca2ad6677d8d1d32ba21cdf283ac165924ad">ImageViewType::ImageView2D</a>, 
<a class="el" href="namespacepvr.html#a43f03a43047f737186d5b90b19dcaca2a6698a767e1fc8afa8db1cd800d78d675">ImageViewType::ImageView3D</a>, 
<a class="el" href="namespacepvr.html#a43f03a43047f737186d5b90b19dcaca2a0e44904a008408462e8f2567465f2157">ImageViewType::ImageView2DCube</a>, 
<br/>
&#160;&#160;<a class="el" href="namespacepvr.html#a43f03a43047f737186d5b90b19dcaca2aba6b5050476daa2d65fe7081478ed7a0">ImageViewType::ImageView1DArray</a>, 
<a class="el" href="namespacepvr.html#a43f03a43047f737186d5b90b19dcaca2abe5a0e508c8c71c3ab11da749a6678a7">ImageViewType::ImageView2DArray</a>, 
<a class="el" href="namespacepvr.html#a43f03a43047f737186d5b90b19dcaca2a9ffe857cfe5d3eff82077db510ca5675">ImageViewType::ImageView2DCubeArray</a>, 
<a class="el" href="namespacepvr.html#a43f03a43047f737186d5b90b19dcaca2aa9d24d469028b69a34b22604c244dfc3">ImageViewType::ImageViewUnknown</a>
<br/>
 }</td></tr>
<tr class="memdesc:a43f03a43047f737186d5b90b19dcaca2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enumeration of Texture dimensionalities. <a href="namespacepvr.html#a43f03a43047f737186d5b90b19dcaca2">More...</a><br/></td></tr>
<tr class="separator:a43f03a43047f737186d5b90b19dcaca2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab40a4733df51a99c80b389348c493ac"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr.html#aab40a4733df51a99c80b389348c493ac">IndexType</a> : uint32_t { <a class="el" href="namespacepvr.html#aab40a4733df51a99c80b389348c493acac995e06991264df36fe28315304bcd6e">IndexType::IndexType16Bit</a> = static_cast&lt;uint32_t&gt;(DataType::UInt16), 
<a class="el" href="namespacepvr.html#aab40a4733df51a99c80b389348c493aca456ada99990fe2c6043f27810c550148">IndexType::IndexType32Bit</a> = static_cast&lt;uint32_t&gt;(DataType::UInt32)
 }</td></tr>
<tr class="memdesc:aab40a4733df51a99c80b389348c493ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">An enumeration that defines a type that can use as an index, typically 16 or 32 bit int. Especially used in Model classes. <a href="namespacepvr.html#aab40a4733df51a99c80b389348c493ac">More...</a><br/></td></tr>
<tr class="separator:aab40a4733df51a99c80b389348c493ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aafc960d10904ec52d4d823ed66717c43"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr.html#aafc960d10904ec52d4d823ed66717c43">PackedSamplerFilter</a> : int8_t { <br/>
&#160;&#160;<b>PackNone</b>, 
<b>PackNearestMipNone</b>, 
<b>PackNearestMipNearest</b>, 
<b>PackNearestMipLinear</b>, 
<br/>
&#160;&#160;<b>PackLinearMipNone</b>, 
<b>PackLinearMipNearest</b>, 
<b>PackTrilinear</b>, 
<b>Size</b>, 
<br/>
&#160;&#160;<b>Size</b> = 4, 
<b>Size</b>, 
<b>PackDefault</b> = PackTrilinear
<br/>
 }</td></tr>
<tr class="memdesc:aafc960d10904ec52d4d823ed66717c43"><td class="mdescLeft">&#160;</td><td class="mdescRight">This enum is made to pack all sampler filtering info in 8 bits for specific uses. Use "packSamplerFilter" and "unpackSamplerFilter". NOTE: The defined values are only the most common cases - other 8 bit values are also valid (for example, different minification and magnification filters) <a href="namespacepvr.html#aafc960d10904ec52d4d823ed66717c43">More...</a><br/></td></tr>
<tr class="separator:aafc960d10904ec52d4d823ed66717c43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acebf4429ca4e976bca1ecaf28401bd59"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr.html#acebf4429ca4e976bca1ecaf28401bd59">PolygonWindingOrder</a> : uint8_t { <a class="el" href="namespacepvr.html#acebf4429ca4e976bca1ecaf28401bd59a6baa14a02b39a3336b6bf0087473eff3">PolygonWindingOrder::FrontFaceCCW</a>, 
<a class="el" href="namespacepvr.html#acebf4429ca4e976bca1ecaf28401bd59a8331b56f0f66fa794a20609344081509">PolygonWindingOrder::FrontFaceCW</a>, 
<b>Default</b> = FrontFaceCCW
 }</td></tr>
<tr class="memdesc:acebf4429ca4e976bca1ecaf28401bd59"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enumeration of the different front face to winding order correlations. <a href="namespacepvr.html#acebf4429ca4e976bca1ecaf28401bd59">More...</a><br/></td></tr>
<tr class="separator:acebf4429ca4e976bca1ecaf28401bd59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95105fe432efbe2b976187f0270b6012"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr.html#a95105fe432efbe2b976187f0270b6012">PrimitiveTopology</a> : uint32_t { <br/>
&#160;&#160;<a class="el" href="namespacepvr.html#a95105fe432efbe2b976187f0270b6012a1a18ff71b3df3e362a2489eef4b30003">PrimitiveTopology::PointList</a>, 
<a class="el" href="namespacepvr.html#a95105fe432efbe2b976187f0270b6012a596e1b7afe8925f3f578c716d5af8fef">PrimitiveTopology::LineList</a>, 
<a class="el" href="namespacepvr.html#a95105fe432efbe2b976187f0270b6012ae7f9e73b8edd21f420a63b3ace5768a2">PrimitiveTopology::LineStrip</a>, 
<a class="el" href="namespacepvr.html#a95105fe432efbe2b976187f0270b6012af5beeab7a1f452e5b0e9b03b44f0de92">PrimitiveTopology::TriangleList</a>, 
<br/>
&#160;&#160;<a class="el" href="namespacepvr.html#a95105fe432efbe2b976187f0270b6012a1da0b9ead8b051940a89214bae22831c">PrimitiveTopology::TriangleStrip</a>, 
<a class="el" href="namespacepvr.html#a95105fe432efbe2b976187f0270b6012a18d58fde618e4a30e2dfdc122e693047">PrimitiveTopology::TriangleFan</a>, 
<a class="el" href="namespacepvr.html#a95105fe432efbe2b976187f0270b6012af951dbe32c0c5d525b8e0ec3884de6c7">PrimitiveTopology::LineListWithAdjacency</a>, 
<a class="el" href="namespacepvr.html#a95105fe432efbe2b976187f0270b6012ae6a2093eb583f16122d50acb096af542">PrimitiveTopology::LineStripWithAdjacency</a>, 
<br/>
&#160;&#160;<a class="el" href="namespacepvr.html#a95105fe432efbe2b976187f0270b6012a150324739f6017972f918eff656ba998">PrimitiveTopology::TriangleListWithAdjacency</a>, 
<a class="el" href="namespacepvr.html#a95105fe432efbe2b976187f0270b6012aa8df42f3be2313042a310fb7319b4c36">PrimitiveTopology::TriangleStripWithAdjacency</a>, 
<a class="el" href="namespacepvr.html#a95105fe432efbe2b976187f0270b6012af1b220525e3cc747140a46b7e2d7532e">PrimitiveTopology::PatchList</a>, 
<b>Count</b>
<br/>
 }</td></tr>
<tr class="memdesc:a95105fe432efbe2b976187f0270b6012"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enumeration containing all possible Primitive topologies (Point, line trianglelist etc.). <a href="namespacepvr.html#a95105fe432efbe2b976187f0270b6012">More...</a><br/></td></tr>
<tr class="separator:a95105fe432efbe2b976187f0270b6012"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c5fa1488e4ba61dd568718646a8c73d"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr.html#a1c5fa1488e4ba61dd568718646a8c73d">Result</a> { <br/>
&#160;&#160;<b>Success</b>, 
<b>UnknownError</b>, 
<b>NotInitialized</b>, 
<b>InitializationError</b>, 
<br/>
&#160;&#160;<b>UnsupportedRequest</b>, 
<b>ExitRenderFrame</b>
<br/>
 }</td></tr>
<tr class="memdesc:a1c5fa1488e4ba61dd568718646a8c73d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pre-defined Result codes (success and generic errors). <a href="namespacepvr.html#a1c5fa1488e4ba61dd568718646a8c73d">More...</a><br/></td></tr>
<tr class="separator:a1c5fa1488e4ba61dd568718646a8c73d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aedec1ca92cba055434a2a27da89f5643"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr.html#aedec1ca92cba055434a2a27da89f5643">SamplerAddressMode</a> : uint8_t { <br/>
&#160;&#160;<a class="el" href="namespacepvr.html#aedec1ca92cba055434a2a27da89f5643a7020426cfb0a204051be4b3053d2acc8">SamplerAddressMode::Repeat</a>, 
<a class="el" href="namespacepvr.html#aedec1ca92cba055434a2a27da89f5643a39a681a9d5ccc902bebd16a343dd7b74">SamplerAddressMode::MirrorRepeat</a>, 
<a class="el" href="namespacepvr.html#aedec1ca92cba055434a2a27da89f5643a74556551231333c36debc3d373261134">SamplerAddressMode::ClampToEdge</a>, 
<a class="el" href="namespacepvr.html#aedec1ca92cba055434a2a27da89f5643afb07f88f6f11cc5ab9c951290716f147">SamplerAddressMode::ClampToBorder</a>, 
<br/>
&#160;&#160;<a class="el" href="namespacepvr.html#aedec1ca92cba055434a2a27da89f5643a01f488e80fc32761aecfbeb3d1c8f26b">SamplerAddressMode::MirrorClampToEdge</a>, 
<b>Size</b>, 
<b>Default</b> = Repeat
<br/>
 }</td></tr>
<tr class="memdesc:aedec1ca92cba055434a2a27da89f5643"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enumeration for defining texture wrapping mode: Repeat, Mirror, Clamp, Border. <a href="namespacepvr.html#aedec1ca92cba055434a2a27da89f5643">More...</a><br/></td></tr>
<tr class="separator:aedec1ca92cba055434a2a27da89f5643"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7a59f03f943f1c79a5339331fc15abe"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr.html#ac7a59f03f943f1c79a5339331fc15abe">SamplerMipmapMode</a> : uint8_t { <a class="el" href="namespacepvr.html#ac7a59f03f943f1c79a5339331fc15abea60494f02d440f316319dd0fad40ad007">SamplerMipmapMode::Nearest</a>, 
<a class="el" href="namespacepvr.html#ac7a59f03f943f1c79a5339331fc15abea32a843da6ea40ab3b17a3421ccdf671b">SamplerMipmapMode::Linear</a>, 
<b>Count</b>
 }</td></tr>
<tr class="memdesc:ac7a59f03f943f1c79a5339331fc15abe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enumeration of mipmap modes supported for a sampler <a href="namespacepvr.html#ac7a59f03f943f1c79a5339331fc15abe">More...</a><br/></td></tr>
<tr class="separator:ac7a59f03f943f1c79a5339331fc15abe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5c2a4d46bb7aa6a877a0ed8c5ba3ac8"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr.html#af5c2a4d46bb7aa6a877a0ed8c5ba3ac8">ShaderType</a> { <br/>
&#160;&#160;<a class="el" href="namespacepvr.html#af5c2a4d46bb7aa6a877a0ed8c5ba3ac8a05c0d061c57b467a86d66f7529f19bb5">ShaderType::UnknownShader</a> = 0, 
<a class="el" href="namespacepvr.html#af5c2a4d46bb7aa6a877a0ed8c5ba3ac8aeb3ca4dac3e206977e0b7d998eefcc33">ShaderType::VertexShader</a>, 
<a class="el" href="namespacepvr.html#af5c2a4d46bb7aa6a877a0ed8c5ba3ac8a90a9bb4e665932b1781da33fc2f32922">ShaderType::FragmentShader</a>, 
<a class="el" href="namespacepvr.html#af5c2a4d46bb7aa6a877a0ed8c5ba3ac8a2216355d14abbc1a80dadd4f881c0f39">ShaderType::ComputeShader</a>, 
<br/>
&#160;&#160;<b>TessControlShader</b>, 
<b>TessEvaluationShader</b>, 
<b>GeometryShader</b>, 
<b>RayShader</b>, 
<br/>
&#160;&#160;<b>FrameShader</b>, 
<b>Count</b>
<br/>
 }</td></tr>
<tr class="memdesc:af5c2a4d46bb7aa6a877a0ed8c5ba3ac8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enumeration of all supported shader types. <a href="namespacepvr.html#af5c2a4d46bb7aa6a877a0ed8c5ba3ac8">More...</a><br/></td></tr>
<tr class="separator:af5c2a4d46bb7aa6a877a0ed8c5ba3ac8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adaffc1ac547687d86eef4bb51d0533aa"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr.html#adaffc1ac547687d86eef4bb51d0533aa">StencilOp</a> : uint8_t { <br/>
&#160;&#160;<a class="el" href="namespacepvr.html#adaffc1ac547687d86eef4bb51d0533aaa02bce93bff905887ad2233110bf9c49e">StencilOp::Keep</a>, 
<a class="el" href="namespacepvr.html#adaffc1ac547687d86eef4bb51d0533aaad7ed4ee1df437474d005188535f74875">StencilOp::Zero</a>, 
<a class="el" href="namespacepvr.html#adaffc1ac547687d86eef4bb51d0533aaa0ebe6df8a3ac338e0512acc741823fdb">StencilOp::Replace</a>, 
<a class="el" href="namespacepvr.html#adaffc1ac547687d86eef4bb51d0533aaa39f5ed1c9a1e48cc90401d52864202ab">StencilOp::IncrementClamp</a>, 
<br/>
&#160;&#160;<a class="el" href="namespacepvr.html#adaffc1ac547687d86eef4bb51d0533aaa669ecd4a04c7b2cda3fbf54f62e180f1">StencilOp::DecrementClamp</a>, 
<a class="el" href="namespacepvr.html#adaffc1ac547687d86eef4bb51d0533aaa9b8958acb7be504bb5f55f17c0eea366">StencilOp::Invert</a>, 
<a class="el" href="namespacepvr.html#adaffc1ac547687d86eef4bb51d0533aaaaa91cb7f033b90dec9582dc5e9611732">StencilOp::IncrementWrap</a>, 
<a class="el" href="namespacepvr.html#adaffc1ac547687d86eef4bb51d0533aaa6ec565c329385c8d59333abc6a1003d1">StencilOp::DecrementWrap</a>, 
<br/>
&#160;&#160;<b>NumStencilOp</b>, 
<b>Default</b> = Keep
<br/>
 }</td></tr>
<tr class="memdesc:adaffc1ac547687d86eef4bb51d0533aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enumeration of the different stencil operations. <a href="namespacepvr.html#adaffc1ac547687d86eef4bb51d0533aa">More...</a><br/></td></tr>
<tr class="separator:adaffc1ac547687d86eef4bb51d0533aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6fffa33db4623ece1088010c6f78bc9f"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr.html#a6fffa33db4623ece1088010c6f78bc9f">StepRate</a> : uint32_t { <a class="el" href="namespacepvr.html#a6fffa33db4623ece1088010c6f78bc9fab22b929ba52471a02d18bb3a4e4472e6">StepRate::Vertex</a>, 
<a class="el" href="namespacepvr.html#a6fffa33db4623ece1088010c6f78bc9fad9a17c1c9e8ef6866e4dbeef41c741b2">StepRate::Instance</a>, 
<b>Default</b> = Vertex
 }</td></tr>
<tr class="memdesc:a6fffa33db4623ece1088010c6f78bc9f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Step rate for a vertex attribute when drawing: Per vertex, per instance, per draw. <a href="namespacepvr.html#a6fffa33db4623ece1088010c6f78bc9f">More...</a><br/></td></tr>
<tr class="separator:a6fffa33db4623ece1088010c6f78bc9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab74a3e033b17a2d3f50ee6d0299eb195"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr.html#ab74a3e033b17a2d3f50ee6d0299eb195">Swizzle</a> : uint8_t { <br/>
&#160;&#160;<b>Identity</b> = 0, 
<b>Zero</b> = 1, 
<b>One</b> = 2, 
<b>R</b> = 3, 
<br/>
&#160;&#160;<b>G</b> = 4, 
<b>B</b> = 5, 
<b>A</b> = 6, 
<b>Red</b> = R, 
<br/>
&#160;&#160;<b>Green</b> = G, 
<b>Blue</b> = B, 
<b>Alpha</b> = A
<br/>
 }</td></tr>
<tr class="memdesc:ab74a3e033b17a2d3f50ee6d0299eb195"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enumeration of texture Swizzle mask channels. <a href="namespacepvr.html#ab74a3e033b17a2d3f50ee6d0299eb195">More...</a><br/></td></tr>
<tr class="separator:ab74a3e033b17a2d3f50ee6d0299eb195"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8be7d779089afe1df56a1bf542134d0d"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr.html#a8be7d779089afe1df56a1bf542134d0d">TextureFileFormat</a> { <br/>
&#160;&#160;<b>UNKNOWN</b> = 0, 
<b>KTX</b>, 
<b>DDX</b>, 
<b>PVR</b>, 
<br/>
&#160;&#160;<b>TGA</b>, 
<b>BMP</b>, 
<b>DDS</b>
<br/>
 }</td></tr>
<tr class="memdesc:a8be7d779089afe1df56a1bf542134d0d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enumerates the formats directly supported by the Framework. <a href="namespacepvr.html#a8be7d779089afe1df56a1bf542134d0d">More...</a><br/></td></tr>
<tr class="separator:a8be7d779089afe1df56a1bf542134d0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f7777c11dfff8fcf4a03d85e5ab0b98"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr.html#a6f7777c11dfff8fcf4a03d85e5ab0b98">VariableType</a> { <br/>
&#160;&#160;<b>UnsignedByteNorm</b>, 
<b>SignedByteNorm</b>, 
<b>UnsignedByte</b>, 
<b>SignedByte</b>, 
<br/>
&#160;&#160;<b>UnsignedShortNorm</b>, 
<b>SignedShortNorm</b>, 
<b>UnsignedShort</b>, 
<b>SignedShort</b>, 
<br/>
&#160;&#160;<b>UnsignedIntegerNorm</b>, 
<b>SignedIntegerNorm</b>, 
<b>UnsignedInteger</b>, 
<b>SignedInteger</b>, 
<br/>
&#160;&#160;<b>SignedFloat</b>, 
<b>Float</b> = SignedFloat, 
<b>UnsignedFloat</b>, 
<b>NumVarTypes</b>
<br/>
 }</td></tr>
<tr class="memdesc:a6f7777c11dfff8fcf4a03d85e5ab0b98"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enumeration of Datatypes. <a href="namespacepvr.html#a6f7777c11dfff8fcf4a03d85e5ab0b98">More...</a><br/></td></tr>
<tr class="separator:a6f7777c11dfff8fcf4a03d85e5ab0b98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f3166dd9130684c23ff89682e4b38c8"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr.html#a7f3166dd9130684c23ff89682e4b38c8">VsyncMode</a> { <br/>
&#160;&#160;<a class="el" href="namespacepvr.html#a7f3166dd9130684c23ff89682e4b38c8ad15305d7a4e34e02489c74a5ef542f36">VsyncMode::Off</a>, 
<a class="el" href="namespacepvr.html#a7f3166dd9130684c23ff89682e4b38c8a521c36a31c2762741cf0f8890cbe05e3">VsyncMode::On</a>, 
<a class="el" href="namespacepvr.html#a7f3166dd9130684c23ff89682e4b38c8a4160be5df3fc34c3b165f28616f1bd16">VsyncMode::Relaxed</a>, 
<a class="el" href="namespacepvr.html#a7f3166dd9130684c23ff89682e4b38c8a2dcff8c037093c5d3552ad532e603f9f">VsyncMode::Mailbox</a>, 
<br/>
&#160;&#160;<a class="el" href="namespacepvr.html#a7f3166dd9130684c23ff89682e4b38c8ac48615a1bc4197056d522af276aa5a85">VsyncMode::Half</a>
<br/>
 }</td></tr>
<tr class="memdesc:a7f3166dd9130684c23ff89682e4b38c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">The Vertical Synchronization (or lack thereof) modes, A.K.A. Presentation mode. <a href="namespacepvr.html#a7f3166dd9130684c23ff89682e4b38c8">More...</a><br/></td></tr>
<tr class="separator:a7f3166dd9130684c23ff89682e4b38c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a3dc927ae582f3ec00005bf32ceb97830"><td class="memTemplParams" colspan="2">template&lt;typename t1 , typename t2 &gt; </td></tr>
<tr class="memitem:a3dc927ae582f3ec00005bf32ceb97830"><td class="memTemplItemLeft" align="right" valign="top">t1&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepvr.html#a3dc927ae582f3ec00005bf32ceb97830">align</a> (t1 numberToAlign, t2 alignment)</td></tr>
<tr class="memdesc:a3dc927ae582f3ec00005bf32ceb97830"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aligns a given number based on the given alignment <a href="#a3dc927ae582f3ec00005bf32ceb97830">More...</a><br/></td></tr>
<tr class="separator:a3dc927ae582f3ec00005bf32ceb97830"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0303f68824c30e29b02875302cd75d96"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr.html#a0303f68824c30e29b02875302cd75d96">apiCode</a> (<a class="el" href="namespacepvr.html#a74c5d1afa51512f076dd8e5844b171c8">Api</a> api)</td></tr>
<tr class="memdesc:a0303f68824c30e29b02875302cd75d96"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a string of the specific api enum <a href="#a0303f68824c30e29b02875302cd75d96">More...</a><br/></td></tr>
<tr class="separator:a0303f68824c30e29b02875302cd75d96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e39bf9a267425bc06d61d9a0130f6ea"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacepvr.html#a74c5d1afa51512f076dd8e5844b171c8">Api</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr.html#a6e39bf9a267425bc06d61d9a0130f6ea">apiFamilyMax</a> (<a class="el" href="namespacepvr.html#a74c5d1afa51512f076dd8e5844b171c8">Api</a> api)</td></tr>
<tr class="memdesc:a6e39bf9a267425bc06d61d9a0130f6ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the highest api version that is of the same family as the parameter <a href="#a6e39bf9a267425bc06d61d9a0130f6ea">More...</a><br/></td></tr>
<tr class="separator:a6e39bf9a267425bc06d61d9a0130f6ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ec9f9921823c5b479a99d3a5f8a3457"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacepvr.html#a74c5d1afa51512f076dd8e5844b171c8">Api</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr.html#a8ec9f9921823c5b479a99d3a5f8a3457">apiFamilyMin</a> (<a class="el" href="namespacepvr.html#a74c5d1afa51512f076dd8e5844b171c8">Api</a> api)</td></tr>
<tr class="memdesc:a8ec9f9921823c5b479a99d3a5f8a3457"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get minimum api that is the same family as the parameter. (e.g. Vulkan returns Vulkan, while OpenGLES31 returns OpenGLES2) api family min version <a href="#a8ec9f9921823c5b479a99d3a5f8a3457">More...</a><br/></td></tr>
<tr class="separator:a8ec9f9921823c5b479a99d3a5f8a3457"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0940447f72ad2b8777a37cd3181b5c9"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr.html#ac0940447f72ad2b8777a37cd3181b5c9">apiName</a> (<a class="el" href="namespacepvr.html#a74c5d1afa51512f076dd8e5844b171c8">Api</a> api)</td></tr>
<tr class="memdesc:ac0940447f72ad2b8777a37cd3181b5c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the api name std::string of the given Enumeration <a href="#ac0940447f72ad2b8777a37cd3181b5c9">More...</a><br/></td></tr>
<tr class="separator:ac0940447f72ad2b8777a37cd3181b5c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32304b6fe8a8ebcfdaa03d5b227da809"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr.html#a32304b6fe8a8ebcfdaa03d5b227da809">dataTypeIsNormalised</a> (<a class="el" href="namespacepvr.html#a7924324f96dc973225ad3c532cc72309">DataType</a> type)</td></tr>
<tr class="memdesc:a32304b6fe8a8ebcfdaa03d5b227da809"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return if the format is Normalized (represents a range between 0..1 for unsigned types or between -1..1 for signed types) <a href="#a32304b6fe8a8ebcfdaa03d5b227da809">More...</a><br/></td></tr>
<tr class="separator:a32304b6fe8a8ebcfdaa03d5b227da809"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4bbe49ea1e5ffbeaf1463379ff1adcfc"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr.html#a4bbe49ea1e5ffbeaf1463379ff1adcfc">dataTypeSize</a> (<a class="el" href="namespacepvr.html#a7924324f96dc973225ad3c532cc72309">DataType</a> type)</td></tr>
<tr class="memdesc:a4bbe49ea1e5ffbeaf1463379ff1adcfc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the Size of a DataType. <a href="#a4bbe49ea1e5ffbeaf1463379ff1adcfc">More...</a><br/></td></tr>
<tr class="separator:a4bbe49ea1e5ffbeaf1463379ff1adcfc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4676d56d2f795d4c4f5b7a094af90c9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacepvr.html#aa6ac287ad32e4b14937cee7ac81fb85e">BufferUsageFlags</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr.html#af4676d56d2f795d4c4f5b7a094af90c9">descriptorTypeToBufferUsage</a> (<a class="el" href="namespacepvr.html#a3283c5c9822ac5135fefd45a7cdd5932">DescriptorType</a> descType)</td></tr>
<tr class="memdesc:af4676d56d2f795d4c4f5b7a094af90c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Infer the BufferUsageFlags that are suitable for the typical use of an object <a href="#af4676d56d2f795d4c4f5b7a094af90c9">More...</a><br/></td></tr>
<tr class="separator:af4676d56d2f795d4c4f5b7a094af90c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43dd44f92c0013d2ed1dd13363070770"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr.html#a43dd44f92c0013d2ed1dd13363070770">getAlignment</a> (<a class="el" href="namespacepvr.html#aa4440f5fd1256889bd3b3822002208b6">GpuDatatypes</a> type)</td></tr>
<tr class="memdesc:a43dd44f92c0013d2ed1dd13363070770"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get required alignment of this type as demanded by std140 rules <a href="#a43dd44f92c0013d2ed1dd13363070770">More...</a><br/></td></tr>
<tr class="separator:a43dd44f92c0013d2ed1dd13363070770"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe1ac49f71337e1cfd4e6436b3bb9ca6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacepvr_1_1_gpu_datatypes_helper.html#abead2e53bdab9ebb17f7c858a2844e14">GpuDatatypesHelper::BaseType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr.html#abe1ac49f71337e1cfd4e6436b3bb9ca6">getBaseType</a> (<a class="el" href="namespacepvr.html#aa4440f5fd1256889bd3b3822002208b6">GpuDatatypes</a> type)</td></tr>
<tr class="memdesc:abe1ac49f71337e1cfd4e6436b3bb9ca6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the underlying element of a type (integer or float) <a href="#abe1ac49f71337e1cfd4e6436b3bb9ca6">More...</a><br/></td></tr>
<tr class="separator:abe1ac49f71337e1cfd4e6436b3bb9ca6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6bc2716579dfbeade26021e2628dd7a7"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr.html#a6bc2716579dfbeade26021e2628dd7a7">getCpuPackedSize</a> (<a class="el" href="namespacepvr.html#aa4440f5fd1256889bd3b3822002208b6">GpuDatatypes</a> type, uint32_t arrayElements=1)</td></tr>
<tr class="memdesc:a6bc2716579dfbeade26021e2628dd7a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the size of n array members of a type, packed in CPU <a href="#a6bc2716579dfbeade26021e2628dd7a7">More...</a><br/></td></tr>
<tr class="separator:a6bc2716579dfbeade26021e2628dd7a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65076be9fba2c986f80ffe1eb64aa29a"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr.html#a65076be9fba2c986f80ffe1eb64aa29a">getNumMatrixColumns</a> (<a class="el" href="namespacepvr.html#aa4440f5fd1256889bd3b3822002208b6">GpuDatatypes</a> type)</td></tr>
<tr class="memdesc:a65076be9fba2c986f80ffe1eb64aa29a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of colums (1..4) of the type <a href="#a65076be9fba2c986f80ffe1eb64aa29a">More...</a><br/></td></tr>
<tr class="separator:a65076be9fba2c986f80ffe1eb64aa29a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8277a30a2c9fa98ba8c66c2c8516f923"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr.html#a8277a30a2c9fa98ba8c66c2c8516f923">getNumVecElements</a> (<a class="el" href="namespacepvr.html#aa4440f5fd1256889bd3b3822002208b6">GpuDatatypes</a> type)</td></tr>
<tr class="memdesc:a8277a30a2c9fa98ba8c66c2c8516f923"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of vector elements (i.e. Rows) of a type. (e.g. vec2=&gt;2) <a href="#a8277a30a2c9fa98ba8c66c2c8516f923">More...</a><br/></td></tr>
<tr class="separator:a8277a30a2c9fa98ba8c66c2c8516f923"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b67db200cee4a4078676dc5f3622ec0"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr.html#a5b67db200cee4a4078676dc5f3622ec0">getOffsetAfter</a> (<a class="el" href="namespacepvr.html#aa4440f5fd1256889bd3b3822002208b6">GpuDatatypes</a> type, uint64_t previousTotalSize)</td></tr>
<tr class="memdesc:a5b67db200cee4a4078676dc5f3622ec0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aligns an address/offset with the alignment of a type &ndash; equivalently, assuming you want to place a type after a known offset (i.e. calculating the offset of an item inside a struct having already calculated its previous element) (i.e. aligning a vec4 after an item that ends at 30 bytes returns 32 bytes...)  <a href="#a5b67db200cee4a4078676dc5f3622ec0">More...</a><br/></td></tr>
<tr class="separator:a5b67db200cee4a4078676dc5f3622ec0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10f119283374e989cd179f6831fe1e36"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr.html#a10f119283374e989cd179f6831fe1e36">getResultCodeString</a> (<a class="el" href="namespacepvr.html#a1c5fa1488e4ba61dd568718646a8c73d">Result</a> result)</td></tr>
<tr class="memdesc:a10f119283374e989cd179f6831fe1e36"><td class="mdescLeft">&#160;</td><td class="mdescRight">Use this function to convert a Result into a std::string that is suitable for outputting. <a href="#a10f119283374e989cd179f6831fe1e36">More...</a><br/></td></tr>
<tr class="separator:a10f119283374e989cd179f6831fe1e36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7caef391618cc1a3ebab73d8ffe90a47"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr.html#a7caef391618cc1a3ebab73d8ffe90a47">getSelfAlignedArraySize</a> (<a class="el" href="namespacepvr.html#aa4440f5fd1256889bd3b3822002208b6">GpuDatatypes</a> type)</td></tr>
<tr class="memdesc:a7caef391618cc1a3ebab73d8ffe90a47"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns "how many bytes will an object of this type take", if it is an array member (arrays have potentially stricter requirements). <a href="#a7caef391618cc1a3ebab73d8ffe90a47">More...</a><br/></td></tr>
<tr class="separator:a7caef391618cc1a3ebab73d8ffe90a47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a239df321236ac77da04fe9d58f5efe55"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr.html#a239df321236ac77da04fe9d58f5efe55">getSelfAlignedSize</a> (<a class="el" href="namespacepvr.html#aa4440f5fd1256889bd3b3822002208b6">GpuDatatypes</a> type)</td></tr>
<tr class="memdesc:a239df321236ac77da04fe9d58f5efe55"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns "how many bytes will an object of this type take", if not an array. <a href="#a239df321236ac77da04fe9d58f5efe55">More...</a><br/></td></tr>
<tr class="separator:a239df321236ac77da04fe9d58f5efe55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e17c970a2a4965269fcb9e3e55049dd"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr.html#a7e17c970a2a4965269fcb9e3e55049dd">getSize</a> (<a class="el" href="namespacepvr.html#aa4440f5fd1256889bd3b3822002208b6">GpuDatatypes</a> type, uint32_t arrayElements=1)</td></tr>
<tr class="memdesc:a7e17c970a2a4965269fcb9e3e55049dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns how many bytes an array of n objects of this type take, but arrayElements = 1 is NOT considered an array (is aligned as a single object, NOT an array of 1) <a href="#a7e17c970a2a4965269fcb9e3e55049dd">More...</a><br/></td></tr>
<tr class="separator:a7e17c970a2a4965269fcb9e3e55049dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e81520ef363fa90bb0d7e341ebe4f9a"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr.html#a8e81520ef363fa90bb0d7e341ebe4f9a">getStackTraceInfo</a> (int skipFrames)</td></tr>
<tr class="memdesc:a8e81520ef363fa90bb0d7e341ebe4f9a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the stacktrace as a string, skipping the specified number of stack frames from the top of the stack. <b>ONLY IMPLEMENTED FOR 32 bit WINDOWS DEBUG BUILDS</b> <a href="#a8e81520ef363fa90bb0d7e341ebe4f9a">More...</a><br/></td></tr>
<tr class="separator:a8e81520ef363fa90bb0d7e341ebe4f9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5486ebd5e2197fa607b0fc29c7850742"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacepvr.html#a8be7d779089afe1df56a1bf542134d0d">TextureFileFormat</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr.html#a5486ebd5e2197fa607b0fc29c7850742">getTextureFormatFromFilename</a> (const char *assetname)</td></tr>
<tr class="memdesc:a5486ebd5e2197fa607b0fc29c7850742"><td class="mdescLeft">&#160;</td><td class="mdescRight">Infer the texture format from a filename. <a href="#a5486ebd5e2197fa607b0fc29c7850742">More...</a><br/></td></tr>
<tr class="separator:a5486ebd5e2197fa607b0fc29c7850742"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6bc881503cace7cf8d883d54905aa462"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr.html#a6bc881503cace7cf8d883d54905aa462">getTotalSizeAfter</a> (<a class="el" href="namespacepvr.html#aa4440f5fd1256889bd3b3822002208b6">GpuDatatypes</a> type, uint32_t arrayElements, uint64_t previousTotalSize)</td></tr>
<tr class="memdesc:a6bc881503cace7cf8d883d54905aa462"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the new size of a hypothetical struct whose old size was previousTotalSize, and to which "arrayElement" new items of type "type" are added <a href="#a6bc881503cace7cf8d883d54905aa462">More...</a><br/></td></tr>
<tr class="separator:a6bc881503cace7cf8d883d54905aa462"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c310f549c8db9647eeeef82a0a56af0"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr.html#a4c310f549c8db9647eeeef82a0a56af0">getVectorSelfAlignedSize</a> (<a class="el" href="namespacepvr.html#aa4440f5fd1256889bd3b3822002208b6">GpuDatatypes</a> type)</td></tr>
<tr class="memdesc:a4c310f549c8db9647eeeef82a0a56af0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the size of a type, including padding, assuming the next item is of the same type <a href="#a4c310f549c8db9647eeeef82a0a56af0">More...</a><br/></td></tr>
<tr class="separator:a4c310f549c8db9647eeeef82a0a56af0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3cbe7fd082e1089dc162d9afdacdd6f1"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr.html#a3cbe7fd082e1089dc162d9afdacdd6f1">getVectorUnalignedSize</a> (<a class="el" href="namespacepvr.html#aa4440f5fd1256889bd3b3822002208b6">GpuDatatypes</a> type)</td></tr>
<tr class="memdesc:a3cbe7fd082e1089dc162d9afdacdd6f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the cpu-packed size of each vector element a type (disregarding matrix columns if they exist) <a href="#a3cbe7fd082e1089dc162d9afdacdd6f1">More...</a><br/></td></tr>
<tr class="separator:a3cbe7fd082e1089dc162d9afdacdd6f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade5ae06be9adae4c32d10aa679b5731e"><td class="memTemplParams" colspan="2">template&lt;typename T1_ &gt; </td></tr>
<tr class="memitem:ade5ae06be9adae4c32d10aa679b5731e"><td class="memTemplItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepvr.html#ade5ae06be9adae4c32d10aa679b5731e">hash32_32</a> (const T1_ &amp;t)</td></tr>
<tr class="memdesc:ade5ae06be9adae4c32d10aa679b5731e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function object hashing to 32 bit values into a 32 bit unsigned Integer. <a href="#ade5ae06be9adae4c32d10aa679b5731e">More...</a><br/></td></tr>
<tr class="separator:ade5ae06be9adae4c32d10aa679b5731e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18b97ab7a969dcd477d5e6c236a0bec4"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr.html#a18b97ab7a969dcd477d5e6c236a0bec4">hash32_bytes</a> (const void *bytes, size_t count)</td></tr>
<tr class="memdesc:a18b97ab7a969dcd477d5e6c236a0bec4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function object hashing a number of bytes into a 32 bit unsigned Integer. <a href="#a18b97ab7a969dcd477d5e6c236a0bec4">More...</a><br/></td></tr>
<tr class="separator:a18b97ab7a969dcd477d5e6c236a0bec4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a128900aeb6815de42a6d6d2c59f67a6e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacepvr.html#ab98ea90165357c2f9030218c337f90bf">ImageType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr.html#a128900aeb6815de42a6d6d2c59f67a6e">imageViewTypeToImageBaseType</a> (<a class="el" href="namespacepvr.html#a43f03a43047f737186d5b90b19dcaca2">ImageViewType</a> viewtype)</td></tr>
<tr class="memdesc:a128900aeb6815de42a6d6d2c59f67a6e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Map an ImageViewType (2dCube etc) to its base type (1d/2d/3d) <a href="#a128900aeb6815de42a6d6d2c59f67a6e">More...</a><br/></td></tr>
<tr class="separator:a128900aeb6815de42a6d6d2c59f67a6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3fd0cfec4d261dd1caa2ce5eefcc2a53"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr.html#a3fd0cfec4d261dd1caa2ce5eefcc2a53">indexTypeSizeInBytes</a> (const <a class="el" href="namespacepvr.html#aab40a4733df51a99c80b389348c493ac">IndexType</a> type)</td></tr>
<tr class="memdesc:a3fd0cfec4d261dd1caa2ce5eefcc2a53"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the Size of an IndexType in bytes. <a href="#a3fd0cfec4d261dd1caa2ce5eefcc2a53">More...</a><br/></td></tr>
<tr class="separator:a3fd0cfec4d261dd1caa2ce5eefcc2a53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff2eee1ed23143ae72185a5472ea765a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr.html#aff2eee1ed23143ae72185a5472ea765a">isDescriptorTypeDynamic</a> (<a class="el" href="namespacepvr.html#a3283c5c9822ac5135fefd45a7cdd5932">DescriptorType</a> descType)</td></tr>
<tr class="memdesc:aff2eee1ed23143ae72185a5472ea765a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if a descriptor type is dynamic (a dynamic UBO or dynamic SSBO) <a href="#aff2eee1ed23143ae72185a5472ea765a">More...</a><br/></td></tr>
<tr class="separator:aff2eee1ed23143ae72185a5472ea765a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47994de10c19816f5b4f0351e265ead5"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr.html#a47994de10c19816f5b4f0351e265ead5">isVariableTypeNormalized</a> (<a class="el" href="namespacepvr.html#a6f7777c11dfff8fcf4a03d85e5ab0b98">VariableType</a> item)</td></tr>
<tr class="memdesc:a47994de10c19816f5b4f0351e265ead5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if a variable type is a Normalizedtype <a href="#a47994de10c19816f5b4f0351e265ead5">More...</a><br/></td></tr>
<tr class="separator:a47994de10c19816f5b4f0351e265ead5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8844086c38cb4b2dddc3317494b16ac"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr.html#ad8844086c38cb4b2dddc3317494b16ac">isVariableTypeSigned</a> (<a class="el" href="namespacepvr.html#a6f7777c11dfff8fcf4a03d85e5ab0b98">VariableType</a> item)</td></tr>
<tr class="memdesc:ad8844086c38cb4b2dddc3317494b16ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if a variable type is a Signed type <a href="#ad8844086c38cb4b2dddc3317494b16ac">More...</a><br/></td></tr>
<tr class="separator:ad8844086c38cb4b2dddc3317494b16ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac73ce628e547374c22057ff8e3a89bb3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacepvr.html#aa4440f5fd1256889bd3b3822002208b6">GpuDatatypes</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr.html#ac73ce628e547374c22057ff8e3a89bb3">mergeDatatypesBigger</a> (<a class="el" href="namespacepvr.html#aa4440f5fd1256889bd3b3822002208b6">GpuDatatypes</a> type1, <a class="el" href="namespacepvr.html#aa4440f5fd1256889bd3b3822002208b6">GpuDatatypes</a> type2)</td></tr>
<tr class="memdesc:ac73ce628e547374c22057ff8e3a89bb3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a datatype that is larger or equal to both of two types: 1) Has the most permissive base type (float&gt;int) 2) Has the largest of the two vector widths 3) Has the most of the two matrix colums heights <a href="#ac73ce628e547374c22057ff8e3a89bb3">More...</a><br/></td></tr>
<tr class="separator:ac73ce628e547374c22057ff8e3a89bb3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ef5be44f3a11eac1a122cafd4a217db"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacepvr.html#aa4440f5fd1256889bd3b3822002208b6">GpuDatatypes</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr.html#a7ef5be44f3a11eac1a122cafd4a217db">mergeDatatypesSmaller</a> (<a class="el" href="namespacepvr.html#aa4440f5fd1256889bd3b3822002208b6">GpuDatatypes</a> type1, <a class="el" href="namespacepvr.html#aa4440f5fd1256889bd3b3822002208b6">GpuDatatypes</a> type2)</td></tr>
<tr class="memdesc:a7ef5be44f3a11eac1a122cafd4a217db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a datatype that is smaller or equal to both of two types: 1) Has the most permissive base type (float&gt;int) 2) Has the smaller of the two vector widths 3) Has the least of the two matrix colums heights <a href="#a7ef5be44f3a11eac1a122cafd4a217db">More...</a><br/></td></tr>
<tr class="separator:a7ef5be44f3a11eac1a122cafd4a217db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33df3732a0a48b5274ac3938a7e570b0"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr.html#a33df3732a0a48b5274ac3938a7e570b0">numDataTypeComponents</a> (<a class="el" href="namespacepvr.html#a7924324f96dc973225ad3c532cc72309">DataType</a> type)</td></tr>
<tr class="memdesc:a33df3732a0a48b5274ac3938a7e570b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the number of components in a datatype. <a href="#a33df3732a0a48b5274ac3938a7e570b0">More...</a><br/></td></tr>
<tr class="separator:a33df3732a0a48b5274ac3938a7e570b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb9d4eda8ff979cd4e5ae394aa9321c6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacepvr.html#aa4440f5fd1256889bd3b3822002208b6">GpuDatatypes</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr.html#acb9d4eda8ff979cd4e5ae394aa9321c6">operator&amp;</a> (<a class="el" href="namespacepvr.html#aa4440f5fd1256889bd3b3822002208b6">GpuDatatypes</a> lhs, <a class="el" href="namespacepvr_1_1_gpu_datatypes_helper.html#a84bf23cf8acb6cfb591074eda461590f">GpuDatatypesHelper::Bits</a> rhs)</td></tr>
<tr class="memdesc:acb9d4eda8ff979cd4e5ae394aa9321c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bitwise operator AND. Typical semantics. Allows AND between GpuDatatypes and Bits <a href="#acb9d4eda8ff979cd4e5ae394aa9321c6">More...</a><br/></td></tr>
<tr class="separator:acb9d4eda8ff979cd4e5ae394aa9321c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6830359c957ddaf92782874bb70e825"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacepvr.html#aa4440f5fd1256889bd3b3822002208b6">GpuDatatypes</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr.html#ae6830359c957ddaf92782874bb70e825">operator&lt;&lt;</a> (<a class="el" href="namespacepvr.html#aa4440f5fd1256889bd3b3822002208b6">GpuDatatypes</a> lhs, <a class="el" href="namespacepvr_1_1_gpu_datatypes_helper.html#a84bf23cf8acb6cfb591074eda461590f">GpuDatatypesHelper::Bits</a> rhs)</td></tr>
<tr class="memdesc:ae6830359c957ddaf92782874bb70e825"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bitwise operator LEFT SHIFT. Typical semantics. Allows LEFT SHIFT of GpuDatatypes by Bits <a href="#ae6830359c957ddaf92782874bb70e825">More...</a><br/></td></tr>
<tr class="separator:ae6830359c957ddaf92782874bb70e825"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab32d83bd296ef37d4c646b2552e276e7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacepvr.html#aa4440f5fd1256889bd3b3822002208b6">GpuDatatypes</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr.html#ab32d83bd296ef37d4c646b2552e276e7">operator&gt;&gt;</a> (<a class="el" href="namespacepvr.html#aa4440f5fd1256889bd3b3822002208b6">GpuDatatypes</a> lhs, <a class="el" href="namespacepvr_1_1_gpu_datatypes_helper.html#a84bf23cf8acb6cfb591074eda461590f">GpuDatatypesHelper::Bits</a> rhs)</td></tr>
<tr class="memdesc:ab32d83bd296ef37d4c646b2552e276e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bitwise operator RIGHT SHIFT. Typical semantics. Allows RIGHT SHIFT of GpuDatatypes by Bits <a href="#ab32d83bd296ef37d4c646b2552e276e7">More...</a><br/></td></tr>
<tr class="separator:ab32d83bd296ef37d4c646b2552e276e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abbe45548f9e676d52b1645ea21ba4d11"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacepvr.html#aafc960d10904ec52d4d823ed66717c43">PackedSamplerFilter</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr.html#abbe45548f9e676d52b1645ea21ba4d11">packSamplerFilter</a> (<a class="el" href="namespacepvr.html#a84d320093e1561f82e57776aafd947d7">Filter</a> mini, <a class="el" href="namespacepvr.html#a84d320093e1561f82e57776aafd947d7">Filter</a> magni, <a class="el" href="namespacepvr.html#ac7a59f03f943f1c79a5339331fc15abe">SamplerMipmapMode</a> mip)</td></tr>
<tr class="memdesc:abbe45548f9e676d52b1645ea21ba4d11"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pack a minification filter, a magnification filter and a mipmap filter into an 8 bit value <a href="#abbe45548f9e676d52b1645ea21ba4d11">More...</a><br/></td></tr>
<tr class="separator:abbe45548f9e676d52b1645ea21ba4d11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25b61a39a49138f7e12cfb6341ee8c10"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr.html#a25b61a39a49138f7e12cfb6341ee8c10">PVRTDecompressETC</a> (const void *srcData, unsigned int xDim, unsigned int yDim, void *dstData, int mode)</td></tr>
<tr class="memdesc:a25b61a39a49138f7e12cfb6341ee8c10"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decompresses ETC to RGBA 8888. <a href="#a25b61a39a49138f7e12cfb6341ee8c10">More...</a><br/></td></tr>
<tr class="separator:a25b61a39a49138f7e12cfb6341ee8c10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a548c4f915769e543602e3f76cc1a3be1"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr.html#a548c4f915769e543602e3f76cc1a3be1">PVRTDecompressPVRTC</a> (const void *compressedData, int do2bitMode, int xDim, int yDim, uint8_t *outResultImage)</td></tr>
<tr class="memdesc:a548c4f915769e543602e3f76cc1a3be1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decompresses PVRTC to RGBA 8888. <a href="#a548c4f915769e543602e3f76cc1a3be1">More...</a><br/></td></tr>
<tr class="separator:a548c4f915769e543602e3f76cc1a3be1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7cc135f8fc78f66cf936fd87efc7fccf"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr.html#a7cc135f8fc78f66cf936fd87efc7fccf">randomrange</a> (float min, float max)</td></tr>
<tr class="memdesc:a7cc135f8fc78f66cf936fd87efc7fccf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a random Number between min and max <a href="#a7cc135f8fc78f66cf936fd87efc7fccf">More...</a><br/></td></tr>
<tr class="separator:a7cc135f8fc78f66cf936fd87efc7fccf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37496ce30d200726b9bef9242ba09067"><td class="memTemplParams" colspan="2">template&lt;typename T1_ &gt; </td></tr>
<tr class="memitem:a37496ce30d200726b9bef9242ba09067"><td class="memTemplItemLeft" align="right" valign="top">std::array&lt; T1_, sizeof(T1_)&gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepvr.html#a37496ce30d200726b9bef9242ba09067">readBits</a> (const T1_ &amp;value)</td></tr>
<tr class="memdesc:a37496ce30d200726b9bef9242ba09067"><td class="mdescLeft">&#160;</td><td class="mdescRight">Store the bits of a value in a static array of char. <a href="#a37496ce30d200726b9bef9242ba09067">More...</a><br/></td></tr>
<tr class="separator:a37496ce30d200726b9bef9242ba09067"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76f231dbfb5ad9022123a9972f169854"><td class="memTemplParams" colspan="2">template&lt;typename Toutput_ , typename Tinput_ &gt; </td></tr>
<tr class="memitem:a76f231dbfb5ad9022123a9972f169854"><td class="memTemplItemLeft" align="right" valign="top">Toutput_&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepvr.html#a76f231dbfb5ad9022123a9972f169854">reinterpretBits</a> (const Tinput_ &amp;value)</td></tr>
<tr class="memdesc:a76f231dbfb5ad9022123a9972f169854"><td class="mdescLeft">&#160;</td><td class="mdescRight">Take a value's bit representation and reinterpret them as another type. Second template parameter should normally be implicitly declared. First template parameter is mandatory. <a href="#a76f231dbfb5ad9022123a9972f169854">More...</a><br/></td></tr>
<tr class="separator:a76f231dbfb5ad9022123a9972f169854"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51280ed25278cee3f54f412a863158ad"><td class="memTemplParams" colspan="2">template&lt;typename Item &gt; </td></tr>
<tr class="memitem:a51280ed25278cee3f54f412a863158ad"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepvr.html#a51280ed25278cee3f54f412a863158ad">swap</a> (<a class="el" href="classpvr_1_1_ring_buffer.html">RingBuffer</a>&lt; Item &gt; &amp;left, <a class="el" href="classpvr_1_1_ring_buffer.html">RingBuffer</a>&lt; Item &gt; &amp;right)</td></tr>
<tr class="memdesc:a51280ed25278cee3f54f412a863158ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">A swap function for the <a class="el" href="classpvr_1_1_ring_buffer.html" title="A classic, templated, efficient RingBuffer implementation. Supports operations at both ends (front...">RingBuffer</a>. Efficiently exchanges the items between two ring buffers. No actual item copies happen. <a href="#a51280ed25278cee3f54f412a863158ad">More...</a><br/></td></tr>
<tr class="separator:a51280ed25278cee3f54f412a863158ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af73ac8316fd8bc048cee4cb33c8ca226"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr.html#af73ac8316fd8bc048cee4cb33c8ca226">textureOffset2D</a> (uint64_t x, uint64_t y, uint64_t width)</td></tr>
<tr class="memdesc:af73ac8316fd8bc048cee4cb33c8ca226"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate the offset of a 2D texture <a href="#af73ac8316fd8bc048cee4cb33c8ca226">More...</a><br/></td></tr>
<tr class="separator:af73ac8316fd8bc048cee4cb33c8ca226"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f1dcae0666fe3f28a26302a7c5d0c03"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr.html#a4f1dcae0666fe3f28a26302a7c5d0c03">textureOffset3D</a> (uint64_t x, uint64_t y, uint64_t z, uint64_t width, uint64_t height)</td></tr>
<tr class="memdesc:a4f1dcae0666fe3f28a26302a7c5d0c03"><td class="mdescLeft">&#160;</td><td class="mdescRight">calculate the offset of 3D texture <a href="#a4f1dcae0666fe3f28a26302a7c5d0c03">More...</a><br/></td></tr>
<tr class="separator:a4f1dcae0666fe3f28a26302a7c5d0c03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a547738cbdb228eba2d1d4b58d2c142c9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacepvr.html#a7924324f96dc973225ad3c532cc72309">DataType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr.html#a547738cbdb228eba2d1d4b58d2c142c9">toDataType</a> (<a class="el" href="namespacepvr.html#aa4440f5fd1256889bd3b3822002208b6">GpuDatatypes</a> type)</td></tr>
<tr class="memdesc:a547738cbdb228eba2d1d4b58d2c142c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the Cpu Datatype <em>type</em>  refers to (i.e. which CPU datatype must you load in the data you upload to the GPU to correctly upload the same value in the shader). <a href="#a547738cbdb228eba2d1d4b58d2c142c9">More...</a><br/></td></tr>
<tr class="separator:a547738cbdb228eba2d1d4b58d2c142c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea8728868bc6c9fa07c48f1f6d0e2f37"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr.html#aea8728868bc6c9fa07c48f1f6d0e2f37">toString</a> (<a class="el" href="namespacepvr.html#aa4440f5fd1256889bd3b3822002208b6">GpuDatatypes</a> type)</td></tr>
<tr class="memdesc:aea8728868bc6c9fa07c48f1f6d0e2f37"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a string with the glsl variable name of a type <a href="#aea8728868bc6c9fa07c48f1f6d0e2f37">More...</a><br/></td></tr>
<tr class="separator:aea8728868bc6c9fa07c48f1f6d0e2f37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93997dab7a634e84d3ac4cdd4bb7fa33"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr.html#a93997dab7a634e84d3ac4cdd4bb7fa33">unpackSamplerFilter</a> (<a class="el" href="namespacepvr.html#aafc960d10904ec52d4d823ed66717c43">PackedSamplerFilter</a> packed, <a class="el" href="namespacepvr.html#a84d320093e1561f82e57776aafd947d7">Filter</a> &amp;mini, <a class="el" href="namespacepvr.html#a84d320093e1561f82e57776aafd947d7">Filter</a> &amp;magni, <a class="el" href="namespacepvr.html#ac7a59f03f943f1c79a5339331fc15abe">SamplerMipmapMode</a> &amp;mip)</td></tr>
<tr class="memdesc:a93997dab7a634e84d3ac4cdd4bb7fa33"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unpack a 8 bit PackedSamplerFilter value into a minification, magnification and mip filter mode <a href="#a93997dab7a634e84d3ac4cdd4bb7fa33">More...</a><br/></td></tr>
<tr class="separator:a93997dab7a634e84d3ac4cdd4bb7fa33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9543f5ab3a8fff438b39adb92b8a1ff4"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr.html#a9543f5ab3a8fff438b39adb92b8a1ff4">writeTGA</a> (const char *const filename, unsigned int w, unsigned int h, const unsigned char *const imageData, const unsigned char stride, unsigned int pixelReplicate=1)</td></tr>
<tr class="memdesc:a9543f5ab3a8fff438b39adb92b8a1ff4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write out TGA data from an image. <a href="#a9543f5ab3a8fff438b39adb92b8a1ff4">More...</a><br/></td></tr>
<tr class="separator:a9543f5ab3a8fff438b39adb92b8a1ff4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Main PowerVR Framework Namespace</p>
</div><h2 class="groupheader">Typedef Documentation</h2>
<a class="anchor" id="a04c7a237dd1eb5c7ab24a7895f06d9fd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef ::std::vector&lt;char&gt; <a class="el" href="namespacepvr.html#a04c7a237dd1eb5c7ab24a7895f06d9fd">pvr::CharBuffer</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Represents a buffer of Unsigned Bytes. Used to store raw data.</p>

</div>
</div>
<a class="anchor" id="a065d965f04c53d6e94e0e56a34289090"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="structpvr_1_1_generic_extent2_d.html">GenericExtent2D</a>&lt;uint32_t&gt; <a class="el" href="namespacepvr.html#a065d965f04c53d6e94e0e56a34289090">pvr::Extent2D</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A 2D, integer Extent typically used for Images</p>

</div>
</div>
<a class="anchor" id="abc7deef434e373b18abd3b929c31e9aa"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="structpvr_1_1_generic_extent3_d.html">GenericExtent3D</a>&lt;uint32_t, uint32_t&gt; <a class="el" href="namespacepvr.html#abc7deef434e373b18abd3b929c31e9aa">pvr::Extent3D</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A 3D, integer Extent typically used for 3D Images</p>

</div>
</div>
<a class="anchor" id="a3c68f9a2f58eb4afee65dee64a84ec60"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="structpvr_1_1_generic_offset2_d.html">GenericOffset2D</a>&lt;int32_t&gt; <a class="el" href="namespacepvr.html#a3c68f9a2f58eb4afee65dee64a84ec60">pvr::Offset2D</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A 2D, integer Offset typically used for Images</p>

</div>
</div>
<a class="anchor" id="a9c82b565cdd75fbf396893a67ce24f4d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="structpvr_1_1_generic_offset3_d.html">GenericOffset3D</a>&lt;int32_t, int32_t&gt; <a class="el" href="namespacepvr.html#a9c82b565cdd75fbf396893a67ce24f4d">pvr::Offset3D</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A 3D, integer Offset typically used for 3D Images</p>

</div>
</div>
<a class="anchor" id="aedeecfbbd5f300d790a94b7f47277582"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void* <a class="el" href="namespacepvr.html#aedeecfbbd5f300d790a94b7f47277582">pvr::OSApplication</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Native application type.</p>

</div>
</div>
<a class="anchor" id="ac6f2b93a38b04d593e40fb33ac919de9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void* <a class="el" href="namespacepvr.html#ac6f2b93a38b04d593e40fb33ac919de9">pvr::OSDATA</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Native application data type.</p>

</div>
</div>
<a class="anchor" id="aeb92095259cdb0e0a5013d243b8cdcad"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void* <a class="el" href="namespacepvr.html#aeb92095259cdb0e0a5013d243b8cdcad">pvr::OSDisplay</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Native display type.</p>

</div>
</div>
<a class="anchor" id="a4a3c2268d5e5b11e1bc9cf97d7c337e8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void* <a class="el" href="namespacepvr.html#a4a3c2268d5e5b11e1bc9cf97d7c337e8">pvr::OSWindow</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Native window type.</p>

</div>
</div>
<a class="anchor" id="afc19de2d5b6952c2d5471033aa4f2563"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="structpvr_1_1_rectangle3_d.html">Rectangle3D</a>&lt;float&gt; <a class="el" href="namespacepvr.html#afc19de2d5b6952c2d5471033aa4f2563">pvr::Rectangle3Df</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A float 3D rectangle</p>

</div>
</div>
<a class="anchor" id="a799b34b4c6caf281d54db6a9756dc39d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="structpvr_1_1_rectangle3_d.html">Rectangle3D</a>&lt;int32_t&gt; <a class="el" href="namespacepvr.html#a799b34b4c6caf281d54db6a9756dc39d">pvr::Rectangle3Di</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>An integer 3D rectangle</p>

</div>
</div>
<a class="anchor" id="aba0728db2b6aa21ad82b263a102fec44"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="structpvr_1_1_rectangle.html">Rectangle</a>&lt;float&gt; <a class="el" href="namespacepvr.html#aba0728db2b6aa21ad82b263a102fec44">pvr::Rectanglef</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A floating point 2D rectangle</p>

</div>
</div>
<a class="anchor" id="a779802ae077693e9183007cfbedf47d4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="structpvr_1_1_rectangle.html">Rectangle</a>&lt;int32_t&gt; <a class="el" href="namespacepvr.html#a779802ae077693e9183007cfbedf47d4">pvr::Rectanglei</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>An integer 2D rectangle</p>

</div>
</div>
<a class="anchor" id="a6d599bef48e61e7de820debff386447e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef ::std::vector&lt;uint8_t&gt; <a class="el" href="namespacepvr.html#a6d599bef48e61e7de820debff386447e">pvr::UInt8Buffer</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Represents a buffer of Unsigned Bytes. Used to store raw data.</p>

</div>
</div>
<a class="anchor" id="a2f1b3a4b714cc874e267883662058a19"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef unsigned short <a class="el" href="namespacepvr.html#a2f1b3a4b714cc874e267883662058a19">pvr::utf16</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A UTF-16 (unsigned) character. 16-bit unsigned Integer.</p>

</div>
</div>
<a class="anchor" id="ae281450f4795e25d5ce35d674b17249b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef unsigned int <a class="el" href="namespacepvr.html#ae281450f4795e25d5ce35d674b17249b">pvr::utf32</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A UTF-32 (unsigned) character. 32-bit unsigned Integer.</p>

</div>
</div>
<a class="anchor" id="a9ee58768dfb56ed9216c98178d572e17"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef unsigned char <a class="el" href="namespacepvr.html#a9ee58768dfb56ed9216c98178d572e17">pvr::utf8</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A UTF-8 (unsigned) character. 8-bit unsigned Integer.</p>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a class="anchor" id="aa46a7b909f63be7b061dd6fedbc66dfc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">anonymous enum</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Flag interpreted as All mipmap levels.</p>

</div>
</div>
<a class="anchor" id="a74c5d1afa51512f076dd8e5844b171c8"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacepvr.html#a74c5d1afa51512f076dd8e5844b171c8">pvr::Api</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Enumeration of all API types supported by this implementation</p>

</div>
</div>
<a class="anchor" id="afc560f133c0bcec5adff02183b4a9386"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacepvr.html#afc560f133c0bcec5adff02183b4a9386">pvr::BlendFactor</a> : uint8_t</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Specfies how the rgba blending facors are computed for source and destination fragments.</p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><em><a class="anchor" id="afc560f133c0bcec5adff02183b4a9386ad7ed4ee1df437474d005188535f74875"></a>Zero</em>&#160;</td><td class="fielddoc">
<p>Zero. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="afc560f133c0bcec5adff02183b4a9386a06c2cea18679d64399783748fa367bdd"></a>One</em>&#160;</td><td class="fielddoc">
<p>One. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="afc560f133c0bcec5adff02183b4a9386a2ad714e29d37896d79187312086bc6fe"></a>SrcColor</em>&#160;</td><td class="fielddoc">
<p>The colour of the incoming fragment. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="afc560f133c0bcec5adff02183b4a9386a09d3240b4e2481b1a729da24e9bfddf7"></a>OneMinusSrcColor</em>&#160;</td><td class="fielddoc">
<p>1 - (SourceColor) </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="afc560f133c0bcec5adff02183b4a9386afaedf511c99a5461048fd6a3b73da26c"></a>DstColor</em>&#160;</td><td class="fielddoc">
<p>The color of the pixel already in the framebuffer. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="afc560f133c0bcec5adff02183b4a9386a09f1a054ebd4d3850fd248bd2fa7b325"></a>OneMinusDstColor</em>&#160;</td><td class="fielddoc">
<p>1 - (Destination Color) </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="afc560f133c0bcec5adff02183b4a9386ad5c7b7f0102df3f7305c43f73fc3a498"></a>SrcAlpha</em>&#160;</td><td class="fielddoc">
<p>The alpha of the incoming fragment. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="afc560f133c0bcec5adff02183b4a9386ac00a6016489cff63d50d489ce52254cc"></a>OneMinusSrcAlpha</em>&#160;</td><td class="fielddoc">
<p>1- (Source Alpha) </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="afc560f133c0bcec5adff02183b4a9386af72dbe2436b38a39e5927ed644e6818b"></a>DstAlpha</em>&#160;</td><td class="fielddoc">
<p>The alpha of the pixel already in the framebuffer (requires an alpha channel) </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="afc560f133c0bcec5adff02183b4a9386a4132e4b87a8d461be2c6ee8fc620cfb2"></a>OneMinusDstAlpha</em>&#160;</td><td class="fielddoc">
<p>1- (Destination Alpha) </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="afc560f133c0bcec5adff02183b4a9386aeb8eb99f8eea9079c0e76d5ce7301dd3"></a>ConstantColor</em>&#160;</td><td class="fielddoc">
<p>A constant color provided by the api. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="afc560f133c0bcec5adff02183b4a9386a13ab8deb1c606ab17745354b4e92f43a"></a>OneMinusConstantColor</em>&#160;</td><td class="fielddoc">
<p>1- (Constant Color) </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="afc560f133c0bcec5adff02183b4a9386a6f0229db491c3b01860363456dc57288"></a>ConstantAlpha</em>&#160;</td><td class="fielddoc">
<p>A constant alpha value provided by the api. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="afc560f133c0bcec5adff02183b4a9386a9a1874144125c69e93ec99f17e985e41"></a>OneMinusConstantAlpha</em>&#160;</td><td class="fielddoc">
<p>1- (ConstantAlpha) </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="afc560f133c0bcec5adff02183b4a9386a87c65d6ae5c79e8a05482365776bd959"></a>Src1Color</em>&#160;</td><td class="fielddoc">
<p>Source Color 1. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="afc560f133c0bcec5adff02183b4a9386ac1686472488cf32c06cc257f4e8ac04f"></a>OneMinusSrc1Color</em>&#160;</td><td class="fielddoc">
<p>1 - (Source Color 1) </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="afc560f133c0bcec5adff02183b4a9386aa69d96453c025ed62b3276e892e59e39"></a>Src1Alpha</em>&#160;</td><td class="fielddoc">
<p>Source Alpha 1. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="afc560f133c0bcec5adff02183b4a9386a88dfdcc65a80f412d0330f00579ab7f2"></a>OneMinusSrc1Alpha</em>&#160;</td><td class="fielddoc">
<p>1 - (Source Alpha 1) </p>
</td></tr>
</table>

</div>
</div>
<a class="anchor" id="a78be6b6f15903b90d6a9d575ebf6d353"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacepvr.html#a78be6b6f15903b90d6a9d575ebf6d353">pvr::BlendOp</a> : uint32_t</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Enumeration of the blend operations (determine how a new pixel (source color) is combined with a pixel already in the framebuffer (destination color).</p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><em><a class="anchor" id="a78be6b6f15903b90d6a9d575ebf6d353aec211f7c20af43e742bf2570c3cb84f9"></a>Add</em>&#160;</td><td class="fielddoc">
<p>Addition. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a78be6b6f15903b90d6a9d575ebf6d353a1d9baf077ee87921f57a8fe42d510b65"></a>Subtract</em>&#160;</td><td class="fielddoc">
<p>Subtraction second from first. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a78be6b6f15903b90d6a9d575ebf6d353abd5458190996e76988cb2f27a820c685"></a>ReverseSubtract</em>&#160;</td><td class="fielddoc">
<p>Subtract first from second. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a78be6b6f15903b90d6a9d575ebf6d353a78d811e98514cd165dda532286610fd2"></a>Min</em>&#160;</td><td class="fielddoc">
<p>Minimum of the two. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a78be6b6f15903b90d6a9d575ebf6d353a6a061313d22e51e0f25b7cd4dc065233"></a>Max</em>&#160;</td><td class="fielddoc">
<p>Maximum of the two. </p>
</td></tr>
</table>

</div>
</div>
<a class="anchor" id="aa6ac287ad32e4b14937cee7ac81fb85e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacepvr.html#aa6ac287ad32e4b14937cee7ac81fb85e">pvr::BufferUsageFlags</a> : uint32_t</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Enumeration of all supported buffer use types.</p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><em><a class="anchor" id="aa6ac287ad32e4b14937cee7ac81fb85eac1b703f2c13fac2fff3e72d3e307d4c0"></a>TransferSrc</em>&#160;</td><td class="fielddoc">
<p>Transfer Source. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="aa6ac287ad32e4b14937cee7ac81fb85ea155895f4426d6fc97295ca2de160fd20"></a>TransferDest</em>&#160;</td><td class="fielddoc">
<p>Transfer Destination. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="aa6ac287ad32e4b14937cee7ac81fb85ea4b43da703340c8273da56cf3445c6754"></a>UniformTexelBuffer</em>&#160;</td><td class="fielddoc">
<p>Uniform Texel Buffer. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="aa6ac287ad32e4b14937cee7ac81fb85eaae1f93780c3073aeadaf118d550f0c65"></a>StorageTexelBuffer</em>&#160;</td><td class="fielddoc">
<p>Storage Texel Buffer. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="aa6ac287ad32e4b14937cee7ac81fb85ea88f133adfed6c854e5731cdffbf208cf"></a>UniformBuffer</em>&#160;</td><td class="fielddoc">
<p>UBO. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="aa6ac287ad32e4b14937cee7ac81fb85ea439f57c2c466c89db942b3de48298b2b"></a>StorageBuffer</em>&#160;</td><td class="fielddoc">
<p>SSBO. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="aa6ac287ad32e4b14937cee7ac81fb85ea7c3895116254ff0417e58b6286de27c0"></a>IndexBuffer</em>&#160;</td><td class="fielddoc">
<p>IBO. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="aa6ac287ad32e4b14937cee7ac81fb85ea10461f19cdb5aadba2fc9986be6400bd"></a>VertexBuffer</em>&#160;</td><td class="fielddoc">
<p>VBO. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="aa6ac287ad32e4b14937cee7ac81fb85ea7e5abafe55b7f7e20d417fe9c967d69e"></a>IndirectBuffer</em>&#160;</td><td class="fielddoc">
<p>A buffer that contains Draw Indirect commands. </p>
</td></tr>
</table>

</div>
</div>
<a class="anchor" id="af9ca1aead0a3149b0af3842d03bc6cd4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacepvr.html#af9ca1aead0a3149b0af3842d03bc6cd4">pvr::Capability</a> : uint8_t</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Capability supported values.</p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><em><a class="anchor" id="af9ca1aead0a3149b0af3842d03bc6cd4ab4080bdf74febf04d578ff105cce9d3f"></a>Unsupported</em>&#160;</td><td class="fielddoc">
<p>The capability is unsupported. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="af9ca1aead0a3149b0af3842d03bc6cd4a11efd9ae6f76e706e3f1b34d97584ebc"></a>Immutable</em>&#160;</td><td class="fielddoc">
<p>The capability exists but cannot be changed. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="af9ca1aead0a3149b0af3842d03bc6cd4ad924522d30d6615e9f71e91504364a9d"></a>Mutable</em>&#160;</td><td class="fielddoc">
<p>The capability is supported and can be changed. </p>
</td></tr>
</table>

</div>
</div>
<a class="anchor" id="a675b14a2f2079f7f72e7f2ad35d13de7"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacepvr.html#a675b14a2f2079f7f72e7f2ad35d13de7">pvr::ColorChannelFlags</a> : uint32_t</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>ChannelWriteMask enable/ disable writting to channel bits.</p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><em><a class="anchor" id="a675b14a2f2079f7f72e7f2ad35d13de7ae1e1d3d40573127e9ee0480caf1283d6"></a>R</em>&#160;</td><td class="fielddoc">
<p>write to red channel </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a675b14a2f2079f7f72e7f2ad35d13de7adfcf28d0734569a6a693bc8194de62bf"></a>G</em>&#160;</td><td class="fielddoc">
<p>write to green channel </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a675b14a2f2079f7f72e7f2ad35d13de7a9d5ed678fe57bcca610140957afab571"></a>B</em>&#160;</td><td class="fielddoc">
<p>write to blue channel </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a675b14a2f2079f7f72e7f2ad35d13de7a7fc56270e7a70fa81a5935b72eacbe29"></a>A</em>&#160;</td><td class="fielddoc">
<p>write to alpha channel </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a675b14a2f2079f7f72e7f2ad35d13de7a6adf97f83acf6453d4a6a4b1070f3754"></a>None</em>&#160;</td><td class="fielddoc">
<p>don't write to any channel </p>
</td></tr>
</table>

</div>
</div>
<a class="anchor" id="a1b94afe6b8a7c21e8f8ddee1f7b5cb91"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacepvr.html#a1b94afe6b8a7c21e8f8ddee1f7b5cb91">pvr::ColorSpace</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Enumeration of Colorspaces (Linear, SRGB).</p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><em><a class="anchor" id="a1b94afe6b8a7c21e8f8ddee1f7b5cb91a4c8bf835da6d934b50f620cdd0cc3913"></a>lRGB</em>&#160;</td><td class="fielddoc">
<p>Linear RGB colorspace. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a1b94afe6b8a7c21e8f8ddee1f7b5cb91a9ed33d9be17d174aeb4393a989586ed9"></a>sRGB</em>&#160;</td><td class="fielddoc">
<p>sRGB colorspace </p>
</td></tr>
</table>

</div>
</div>
<a class="anchor" id="a24a87498f839b45b6e1bc3c8b2ca20fc"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacepvr.html#a24a87498f839b45b6e1bc3c8b2ca20fc">pvr::CompareOp</a> : uint32_t</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>An enumeration that defines Comparison operations (equal, less or equal etc.). Especially used in API classes for functions like depth testing.</p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><em><a class="anchor" id="a24a87498f839b45b6e1bc3c8b2ca20fca6e7b34fa59e1bd229b207892956dc41c"></a>Never</em>&#160;</td><td class="fielddoc">
<p>Always false. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a24a87498f839b45b6e1bc3c8b2ca20fca1cfdf0e8d0c87a228c1f40d9bee7888b"></a>Less</em>&#160;</td><td class="fielddoc">
<p>True if lhs&lt;rhs. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a24a87498f839b45b6e1bc3c8b2ca20fcaf5f286e73bda105e538310b3190f75c5"></a>Equal</em>&#160;</td><td class="fielddoc">
<p>True if lhs==rhs. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a24a87498f839b45b6e1bc3c8b2ca20fcad3e6fdac55bb7b0edd7834c968ba1f38"></a>LessEqual</em>&#160;</td><td class="fielddoc">
<p>True if lhs&lt;=rhs. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a24a87498f839b45b6e1bc3c8b2ca20fca8768a6821cd735aea4f5b0df88c1fc6a"></a>Greater</em>&#160;</td><td class="fielddoc">
<p>True if lhs&gt;rhs. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a24a87498f839b45b6e1bc3c8b2ca20fca19bb0af2c3c530538cb41aff7f235b96"></a>NotEqual</em>&#160;</td><td class="fielddoc">
<p>True if lhs!=rhs. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a24a87498f839b45b6e1bc3c8b2ca20fca758b05d899def79c9eb864ad4f96be1f"></a>GreaterEqual</em>&#160;</td><td class="fielddoc">
<p>True if lhs&gt;=rhs. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a24a87498f839b45b6e1bc3c8b2ca20fca68eec46437c384d8dad18d5464ebc35c"></a>Always</em>&#160;</td><td class="fielddoc">
<p>Always true. </p>
</td></tr>
</table>

</div>
</div>
<a class="anchor" id="a7cfc7d042b44f46e4d5dfbb32d0f16b1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacepvr.html#a7cfc7d042b44f46e4d5dfbb32d0f16b1">pvr::CompressedPixelFormat</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Enumeration of all known Compressed pixel formats.</p>

</div>
</div>
<a class="anchor" id="a0e463dd072d8bc9dd455491d1a663668"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacepvr.html#a0e463dd072d8bc9dd455491d1a663668">pvr::Constants</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Legacy constants (V1/V2)</p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><em><a class="anchor" id="a0e463dd072d8bc9dd455491d1a663668a23671adbbb6b36b70a41c08602e2564f"></a>PVRTEX_TWIDDLE</em>&#160;</td><td class="fielddoc">
<p>&lt; Has mip map levels. DEPRECATED. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a0e463dd072d8bc9dd455491d1a663668ab99b95a8d3e3a09915f701ebd11669e0"></a>PVRTEX_BUMPMAP</em>&#160;</td><td class="fielddoc">
<p>&lt; Is twiddled. DEPRECATED. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a0e463dd072d8bc9dd455491d1a663668a5e73cc8fec9a5861208b97999f1cd0b2"></a>PVRTEX_TILING</em>&#160;</td><td class="fielddoc">
<p>&lt; Has normals encoded for a bump map. DEPRECATED. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a0e463dd072d8bc9dd455491d1a663668a80424d056ec65d5439dc169f1d35b625"></a>PVRTEX_CUBEMAP</em>&#160;</td><td class="fielddoc">
<p>&lt; Is bordered for tiled pvr. DEPRECATED. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a0e463dd072d8bc9dd455491d1a663668aad5d7bfcceebb69cd04ae90c0d908d5b"></a>PVRTEX_FALSEMIPCOL</em>&#160;</td><td class="fielddoc">
<p>&lt; Is a cubemap/skybox. DEPRECATED.} </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a0e463dd072d8bc9dd455491d1a663668aaa409129950b394648312efe10d36586"></a>PVRTEX_VOLUME</em>&#160;</td><td class="fielddoc">
<p>&lt; Are there false colored MIP levels. DEPRECATED. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a0e463dd072d8bc9dd455491d1a663668a572250b03ef82171e377f9c87fa5e25f"></a>PVRTEX_ALPHA</em>&#160;</td><td class="fielddoc">
<p>&lt; Is this a volume texture. DEPRECATED. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a0e463dd072d8bc9dd455491d1a663668aab9c48c3d41c2cc10f01442e1856b77c"></a>PVRTEX_VERTICAL_FLIP</em>&#160;</td><td class="fielddoc">
<p>&lt; v2.1. Is there transparency info in the texture. DEPRECATED. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a0e463dd072d8bc9dd455491d1a663668a691f6acd2426ef4b6dfbecaec8600b13"></a>PVRTEX_PIXELTYPE</em>&#160;</td><td class="fielddoc">
<p>&lt; v2.1. Is the texture vertically flipped. DEPRECATED. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a0e463dd072d8bc9dd455491d1a663668a365c121026e2901f535781d41d93d3da"></a>PVRTEX_IDENTIFIER</em>&#160;</td><td class="fielddoc">
<p>&lt; Pixel type is always in the last 16bits of the flags. DEPRECATED. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a0e463dd072d8bc9dd455491d1a663668aff34d9bbfcc9a6c42a07476cf6661cd9"></a>PVRTEX_V1_HEADER_SIZE</em>&#160;</td><td class="fielddoc">
<p>&lt; The pvr identifier is the characters 'P','V','R'. DEPRECATED. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a0e463dd072d8bc9dd455491d1a663668a7ec982a2d890d48cae143c5970765ecf"></a>PVRTC2_MIN_TEXWIDTH</em>&#160;</td><td class="fielddoc">
<p>&lt; Old header size was 44 for identification purposes. DEPRECATED. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a0e463dd072d8bc9dd455491d1a663668ae3decd2de15588863ccea790249edc0a"></a>PVRTC2_MIN_TEXHEIGHT</em>&#160;</td><td class="fielddoc">
<p>&lt; DEPRECATED. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a0e463dd072d8bc9dd455491d1a663668a997b74fc5e403a09bdb4faf5b352f7b4"></a>PVRTC4_MIN_TEXWIDTH</em>&#160;</td><td class="fielddoc">
<p>&lt; DEPRECATED. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a0e463dd072d8bc9dd455491d1a663668a1a04f251581dd946893556f0dce39d1a"></a>PVRTC4_MIN_TEXHEIGHT</em>&#160;</td><td class="fielddoc">
<p>&lt; DEPRECATED. </p>
</td></tr>
</table>

</div>
</div>
<a class="anchor" id="a87b409df225dee78541eb74988f4e20c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacepvr.html#a87b409df225dee78541eb74988f4e20c">pvr::CubeFace</a> : uint32_t</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Enumeration of the six faces of a Cube</p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><em><a class="anchor" id="a87b409df225dee78541eb74988f4e20ca9f082d04c481aab268b9f614d2ffd129"></a>PositiveX</em>&#160;</td><td class="fielddoc">
<p>+x </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a87b409df225dee78541eb74988f4e20ca963a8a64a09d54efc81b136ca6be21b2"></a>NegativeX</em>&#160;</td><td class="fielddoc">
<p>-x </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a87b409df225dee78541eb74988f4e20cac53c385ced96bd629c0f45a902aceba3"></a>PositiveY</em>&#160;</td><td class="fielddoc">
<p>+y </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a87b409df225dee78541eb74988f4e20cae4d5f02ceecd15caf66e9f0b2393c86b"></a>NegativeY</em>&#160;</td><td class="fielddoc">
<p>-y </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a87b409df225dee78541eb74988f4e20ca1921c16ffdafaf04e378ca1b6774c0ce"></a>PositiveZ</em>&#160;</td><td class="fielddoc">
<p>+z </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a87b409df225dee78541eb74988f4e20cada76df034cd139bd515761c8bb8e3090"></a>NegativeZ</em>&#160;</td><td class="fielddoc">
<p>-z </p>
</td></tr>
</table>

</div>
</div>
<a class="anchor" id="a7924324f96dc973225ad3c532cc72309"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacepvr.html#a7924324f96dc973225ad3c532cc72309">pvr::DataType</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>An enumeration that defines data types used throughout the Framework. Commonly used in places where raw data are used to define the types actually contained.</p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><em><a class="anchor" id="a7924324f96dc973225ad3c532cc72309a6adf97f83acf6453d4a6a4b1070f3754"></a>None</em>&#160;</td><td class="fielddoc">
<p>None, or unknown. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a7924324f96dc973225ad3c532cc72309a166495adc0d0f53bee6baecc577f5204"></a>Float32</em>&#160;</td><td class="fielddoc">
<p>32 bit floating point number </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a7924324f96dc973225ad3c532cc72309ac06129f6e6e15c09328365e553f1dc31"></a>Int32</em>&#160;</td><td class="fielddoc">
<p>32 bit Integer </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a7924324f96dc973225ad3c532cc72309a8bd950a9d7779b83f5c30046c9aaf1cf"></a>UInt16</em>&#160;</td><td class="fielddoc">
<p>16 bit Unsigned Integer (aka Unsigned Short) </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a7924324f96dc973225ad3c532cc72309aea3495a278957dc58165e48a8945469f"></a>RGBA</em>&#160;</td><td class="fielddoc">
<p>32 bit (4 channels x 8bpc), in Red,Green,Blue,Alpha order </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a7924324f96dc973225ad3c532cc72309ae192297ecf3602fabbec5f0a38ede758"></a>ARGB</em>&#160;</td><td class="fielddoc">
<p>32 bit (4 channels x 8bpc), in Alpha,Red,Green,Blue order </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a7924324f96dc973225ad3c532cc72309a67cb8b94254acbfda2cdf7a916421298"></a>D3DCOLOR</em>&#160;</td><td class="fielddoc">
<p>Direct3D color format. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a7924324f96dc973225ad3c532cc72309aa061360f8e01902202f21849c40a1105"></a>UBYTE4</em>&#160;</td><td class="fielddoc">
<p>Direct3D UBYTE4 format. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a7924324f96dc973225ad3c532cc72309aff4e3dcc2ead0fa54993ccbf4eda1ae8"></a>DEC3N</em>&#160;</td><td class="fielddoc">
<p>Direct3D DEC3N format. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a7924324f96dc973225ad3c532cc72309a32e326bf2ef732551075db8987a1408c"></a>Fixed16_16</em>&#160;</td><td class="fielddoc">
<p>32 bit Fixed Point (16 + 16) </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a7924324f96dc973225ad3c532cc72309ab31df9c476d20e85ff898121efe11b5a"></a>UInt8</em>&#160;</td><td class="fielddoc">
<p>Unsigned 8 bit integer (aka unsigned char/byte) </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a7924324f96dc973225ad3c532cc72309a39bc2ae44b184207f560ff8619823208"></a>Int16</em>&#160;</td><td class="fielddoc">
<p>Signed 16 bit integer (aka short) </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a7924324f96dc973225ad3c532cc72309a0f224678669aa9f1b9e9dee8c544912a"></a>Int16Norm</em>&#160;</td><td class="fielddoc">
<p>Signed 16 bit integer scaled to a value from -1..1 (aka normalized short) </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a7924324f96dc973225ad3c532cc72309a7d839b2c12bfd40ac121b4cc9e81c539"></a>Int8</em>&#160;</td><td class="fielddoc">
<p>Signed 8 bit integer (aka char / byte) </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a7924324f96dc973225ad3c532cc72309a74f0eeb95bdbf29bcc7eb2b6431c13f2"></a>Int8Norm</em>&#160;</td><td class="fielddoc">
<p>Signed 8 bit integer, interpreted by scaling to -1..1 (aka normalized byte) </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a7924324f96dc973225ad3c532cc72309a784d359bf21cc07236f54855d9aab91a"></a>UInt8Norm</em>&#160;</td><td class="fielddoc">
<p>Unsigned 8 bit integer, interpreted by scaling to 0..1 (aka unsigned normalized byte) </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a7924324f96dc973225ad3c532cc72309ab296ec5fbf49139c807bd99ba7f7dee8"></a>UInt16Norm</em>&#160;</td><td class="fielddoc">
<p>Unsigned 16 bit integer, interpreted by scaling to 0..1 (aka unsigned normalized short) </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a7924324f96dc973225ad3c532cc72309ae7956ed7be1c5025a27ed3cb42a396bd"></a>UInt32</em>&#160;</td><td class="fielddoc">
<p>Unsigned 32 bit integer (aka Unsigned Int) </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a7924324f96dc973225ad3c532cc72309adce7d10c2f9ffc8ed9e7b6a3f7d8ba6c"></a>ABGR</em>&#160;</td><td class="fielddoc">
<p>32 bit (4 channels x 8 bpc), in Alpha,Blue,Green,Red order </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a7924324f96dc973225ad3c532cc72309a26e6ed77470c6f2f830ecf874e6c0d55"></a>Float16</em>&#160;</td><td class="fielddoc">
<p>16 bit IEEE 754-2008 floating point number (aka Half) </p>
</td></tr>
</table>

</div>
</div>
<a class="anchor" id="a3283c5c9822ac5135fefd45a7cdd5932"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacepvr.html#a3283c5c9822ac5135fefd45a7cdd5932">pvr::DescriptorType</a> : uint32_t</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Enumeration of all the different descriptor types.</p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><em><a class="anchor" id="a3283c5c9822ac5135fefd45a7cdd5932a5bca2f066df1fe641b2b779db2a63c0a"></a>Sampler</em>&#160;</td><td class="fielddoc">
<p>A Sampler object. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a3283c5c9822ac5135fefd45a7cdd5932a8cfe077ac9aea5235b0c3fda85914029"></a>CombinedImageSampler</em>&#160;</td><td class="fielddoc">
<p>A descriptor that contains both and image and its sampler. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a3283c5c9822ac5135fefd45a7cdd5932a4520c597ce328c250d1ca5192047d71d"></a>SampledImage</em>&#160;</td><td class="fielddoc">
<p>Aka "Texture". </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a3283c5c9822ac5135fefd45a7cdd5932aa078fa7ad769f9e7b53b8c42e3b7bbab"></a>StorageImage</em>&#160;</td><td class="fielddoc">
<p>Aka "Image for Image Load Store". </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a3283c5c9822ac5135fefd45a7cdd5932a4b43da703340c8273da56cf3445c6754"></a>UniformTexelBuffer</em>&#160;</td><td class="fielddoc">
<p>Aka <a class="el" href="classpvr_1_1_texture.html" title="A 2D Texture asset, together with Information, Metadata and actual Pixel data. Only represents the ac...">Texture</a> Buffer. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a3283c5c9822ac5135fefd45a7cdd5932aae1f93780c3073aeadaf118d550f0c65"></a>StorageTexelBuffer</em>&#160;</td><td class="fielddoc">
<p>Also known as TextureBuffer. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a3283c5c9822ac5135fefd45a7cdd5932a88f133adfed6c854e5731cdffbf208cf"></a>UniformBuffer</em>&#160;</td><td class="fielddoc">
<p>Aka UBO. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a3283c5c9822ac5135fefd45a7cdd5932a439f57c2c466c89db942b3de48298b2b"></a>StorageBuffer</em>&#160;</td><td class="fielddoc">
<p>Aka SSBO. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a3283c5c9822ac5135fefd45a7cdd5932a517b91f0588b3bf6c80ff3b19b2a7f57"></a>UniformBufferDynamic</em>&#160;</td><td class="fielddoc">
<p>A UBO that can be bound one piece at a time. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a3283c5c9822ac5135fefd45a7cdd5932ada8c94227ee0e3b5cd40da12d594ad55"></a>StorageBufferDynamic</em>&#160;</td><td class="fielddoc">
<p>A SSBO that can be bound one piece at a time. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a3283c5c9822ac5135fefd45a7cdd5932a261d965f5dd43c6873489b68730dbe57"></a>InputAttachment</em>&#160;</td><td class="fielddoc">
<p>An intermediate attachment that can be used between subpasses. </p>
</td></tr>
</table>

</div>
</div>
<a class="anchor" id="a1ca56afd652113209f2535e7688a4189"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacepvr.html#a1ca56afd652113209f2535e7688a4189">pvr::Face</a> : uint32_t</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Enumeration of Face facing (front, back...).</p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><em><a class="anchor" id="a1ca56afd652113209f2535e7688a4189a6adf97f83acf6453d4a6a4b1070f3754"></a>None</em>&#160;</td><td class="fielddoc">
<p>No faces. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a1ca56afd652113209f2535e7688a4189a5835bab1ade0060909e31a06af2e2cde"></a>Front</em>&#160;</td><td class="fielddoc">
<p>The front face. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a1ca56afd652113209f2535e7688a4189a0557fa923dcee4d0f86b1409f5c2167f"></a>Back</em>&#160;</td><td class="fielddoc">
<p>The back face. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a1ca56afd652113209f2535e7688a4189a8be41da9b58e32ece35a2b5751f6aeb9"></a>FrontAndBack</em>&#160;</td><td class="fielddoc">
<p>Both faces. </p>
</td></tr>
</table>

</div>
</div>
<a class="anchor" id="a84d320093e1561f82e57776aafd947d7"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacepvr.html#a84d320093e1561f82e57776aafd947d7">pvr::Filter</a> : uint8_t</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Enumeration describing a filtering type of a specific dimension. In order to describe the filtering mode properly, you would have to define a Minification filter, a Magnification filter and a Mipmapping minification filter. Possible values: Nearest, Linear, Cubic, None.</p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><em><a class="anchor" id="a84d320093e1561f82e57776aafd947d7a60494f02d440f316319dd0fad40ad007"></a>Nearest</em>&#160;</td><td class="fielddoc">
<p>Nearest neighbour. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a84d320093e1561f82e57776aafd947d7a6adf97f83acf6453d4a6a4b1070f3754"></a>None</em>&#160;</td><td class="fielddoc">
<p>No filtering. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a84d320093e1561f82e57776aafd947d7aec6b5414eb175379ff9efc9b3eef5814"></a>Cubic</em>&#160;</td><td class="fielddoc">
<p>Bicubic filtering (IMG extension) </p>
</td></tr>
</table>

</div>
</div>
<a class="anchor" id="aa4440f5fd1256889bd3b3822002208b6"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacepvr.html#aa4440f5fd1256889bd3b3822002208b6">pvr::GpuDatatypes</a> : uint32_t</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A (normally hardware-supported) GPU datatype (e.g. vec4 etc.)</p>

</div>
</div>
<a class="anchor" id="aee12f61a84bee4c4513c6bfad5b042d2"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacepvr.html#aee12f61a84bee4c4513c6bfad5b042d2">pvr::ImageAspectFlags</a> : uint32_t</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Enumeration of the "aspect" (or "semantics") of an image: Color, Depth, Stencil.</p>

</div>
</div>
<a class="anchor" id="ab98ea90165357c2f9030218c337f90bf"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacepvr.html#ab98ea90165357c2f9030218c337f90bf">pvr::ImageType</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The dimension of an image.</p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><em><a class="anchor" id="ab98ea90165357c2f9030218c337f90bfa4be6a4b9c4d4594764eb625d5c146fff"></a>Image1D</em>&#160;</td><td class="fielddoc">
<p>One-dimensional image. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="ab98ea90165357c2f9030218c337f90bfab696e5f895616f606a8be85892c374a9"></a>Image2D</em>&#160;</td><td class="fielddoc">
<p>Two-dimensional image. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="ab98ea90165357c2f9030218c337f90bfa2d4c32ae3db71aee7bf3a801d15f5075"></a>Image3D</em>&#160;</td><td class="fielddoc">
<p>Three-dimensional image. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="ab98ea90165357c2f9030218c337f90bfa9aeb35984c497717cce0044620fc964a"></a>Unallocated</em>&#160;</td><td class="fielddoc">
<p>An image that has not been allocated yet. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="ab98ea90165357c2f9030218c337f90bfa88183b946cc5f0e8c96b2e66e1c74a7e"></a>Unknown</em>&#160;</td><td class="fielddoc">
<p>An image of unknown dimensions. </p>
</td></tr>
</table>

</div>
</div>
<a class="anchor" id="a43f03a43047f737186d5b90b19dcaca2"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacepvr.html#a43f03a43047f737186d5b90b19dcaca2">pvr::ImageViewType</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Enumeration of <a class="el" href="classpvr_1_1_texture.html" title="A 2D Texture asset, together with Information, Metadata and actual Pixel data. Only represents the ac...">Texture</a> dimensionalities.</p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><em><a class="anchor" id="a43f03a43047f737186d5b90b19dcaca2a882bc3b744cc0702640a7bacf0bbcfec"></a>ImageView1D</em>&#160;</td><td class="fielddoc">
<p>1 dimensional Image View </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a43f03a43047f737186d5b90b19dcaca2ad6677d8d1d32ba21cdf283ac165924ad"></a>ImageView2D</em>&#160;</td><td class="fielddoc">
<p>2 dimensional Image View </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a43f03a43047f737186d5b90b19dcaca2a6698a767e1fc8afa8db1cd800d78d675"></a>ImageView3D</em>&#160;</td><td class="fielddoc">
<p>3 dimensional Image View </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a43f03a43047f737186d5b90b19dcaca2a0e44904a008408462e8f2567465f2157"></a>ImageView2DCube</em>&#160;</td><td class="fielddoc">
<p>cube texture </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a43f03a43047f737186d5b90b19dcaca2aba6b5050476daa2d65fe7081478ed7a0"></a>ImageView1DArray</em>&#160;</td><td class="fielddoc">
<p>1 dimensional Image View </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a43f03a43047f737186d5b90b19dcaca2abe5a0e508c8c71c3ab11da749a6678a7"></a>ImageView2DArray</em>&#160;</td><td class="fielddoc">
<p>2 dimensional Image View </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a43f03a43047f737186d5b90b19dcaca2a9ffe857cfe5d3eff82077db510ca5675"></a>ImageView2DCubeArray</em>&#160;</td><td class="fielddoc">
<p>2 dimensional Image View </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a43f03a43047f737186d5b90b19dcaca2aa9d24d469028b69a34b22604c244dfc3"></a>ImageViewUnknown</em>&#160;</td><td class="fielddoc">
<p>3 dimensional Image View </p>
</td></tr>
</table>

</div>
</div>
<a class="anchor" id="aab40a4733df51a99c80b389348c493ac"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacepvr.html#aab40a4733df51a99c80b389348c493ac">pvr::IndexType</a> : uint32_t</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>An enumeration that defines a type that can use as an index, typically 16 or 32 bit int. Especially used in Model classes.</p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><em><a class="anchor" id="aab40a4733df51a99c80b389348c493acac995e06991264df36fe28315304bcd6e"></a>IndexType16Bit</em>&#160;</td><td class="fielddoc">
<p>16 bit index </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="aab40a4733df51a99c80b389348c493aca456ada99990fe2c6043f27810c550148"></a>IndexType32Bit</em>&#160;</td><td class="fielddoc">
<p>32 bit index </p>
</td></tr>
</table>

</div>
</div>
<a class="anchor" id="aafc960d10904ec52d4d823ed66717c43"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacepvr.html#aafc960d10904ec52d4d823ed66717c43">pvr::PackedSamplerFilter</a> : int8_t</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This enum is made to pack all sampler filtering info in 8 bits for specific uses. Use "packSamplerFilter" and "unpackSamplerFilter". NOTE: The defined values are only the most common cases - other 8 bit values are also valid (for example, different minification and magnification filters)</p>

</div>
</div>
<a class="anchor" id="acebf4429ca4e976bca1ecaf28401bd59"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacepvr.html#acebf4429ca4e976bca1ecaf28401bd59">pvr::PolygonWindingOrder</a> : uint8_t</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Enumeration of the different front face to winding order correlations.</p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><em><a class="anchor" id="acebf4429ca4e976bca1ecaf28401bd59a6baa14a02b39a3336b6bf0087473eff3"></a>FrontFaceCCW</em>&#160;</td><td class="fielddoc">
<p>Front face is the Counter Clockwise face. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="acebf4429ca4e976bca1ecaf28401bd59a8331b56f0f66fa794a20609344081509"></a>FrontFaceCW</em>&#160;</td><td class="fielddoc">
<p>Front face is the Clockwise face. </p>
</td></tr>
</table>

</div>
</div>
<a class="anchor" id="a95105fe432efbe2b976187f0270b6012"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacepvr.html#a95105fe432efbe2b976187f0270b6012">pvr::PrimitiveTopology</a> : uint32_t</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Enumeration containing all possible Primitive topologies (Point, line trianglelist etc.).</p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><em><a class="anchor" id="a95105fe432efbe2b976187f0270b6012a1a18ff71b3df3e362a2489eef4b30003"></a>PointList</em>&#160;</td><td class="fielddoc">
<p>Renders poins. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a95105fe432efbe2b976187f0270b6012a596e1b7afe8925f3f578c716d5af8fef"></a>LineList</em>&#160;</td><td class="fielddoc">
<p>Each two items render a separate line segment. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a95105fe432efbe2b976187f0270b6012ae7f9e73b8edd21f420a63b3ace5768a2"></a>LineStrip</em>&#160;</td><td class="fielddoc">
<p>Renders one continuous polyline (n vertices represent n-1 lines) </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a95105fe432efbe2b976187f0270b6012af5beeab7a1f452e5b0e9b03b44f0de92"></a>TriangleList</em>&#160;</td><td class="fielddoc">
<p>Each 3 vertices render one triangle. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a95105fe432efbe2b976187f0270b6012a1da0b9ead8b051940a89214bae22831c"></a>TriangleStrip</em>&#160;</td><td class="fielddoc">
<p>Renders one continuous triangle strip, (n vertices represent n-2 triangles in a strip configuration) </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a95105fe432efbe2b976187f0270b6012a18d58fde618e4a30e2dfdc122e693047"></a>TriangleFan</em>&#160;</td><td class="fielddoc">
<p>Renders one continuous triangle fan (n vertices represent n-2 triangles in a fan configuration) </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a95105fe432efbe2b976187f0270b6012af951dbe32c0c5d525b8e0ec3884de6c7"></a>LineListWithAdjacency</em>&#160;</td><td class="fielddoc">
<p>Represents a list of lines, but contains adjacency info (2 additional vertices per 2 vertices: 4 vertices per line segment) </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a95105fe432efbe2b976187f0270b6012ae6a2093eb583f16122d50acb096af542"></a>LineStripWithAdjacency</em>&#160;</td><td class="fielddoc">
<p>Represents a continuous strip of lines, but contains adjacency info (2 additional vertices: the vertex before the first and the vertex after the last line segment) </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a95105fe432efbe2b976187f0270b6012a150324739f6017972f918eff656ba998"></a>TriangleListWithAdjacency</em>&#160;</td><td class="fielddoc">
<p>Represents a triangle list with adjacency info (6 vertices per primitive). </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a95105fe432efbe2b976187f0270b6012aa8df42f3be2313042a310fb7319b4c36"></a>TriangleStripWithAdjacency</em>&#160;</td><td class="fielddoc">
<p>Represents a triangle strip with adjacency info (1 additional adjacency vertex per triangle, plus the adjacent vertices of the first and last triangle sides of the list). </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a95105fe432efbe2b976187f0270b6012af1b220525e3cc747140a46b7e2d7532e"></a>PatchList</em>&#160;</td><td class="fielddoc">
<p>A list of Patches, intended for tessellation. </p>
</td></tr>
</table>

</div>
</div>
<a class="anchor" id="a1c5fa1488e4ba61dd568718646a8c73d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacepvr.html#a1c5fa1488e4ba61dd568718646a8c73d">pvr::Result</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Pre-defined Result codes (success and generic errors).</p>

</div>
</div>
<a class="anchor" id="aedec1ca92cba055434a2a27da89f5643"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacepvr.html#aedec1ca92cba055434a2a27da89f5643">pvr::SamplerAddressMode</a> : uint8_t</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Enumeration for defining texture wrapping mode: Repeat, Mirror, Clamp, Border.</p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><em><a class="anchor" id="aedec1ca92cba055434a2a27da89f5643a7020426cfb0a204051be4b3053d2acc8"></a>Repeat</em>&#160;</td><td class="fielddoc">
<p>repeat </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="aedec1ca92cba055434a2a27da89f5643a39a681a9d5ccc902bebd16a343dd7b74"></a>MirrorRepeat</em>&#160;</td><td class="fielddoc">
<p>mirror repeat </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="aedec1ca92cba055434a2a27da89f5643a74556551231333c36debc3d373261134"></a>ClampToEdge</em>&#160;</td><td class="fielddoc">
<p>clamp </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="aedec1ca92cba055434a2a27da89f5643afb07f88f6f11cc5ab9c951290716f147"></a>ClampToBorder</em>&#160;</td><td class="fielddoc">
<p>border </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="aedec1ca92cba055434a2a27da89f5643a01f488e80fc32761aecfbeb3d1c8f26b"></a>MirrorClampToEdge</em>&#160;</td><td class="fielddoc">
<p>mirror clamp </p>
</td></tr>
</table>

</div>
</div>
<a class="anchor" id="ac7a59f03f943f1c79a5339331fc15abe"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacepvr.html#ac7a59f03f943f1c79a5339331fc15abe">pvr::SamplerMipmapMode</a> : uint8_t</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Enumeration of mipmap modes supported for a sampler</p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><em><a class="anchor" id="ac7a59f03f943f1c79a5339331fc15abea60494f02d440f316319dd0fad40ad007"></a>Nearest</em>&#160;</td><td class="fielddoc">
<p>Nearest neighbour. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="ac7a59f03f943f1c79a5339331fc15abea32a843da6ea40ab3b17a3421ccdf671b"></a>Linear</em>&#160;</td><td class="fielddoc">
<p>Linear. </p>
</td></tr>
</table>

</div>
</div>
<a class="anchor" id="af5c2a4d46bb7aa6a877a0ed8c5ba3ac8"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacepvr.html#af5c2a4d46bb7aa6a877a0ed8c5ba3ac8">pvr::ShaderType</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Enumeration of all supported shader types.</p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><em><a class="anchor" id="af5c2a4d46bb7aa6a877a0ed8c5ba3ac8a05c0d061c57b467a86d66f7529f19bb5"></a>UnknownShader</em>&#160;</td><td class="fielddoc">
<p>unknown shader type </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="af5c2a4d46bb7aa6a877a0ed8c5ba3ac8aeb3ca4dac3e206977e0b7d998eefcc33"></a>VertexShader</em>&#160;</td><td class="fielddoc">
<p>vertex shader </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="af5c2a4d46bb7aa6a877a0ed8c5ba3ac8a90a9bb4e665932b1781da33fc2f32922"></a>FragmentShader</em>&#160;</td><td class="fielddoc">
<p>fragment shader </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="af5c2a4d46bb7aa6a877a0ed8c5ba3ac8a2216355d14abbc1a80dadd4f881c0f39"></a>ComputeShader</em>&#160;</td><td class="fielddoc">
<p>compute shader </p>
</td></tr>
</table>

</div>
</div>
<a class="anchor" id="adaffc1ac547687d86eef4bb51d0533aa"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacepvr.html#adaffc1ac547687d86eef4bb51d0533aa">pvr::StencilOp</a> : uint8_t</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Enumeration of the different stencil operations.</p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><em><a class="anchor" id="adaffc1ac547687d86eef4bb51d0533aaa02bce93bff905887ad2233110bf9c49e"></a>Keep</em>&#160;</td><td class="fielddoc">
<p>Keep existing value. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="adaffc1ac547687d86eef4bb51d0533aaad7ed4ee1df437474d005188535f74875"></a>Zero</em>&#160;</td><td class="fielddoc">
<p>Set to zero. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="adaffc1ac547687d86eef4bb51d0533aaa0ebe6df8a3ac338e0512acc741823fdb"></a>Replace</em>&#160;</td><td class="fielddoc">
<p>Replace value with Ref. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="adaffc1ac547687d86eef4bb51d0533aaa39f5ed1c9a1e48cc90401d52864202ab"></a>IncrementClamp</em>&#160;</td><td class="fielddoc">
<p>Increment until max value. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="adaffc1ac547687d86eef4bb51d0533aaa669ecd4a04c7b2cda3fbf54f62e180f1"></a>DecrementClamp</em>&#160;</td><td class="fielddoc">
<p>Decrement until min value. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="adaffc1ac547687d86eef4bb51d0533aaa9b8958acb7be504bb5f55f17c0eea366"></a>Invert</em>&#160;</td><td class="fielddoc">
<p>Bitwise-not the existing value. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="adaffc1ac547687d86eef4bb51d0533aaaaa91cb7f033b90dec9582dc5e9611732"></a>IncrementWrap</em>&#160;</td><td class="fielddoc">
<p>Increment the existing value, wrap if &gt;max. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="adaffc1ac547687d86eef4bb51d0533aaa6ec565c329385c8d59333abc6a1003d1"></a>DecrementWrap</em>&#160;</td><td class="fielddoc">
<p>Decrement the existing value, wrap if &lt;min. </p>
</td></tr>
</table>

</div>
</div>
<a class="anchor" id="a6fffa33db4623ece1088010c6f78bc9f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacepvr.html#a6fffa33db4623ece1088010c6f78bc9f">pvr::StepRate</a> : uint32_t</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Step rate for a vertex attribute when drawing: Per vertex, per instance, per draw.</p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><em><a class="anchor" id="a6fffa33db4623ece1088010c6f78bc9fab22b929ba52471a02d18bb3a4e4472e6"></a>Vertex</em>&#160;</td><td class="fielddoc">
<p>Step rate Per vertex. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a6fffa33db4623ece1088010c6f78bc9fad9a17c1c9e8ef6866e4dbeef41c741b2"></a>Instance</em>&#160;</td><td class="fielddoc">
<p>Step rate per instance. </p>
</td></tr>
</table>

</div>
</div>
<a class="anchor" id="ab74a3e033b17a2d3f50ee6d0299eb195"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacepvr.html#ab74a3e033b17a2d3f50ee6d0299eb195">pvr::Swizzle</a> : uint8_t</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Enumeration of texture Swizzle mask channels.</p>

</div>
</div>
<a class="anchor" id="a8be7d779089afe1df56a1bf542134d0d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacepvr.html#a8be7d779089afe1df56a1bf542134d0d">pvr::TextureFileFormat</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Enumerates the formats directly supported by the Framework.</p>

</div>
</div>
<a class="anchor" id="a6f7777c11dfff8fcf4a03d85e5ab0b98"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacepvr.html#a6f7777c11dfff8fcf4a03d85e5ab0b98">pvr::VariableType</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Enumeration of Datatypes.</p>

</div>
</div>
<a class="anchor" id="a7f3166dd9130684c23ff89682e4b38c8"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacepvr.html#a7f3166dd9130684c23ff89682e4b38c8">pvr::VsyncMode</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The Vertical Synchronization (or lack thereof) modes, A.K.A. Presentation mode.</p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><em><a class="anchor" id="a7f3166dd9130684c23ff89682e4b38c8ad15305d7a4e34e02489c74a5ef542f36"></a>Off</em>&#160;</td><td class="fielddoc">
<p>The application does not synchronizes with the vertical sync. If application renders faster than the display refreshes, frames are wasted and tearing may be observed. FPS is uncapped. Maximum power consumption. If unsupported, "ON" value will be used instead. Minimum latency. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a7f3166dd9130684c23ff89682e4b38c8a521c36a31c2762741cf0f8890cbe05e3"></a>On</em>&#160;</td><td class="fielddoc">
<p>The application is always syncrhonized with the vertical sync. Tearing does not happen. FPS is capped to the display's refresh rate. For fast applications, battery life is improved. Always supported. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a7f3166dd9130684c23ff89682e4b38c8a4160be5df3fc34c3b165f28616f1bd16"></a>Relaxed</em>&#160;</td><td class="fielddoc">
<p>The application synchronizes with the vertical sync, but only if the application rendering speed is greater than refresh rate. Compared to OFF, there is no tearing. Compared to ON, the FPS will be improved for "slower" applications. If unsupported, "ON" value will be used instead. Recommended for most applications. Default if supported. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a7f3166dd9130684c23ff89682e4b38c8a2dcff8c037093c5d3552ad532e603f9f"></a>Mailbox</em>&#160;</td><td class="fielddoc">
<p>The presentation engine will always use the latest fully rendered image. Compared to OFF, no tearing will be observed. Compared to ON, battery power will be worse, especially for faster applications. If unsupported, "OFF" will be attempted next. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a7f3166dd9130684c23ff89682e4b38c8ac48615a1bc4197056d522af276aa5a85"></a>Half</em>&#160;</td><td class="fielddoc">
<p>The application is capped to using half the vertical sync time. FPS artificially capped to Half the display speed (usually 30fps) to maintain battery. Best possible battery savings. Worst possibly performance. Recommended for specific applications where battery saving is critical. </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="a3dc927ae582f3ec00005bf32ceb97830"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename t1 , typename t2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">t1 pvr::align </td>
          <td>(</td>
          <td class="paramtype">t1&#160;</td>
          <td class="paramname"><em>numberToAlign</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">t2&#160;</td>
          <td class="paramname"><em>alignment</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Aligns a given number based on the given alignment</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">numberToAlign</td><td>A number ot align based alignment</td></tr>
    <tr><td class="paramname">alignment</td><td>The value to which the numberToAlign will be aligned</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An aligned value</dd></dl>

</div>
</div>
<a class="anchor" id="a0303f68824c30e29b02875302cd75d96"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const char* pvr::apiCode </td>
          <td>(</td>
          <td class="paramtype">Api&#160;</td>
          <td class="paramname"><em>api</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a string of the specific api enum</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">api</td><td>The api</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Api code</dd></dl>

</div>
</div>
<a class="anchor" id="a6e39bf9a267425bc06d61d9a0130f6ea"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacepvr.html#a74c5d1afa51512f076dd8e5844b171c8">Api</a> pvr::apiFamilyMax </td>
          <td>(</td>
          <td class="paramtype">Api&#160;</td>
          <td class="paramname"><em>api</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the highest api version that is of the same family as the parameter</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">api</td><td>The api</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Api family Max</dd></dl>

</div>
</div>
<a class="anchor" id="a8ec9f9921823c5b479a99d3a5f8a3457"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacepvr.html#a74c5d1afa51512f076dd8e5844b171c8">Api</a> pvr::apiFamilyMin </td>
          <td>(</td>
          <td class="paramtype">Api&#160;</td>
          <td class="paramname"><em>api</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get minimum api that is the same family as the parameter. (e.g. Vulkan returns Vulkan, while OpenGLES31 returns OpenGLES2) api family min version</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">api</td><td>The api</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Api family min</dd></dl>

</div>
</div>
<a class="anchor" id="ac0940447f72ad2b8777a37cd3181b5c9"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const char* pvr::apiName </td>
          <td>(</td>
          <td class="paramtype">Api&#160;</td>
          <td class="paramname"><em>api</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the api name std::string of the given Enumeration</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">api</td><td>The api</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Api name std::string</dd></dl>

</div>
</div>
<a class="anchor" id="a32304b6fe8a8ebcfdaa03d5b227da809"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool pvr::dataTypeIsNormalised </td>
          <td>(</td>
          <td class="paramtype">DataType&#160;</td>
          <td class="paramname"><em>type</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return if the format is Normalized (represents a range between 0..1 for unsigned types or between -1..1 for signed types)</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">type</td><td>The format to test.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the format is Normalised.</dd></dl>
<p>A Normalised format is a value that is stored as an Integer, but that actually represents a value from 0..1 or -1..1 instead of the numeric value of the Integer. For example, for a normalised unsigned char value, the value 0 represents 0.0, the value 127 represents 0.5 and the value 255 represents 1.0.</p>

</div>
</div>
<a class="anchor" id="a4bbe49ea1e5ffbeaf1463379ff1adcfc"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t pvr::dataTypeSize </td>
          <td>(</td>
          <td class="paramtype">DataType&#160;</td>
          <td class="paramname"><em>type</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the Size of a DataType.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">type</td><td>The Data type</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The size of the Datatype in bytes.</dd></dl>

</div>
</div>
<a class="anchor" id="af4676d56d2f795d4c4f5b7a094af90c9"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacepvr.html#aa6ac287ad32e4b14937cee7ac81fb85e">BufferUsageFlags</a> pvr::descriptorTypeToBufferUsage </td>
          <td>(</td>
          <td class="paramtype">DescriptorType&#160;</td>
          <td class="paramname"><em>descType</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Infer the BufferUsageFlags that are suitable for the typical use of an object</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">descType</td><td>A descriptor type</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The typical usage flags for &lt;paramref name="descType/&gt;</dd></dl>

</div>
</div>
<a class="anchor" id="a43dd44f92c0013d2ed1dd13363070770"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t pvr::getAlignment </td>
          <td>(</td>
          <td class="paramtype">GpuDatatypes&#160;</td>
          <td class="paramname"><em>type</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get required alignment of this type as demanded by std140 rules</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">type</td><td>The datatype to test</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The required alignment of the type based on std140 (see the GLSL spec)</dd></dl>

</div>
</div>
<a class="anchor" id="abe1ac49f71337e1cfd4e6436b3bb9ca6"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacepvr_1_1_gpu_datatypes_helper.html#abead2e53bdab9ebb17f7c858a2844e14">GpuDatatypesHelper::BaseType</a> pvr::getBaseType </td>
          <td>(</td>
          <td class="paramtype">GpuDatatypes&#160;</td>
          <td class="paramname"><em>type</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the underlying element of a type (integer or float)</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">type</td><td>The datatype to test</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A BaseType enum (integer or float)</dd></dl>

</div>
</div>
<a class="anchor" id="a6bc2716579dfbeade26021e2628dd7a7"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t pvr::getCpuPackedSize </td>
          <td>(</td>
          <td class="paramtype">GpuDatatypes&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>arrayElements</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the size of n array members of a type, packed in CPU</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">type</td><td>The datatype to test</td></tr>
    <tr><td class="paramname">arrayElements</td><td>The number of array elements</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The base size of the type multiplied by arrayElements</dd></dl>

</div>
</div>
<a class="anchor" id="a65076be9fba2c986f80ffe1eb64aa29a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t pvr::getNumMatrixColumns </td>
          <td>(</td>
          <td class="paramtype">GpuDatatypes&#160;</td>
          <td class="paramname"><em>type</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the number of colums (1..4) of the type</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">type</td><td>The datatype to test</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of matrix colums (1..4) of the type. 1 implies not a matrix</dd></dl>

</div>
</div>
<a class="anchor" id="a8277a30a2c9fa98ba8c66c2c8516f923"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t pvr::getNumVecElements </td>
          <td>(</td>
          <td class="paramtype">GpuDatatypes&#160;</td>
          <td class="paramname"><em>type</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the number of vector elements (i.e. Rows) of a type. (e.g. vec2=&gt;2)</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">type</td><td>The datatype to test</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of vector elements.</dd></dl>

</div>
</div>
<a class="anchor" id="a5b67db200cee4a4078676dc5f3622ec0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t pvr::getOffsetAfter </td>
          <td>(</td>
          <td class="paramtype">GpuDatatypes&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>previousTotalSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Aligns an address/offset with the alignment of a type &ndash; equivalently, assuming you want to place a type after a known offset (i.e. calculating the offset of an item inside a struct having already calculated its previous element) (i.e. aligning a vec4 after an item that ends at 30 bytes returns 32 bytes...) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">type</td><td>The datatype to test</td></tr>
    <tr><td class="paramname">previousTotalSize</td><td>The address/offset to align for that type</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>previousTotalSize</em>  aligned to the requirements of <em>type</em> </dd></dl>

</div>
</div>
<a class="anchor" id="a10f119283374e989cd179f6831fe1e36"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const char* pvr::getResultCodeString </td>
          <td>(</td>
          <td class="paramtype">Result&#160;</td>
          <td class="paramname"><em>result</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Use this function to convert a Result into a std::string that is suitable for outputting.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The result</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A std::string suitable for writing out that represents this Result</dd></dl>

</div>
</div>
<a class="anchor" id="a7caef391618cc1a3ebab73d8ffe90a47"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t pvr::getSelfAlignedArraySize </td>
          <td>(</td>
          <td class="paramtype">GpuDatatypes&#160;</td>
          <td class="paramname"><em>type</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns "how many bytes will an object of this type take", if it is an array member (arrays have potentially stricter requirements).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">type</td><td>The datatype to test</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The size of this type, aligned to max array alignment restrictions</dd></dl>

</div>
</div>
<a class="anchor" id="a239df321236ac77da04fe9d58f5efe55"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t pvr::getSelfAlignedSize </td>
          <td>(</td>
          <td class="paramtype">GpuDatatypes&#160;</td>
          <td class="paramname"><em>type</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns "how many bytes will an object of this type take", if not an array.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">type</td><td>The datatype to test</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The size of this type, aligned to its own alignment restrictions</dd></dl>

</div>
</div>
<a class="anchor" id="a7e17c970a2a4965269fcb9e3e55049dd"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t pvr::getSize </td>
          <td>(</td>
          <td class="paramtype">GpuDatatypes&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>arrayElements</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns how many bytes an array of n objects of this type take, but arrayElements = 1 is NOT considered an array (is aligned as a single object, NOT an array of 1)</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">type</td><td>The datatype to test</td></tr>
    <tr><td class="paramname">arrayElements</td><td>The number of array elements. 1 is NOT considered an array.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The size of X elements takes</dd></dl>

</div>
</div>
<a class="anchor" id="a8e81520ef363fa90bb0d7e341ebe4f9a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string pvr::getStackTraceInfo </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>skipFrames</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the stacktrace as a string, skipping the specified number of stack frames from the top of the stack. <b>ONLY IMPLEMENTED FOR 32 bit WINDOWS DEBUG BUILDS</b></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">skipFrames</td><td>The number of frames to skip</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The stack trace</dd></dl>

</div>
</div>
<a class="anchor" id="a5486ebd5e2197fa607b0fc29c7850742"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacepvr.html#a8be7d779089afe1df56a1bf542134d0d">TextureFileFormat</a> pvr::getTextureFormatFromFilename </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>assetname</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Infer the texture format from a filename.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">assetname</td><td>The name of the asset, containing the extension.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The TextureFileFormat if understood, otherwise <a class="el" href="namespacepvr.html#ab98ea90165357c2f9030218c337f90bfa88183b946cc5f0e8c96b2e66e1c74a7e" title="An image of unknown dimensions. ">TextureFileFormat::Unknown</a>.</dd></dl>

</div>
</div>
<a class="anchor" id="a6bc881503cace7cf8d883d54905aa462"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t pvr::getTotalSizeAfter </td>
          <td>(</td>
          <td class="paramtype">GpuDatatypes&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>arrayElements</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>previousTotalSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the new size of a hypothetical struct whose old size was previousTotalSize, and to which "arrayElement" new items of type "type" are added</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">type</td><td>The datatype to add</td></tr>
    <tr><td class="paramname">arrayElements</td><td>The number of items of type <em>type</em>  to add</td></tr>
    <tr><td class="paramname">previousTotalSize</td><td>The address/offset to align for that type</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The new size</dd></dl>

</div>
</div>
<a class="anchor" id="a4c310f549c8db9647eeeef82a0a56af0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t pvr::getVectorSelfAlignedSize </td>
          <td>(</td>
          <td class="paramtype">GpuDatatypes&#160;</td>
          <td class="paramname"><em>type</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the size of a type, including padding, assuming the next item is of the same type</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">type</td><td>The datatype to test</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The size plus padding of this type</dd></dl>

</div>
</div>
<a class="anchor" id="a3cbe7fd082e1089dc162d9afdacdd6f1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t pvr::getVectorUnalignedSize </td>
          <td>(</td>
          <td class="paramtype">GpuDatatypes&#160;</td>
          <td class="paramname"><em>type</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the cpu-packed size of each vector element a type (disregarding matrix columns if they exist)</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">type</td><td>The datatype to test</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The size that a single column of <em>type</em>  would take on the CPU</dd></dl>

</div>
</div>
<a class="anchor" id="ade5ae06be9adae4c32d10aa679b5731e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1_ &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t pvr::hash32_32 </td>
          <td>(</td>
          <td class="paramtype">const T1_ &amp;&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Function object hashing to 32 bit values into a 32 bit unsigned Integer.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>The value to hash.</td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T1_</td><td>The type of the value to hash.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The hash of the value.</dd></dl>

</div>
</div>
<a class="anchor" id="a18b97ab7a969dcd477d5e6c236a0bec4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t pvr::hash32_bytes </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>bytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Function object hashing a number of bytes into a 32 bit unsigned Integer.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bytes</td><td>Pointer to a block of memory.</td></tr>
    <tr><td class="paramname">count</td><td>Number of bytes to hash.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The hash of the value.</dd></dl>

</div>
</div>
<a class="anchor" id="a128900aeb6815de42a6d6d2c59f67a6e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacepvr.html#ab98ea90165357c2f9030218c337f90bf">ImageType</a> pvr::imageViewTypeToImageBaseType </td>
          <td>(</td>
          <td class="paramtype">ImageViewType&#160;</td>
          <td class="paramname"><em>viewtype</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Map an ImageViewType (2dCube etc) to its base type (1d/2d/3d)</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">viewtype</td><td>The ImageViewType</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The base type</dd></dl>

</div>
</div>
<a class="anchor" id="a3fd0cfec4d261dd1caa2ce5eefcc2a53"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t pvr::indexTypeSizeInBytes </td>
          <td>(</td>
          <td class="paramtype">const IndexType&#160;</td>
          <td class="paramname"><em>type</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the Size of an IndexType in bytes.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">type</td><td>The Index type</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of bytes in an index type</dd></dl>

</div>
</div>
<a class="anchor" id="aff2eee1ed23143ae72185a5472ea765a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool pvr::isDescriptorTypeDynamic </td>
          <td>(</td>
          <td class="paramtype">DescriptorType&#160;</td>
          <td class="paramname"><em>descType</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if a descriptor type is dynamic (a dynamic UBO or dynamic SSBO)</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">descType</td><td>A descriptor type</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if descType is UniformBufferDynamic or StorageBufferDynamic, otherwise false</dd></dl>

</div>
</div>
<a class="anchor" id="a47994de10c19816f5b4f0351e265ead5"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool pvr::isVariableTypeNormalized </td>
          <td>(</td>
          <td class="paramtype">VariableType&#160;</td>
          <td class="paramname"><em>item</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if a variable type is a Normalizedtype</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">item</td><td>The variable to check</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if item is a normalized type (nomralized short, normalized integer etc)</dd></dl>

</div>
</div>
<a class="anchor" id="ad8844086c38cb4b2dddc3317494b16ac"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool pvr::isVariableTypeSigned </td>
          <td>(</td>
          <td class="paramtype">VariableType&#160;</td>
          <td class="paramname"><em>item</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if a variable type is a Signed type</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">item</td><td>The variable to check</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if item is a signed type (signed integer, signed float etc), otherwise false</dd></dl>

</div>
</div>
<a class="anchor" id="ac73ce628e547374c22057ff8e3a89bb3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacepvr.html#aa4440f5fd1256889bd3b3822002208b6">GpuDatatypes</a> pvr::mergeDatatypesBigger </td>
          <td>(</td>
          <td class="paramtype">GpuDatatypes&#160;</td>
          <td class="paramname"><em>type1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GpuDatatypes&#160;</td>
          <td class="paramname"><em>type2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a datatype that is larger or equal to both of two types: 1) Has the most permissive base type (float&gt;int) 2) Has the largest of the two vector widths 3) Has the most of the two matrix colums heights</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">type1</td><td>The first type</td></tr>
    <tr><td class="paramname">type2</td><td>The second type</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A type that can fit either of type1 or type1</dd></dl>

</div>
</div>
<a class="anchor" id="a7ef5be44f3a11eac1a122cafd4a217db"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacepvr.html#aa4440f5fd1256889bd3b3822002208b6">GpuDatatypes</a> pvr::mergeDatatypesSmaller </td>
          <td>(</td>
          <td class="paramtype">GpuDatatypes&#160;</td>
          <td class="paramname"><em>type1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GpuDatatypes&#160;</td>
          <td class="paramname"><em>type2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a datatype that is smaller or equal to both of two types: 1) Has the most permissive base type (float&gt;int) 2) Has the smaller of the two vector widths 3) Has the least of the two matrix colums heights</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">type1</td><td>The first type</td></tr>
    <tr><td class="paramname">type2</td><td>The second type</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A type that will truncate everything the two types don't share</dd></dl>

</div>
</div>
<a class="anchor" id="a33df3732a0a48b5274ac3938a7e570b0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t pvr::numDataTypeComponents </td>
          <td>(</td>
          <td class="paramtype">DataType&#160;</td>
          <td class="paramname"><em>type</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the number of components in a datatype.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">type</td><td>The datatype</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of components (e.g. float is 1, vec3 is 3)</dd></dl>

</div>
</div>
<a class="anchor" id="acb9d4eda8ff979cd4e5ae394aa9321c6"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacepvr.html#aa4440f5fd1256889bd3b3822002208b6">GpuDatatypes</a> pvr::operator&amp; </td>
          <td>(</td>
          <td class="paramtype">GpuDatatypes&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GpuDatatypesHelper::Bits&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Bitwise operator AND. Typical semantics. Allows AND between GpuDatatypes and Bits</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>Left hand side</td></tr>
    <tr><td class="paramname">rhs</td><td>Right hand side</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>lhs AND rhs</dd></dl>

</div>
</div>
<a class="anchor" id="ae6830359c957ddaf92782874bb70e825"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacepvr.html#aa4440f5fd1256889bd3b3822002208b6">GpuDatatypes</a> pvr::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">GpuDatatypes&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GpuDatatypesHelper::Bits&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Bitwise operator LEFT SHIFT. Typical semantics. Allows LEFT SHIFT of GpuDatatypes by Bits</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>Left hand side</td></tr>
    <tr><td class="paramname">rhs</td><td>Right hand side</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>lhs LEFT SHIFT rhs</dd></dl>

</div>
</div>
<a class="anchor" id="ab32d83bd296ef37d4c646b2552e276e7"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacepvr.html#aa4440f5fd1256889bd3b3822002208b6">GpuDatatypes</a> pvr::operator&gt;&gt; </td>
          <td>(</td>
          <td class="paramtype">GpuDatatypes&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GpuDatatypesHelper::Bits&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Bitwise operator RIGHT SHIFT. Typical semantics. Allows RIGHT SHIFT of GpuDatatypes by Bits</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>Left hand side</td></tr>
    <tr><td class="paramname">rhs</td><td>Right hand side</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>lhs RIGHT SHIFT rhs</dd></dl>

</div>
</div>
<a class="anchor" id="abbe45548f9e676d52b1645ea21ba4d11"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacepvr.html#aafc960d10904ec52d4d823ed66717c43">PackedSamplerFilter</a> pvr::packSamplerFilter </td>
          <td>(</td>
          <td class="paramtype">Filter&#160;</td>
          <td class="paramname"><em>mini</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Filter&#160;</td>
          <td class="paramname"><em>magni</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SamplerMipmapMode&#160;</td>
          <td class="paramname"><em>mip</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Pack a minification filter, a magnification filter and a mipmap filter into an 8 bit value</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mini</td><td>The filtering mode that should be used for minification</td></tr>
    <tr><td class="paramname">magni</td><td>The filtering mode that should be used for magnification</td></tr>
    <tr><td class="paramname">mip</td><td>The filtering mode that should be used for mipmapping</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An 8 bit value representing the described sampler</dd></dl>

</div>
</div>
<a class="anchor" id="a25b61a39a49138f7e12cfb6341ee8c10"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int pvr::PVRTDecompressETC </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>srcData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xDim</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>yDim</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>dstData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>mode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Decompresses ETC to RGBA 8888.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">srcData</td><td>The ETC texture data to decompress</td></tr>
    <tr><td class="paramname">xDim</td><td>X dimension of the texture</td></tr>
    <tr><td class="paramname">yDim</td><td>Y dimension of the texture</td></tr>
    <tr><td class="paramname">dstData</td><td>The decompressed texture data</td></tr>
    <tr><td class="paramname">mode</td><td>The format of the data</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Return The number of bytes of ETC data decompressed</dd></dl>

</div>
</div>
<a class="anchor" id="a548c4f915769e543602e3f76cc1a3be1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int pvr::PVRTDecompressPVRTC </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>compressedData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>do2bitMode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xDim</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>yDim</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>outResultImage</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Decompresses PVRTC to RGBA 8888.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">compressedData</td><td>The PVRTC texture data to decompress</td></tr>
    <tr><td class="paramname">do2bitMode</td><td>Signifies whether the data is PVRTC2 or PVRTC4</td></tr>
    <tr><td class="paramname">xDim</td><td>X dimension of the texture</td></tr>
    <tr><td class="paramname">yDim</td><td>Y dimension of the texture</td></tr>
    <tr><td class="paramname">outResultImage</td><td>The decompressed texture data</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Return the amount of data that was decompressed.</dd></dl>

</div>
</div>
<a class="anchor" id="a7cc135f8fc78f66cf936fd87efc7fccf"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float pvr::randomrange </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>min</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>max</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a random Number between min and max</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">min</td><td>Minimum number (inclusive)</td></tr>
    <tr><td class="paramname">max</td><td>Maximum number (inclusive)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Random number</dd></dl>

</div>
</div>
<a class="anchor" id="a37496ce30d200726b9bef9242ba09067"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1_ &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::array&lt;T1_, sizeof(T1_)&gt; pvr::readBits </td>
          <td>(</td>
          <td class="paramtype">const T1_ &amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Store the bits of a value in a static array of char.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>The value to reinterpret</td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T1_</td><td>Input value type. Should not need to be explicitly defined, can be inferred.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A StaticArray&lt;T1_&gt; with a size exactly equal to the size of T1_ in characters, containing the bit representation of value.</dd></dl>

</div>
</div>
<a class="anchor" id="a76f231dbfb5ad9022123a9972f169854"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Toutput_ , typename Tinput_ &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Toutput_ pvr::reinterpretBits </td>
          <td>(</td>
          <td class="paramtype">const Tinput_ &amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Take a value's bit representation and reinterpret them as another type. Second template parameter should normally be implicitly declared. First template parameter is mandatory.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>The value to reinterpret</td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Toutput_</td><td>Output value type. Must be explicitly defined.</td></tr>
    <tr><td class="paramname">Tinput_</td><td>Input value type. Should not need to be explicitly defined, can be inferred. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The reinterpreted value</dd></dl>

</div>
</div>
<a class="anchor" id="a51280ed25278cee3f54f412a863158ad"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Item &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void pvr::swap </td>
          <td>(</td>
          <td class="paramtype">RingBuffer&lt; Item &gt; &amp;&#160;</td>
          <td class="paramname"><em>left</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RingBuffer&lt; Item &gt; &amp;&#160;</td>
          <td class="paramname"><em>right</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A swap function for the <a class="el" href="classpvr_1_1_ring_buffer.html" title="A classic, templated, efficient RingBuffer implementation. Supports operations at both ends (front...">RingBuffer</a>. Efficiently exchanges the items between two ring buffers. No actual item copies happen.</p>
<p>Swap the items of two ringbuffers.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">left</td><td>The first <a class="el" href="classpvr_1_1_ring_buffer.html" title="A classic, templated, efficient RingBuffer implementation. Supports operations at both ends (front...">RingBuffer</a> to swap</td></tr>
    <tr><td class="paramname">right</td><td>The second <a class="el" href="classpvr_1_1_ring_buffer.html" title="A classic, templated, efficient RingBuffer implementation. Supports operations at both ends (front...">RingBuffer</a> to swap</td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Item</td><td>The type of the items stored in the <a class="el" href="classpvr_1_1_ring_buffer.html" title="A classic, templated, efficient RingBuffer implementation. Supports operations at both ends (front...">RingBuffer</a></td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">left</td><td>The first item to swap</td></tr>
    <tr><td class="paramname">left</td><td>The right item to swap</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="af73ac8316fd8bc048cee4cb33c8ca226"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t pvr::textureOffset2D </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>width</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculate the offset of a 2D texture</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Offset X</td></tr>
    <tr><td class="paramname">y</td><td>Offset Y</td></tr>
    <tr><td class="paramname">width</td><td><a class="el" href="classpvr_1_1_texture.html" title="A 2D Texture asset, together with Information, Metadata and actual Pixel data. Only represents the ac...">Texture</a> width</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Return the offset of a 2D texture</dd></dl>

</div>
</div>
<a class="anchor" id="a4f1dcae0666fe3f28a26302a7c5d0c03"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t pvr::textureOffset3D </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>z</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>height</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>calculate the offset of 3D texture</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Offset X</td></tr>
    <tr><td class="paramname">y</td><td>Offset Y</td></tr>
    <tr><td class="paramname">z</td><td>Offset Z</td></tr>
    <tr><td class="paramname">width</td><td><a class="el" href="classpvr_1_1_texture.html" title="A 2D Texture asset, together with Information, Metadata and actual Pixel data. Only represents the ac...">Texture</a> Width</td></tr>
    <tr><td class="paramname">height</td><td><a class="el" href="classpvr_1_1_texture.html" title="A 2D Texture asset, together with Information, Metadata and actual Pixel data. Only represents the ac...">Texture</a> Height</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Return the offset of a 3D texture</dd></dl>

</div>
</div>
<a class="anchor" id="a547738cbdb228eba2d1d4b58d2c142c9"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacepvr.html#a7924324f96dc973225ad3c532cc72309">DataType</a> pvr::toDataType </td>
          <td>(</td>
          <td class="paramtype">GpuDatatypes&#160;</td>
          <td class="paramname"><em>type</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the Cpu Datatype <em>type</em>  refers to (i.e. which CPU datatype must you load in the data you upload to the GPU to correctly upload the same value in the shader).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">type</td><td>The type to convert</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A CPU type that has the same bit representation as one scalar element of type (i.e. mat4x4 returns "float")</dd></dl>

</div>
</div>
<a class="anchor" id="aea8728868bc6c9fa07c48f1f6d0e2f37"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const char* pvr::toString </td>
          <td>(</td>
          <td class="paramtype">GpuDatatypes&#160;</td>
          <td class="paramname"><em>type</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a string with the glsl variable name of a type</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">type</td><td>The datatype to test</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A c-style string with the glsl variable keyword of <em>type</em> </dd></dl>

</div>
</div>
<a class="anchor" id="a93997dab7a634e84d3ac4cdd4bb7fa33"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pvr::unpackSamplerFilter </td>
          <td>(</td>
          <td class="paramtype">PackedSamplerFilter&#160;</td>
          <td class="paramname"><em>packed</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Filter &amp;&#160;</td>
          <td class="paramname"><em>mini</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Filter &amp;&#160;</td>
          <td class="paramname"><em>magni</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SamplerMipmapMode &amp;&#160;</td>
          <td class="paramname"><em>mip</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Unpack a 8 bit PackedSamplerFilter value into a minification, magnification and mip filter mode</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packed</td><td>The packed sampler filter to unpack</td></tr>
    <tr><td class="paramname">mini</td><td>The filtering mode that should be used for minification</td></tr>
    <tr><td class="paramname">magni</td><td>The filtering mode that should be used for magnification</td></tr>
    <tr><td class="paramname">mip</td><td>The filtering mode that should be used for mipmapping</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An 8 bit value representing the described sampler</dd></dl>

</div>
</div>
<a class="anchor" id="a9543f5ab3a8fff438b39adb92b8a1ff4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool pvr::writeTGA </td>
          <td>(</td>
          <td class="paramtype">const char *const&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>w</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>h</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned char *const&#160;</td>
          <td class="paramname"><em>imageData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned char&#160;</td>
          <td class="paramname"><em>stride</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>pixelReplicate</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Write out TGA data from an image.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">filename</td><td>C-style string with the filename to write the TGA.</td></tr>
    <tr><td class="paramname">w</td><td>The width of the image</td></tr>
    <tr><td class="paramname">h</td><td>The height of the image</td></tr>
    <tr><td class="paramname">imageData</td><td>Pointer to the raw image data</td></tr>
    <tr><td class="paramname">stride</td><td>Size in bytes of each pixel</td></tr>
    <tr><td class="paramname">pixelReplicate</td><td>Upscale factor.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if successfuly completed, otherwise False. (log error on false)</dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.4-->
<!-- start footer part (NON TREEVIEW ONLY!!) -->
<!--BEGIN GENERATE_TREEVIEW-->
<div id="FooterMainContainer">
	<div id="FooterContainer">
		<div class="footerlogo">
			<a href="http://www.imgtec.com" target="_blank"><img src="img-footer-logo-grey.png" width="100%" height="100%" border="none" /></a>
		</div>
		<div class="copyright"><p>&copy; Imagination Technologies Limited<br> All rights reserved</p></div>
	</div>
</div>
</body>
</html>
