<!-- HTML header for doxygen 1.8.4-->
<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="generator" content="Doxygen 1.8.6"/>
<title>PVRCore: pvr::async::TextureLoadFuture_ Struct Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="IMGdoxygen.css" rel="stylesheet" type="text/css"/>
<link rel="shortcut icon" type="image/x-icon" href="img.ico">
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
  <div class="headercontent">
    <div class="PVRlogo">
      <a href="https://www.imgtec.com/developers/" target="_blank"><img src="PVRlogo.png" width="40%" height="40%"  border="none" /></a>
    </div>
    <a class="SiteTitle"><span id="projectname">PVRCore</span> Documentation</a>
   <tbody>
  </div>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="inherits.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Macros</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacepvr.html">pvr</a></li><li class="navelem"><b>async</b></li><li class="navelem"><a class="el" href="structpvr_1_1async_1_1_texture_load_future__.html">TextureLoadFuture_</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="structpvr_1_1async_1_1_texture_load_future__-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">pvr::async::TextureLoadFuture_ Struct Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>A class wrapping the operations necessary to retrieve an asynchronously loaded texture, (e.g. querying if the load is complete, or blocking-wait get the result. Is an EmbeddedRefCounted Resource, so must always be instantiated with <a class="el" href="structpvr_1_1async_1_1_texture_load_future__.html#adb3280b2a4281681fd18c07e0ff2a214" title="Create a new TextureLoadFuture, wrapped in an EmbeddedRefCountedResource. TextureLoadFuture can only ...">createNew()</a> 
 <a href="structpvr_1_1async_1_1_texture_load_future__.html#details">More...</a></p>
<div class="dynheader">
Inheritance diagram for pvr::async::TextureLoadFuture_:</div>
<div class="dyncontent">
<div class="center"><img src="structpvr_1_1async_1_1_texture_load_future____inherit__graph.png" border="0" usemap="#pvr_1_1async_1_1_texture_load_future___inherit__map" alt="Inheritance graph"/></div>
<map name="pvr_1_1async_1_1_texture_load_future___inherit__map" id="pvr_1_1async_1_1_texture_load_future___inherit__map">
<area shape="rect" id="node2" href="classpvr_1_1async_1_1_i_framework_async_result.html" title="pvr::async::IFrameworkAsync\lResult\&lt; TexturePtr \&gt;" alt="" coords="261,5,459,46"/><area shape="rect" id="node3" href="classpvr_1_1async_1_1_i_framework_cleanup_object.html" title="pvr::async::IFrameworkCleanup\lObject\&lt; TexturePtr \&gt;" alt="" coords="5,5,213,46"/></map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a8416443f9cab22d5b542ebf52e58ae71"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1async_1_1_i_framework_async_result.html#a8416443f9cab22d5b542ebf52e58ae71">Callback</a> )(<a class="el" href="classpvr_1_1async_1_1_i_framework_async_result.html#ac2389a7b868955c43b03f7c14158c039">PointerType</a>)</td></tr>
<tr class="memdesc:a8416443f9cab22d5b542ebf52e58ae71"><td class="mdescLeft">&#160;</td><td class="mdescRight">A function pointer type that can be used as a callback to call when the return value is ready <a href="#a8416443f9cab22d5b542ebf52e58ae71">More...</a><br/></td></tr>
<tr class="separator:a8416443f9cab22d5b542ebf52e58ae71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0a2354267bb90adac66def0e251f34d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab0a2354267bb90adac66def0e251f34d"></a>
typedef <a class="el" href="classpvr_1_1async_1_1_i_framework_async_result.html#a8416443f9cab22d5b542ebf52e58ae71">MyBase::Callback</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpvr_1_1async_1_1_texture_load_future__.html#ab0a2354267bb90adac66def0e251f34d">CallbackType</a></td></tr>
<tr class="memdesc:ab0a2354267bb90adac66def0e251f34d"><td class="mdescLeft">&#160;</td><td class="mdescRight">The type of function that can be used as a completion callback. <br/></td></tr>
<tr class="separator:ab0a2354267bb90adac66def0e251f34d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab87cc198bd4f73a6ffe95a5409a98c9c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab87cc198bd4f73a6ffe95a5409a98c9c"></a>
typedef <a class="el" href="classpvr_1_1async_1_1_i_framework_async_result.html">IFrameworkAsyncResult</a><br class="typebreak"/>
&lt; TexturePtr &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpvr_1_1async_1_1_texture_load_future__.html#ab87cc198bd4f73a6ffe95a5409a98c9c">MyBase</a></td></tr>
<tr class="memdesc:ab87cc198bd4f73a6ffe95a5409a98c9c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class. <br/></td></tr>
<tr class="separator:ab87cc198bd4f73a6ffe95a5409a98c9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2389a7b868955c43b03f7c14158c039"><td class="memItemLeft" align="right" valign="top">typedef <br class="typebreak"/>
EmbeddedRefCountedResource<br class="typebreak"/>
&lt; <a class="el" href="classpvr_1_1async_1_1_i_framework_async_result.html">IFrameworkAsyncResult</a><br class="typebreak"/>
&lt; TexturePtr &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1async_1_1_i_framework_async_result.html#ac2389a7b868955c43b03f7c14158c039">PointerType</a></td></tr>
<tr class="memdesc:ac2389a7b868955c43b03f7c14158c039"><td class="mdescLeft">&#160;</td><td class="mdescRight">A smart pointer to this result object (not the wrapped value) <a href="#ac2389a7b868955c43b03f7c14158c039">More...</a><br/></td></tr>
<tr class="separator:ac2389a7b868955c43b03f7c14158c039"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a443532fc20e721cbf2ffa8a15e180f56"><td class="memItemLeft" align="right" valign="top">typedef TexturePtr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1async_1_1_i_framework_async_result.html#a443532fc20e721cbf2ffa8a15e180f56">ValueType</a></td></tr>
<tr class="memdesc:a443532fc20e721cbf2ffa8a15e180f56"><td class="mdescLeft">&#160;</td><td class="mdescRight">The type of the return value <a href="#a443532fc20e721cbf2ffa8a15e180f56">More...</a><br/></td></tr>
<tr class="separator:a443532fc20e721cbf2ffa8a15e180f56"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a2eeb9f821e79c7fc311b54d2640a9831"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1async_1_1_i_framework_cleanup_object.html#a2eeb9f821e79c7fc311b54d2640a9831">cleanup</a> ()</td></tr>
<tr class="memdesc:a2eeb9f821e79c7fc311b54d2640a9831"><td class="mdescLeft">&#160;</td><td class="mdescRight">Call this function when you are done using this object. <a href="#a2eeb9f821e79c7fc311b54d2640a9831">More...</a><br/></td></tr>
<tr class="separator:a2eeb9f821e79c7fc311b54d2640a9831"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c729bc2846556f45ccdc5fb65103a44"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpvr_1_1async_1_1_i_framework_async_result.html#a443532fc20e721cbf2ffa8a15e180f56">ValueType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1async_1_1_i_framework_async_result.html#a3c729bc2846556f45ccdc5fb65103a44">get</a> ()</td></tr>
<tr class="memdesc:a3c729bc2846556f45ccdc5fb65103a44"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is the most important function of IFrameworkAsyncResult: it actually gets the return value. If the value is not yet ready (the task is not complete), it will wait for the task completion. Use this immediately when other operations depend on the value. Otherwise, in order to avoid any wait, you can first check <a class="el" href="classpvr_1_1async_1_1_i_framework_async_result.html#ac30ba49b33466516d0427e06a84bf044" title="Query is the return value is ready to be used">isComplete()</a> and only call this function after <a class="el" href="classpvr_1_1async_1_1_i_framework_async_result.html#ac30ba49b33466516d0427e06a84bf044" title="Query is the return value is ready to be used">isComplete()</a> has returned true. If the task may fail, you should call <a class="el" href="classpvr_1_1async_1_1_i_framework_async_result.html#af8bf665b607ed2f0d37fc55be0e51f71" title="Returns true if the operation was successful. An operation that is not complete cannot be successful...">isSuccessful()</a> before using the value to ensure it is what you expect. <a href="#a3c729bc2846556f45ccdc5fb65103a44">More...</a><br/></td></tr>
<tr class="separator:a3c729bc2846556f45ccdc5fb65103a44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac30ba49b33466516d0427e06a84bf044"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1async_1_1_i_framework_async_result.html#ac30ba49b33466516d0427e06a84bf044">isComplete</a> () const</td></tr>
<tr class="memdesc:ac30ba49b33466516d0427e06a84bf044"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query is the return value is ready to be used <a href="#ac30ba49b33466516d0427e06a84bf044">More...</a><br/></td></tr>
<tr class="separator:ac30ba49b33466516d0427e06a84bf044"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8bf665b607ed2f0d37fc55be0e51f71"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af8bf665b607ed2f0d37fc55be0e51f71"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1async_1_1_i_framework_async_result.html#af8bf665b607ed2f0d37fc55be0e51f71">isSuccessful</a> () const</td></tr>
<tr class="memdesc:af8bf665b607ed2f0d37fc55be0e51f71"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the operation was successful. An operation that is not complete cannot be successful, so check isComplete to ensure that a return value of false means that the operation actually failed<dl class="section return"><dt>Returns</dt><dd>True if the operation is complete and successful, false if the operation failed or has not yet completed</dd></dl>
<br/></td></tr>
<tr class="separator:af8bf665b607ed2f0d37fc55be0e51f71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0dfecf32f5552c811b549c02c1fb2836"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpvr_1_1async_1_1_texture_load_future__.html#a0dfecf32f5552c811b549c02c1fb2836">loadNow</a> ()</td></tr>
<tr class="memdesc:a0dfecf32f5552c811b549c02c1fb2836"><td class="mdescLeft">&#160;</td><td class="mdescRight">Load the texture synchronously and signal the result semaphore. Normally called by the worker thread <a href="#a0dfecf32f5552c811b549c02c1fb2836">More...</a><br/></td></tr>
<tr class="separator:a0dfecf32f5552c811b549c02c1fb2836"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d4263ecd25214768bdae235faa0c6d1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpvr_1_1async_1_1_texture_load_future__.html#a4d4263ecd25214768bdae235faa0c6d1">setCallBack</a> (<a class="el" href="structpvr_1_1async_1_1_texture_load_future__.html#ab0a2354267bb90adac66def0e251f34d">CallbackType</a> callback)</td></tr>
<tr class="memdesc:a4d4263ecd25214768bdae235faa0c6d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set a function to be called when the texture loading has been finished. <a href="#a4d4263ecd25214768bdae235faa0c6d1">More...</a><br/></td></tr>
<tr class="separator:a4d4263ecd25214768bdae235faa0c6d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:adb3280b2a4281681fd18c07e0ff2a214"><td class="memItemLeft" align="right" valign="top">static StrongReferenceType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpvr_1_1async_1_1_texture_load_future__.html#adb3280b2a4281681fd18c07e0ff2a214">createNew</a> ()</td></tr>
<tr class="memdesc:adb3280b2a4281681fd18c07e0ff2a214"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new TextureLoadFuture, wrapped in an EmbeddedRefCountedResource. TextureLoadFuture can only be instantiated using this function. <a href="#adb3280b2a4281681fd18c07e0ff2a214">More...</a><br/></td></tr>
<tr class="separator:adb3280b2a4281681fd18c07e0ff2a214"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:a7fef173aeebc5970387f6c9ea22c3da0"><td class="memItemLeft" align="right" valign="top">std::exception_ptr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpvr_1_1async_1_1_texture_load_future__.html#a7fef173aeebc5970387f6c9ea22c3da0">exception</a></td></tr>
<tr class="memdesc:a7fef173aeebc5970387f6c9ea22c3da0"><td class="mdescLeft">&#160;</td><td class="mdescRight">A pointer to an exception to throw <a href="#a7fef173aeebc5970387f6c9ea22c3da0">More...</a><br/></td></tr>
<tr class="separator:a7fef173aeebc5970387f6c9ea22c3da0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a611c13912be5b0c6191767393a5db12d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a611c13912be5b0c6191767393a5db12d"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpvr_1_1async_1_1_texture_load_future__.html#a611c13912be5b0c6191767393a5db12d">filename</a></td></tr>
<tr class="memdesc:a611c13912be5b0c6191767393a5db12d"><td class="mdescLeft">&#160;</td><td class="mdescRight">The filename from which the texture is loaded. <br/></td></tr>
<tr class="separator:a611c13912be5b0c6191767393a5db12d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79153dd15e3c4b505a795ee6eae1c710"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a79153dd15e3c4b505a795ee6eae1c710"></a>
<a class="el" href="namespacepvr.html#a8be7d779089afe1df56a1bf542134d0d">TextureFileFormat</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpvr_1_1async_1_1_texture_load_future__.html#a79153dd15e3c4b505a795ee6eae1c710">fmt</a></td></tr>
<tr class="memdesc:a79153dd15e3c4b505a795ee6eae1c710"><td class="mdescLeft">&#160;</td><td class="mdescRight">The format of the texture. <br/></td></tr>
<tr class="separator:a79153dd15e3c4b505a795ee6eae1c710"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6dfaf430f539cc483da22998ff5ac24"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac6dfaf430f539cc483da22998ff5ac24"></a>
<a class="el" href="classpvr_1_1_i_asset_provider.html">IAssetProvider</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpvr_1_1async_1_1_texture_load_future__.html#ac6dfaf430f539cc483da22998ff5ac24">loader</a></td></tr>
<tr class="memdesc:ac6dfaf430f539cc483da22998ff5ac24"><td class="mdescLeft">&#160;</td><td class="mdescRight">The AssetProvider to use to load the texture. <br/></td></tr>
<tr class="separator:ac6dfaf430f539cc483da22998ff5ac24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3973d95b7c30714e73d0f47da6b6b40f"><td class="memItemLeft" align="right" valign="top">TexturePtr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpvr_1_1async_1_1_texture_load_future__.html#a3973d95b7c30714e73d0f47da6b6b40f">result</a></td></tr>
<tr class="memdesc:a3973d95b7c30714e73d0f47da6b6b40f"><td class="mdescLeft">&#160;</td><td class="mdescRight">The result of the operation will be stored here  <a href="#a3973d95b7c30714e73d0f47da6b6b40f">More...</a><br/></td></tr>
<tr class="separator:a3973d95b7c30714e73d0f47da6b6b40f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a810d69aa126f378dc151a305dca20e97"><td class="memItemLeft" align="right" valign="top">SemaphorePtr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpvr_1_1async_1_1_texture_load_future__.html#a810d69aa126f378dc151a305dca20e97">resultSema</a></td></tr>
<tr class="separator:a810d69aa126f378dc151a305dca20e97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e9ed85e6ad9daa3262945d16cc3b00b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2e9ed85e6ad9daa3262945d16cc3b00b"></a>
Semaphore *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpvr_1_1async_1_1_texture_load_future__.html#a2e9ed85e6ad9daa3262945d16cc3b00b">workSema</a></td></tr>
<tr class="memdesc:a2e9ed85e6ad9daa3262945d16cc3b00b"><td class="mdescLeft">&#160;</td><td class="mdescRight">A pointer to an externally used semaphore (normally the one used by the queue) <br/></td></tr>
<tr class="separator:a2e9ed85e6ad9daa3262945d16cc3b00b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:ad11fe888126058746669ec00b98d33a2"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1async_1_1_i_framework_async_result.html#ad11fe888126058746669ec00b98d33a2">executeCallBack</a> (<a class="el" href="classpvr_1_1async_1_1_i_framework_async_result.html#ac2389a7b868955c43b03f7c14158c039">PointerType</a> thisPtr)</td></tr>
<tr class="memdesc:ad11fe888126058746669ec00b98d33a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Execute the callback (overridable) <a href="#ad11fe888126058746669ec00b98d33a2">More...</a><br/></td></tr>
<tr class="separator:ad11fe888126058746669ec00b98d33a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9484ee12974a95ce286429f04d82c4b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1async_1_1_i_framework_async_result.html#ad9484ee12974a95ce286429f04d82c4b">setTheCallback</a> (<a class="el" href="classpvr_1_1async_1_1_i_framework_async_result.html#a8416443f9cab22d5b542ebf52e58ae71">Callback</a> completionCallback)</td></tr>
<tr class="memdesc:ad9484ee12974a95ce286429f04d82c4b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the callback (a function pointer that will be called whenever processing an item is done) <a href="#ad9484ee12974a95ce286429f04d82c4b">More...</a><br/></td></tr>
<tr class="separator:ad9484ee12974a95ce286429f04d82c4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:a3b8008b722bead0caf64f2766d5fb37d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3b8008b722bead0caf64f2766d5fb37d"></a>
<a class="el" href="classpvr_1_1async_1_1_i_framework_async_result.html#a8416443f9cab22d5b542ebf52e58ae71">Callback</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1async_1_1_i_framework_async_result.html#a3b8008b722bead0caf64f2766d5fb37d">_completionCallback</a></td></tr>
<tr class="memdesc:a3b8008b722bead0caf64f2766d5fb37d"><td class="mdescLeft">&#160;</td><td class="mdescRight">The callback that will be called on completion. <br/></td></tr>
<tr class="separator:a3b8008b722bead0caf64f2766d5fb37d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d3dac58ec5cafe521e7816eb22334c1"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8d3dac58ec5cafe521e7816eb22334c1"></a>
std::atomic&lt; bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1async_1_1_i_framework_async_result.html#a8d3dac58ec5cafe521e7816eb22334c1">_inCallback</a></td></tr>
<tr class="memdesc:a8d3dac58ec5cafe521e7816eb22334c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is a mechanism to query if a function is actually called BY the callback to avoid deadlocking. <br/></td></tr>
<tr class="separator:a8d3dac58ec5cafe521e7816eb22334c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e6065186c0708bf0efabd8dca3d138b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2e6065186c0708bf0efabd8dca3d138b"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1async_1_1_i_framework_async_result.html#a2e6065186c0708bf0efabd8dca3d138b">_successful</a></td></tr>
<tr class="memdesc:a2e6065186c0708bf0efabd8dca3d138b"><td class="mdescLeft">&#160;</td><td class="mdescRight">This will / should be set to true when the work is successfully completed. <br/></td></tr>
<tr class="separator:a2e6065186c0708bf0efabd8dca3d138b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>A class wrapping the operations necessary to retrieve an asynchronously loaded texture, (e.g. querying if the load is complete, or blocking-wait get the result. Is an EmbeddedRefCounted Resource, so must always be instantiated with <a class="el" href="structpvr_1_1async_1_1_texture_load_future__.html#adb3280b2a4281681fd18c07e0ff2a214" title="Create a new TextureLoadFuture, wrapped in an EmbeddedRefCountedResource. TextureLoadFuture can only ...">createNew()</a></p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a class="anchor" id="a8416443f9cab22d5b542ebf52e58ae71"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* <a class="el" href="classpvr_1_1async_1_1_i_framework_async_result.html">pvr::async::IFrameworkAsyncResult</a>&lt; TexturePtr  &gt;::Callback)(<a class="el" href="classpvr_1_1async_1_1_i_framework_async_result.html#ac2389a7b868955c43b03f7c14158c039">PointerType</a>)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A function pointer type that can be used as a callback to call when the return value is ready</p>

</div>
</div>
<a class="anchor" id="ac2389a7b868955c43b03f7c14158c039"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">typedef EmbeddedRefCountedResource&lt;<a class="el" href="classpvr_1_1async_1_1_i_framework_async_result.html">IFrameworkAsyncResult</a>&lt;TexturePtr &gt; &gt; <a class="el" href="classpvr_1_1async_1_1_i_framework_async_result.html">pvr::async::IFrameworkAsyncResult</a>&lt; TexturePtr  &gt;::PointerType</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A smart pointer to this result object (not the wrapped value)</p>

</div>
</div>
<a class="anchor" id="a443532fc20e721cbf2ffa8a15e180f56"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">typedef TexturePtr  <a class="el" href="classpvr_1_1async_1_1_i_framework_async_result.html">pvr::async::IFrameworkAsyncResult</a>&lt; TexturePtr  &gt;::<a class="el" href="classpvr_1_1async_1_1_i_framework_async_result.html#a443532fc20e721cbf2ffa8a15e180f56">ValueType</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The type of the return value</p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a2eeb9f821e79c7fc311b54d2640a9831"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classpvr_1_1async_1_1_i_framework_cleanup_object.html">pvr::async::IFrameworkCleanupObject</a>&lt; TexturePtr  &gt;::cleanup </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Call this function when you are done using this object.</p>

</div>
</div>
<a class="anchor" id="adb3280b2a4281681fd18c07e0ff2a214"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static StrongReferenceType pvr::async::TextureLoadFuture_::createNew </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a new TextureLoadFuture, wrapped in an EmbeddedRefCountedResource. TextureLoadFuture can only be instantiated using this function.</p>
<dl class="section return"><dt>Returns</dt><dd>A new <a class="el" href="structpvr_1_1async_1_1_texture_load_future__.html" title="A class wrapping the operations necessary to retrieve an asynchronously loaded texture, (e.g. querying if the load is complete, or blocking-wait get the result. Is an EmbeddedRefCounted Resource, so must always be instantiated with createNew()">TextureLoadFuture_</a></dd></dl>

</div>
</div>
<a class="anchor" id="ad11fe888126058746669ec00b98d33a2"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classpvr_1_1async_1_1_i_framework_async_result.html">pvr::async::IFrameworkAsyncResult</a>&lt; TexturePtr  &gt;::executeCallBack </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpvr_1_1async_1_1_i_framework_async_result.html#ac2389a7b868955c43b03f7c14158c039">PointerType</a>&#160;</td>
          <td class="paramname"><em>thisPtr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Execute the callback (overridable)</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thisPtr</td><td>The object with which the callback will be executed as a parameter.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a3c729bc2846556f45ccdc5fb65103a44"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpvr_1_1async_1_1_i_framework_async_result.html#a443532fc20e721cbf2ffa8a15e180f56">ValueType</a> <a class="el" href="classpvr_1_1async_1_1_i_framework_async_result.html">pvr::async::IFrameworkAsyncResult</a>&lt; TexturePtr  &gt;::get </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This is the most important function of IFrameworkAsyncResult: it actually gets the return value. If the value is not yet ready (the task is not complete), it will wait for the task completion. Use this immediately when other operations depend on the value. Otherwise, in order to avoid any wait, you can first check <a class="el" href="classpvr_1_1async_1_1_i_framework_async_result.html#ac30ba49b33466516d0427e06a84bf044" title="Query is the return value is ready to be used">isComplete()</a> and only call this function after <a class="el" href="classpvr_1_1async_1_1_i_framework_async_result.html#ac30ba49b33466516d0427e06a84bf044" title="Query is the return value is ready to be used">isComplete()</a> has returned true. If the task may fail, you should call <a class="el" href="classpvr_1_1async_1_1_i_framework_async_result.html#af8bf665b607ed2f0d37fc55be0e51f71" title="Returns true if the operation was successful. An operation that is not complete cannot be successful...">isSuccessful()</a> before using the value to ensure it is what you expect.</p>
<dl class="section return"><dt>Returns</dt><dd>The return value of the operation.</dd></dl>

</div>
</div>
<a class="anchor" id="ac30ba49b33466516d0427e06a84bf044"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classpvr_1_1async_1_1_i_framework_async_result.html">pvr::async::IFrameworkAsyncResult</a>&lt; TexturePtr  &gt;::isComplete </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Query is the return value is ready to be used</p>
<dl class="section return"><dt>Returns</dt><dd>True if the value is ready, otherwise false</dd></dl>

</div>
</div>
<a class="anchor" id="a0dfecf32f5552c811b549c02c1fb2836"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pvr::async::TextureLoadFuture_::loadNow </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Load the texture synchronously and signal the result semaphore. Normally called by the worker thread</p>

</div>
</div>
<a class="anchor" id="a4d4263ecd25214768bdae235faa0c6d1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pvr::async::TextureLoadFuture_::setCallBack </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structpvr_1_1async_1_1_texture_load_future__.html#ab0a2354267bb90adac66def0e251f34d">CallbackType</a>&#160;</td>
          <td class="paramname"><em>callback</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set a function to be called when the texture loading has been finished.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">callback</td><td>Set a function to be called when the texture loading has been finished.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ad9484ee12974a95ce286429f04d82c4b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classpvr_1_1async_1_1_i_framework_async_result.html">pvr::async::IFrameworkAsyncResult</a>&lt; TexturePtr  &gt;::setTheCallback </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpvr_1_1async_1_1_i_framework_async_result.html#a8416443f9cab22d5b542ebf52e58ae71">Callback</a>&#160;</td>
          <td class="paramname"><em>completionCallback</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the callback (a function pointer that will be called whenever processing an item is done)</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">completionCallback</td><td>The callback to set</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a class="anchor" id="a7fef173aeebc5970387f6c9ea22c3da0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::exception_ptr pvr::async::TextureLoadFuture_::exception</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A pointer to an exception to throw</p>

</div>
</div>
<a class="anchor" id="a3973d95b7c30714e73d0f47da6b6b40f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TexturePtr pvr::async::TextureLoadFuture_::result</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The result of the operation will be stored here </p>

</div>
</div>
<a class="anchor" id="a810d69aa126f378dc151a305dca20e97"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">SemaphorePtr pvr::async::TextureLoadFuture_::resultSema</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">mutable</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The semaphore that is used to wait for the result </p>

</div>
</div>
<hr/>The documentation for this struct was generated from the following file:<ul>
<li>/usr/buildxl/buildroot/sdk/branch/SDK/framework/PVRCore/texture/<a class="el" href="_texture_load_async_8h_source.html">TextureLoadAsync.h</a></li>
</ul>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.4-->
<!-- start footer part (NON TREEVIEW ONLY!!) -->
<!--BEGIN GENERATE_TREEVIEW-->
<div id="FooterMainContainer">
	<div id="FooterContainer">
		<div class="footerlogo">
			<a href="http://www.imgtec.com" target="_blank"><img src="img-footer-logo-grey.png" width="100%" height="100%" border="none" /></a>
		</div>
		<div class="copyright"><p>&copy; Imagination Technologies Limited<br> All rights reserved</p></div>
	</div>
</div>
</body>
</html>
