<!-- HTML header for doxygen 1.8.4-->
<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="generator" content="Doxygen 1.8.6"/>
<title>PVRCore: /usr/buildxl/buildroot/sdk/branch/SDK/framework/PVRCore/Base/Types.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="IMGdoxygen.css" rel="stylesheet" type="text/css"/>
<link rel="shortcut icon" href="http://www.imgtec.com/images/img.ico">
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
  <div class="headercontent">
    <div class="PVRlogo">
      <a href="http://www.powervrinsider.com" target="_blank"><img src="PVRlogo.png" width="40%" height="40%"  border="none" /></a>
    </div>
    <a class="SiteTitle"><span id="projectname">PVRCore</span> Documentation</a>
   <tbody>
  </div>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="inherits.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Macros</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_687531cb5acd5e736601deea3ef3b7c0.html">SDK</a></li><li class="navelem"><a class="el" href="dir_407ce59cc93389552d4bbf4df897abf8.html">framework</a></li><li class="navelem"><a class="el" href="dir_72a2a6c70dc66b6caf7d035656739fa9.html">PVRCore</a></li><li class="navelem"><a class="el" href="dir_941d4785b6ce95731493ac3d112807f3.html">Base</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#namespaces">Namespaces</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Types.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Basic file used in the PowerVR Framework. Defines several types used throughout the Framework (sized arithmetic types, enumerations, character types).  
<a href="#details">More...</a></p>

<p><a href="_types_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpvr_1_1_gpu_datatypes_helper_1_1_metadata.html">pvr::GpuDatatypesHelper::Metadata&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structpvr_1_1_gpu_datatypes_helper_1_1_metadata.html" title="Metadata for mapping GpuDatatypes to actual types. Specializations provide the following members: sto...">Metadata</a> for mapping GpuDatatypes to actual types. Specializations provide the following members: storagetype, dataType, gpuSize, . <a href="structpvr_1_1_gpu_datatypes_helper_1_1_metadata.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1_index_out_of_range.html">pvr::IndexOutOfRange</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A simple std::runtime_error wrapper for throwing exceptions when attempting to use index out of range <a href="classpvr_1_1_index_out_of_range.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1_invalid_argument_error.html">pvr::InvalidArgumentError</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A simple std::runtime_error wrapper for throwing exceptions when invalid arguments are provided <a href="classpvr_1_1_invalid_argument_error.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1_invalid_data_error.html">pvr::InvalidDataError</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A simple std::runtime_error wrapper for throwing exceptions when invalid data is provided <a href="classpvr_1_1_invalid_data_error.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1_invalid_operation_error.html">pvr::InvalidOperationError</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A simple std::runtime_error wrapper for throwing exceptions when invalid operations are attempted <a href="classpvr_1_1_invalid_operation_error.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1_operation_failed_error.html">pvr::OperationFailedError</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A simple std::runtime_error wrapper for throwing exceptions when operations fail <a href="classpvr_1_1_operation_failed_error.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1_pvr_error.html">pvr::PvrError</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A simple std::runtime_error wrapper for throwing generic PVR exceptions <a href="classpvr_1_1_pvr_error.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1_strided_buffer.html">pvr::StridedBuffer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Representation of raw data. Used to store raw data that is logically grouped in blocks with a stride. <a href="classpvr_1_1_strided_buffer.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1_unsupported_operation_error.html">pvr::UnsupportedOperationError</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A simple std::runtime_error wrapper for throwing exceptions when unsupported operations are attempted <a href="classpvr_1_1_unsupported_operation_error.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespacepvr"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr.html">pvr</a></td></tr>
<tr class="memdesc:namespacepvr"><td class="mdescLeft">&#160;</td><td class="mdescRight">Main PowerVR Framework Namespace<br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacepvr_1_1_gpu_datatypes_helper"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1_gpu_datatypes_helper.html">pvr::GpuDatatypesHelper</a></td></tr>
<tr class="memdesc:namespacepvr_1_1_gpu_datatypes_helper"><td class="mdescLeft">&#160;</td><td class="mdescRight">Groups functionality that has to do with bit calculations/sizes/offsets of glsl types<br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:a6242a25f9d996f0cc4f4cdb911218b75"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_types_8h.html#a6242a25f9d996f0cc4f4cdb911218b75">ARRAY_SIZE</a>(x)&#160;&#160;&#160;(sizeof(x) / sizeof(x[0]))</td></tr>
<tr class="memdesc:a6242a25f9d996f0cc4f4cdb911218b75"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="_types_8h.html#a6242a25f9d996f0cc4f4cdb911218b75" title="ARRAY_SIZE(a) is a compile-time constant which represents the number of elements of the given array...">ARRAY_SIZE(a)</a> is a compile-time constant which represents the number of elements of the given array. ONLY use ARRAY_SIZE for statically allocated arrays. <a href="#a6242a25f9d996f0cc4f4cdb911218b75">More...</a><br/></td></tr>
<tr class="separator:a6242a25f9d996f0cc4f4cdb911218b75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8cb2e23e76f955e8248575af0a80d8dc"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8cb2e23e76f955e8248575af0a80d8dc"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_types_8h.html#a8cb2e23e76f955e8248575af0a80d8dc">DEFINE_ENUM_OPERATORS</a>(type_)</td></tr>
<tr class="memdesc:a8cb2e23e76f955e8248575af0a80d8dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Macro that defines all common bitwise operators for an enum-class. <br/></td></tr>
<tr class="separator:a8cb2e23e76f955e8248575af0a80d8dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a04c7a237dd1eb5c7ab24a7895f06d9fd"><td class="memItemLeft" align="right" valign="top">typedef ::std::vector&lt; char &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr.html#a04c7a237dd1eb5c7ab24a7895f06d9fd">pvr::CharBuffer</a></td></tr>
<tr class="memdesc:a04c7a237dd1eb5c7ab24a7895f06d9fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a buffer of Unsigned Bytes. Used to store raw data. <a href="#a04c7a237dd1eb5c7ab24a7895f06d9fd">More...</a><br/></td></tr>
<tr class="separator:a04c7a237dd1eb5c7ab24a7895f06d9fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d599bef48e61e7de820debff386447e"><td class="memItemLeft" align="right" valign="top">typedef ::std::vector&lt; uint8_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr.html#a6d599bef48e61e7de820debff386447e">pvr::UInt8Buffer</a></td></tr>
<tr class="memdesc:a6d599bef48e61e7de820debff386447e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a buffer of Unsigned Bytes. Used to store raw data. <a href="#a6d599bef48e61e7de820debff386447e">More...</a><br/></td></tr>
<tr class="separator:a6d599bef48e61e7de820debff386447e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f1b3a4b714cc874e267883662058a19"><td class="memItemLeft" align="right" valign="top">typedef unsigned short&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr.html#a2f1b3a4b714cc874e267883662058a19">pvr::utf16</a></td></tr>
<tr class="memdesc:a2f1b3a4b714cc874e267883662058a19"><td class="mdescLeft">&#160;</td><td class="mdescRight">A UTF-16 (unsigned) character. 16-bit unsigned Integer. <a href="#a2f1b3a4b714cc874e267883662058a19">More...</a><br/></td></tr>
<tr class="separator:a2f1b3a4b714cc874e267883662058a19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae281450f4795e25d5ce35d674b17249b"><td class="memItemLeft" align="right" valign="top">typedef unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr.html#ae281450f4795e25d5ce35d674b17249b">pvr::utf32</a></td></tr>
<tr class="memdesc:ae281450f4795e25d5ce35d674b17249b"><td class="mdescLeft">&#160;</td><td class="mdescRight">A UTF-32 (unsigned) character. 32-bit unsigned Integer. <a href="#ae281450f4795e25d5ce35d674b17249b">More...</a><br/></td></tr>
<tr class="separator:ae281450f4795e25d5ce35d674b17249b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ee58768dfb56ed9216c98178d572e17"><td class="memItemLeft" align="right" valign="top">typedef unsigned char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr.html#a9ee58768dfb56ed9216c98178d572e17">pvr::utf8</a></td></tr>
<tr class="memdesc:a9ee58768dfb56ed9216c98178d572e17"><td class="mdescLeft">&#160;</td><td class="mdescRight">A UTF-8 (unsigned) character. 8-bit unsigned Integer. <a href="#a9ee58768dfb56ed9216c98178d572e17">More...</a><br/></td></tr>
<tr class="separator:a9ee58768dfb56ed9216c98178d572e17"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:a74c5d1afa51512f076dd8e5844b171c8"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr.html#a74c5d1afa51512f076dd8e5844b171c8">pvr::Api</a> { <br/>
&#160;&#160;<b>Unspecified</b> = 0, 
<b>OpenGLES2</b>, 
<b>OpenGLES3</b>, 
<b>OpenGLES31</b>, 
<br/>
&#160;&#160;<b>OpenGLESMaxVersion</b> = OpenGLES31, 
<b>Vulkan</b>, 
<b>NumApis</b>
<br/>
 }</td></tr>
<tr class="memdesc:a74c5d1afa51512f076dd8e5844b171c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enumeration of all API types supported by this implementation <a href="namespacepvr.html#a74c5d1afa51512f076dd8e5844b171c8">More...</a><br/></td></tr>
<tr class="separator:a74c5d1afa51512f076dd8e5844b171c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abead2e53bdab9ebb17f7c858a2844e14"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1_gpu_datatypes_helper.html#abead2e53bdab9ebb17f7c858a2844e14">pvr::GpuDatatypesHelper::BaseType</a> { <b>Integer</b> = 0, 
<b>Float</b> = 1
 }</td></tr>
<tr class="memdesc:abead2e53bdab9ebb17f7c858a2844e14"><td class="mdescLeft">&#160;</td><td class="mdescRight">A bit representing if a type is basically of integer or floating point format  <a href="namespacepvr_1_1_gpu_datatypes_helper.html#abead2e53bdab9ebb17f7c858a2844e14">More...</a><br/></td></tr>
<tr class="separator:abead2e53bdab9ebb17f7c858a2844e14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84bf23cf8acb6cfb591074eda461590f"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1_gpu_datatypes_helper.html#a84bf23cf8acb6cfb591074eda461590f">pvr::GpuDatatypesHelper::Bits</a> : uint32_t { <br/>
&#160;&#160;<b>Integer</b> = 0, 
<b>Float</b> = 1, 
<b>BitScalar</b> = 0, 
<b>BitVec2</b> = 2, 
<br/>
&#160;&#160;<b>BitVec3</b> = 4, 
<b>BitVec4</b> = 6, 
<b>BitOneCol</b> = 0, 
<b>BitMat2x</b> = 8, 
<br/>
&#160;&#160;<b>BitMat3x</b> = 16, 
<b>BitMat4x</b> = 24, 
<b>ShiftType</b> = 0, 
<b>MaskType</b> = 1, 
<br/>
&#160;&#160;<b>NotMaskType</b> = static_cast&lt;uint32_t&gt;(~MaskType), 
<b>ShiftVec</b> = 1, 
<b>MaskVec</b> = (3 &lt;&lt; ShiftVec), 
<b>NotMaskVec</b> = static_cast&lt;uint32_t&gt;(~MaskVec), 
<br/>
&#160;&#160;<b>ShiftCols</b> = 3, 
<b>MaskCols</b> = (3 &lt;&lt; ShiftCols), 
<b>NotMaskCols</b> = static_cast&lt;uint32_t&gt;(~MaskCols)
<br/>
 }</td></tr>
<tr class="memdesc:a84bf23cf8acb6cfb591074eda461590f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Contains bit enums for the expressiveness of the GpuDatatypes class' definition <a href="namespacepvr_1_1_gpu_datatypes_helper.html#a84bf23cf8acb6cfb591074eda461590f">More...</a><br/></td></tr>
<tr class="separator:a84bf23cf8acb6cfb591074eda461590f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc560f133c0bcec5adff02183b4a9386"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr.html#afc560f133c0bcec5adff02183b4a9386">pvr::BlendFactor</a> : uint8_t { <br/>
&#160;&#160;<a class="el" href="namespacepvr.html#afc560f133c0bcec5adff02183b4a9386ad7ed4ee1df437474d005188535f74875">pvr::BlendFactor::Zero</a>, 
<a class="el" href="namespacepvr.html#afc560f133c0bcec5adff02183b4a9386a06c2cea18679d64399783748fa367bdd">pvr::BlendFactor::One</a>, 
<a class="el" href="namespacepvr.html#afc560f133c0bcec5adff02183b4a9386a2ad714e29d37896d79187312086bc6fe">pvr::BlendFactor::SrcColor</a>, 
<a class="el" href="namespacepvr.html#afc560f133c0bcec5adff02183b4a9386a09d3240b4e2481b1a729da24e9bfddf7">pvr::BlendFactor::OneMinusSrcColor</a>, 
<br/>
&#160;&#160;<a class="el" href="namespacepvr.html#afc560f133c0bcec5adff02183b4a9386afaedf511c99a5461048fd6a3b73da26c">pvr::BlendFactor::DstColor</a>, 
<a class="el" href="namespacepvr.html#afc560f133c0bcec5adff02183b4a9386a09f1a054ebd4d3850fd248bd2fa7b325">pvr::BlendFactor::OneMinusDstColor</a>, 
<a class="el" href="namespacepvr.html#afc560f133c0bcec5adff02183b4a9386ad5c7b7f0102df3f7305c43f73fc3a498">pvr::BlendFactor::SrcAlpha</a>, 
<a class="el" href="namespacepvr.html#afc560f133c0bcec5adff02183b4a9386ac00a6016489cff63d50d489ce52254cc">pvr::BlendFactor::OneMinusSrcAlpha</a>, 
<br/>
&#160;&#160;<a class="el" href="namespacepvr.html#afc560f133c0bcec5adff02183b4a9386af72dbe2436b38a39e5927ed644e6818b">pvr::BlendFactor::DstAlpha</a>, 
<a class="el" href="namespacepvr.html#afc560f133c0bcec5adff02183b4a9386a4132e4b87a8d461be2c6ee8fc620cfb2">pvr::BlendFactor::OneMinusDstAlpha</a>, 
<a class="el" href="namespacepvr.html#afc560f133c0bcec5adff02183b4a9386aeb8eb99f8eea9079c0e76d5ce7301dd3">pvr::BlendFactor::ConstantColor</a>, 
<a class="el" href="namespacepvr.html#afc560f133c0bcec5adff02183b4a9386a13ab8deb1c606ab17745354b4e92f43a">pvr::BlendFactor::OneMinusConstantColor</a>, 
<br/>
&#160;&#160;<a class="el" href="namespacepvr.html#afc560f133c0bcec5adff02183b4a9386a6f0229db491c3b01860363456dc57288">pvr::BlendFactor::ConstantAlpha</a>, 
<a class="el" href="namespacepvr.html#afc560f133c0bcec5adff02183b4a9386a9a1874144125c69e93ec99f17e985e41">pvr::BlendFactor::OneMinusConstantAlpha</a>, 
<a class="el" href="namespacepvr.html#afc560f133c0bcec5adff02183b4a9386a87c65d6ae5c79e8a05482365776bd959">pvr::BlendFactor::Src1Color</a>, 
<a class="el" href="namespacepvr.html#afc560f133c0bcec5adff02183b4a9386ac1686472488cf32c06cc257f4e8ac04f">pvr::BlendFactor::OneMinusSrc1Color</a>, 
<br/>
&#160;&#160;<a class="el" href="namespacepvr.html#afc560f133c0bcec5adff02183b4a9386aa69d96453c025ed62b3276e892e59e39">pvr::BlendFactor::Src1Alpha</a>, 
<a class="el" href="namespacepvr.html#afc560f133c0bcec5adff02183b4a9386a88dfdcc65a80f412d0330f00579ab7f2">pvr::BlendFactor::OneMinusSrc1Alpha</a>, 
<b>NumBlendFactor</b>, 
<b>DefaultSrcRgba</b> = One, 
<br/>
&#160;&#160;<b>DefaultDestRgba</b> = Zero
<br/>
 }</td></tr>
<tr class="memdesc:afc560f133c0bcec5adff02183b4a9386"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specfies how the rgba blending facors are computed for source and destination fragments. <a href="namespacepvr.html#afc560f133c0bcec5adff02183b4a9386">More...</a><br/></td></tr>
<tr class="separator:afc560f133c0bcec5adff02183b4a9386"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78be6b6f15903b90d6a9d575ebf6d353"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr.html#a78be6b6f15903b90d6a9d575ebf6d353">pvr::BlendOp</a> : uint32_t { <br/>
&#160;&#160;<a class="el" href="namespacepvr.html#a78be6b6f15903b90d6a9d575ebf6d353aec211f7c20af43e742bf2570c3cb84f9">pvr::BlendOp::Add</a>, 
<a class="el" href="namespacepvr.html#a78be6b6f15903b90d6a9d575ebf6d353a1d9baf077ee87921f57a8fe42d510b65">pvr::BlendOp::Subtract</a>, 
<a class="el" href="namespacepvr.html#a78be6b6f15903b90d6a9d575ebf6d353abd5458190996e76988cb2f27a820c685">pvr::BlendOp::ReverseSubtract</a>, 
<a class="el" href="namespacepvr.html#a78be6b6f15903b90d6a9d575ebf6d353a78d811e98514cd165dda532286610fd2">pvr::BlendOp::Min</a>, 
<br/>
&#160;&#160;<a class="el" href="namespacepvr.html#a78be6b6f15903b90d6a9d575ebf6d353a6a061313d22e51e0f25b7cd4dc065233">pvr::BlendOp::Max</a>, 
<b>NumBlendFunc</b>, 
<b>Default</b> = Add
<br/>
 }</td></tr>
<tr class="memdesc:a78be6b6f15903b90d6a9d575ebf6d353"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enumeration of the blend operations (determine how a new pixel (source color) is combined with a pixel already in the framebuffer (destination color). <a href="namespacepvr.html#a78be6b6f15903b90d6a9d575ebf6d353">More...</a><br/></td></tr>
<tr class="separator:a78be6b6f15903b90d6a9d575ebf6d353"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6ac287ad32e4b14937cee7ac81fb85e"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr.html#aa6ac287ad32e4b14937cee7ac81fb85e">pvr::BufferUsageFlags</a> : uint32_t { <br/>
&#160;&#160;<a class="el" href="namespacepvr.html#aa6ac287ad32e4b14937cee7ac81fb85eac1b703f2c13fac2fff3e72d3e307d4c0">pvr::BufferUsageFlags::TransferSrc</a> = 0x00000001, 
<a class="el" href="namespacepvr.html#aa6ac287ad32e4b14937cee7ac81fb85ea155895f4426d6fc97295ca2de160fd20">pvr::BufferUsageFlags::TransferDest</a> = 0x00000002, 
<a class="el" href="namespacepvr.html#aa6ac287ad32e4b14937cee7ac81fb85ea4b43da703340c8273da56cf3445c6754">pvr::BufferUsageFlags::UniformTexelBuffer</a> = 0x00000004, 
<a class="el" href="namespacepvr.html#aa6ac287ad32e4b14937cee7ac81fb85eaae1f93780c3073aeadaf118d550f0c65">pvr::BufferUsageFlags::StorageTexelBuffer</a> = 0x00000008, 
<br/>
&#160;&#160;<a class="el" href="namespacepvr.html#aa6ac287ad32e4b14937cee7ac81fb85ea88f133adfed6c854e5731cdffbf208cf">pvr::BufferUsageFlags::UniformBuffer</a> = 0x00000010, 
<a class="el" href="namespacepvr.html#aa6ac287ad32e4b14937cee7ac81fb85ea439f57c2c466c89db942b3de48298b2b">pvr::BufferUsageFlags::StorageBuffer</a> = 0x00000020, 
<a class="el" href="namespacepvr.html#aa6ac287ad32e4b14937cee7ac81fb85ea7c3895116254ff0417e58b6286de27c0">pvr::BufferUsageFlags::IndexBuffer</a> = 0x00000040, 
<a class="el" href="namespacepvr.html#aa6ac287ad32e4b14937cee7ac81fb85ea10461f19cdb5aadba2fc9986be6400bd">pvr::BufferUsageFlags::VertexBuffer</a> = 0x00000080, 
<br/>
&#160;&#160;<a class="el" href="namespacepvr.html#aa6ac287ad32e4b14937cee7ac81fb85ea7e5abafe55b7f7e20d417fe9c967d69e">pvr::BufferUsageFlags::IndirectBuffer</a> = 0x00000100, 
<b>Count</b> = 10
<br/>
 }</td></tr>
<tr class="memdesc:aa6ac287ad32e4b14937cee7ac81fb85e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enumeration of all supported buffer use types. <a href="namespacepvr.html#aa6ac287ad32e4b14937cee7ac81fb85e">More...</a><br/></td></tr>
<tr class="separator:aa6ac287ad32e4b14937cee7ac81fb85e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9ca1aead0a3149b0af3842d03bc6cd4"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr.html#af9ca1aead0a3149b0af3842d03bc6cd4">pvr::Capability</a> : uint8_t { <a class="el" href="namespacepvr.html#af9ca1aead0a3149b0af3842d03bc6cd4ab4080bdf74febf04d578ff105cce9d3f">pvr::Capability::Unsupported</a>, 
<a class="el" href="namespacepvr.html#af9ca1aead0a3149b0af3842d03bc6cd4a11efd9ae6f76e706e3f1b34d97584ebc">pvr::Capability::Immutable</a>, 
<a class="el" href="namespacepvr.html#af9ca1aead0a3149b0af3842d03bc6cd4ad924522d30d6615e9f71e91504364a9d">pvr::Capability::Mutable</a>
 }</td></tr>
<tr class="memdesc:af9ca1aead0a3149b0af3842d03bc6cd4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Capability supported values. <a href="namespacepvr.html#af9ca1aead0a3149b0af3842d03bc6cd4">More...</a><br/></td></tr>
<tr class="separator:af9ca1aead0a3149b0af3842d03bc6cd4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a675b14a2f2079f7f72e7f2ad35d13de7"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr.html#a675b14a2f2079f7f72e7f2ad35d13de7">pvr::ColorChannelFlags</a> : uint32_t { <br/>
&#160;&#160;<a class="el" href="namespacepvr.html#a675b14a2f2079f7f72e7f2ad35d13de7ae1e1d3d40573127e9ee0480caf1283d6">pvr::ColorChannelFlags::R</a> = 0x01, 
<a class="el" href="namespacepvr.html#a675b14a2f2079f7f72e7f2ad35d13de7adfcf28d0734569a6a693bc8194de62bf">pvr::ColorChannelFlags::G</a> = 0x02, 
<a class="el" href="namespacepvr.html#a675b14a2f2079f7f72e7f2ad35d13de7a9d5ed678fe57bcca610140957afab571">pvr::ColorChannelFlags::B</a> = 0x04, 
<a class="el" href="namespacepvr.html#a675b14a2f2079f7f72e7f2ad35d13de7a7fc56270e7a70fa81a5935b72eacbe29">pvr::ColorChannelFlags::A</a> = 0x08, 
<br/>
&#160;&#160;<a class="el" href="namespacepvr.html#a675b14a2f2079f7f72e7f2ad35d13de7a6adf97f83acf6453d4a6a4b1070f3754">pvr::ColorChannelFlags::None</a> = 0, 
<b>All</b> = R | G | B | A
<br/>
 }</td></tr>
<tr class="memdesc:a675b14a2f2079f7f72e7f2ad35d13de7"><td class="mdescLeft">&#160;</td><td class="mdescRight">ChannelWriteMask enable/ disable writting to channel bits. <a href="namespacepvr.html#a675b14a2f2079f7f72e7f2ad35d13de7">More...</a><br/></td></tr>
<tr class="separator:a675b14a2f2079f7f72e7f2ad35d13de7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b94afe6b8a7c21e8f8ddee1f7b5cb91"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr.html#a1b94afe6b8a7c21e8f8ddee1f7b5cb91">pvr::ColorSpace</a> { <a class="el" href="namespacepvr.html#a1b94afe6b8a7c21e8f8ddee1f7b5cb91a4c8bf835da6d934b50f620cdd0cc3913">pvr::ColorSpace::lRGB</a>, 
<a class="el" href="namespacepvr.html#a1b94afe6b8a7c21e8f8ddee1f7b5cb91a9ed33d9be17d174aeb4393a989586ed9">pvr::ColorSpace::sRGB</a>, 
<b>NumSpaces</b>
 }</td></tr>
<tr class="memdesc:a1b94afe6b8a7c21e8f8ddee1f7b5cb91"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enumeration of Colorspaces (Linear, SRGB). <a href="namespacepvr.html#a1b94afe6b8a7c21e8f8ddee1f7b5cb91">More...</a><br/></td></tr>
<tr class="separator:a1b94afe6b8a7c21e8f8ddee1f7b5cb91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24a87498f839b45b6e1bc3c8b2ca20fc"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr.html#a24a87498f839b45b6e1bc3c8b2ca20fc">pvr::CompareOp</a> : uint32_t { <br/>
&#160;&#160;<a class="el" href="namespacepvr.html#a24a87498f839b45b6e1bc3c8b2ca20fca6e7b34fa59e1bd229b207892956dc41c">pvr::CompareOp::Never</a> = 0, 
<a class="el" href="namespacepvr.html#a24a87498f839b45b6e1bc3c8b2ca20fca1cfdf0e8d0c87a228c1f40d9bee7888b">pvr::CompareOp::Less</a> = 1, 
<a class="el" href="namespacepvr.html#a24a87498f839b45b6e1bc3c8b2ca20fcaf5f286e73bda105e538310b3190f75c5">pvr::CompareOp::Equal</a> = 2, 
<a class="el" href="namespacepvr.html#a24a87498f839b45b6e1bc3c8b2ca20fcad3e6fdac55bb7b0edd7834c968ba1f38">pvr::CompareOp::LessEqual</a> = 3, 
<br/>
&#160;&#160;<a class="el" href="namespacepvr.html#a24a87498f839b45b6e1bc3c8b2ca20fca8768a6821cd735aea4f5b0df88c1fc6a">pvr::CompareOp::Greater</a> = 4, 
<a class="el" href="namespacepvr.html#a24a87498f839b45b6e1bc3c8b2ca20fca19bb0af2c3c530538cb41aff7f235b96">pvr::CompareOp::NotEqual</a> = 5, 
<a class="el" href="namespacepvr.html#a24a87498f839b45b6e1bc3c8b2ca20fca758b05d899def79c9eb864ad4f96be1f">pvr::CompareOp::GreaterEqual</a> = 6, 
<a class="el" href="namespacepvr.html#a24a87498f839b45b6e1bc3c8b2ca20fca68eec46437c384d8dad18d5464ebc35c">pvr::CompareOp::Always</a> = 7, 
<br/>
&#160;&#160;<b>NumComparisonMode</b>, 
<b>DefaultDepthFunc</b> = Less, 
<b>DefaultStencilFunc</b> = Always
<br/>
 }</td></tr>
<tr class="memdesc:a24a87498f839b45b6e1bc3c8b2ca20fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">An enumeration that defines Comparison operations (equal, less or equal etc.). Especially used in API classes for functions like depth testing. <a href="namespacepvr.html#a24a87498f839b45b6e1bc3c8b2ca20fc">More...</a><br/></td></tr>
<tr class="separator:a24a87498f839b45b6e1bc3c8b2ca20fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87b409df225dee78541eb74988f4e20c"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr.html#a87b409df225dee78541eb74988f4e20c">pvr::CubeFace</a> : uint32_t { <br/>
&#160;&#160;<a class="el" href="namespacepvr.html#a87b409df225dee78541eb74988f4e20ca9f082d04c481aab268b9f614d2ffd129">pvr::CubeFace::PositiveX</a> = 0, 
<a class="el" href="namespacepvr.html#a87b409df225dee78541eb74988f4e20ca963a8a64a09d54efc81b136ca6be21b2">pvr::CubeFace::NegativeX</a>, 
<a class="el" href="namespacepvr.html#a87b409df225dee78541eb74988f4e20cac53c385ced96bd629c0f45a902aceba3">pvr::CubeFace::PositiveY</a>, 
<a class="el" href="namespacepvr.html#a87b409df225dee78541eb74988f4e20cae4d5f02ceecd15caf66e9f0b2393c86b">pvr::CubeFace::NegativeY</a>, 
<br/>
&#160;&#160;<a class="el" href="namespacepvr.html#a87b409df225dee78541eb74988f4e20ca1921c16ffdafaf04e378ca1b6774c0ce">pvr::CubeFace::PositiveZ</a>, 
<a class="el" href="namespacepvr.html#a87b409df225dee78541eb74988f4e20cada76df034cd139bd515761c8bb8e3090">pvr::CubeFace::NegativeZ</a>
<br/>
 }</td></tr>
<tr class="memdesc:a87b409df225dee78541eb74988f4e20c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enumeration of the six faces of a Cube <a href="namespacepvr.html#a87b409df225dee78541eb74988f4e20c">More...</a><br/></td></tr>
<tr class="separator:a87b409df225dee78541eb74988f4e20c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7924324f96dc973225ad3c532cc72309"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr.html#a7924324f96dc973225ad3c532cc72309">pvr::DataType</a> { <br/>
&#160;&#160;<a class="el" href="namespacepvr.html#a7924324f96dc973225ad3c532cc72309a6adf97f83acf6453d4a6a4b1070f3754">pvr::DataType::None</a>, 
<a class="el" href="namespacepvr.html#a7924324f96dc973225ad3c532cc72309a166495adc0d0f53bee6baecc577f5204">pvr::DataType::Float32</a>, 
<a class="el" href="namespacepvr.html#a7924324f96dc973225ad3c532cc72309ac06129f6e6e15c09328365e553f1dc31">pvr::DataType::Int32</a>, 
<a class="el" href="namespacepvr.html#a7924324f96dc973225ad3c532cc72309a8bd950a9d7779b83f5c30046c9aaf1cf">pvr::DataType::UInt16</a>, 
<br/>
&#160;&#160;<a class="el" href="namespacepvr.html#a7924324f96dc973225ad3c532cc72309aea3495a278957dc58165e48a8945469f">pvr::DataType::RGBA</a>, 
<a class="el" href="namespacepvr.html#a7924324f96dc973225ad3c532cc72309ae192297ecf3602fabbec5f0a38ede758">pvr::DataType::ARGB</a>, 
<a class="el" href="namespacepvr.html#a7924324f96dc973225ad3c532cc72309a67cb8b94254acbfda2cdf7a916421298">pvr::DataType::D3DCOLOR</a>, 
<a class="el" href="namespacepvr.html#a7924324f96dc973225ad3c532cc72309aa061360f8e01902202f21849c40a1105">pvr::DataType::UBYTE4</a>, 
<br/>
&#160;&#160;<a class="el" href="namespacepvr.html#a7924324f96dc973225ad3c532cc72309aff4e3dcc2ead0fa54993ccbf4eda1ae8">pvr::DataType::DEC3N</a>, 
<a class="el" href="namespacepvr.html#a7924324f96dc973225ad3c532cc72309a32e326bf2ef732551075db8987a1408c">pvr::DataType::Fixed16_16</a>, 
<a class="el" href="namespacepvr.html#a7924324f96dc973225ad3c532cc72309ab31df9c476d20e85ff898121efe11b5a">pvr::DataType::UInt8</a>, 
<a class="el" href="namespacepvr.html#a7924324f96dc973225ad3c532cc72309a39bc2ae44b184207f560ff8619823208">pvr::DataType::Int16</a>, 
<br/>
&#160;&#160;<a class="el" href="namespacepvr.html#a7924324f96dc973225ad3c532cc72309a0f224678669aa9f1b9e9dee8c544912a">pvr::DataType::Int16Norm</a>, 
<a class="el" href="namespacepvr.html#a7924324f96dc973225ad3c532cc72309a7d839b2c12bfd40ac121b4cc9e81c539">pvr::DataType::Int8</a>, 
<a class="el" href="namespacepvr.html#a7924324f96dc973225ad3c532cc72309a74f0eeb95bdbf29bcc7eb2b6431c13f2">pvr::DataType::Int8Norm</a>, 
<a class="el" href="namespacepvr.html#a7924324f96dc973225ad3c532cc72309a784d359bf21cc07236f54855d9aab91a">pvr::DataType::UInt8Norm</a>, 
<br/>
&#160;&#160;<a class="el" href="namespacepvr.html#a7924324f96dc973225ad3c532cc72309ab296ec5fbf49139c807bd99ba7f7dee8">pvr::DataType::UInt16Norm</a>, 
<a class="el" href="namespacepvr.html#a7924324f96dc973225ad3c532cc72309ae7956ed7be1c5025a27ed3cb42a396bd">pvr::DataType::UInt32</a>, 
<a class="el" href="namespacepvr.html#a7924324f96dc973225ad3c532cc72309adce7d10c2f9ffc8ed9e7b6a3f7d8ba6c">pvr::DataType::ABGR</a>, 
<a class="el" href="namespacepvr.html#a7924324f96dc973225ad3c532cc72309a26e6ed77470c6f2f830ecf874e6c0d55">pvr::DataType::Float16</a>, 
<br/>
&#160;&#160;<b>Custom</b> = 1000
<br/>
 }</td></tr>
<tr class="memdesc:a7924324f96dc973225ad3c532cc72309"><td class="mdescLeft">&#160;</td><td class="mdescRight">An enumeration that defines data types used throughout the Framework. Commonly used in places where raw data are used to define the types actually contained. <a href="namespacepvr.html#a7924324f96dc973225ad3c532cc72309">More...</a><br/></td></tr>
<tr class="separator:a7924324f96dc973225ad3c532cc72309"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3283c5c9822ac5135fefd45a7cdd5932"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr.html#a3283c5c9822ac5135fefd45a7cdd5932">pvr::DescriptorType</a> : uint32_t { <br/>
&#160;&#160;<a class="el" href="namespacepvr.html#a3283c5c9822ac5135fefd45a7cdd5932a5bca2f066df1fe641b2b779db2a63c0a">pvr::DescriptorType::Sampler</a>, 
<a class="el" href="namespacepvr.html#a3283c5c9822ac5135fefd45a7cdd5932a8cfe077ac9aea5235b0c3fda85914029">pvr::DescriptorType::CombinedImageSampler</a>, 
<a class="el" href="namespacepvr.html#a3283c5c9822ac5135fefd45a7cdd5932a4520c597ce328c250d1ca5192047d71d">pvr::DescriptorType::SampledImage</a>, 
<a class="el" href="namespacepvr.html#a3283c5c9822ac5135fefd45a7cdd5932aa078fa7ad769f9e7b53b8c42e3b7bbab">pvr::DescriptorType::StorageImage</a>, 
<br/>
&#160;&#160;<a class="el" href="namespacepvr.html#a3283c5c9822ac5135fefd45a7cdd5932a4b43da703340c8273da56cf3445c6754">pvr::DescriptorType::UniformTexelBuffer</a>, 
<a class="el" href="namespacepvr.html#a3283c5c9822ac5135fefd45a7cdd5932aae1f93780c3073aeadaf118d550f0c65">pvr::DescriptorType::StorageTexelBuffer</a>, 
<a class="el" href="namespacepvr.html#a3283c5c9822ac5135fefd45a7cdd5932a88f133adfed6c854e5731cdffbf208cf">pvr::DescriptorType::UniformBuffer</a>, 
<a class="el" href="namespacepvr.html#a3283c5c9822ac5135fefd45a7cdd5932a439f57c2c466c89db942b3de48298b2b">pvr::DescriptorType::StorageBuffer</a>, 
<br/>
&#160;&#160;<a class="el" href="namespacepvr.html#a3283c5c9822ac5135fefd45a7cdd5932a517b91f0588b3bf6c80ff3b19b2a7f57">pvr::DescriptorType::UniformBufferDynamic</a>, 
<a class="el" href="namespacepvr.html#a3283c5c9822ac5135fefd45a7cdd5932ada8c94227ee0e3b5cd40da12d594ad55">pvr::DescriptorType::StorageBufferDynamic</a>, 
<a class="el" href="namespacepvr.html#a3283c5c9822ac5135fefd45a7cdd5932a261d965f5dd43c6873489b68730dbe57">pvr::DescriptorType::InputAttachment</a>, 
<b>Count</b> = 12, 
<br/>
&#160;&#160;<b>NumBits</b> = 4
<br/>
 }</td></tr>
<tr class="memdesc:a3283c5c9822ac5135fefd45a7cdd5932"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enumeration of all the different descriptor types. <a href="namespacepvr.html#a3283c5c9822ac5135fefd45a7cdd5932">More...</a><br/></td></tr>
<tr class="separator:a3283c5c9822ac5135fefd45a7cdd5932"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ca56afd652113209f2535e7688a4189"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr.html#a1ca56afd652113209f2535e7688a4189">pvr::Face</a> : uint32_t { <br/>
&#160;&#160;<a class="el" href="namespacepvr.html#a1ca56afd652113209f2535e7688a4189a6adf97f83acf6453d4a6a4b1070f3754">pvr::Face::None</a> = 0, 
<a class="el" href="namespacepvr.html#a1ca56afd652113209f2535e7688a4189a5835bab1ade0060909e31a06af2e2cde">pvr::Face::Front</a> = 1, 
<a class="el" href="namespacepvr.html#a1ca56afd652113209f2535e7688a4189a0557fa923dcee4d0f86b1409f5c2167f">pvr::Face::Back</a> = 2, 
<a class="el" href="namespacepvr.html#a1ca56afd652113209f2535e7688a4189a8be41da9b58e32ece35a2b5751f6aeb9">pvr::Face::FrontAndBack</a> = 3, 
<br/>
&#160;&#160;<b>Default</b> = None
<br/>
 }</td></tr>
<tr class="memdesc:a1ca56afd652113209f2535e7688a4189"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enumeration of Face facing (front, back...). <a href="namespacepvr.html#a1ca56afd652113209f2535e7688a4189">More...</a><br/></td></tr>
<tr class="separator:a1ca56afd652113209f2535e7688a4189"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84d320093e1561f82e57776aafd947d7"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr.html#a84d320093e1561f82e57776aafd947d7">pvr::Filter</a> : uint8_t { <br/>
&#160;&#160;<a class="el" href="namespacepvr.html#a84d320093e1561f82e57776aafd947d7a60494f02d440f316319dd0fad40ad007">pvr::Filter::Nearest</a>, 
<b>Linear</b>, 
<a class="el" href="namespacepvr.html#a84d320093e1561f82e57776aafd947d7a6adf97f83acf6453d4a6a4b1070f3754">pvr::Filter::None</a>, 
<a class="el" href="namespacepvr.html#a84d320093e1561f82e57776aafd947d7aec6b5414eb175379ff9efc9b3eef5814">pvr::Filter::Cubic</a>, 
<br/>
&#160;&#160;<b>Default</b> = Linear, 
<b>MipDefault</b> = Linear, 
<b>Size</b> = 4
<br/>
 }</td></tr>
<tr class="memdesc:a84d320093e1561f82e57776aafd947d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enumeration describing a filtering type of a specific dimension. In order to describe the filtering mode properly, you would have to define a Minification filter, a Magnification filter and a Mipmapping minification filter. Possible values: Nearest, Linear, Cubic, None. <a href="namespacepvr.html#a84d320093e1561f82e57776aafd947d7">More...</a><br/></td></tr>
<tr class="separator:a84d320093e1561f82e57776aafd947d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4440f5fd1256889bd3b3822002208b6"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr.html#aa4440f5fd1256889bd3b3822002208b6">pvr::GpuDatatypes</a> : uint32_t { <br/>
&#160;&#160;<b>Integer</b>, 
<b>uinteger</b> = Integer, 
<b>boolean</b> = Integer, 
<b>Float</b>, 
<br/>
&#160;&#160;<b>ivec2</b>, 
<b>uvec2</b> = ivec2, 
<b>bvec2</b> = ivec2, 
<b>ivec3</b>, 
<br/>
&#160;&#160;<b>uvec3</b> = ivec3, 
<b>bvec3</b> = ivec3, 
<b>ivec4</b>, 
<b>uvec4</b> = ivec4, 
<br/>
&#160;&#160;<b>bvec4</b> = ivec4, 
<b>vec2</b>, 
<b>vec3</b>, 
<b>vec4</b>, 
<br/>
&#160;&#160;<b>mat2x2</b>, 
<b>mat2x3</b>, 
<b>mat2x4</b>, 
<b>mat3x2</b>, 
<br/>
&#160;&#160;<b>mat3x3</b>, 
<b>mat3x4</b>, 
<b>mat4x2</b>, 
<b>mat4x3</b>, 
<br/>
&#160;&#160;<b>mat4x4</b>, 
<b>none</b> = 0xFFFFFFFF, 
<b>structure</b> = none
<br/>
 }</td></tr>
<tr class="memdesc:aa4440f5fd1256889bd3b3822002208b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">A (normally hardware-supported) GPU datatype (e.g. vec4 etc.) <a href="namespacepvr.html#aa4440f5fd1256889bd3b3822002208b6">More...</a><br/></td></tr>
<tr class="separator:aa4440f5fd1256889bd3b3822002208b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee12f61a84bee4c4513c6bfad5b042d2"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr.html#aee12f61a84bee4c4513c6bfad5b042d2">pvr::ImageAspectFlags</a> : uint32_t { <br/>
&#160;&#160;<b>Color</b> = 0x1, 
<b>Depth</b> = 0x2, 
<b>Stencil</b> = 0x4, 
<b>Metadata</b> = 0x8, 
<br/>
&#160;&#160;<b>DepthAndStencil</b> = Depth | Stencil
<br/>
 }</td></tr>
<tr class="memdesc:aee12f61a84bee4c4513c6bfad5b042d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enumeration of the "aspect" (or "semantics") of an image: Color, Depth, Stencil. <a href="namespacepvr.html#aee12f61a84bee4c4513c6bfad5b042d2">More...</a><br/></td></tr>
<tr class="separator:aee12f61a84bee4c4513c6bfad5b042d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab98ea90165357c2f9030218c337f90bf"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr.html#ab98ea90165357c2f9030218c337f90bf">pvr::ImageType</a> { <br/>
&#160;&#160;<a class="el" href="namespacepvr.html#ab98ea90165357c2f9030218c337f90bfa4be6a4b9c4d4594764eb625d5c146fff">pvr::ImageType::Image1D</a>, 
<a class="el" href="namespacepvr.html#ab98ea90165357c2f9030218c337f90bfab696e5f895616f606a8be85892c374a9">pvr::ImageType::Image2D</a>, 
<a class="el" href="namespacepvr.html#ab98ea90165357c2f9030218c337f90bfa2d4c32ae3db71aee7bf3a801d15f5075">pvr::ImageType::Image3D</a>, 
<a class="el" href="namespacepvr.html#ab98ea90165357c2f9030218c337f90bfa9aeb35984c497717cce0044620fc964a">pvr::ImageType::Unallocated</a>, 
<br/>
&#160;&#160;<a class="el" href="namespacepvr.html#ab98ea90165357c2f9030218c337f90bfa88183b946cc5f0e8c96b2e66e1c74a7e">pvr::ImageType::Unknown</a>, 
<b>Count</b> = Image3D + 1
<br/>
 }</td></tr>
<tr class="memdesc:ab98ea90165357c2f9030218c337f90bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">The dimension of an image. <a href="namespacepvr.html#ab98ea90165357c2f9030218c337f90bf">More...</a><br/></td></tr>
<tr class="separator:ab98ea90165357c2f9030218c337f90bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43f03a43047f737186d5b90b19dcaca2"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr.html#a43f03a43047f737186d5b90b19dcaca2">pvr::ImageViewType</a> { <br/>
&#160;&#160;<a class="el" href="namespacepvr.html#a43f03a43047f737186d5b90b19dcaca2a882bc3b744cc0702640a7bacf0bbcfec">pvr::ImageViewType::ImageView1D</a>, 
<a class="el" href="namespacepvr.html#a43f03a43047f737186d5b90b19dcaca2ad6677d8d1d32ba21cdf283ac165924ad">pvr::ImageViewType::ImageView2D</a>, 
<a class="el" href="namespacepvr.html#a43f03a43047f737186d5b90b19dcaca2a6698a767e1fc8afa8db1cd800d78d675">pvr::ImageViewType::ImageView3D</a>, 
<a class="el" href="namespacepvr.html#a43f03a43047f737186d5b90b19dcaca2a0e44904a008408462e8f2567465f2157">pvr::ImageViewType::ImageView2DCube</a>, 
<br/>
&#160;&#160;<a class="el" href="namespacepvr.html#a43f03a43047f737186d5b90b19dcaca2aba6b5050476daa2d65fe7081478ed7a0">pvr::ImageViewType::ImageView1DArray</a>, 
<a class="el" href="namespacepvr.html#a43f03a43047f737186d5b90b19dcaca2abe5a0e508c8c71c3ab11da749a6678a7">pvr::ImageViewType::ImageView2DArray</a>, 
<a class="el" href="namespacepvr.html#a43f03a43047f737186d5b90b19dcaca2a9ffe857cfe5d3eff82077db510ca5675">pvr::ImageViewType::ImageView2DCubeArray</a>, 
<a class="el" href="namespacepvr.html#a43f03a43047f737186d5b90b19dcaca2aa9d24d469028b69a34b22604c244dfc3">pvr::ImageViewType::ImageViewUnknown</a>
<br/>
 }</td></tr>
<tr class="memdesc:a43f03a43047f737186d5b90b19dcaca2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enumeration of Texture dimensionalities. <a href="namespacepvr.html#a43f03a43047f737186d5b90b19dcaca2">More...</a><br/></td></tr>
<tr class="separator:a43f03a43047f737186d5b90b19dcaca2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab40a4733df51a99c80b389348c493ac"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr.html#aab40a4733df51a99c80b389348c493ac">pvr::IndexType</a> : uint32_t { <a class="el" href="namespacepvr.html#aab40a4733df51a99c80b389348c493acac995e06991264df36fe28315304bcd6e">pvr::IndexType::IndexType16Bit</a> = static_cast&lt;uint32_t&gt;(DataType::UInt16), 
<a class="el" href="namespacepvr.html#aab40a4733df51a99c80b389348c493aca456ada99990fe2c6043f27810c550148">pvr::IndexType::IndexType32Bit</a> = static_cast&lt;uint32_t&gt;(DataType::UInt32)
 }</td></tr>
<tr class="memdesc:aab40a4733df51a99c80b389348c493ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">An enumeration that defines a type that can use as an index, typically 16 or 32 bit int. Especially used in Model classes. <a href="namespacepvr.html#aab40a4733df51a99c80b389348c493ac">More...</a><br/></td></tr>
<tr class="separator:aab40a4733df51a99c80b389348c493ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a443ed852f4fa9bd3cc3cc446ed1499"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1_gpu_datatypes_helper.html#a1a443ed852f4fa9bd3cc3cc446ed1499">pvr::GpuDatatypesHelper::MatrixColumns</a> { <b>OneCol</b> = 0, 
<b>Mat2x</b> = 1, 
<b>Mat3x</b> = 2, 
<b>Mat4x</b> = 3
 }</td></tr>
<tr class="memdesc:a1a443ed852f4fa9bd3cc3cc446ed1499"><td class="mdescLeft">&#160;</td><td class="mdescRight">Three bits, representing the number of matrix columns (from not a matrix to 4) <a href="namespacepvr_1_1_gpu_datatypes_helper.html#a1a443ed852f4fa9bd3cc3cc446ed1499">More...</a><br/></td></tr>
<tr class="separator:a1a443ed852f4fa9bd3cc3cc446ed1499"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aafc960d10904ec52d4d823ed66717c43"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr.html#aafc960d10904ec52d4d823ed66717c43">pvr::PackedSamplerFilter</a> : int8_t { <br/>
&#160;&#160;<b>PackNone</b>, 
<b>PackNearestMipNone</b>, 
<b>PackNearestMipNearest</b>, 
<b>PackNearestMipLinear</b>, 
<br/>
&#160;&#160;<b>PackLinearMipNone</b>, 
<b>PackLinearMipNearest</b>, 
<b>PackTrilinear</b>, 
<b>Size</b>, 
<br/>
&#160;&#160;<b>Size</b> = 4, 
<b>Size</b>, 
<b>PackDefault</b> = PackTrilinear
<br/>
 }</td></tr>
<tr class="memdesc:aafc960d10904ec52d4d823ed66717c43"><td class="mdescLeft">&#160;</td><td class="mdescRight">This enum is made to pack all sampler filtering info in 8 bits for specific uses. Use "packSamplerFilter" and "unpackSamplerFilter". NOTE: The defined values are only the most common cases - other 8 bit values are also valid (for example, different minification and magnification filters) <a href="namespacepvr.html#aafc960d10904ec52d4d823ed66717c43">More...</a><br/></td></tr>
<tr class="separator:aafc960d10904ec52d4d823ed66717c43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acebf4429ca4e976bca1ecaf28401bd59"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr.html#acebf4429ca4e976bca1ecaf28401bd59">pvr::PolygonWindingOrder</a> : uint8_t { <a class="el" href="namespacepvr.html#acebf4429ca4e976bca1ecaf28401bd59a6baa14a02b39a3336b6bf0087473eff3">pvr::PolygonWindingOrder::FrontFaceCCW</a>, 
<a class="el" href="namespacepvr.html#acebf4429ca4e976bca1ecaf28401bd59a8331b56f0f66fa794a20609344081509">pvr::PolygonWindingOrder::FrontFaceCW</a>, 
<b>Default</b> = FrontFaceCCW
 }</td></tr>
<tr class="memdesc:acebf4429ca4e976bca1ecaf28401bd59"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enumeration of the different front face to winding order correlations. <a href="namespacepvr.html#acebf4429ca4e976bca1ecaf28401bd59">More...</a><br/></td></tr>
<tr class="separator:acebf4429ca4e976bca1ecaf28401bd59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95105fe432efbe2b976187f0270b6012"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr.html#a95105fe432efbe2b976187f0270b6012">pvr::PrimitiveTopology</a> : uint32_t { <br/>
&#160;&#160;<a class="el" href="namespacepvr.html#a95105fe432efbe2b976187f0270b6012a1a18ff71b3df3e362a2489eef4b30003">pvr::PrimitiveTopology::PointList</a>, 
<a class="el" href="namespacepvr.html#a95105fe432efbe2b976187f0270b6012a596e1b7afe8925f3f578c716d5af8fef">pvr::PrimitiveTopology::LineList</a>, 
<a class="el" href="namespacepvr.html#a95105fe432efbe2b976187f0270b6012ae7f9e73b8edd21f420a63b3ace5768a2">pvr::PrimitiveTopology::LineStrip</a>, 
<a class="el" href="namespacepvr.html#a95105fe432efbe2b976187f0270b6012af5beeab7a1f452e5b0e9b03b44f0de92">pvr::PrimitiveTopology::TriangleList</a>, 
<br/>
&#160;&#160;<a class="el" href="namespacepvr.html#a95105fe432efbe2b976187f0270b6012a1da0b9ead8b051940a89214bae22831c">pvr::PrimitiveTopology::TriangleStrip</a>, 
<a class="el" href="namespacepvr.html#a95105fe432efbe2b976187f0270b6012a18d58fde618e4a30e2dfdc122e693047">pvr::PrimitiveTopology::TriangleFan</a>, 
<a class="el" href="namespacepvr.html#a95105fe432efbe2b976187f0270b6012af951dbe32c0c5d525b8e0ec3884de6c7">pvr::PrimitiveTopology::LineListWithAdjacency</a>, 
<a class="el" href="namespacepvr.html#a95105fe432efbe2b976187f0270b6012ae6a2093eb583f16122d50acb096af542">pvr::PrimitiveTopology::LineStripWithAdjacency</a>, 
<br/>
&#160;&#160;<a class="el" href="namespacepvr.html#a95105fe432efbe2b976187f0270b6012a150324739f6017972f918eff656ba998">pvr::PrimitiveTopology::TriangleListWithAdjacency</a>, 
<a class="el" href="namespacepvr.html#a95105fe432efbe2b976187f0270b6012aa8df42f3be2313042a310fb7319b4c36">pvr::PrimitiveTopology::TriangleStripWithAdjacency</a>, 
<a class="el" href="namespacepvr.html#a95105fe432efbe2b976187f0270b6012af1b220525e3cc747140a46b7e2d7532e">pvr::PrimitiveTopology::PatchList</a>, 
<b>Count</b>
<br/>
 }</td></tr>
<tr class="memdesc:a95105fe432efbe2b976187f0270b6012"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enumeration containing all possible Primitive topologies (Point, line trianglelist etc.). <a href="namespacepvr.html#a95105fe432efbe2b976187f0270b6012">More...</a><br/></td></tr>
<tr class="separator:a95105fe432efbe2b976187f0270b6012"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c5fa1488e4ba61dd568718646a8c73d"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr.html#a1c5fa1488e4ba61dd568718646a8c73d">pvr::Result</a> { <br/>
&#160;&#160;<b>Success</b>, 
<b>UnknownError</b>, 
<b>NotInitialized</b>, 
<b>InitializationError</b>, 
<br/>
&#160;&#160;<b>UnsupportedRequest</b>, 
<b>ExitRenderFrame</b>
<br/>
 }</td></tr>
<tr class="memdesc:a1c5fa1488e4ba61dd568718646a8c73d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pre-defined Result codes (success and generic errors). <a href="namespacepvr.html#a1c5fa1488e4ba61dd568718646a8c73d">More...</a><br/></td></tr>
<tr class="separator:a1c5fa1488e4ba61dd568718646a8c73d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aedec1ca92cba055434a2a27da89f5643"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr.html#aedec1ca92cba055434a2a27da89f5643">pvr::SamplerAddressMode</a> : uint8_t { <br/>
&#160;&#160;<a class="el" href="namespacepvr.html#aedec1ca92cba055434a2a27da89f5643a7020426cfb0a204051be4b3053d2acc8">pvr::SamplerAddressMode::Repeat</a>, 
<a class="el" href="namespacepvr.html#aedec1ca92cba055434a2a27da89f5643a39a681a9d5ccc902bebd16a343dd7b74">pvr::SamplerAddressMode::MirrorRepeat</a>, 
<a class="el" href="namespacepvr.html#aedec1ca92cba055434a2a27da89f5643a74556551231333c36debc3d373261134">pvr::SamplerAddressMode::ClampToEdge</a>, 
<a class="el" href="namespacepvr.html#aedec1ca92cba055434a2a27da89f5643afb07f88f6f11cc5ab9c951290716f147">pvr::SamplerAddressMode::ClampToBorder</a>, 
<br/>
&#160;&#160;<a class="el" href="namespacepvr.html#aedec1ca92cba055434a2a27da89f5643a01f488e80fc32761aecfbeb3d1c8f26b">pvr::SamplerAddressMode::MirrorClampToEdge</a>, 
<b>Size</b>, 
<b>Default</b> = Repeat
<br/>
 }</td></tr>
<tr class="memdesc:aedec1ca92cba055434a2a27da89f5643"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enumeration for defining texture wrapping mode: Repeat, Mirror, Clamp, Border. <a href="namespacepvr.html#aedec1ca92cba055434a2a27da89f5643">More...</a><br/></td></tr>
<tr class="separator:aedec1ca92cba055434a2a27da89f5643"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7a59f03f943f1c79a5339331fc15abe"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr.html#ac7a59f03f943f1c79a5339331fc15abe">pvr::SamplerMipmapMode</a> : uint8_t { <a class="el" href="namespacepvr.html#ac7a59f03f943f1c79a5339331fc15abea60494f02d440f316319dd0fad40ad007">pvr::SamplerMipmapMode::Nearest</a>, 
<a class="el" href="namespacepvr.html#ac7a59f03f943f1c79a5339331fc15abea32a843da6ea40ab3b17a3421ccdf671b">pvr::SamplerMipmapMode::Linear</a>, 
<b>Count</b>
 }</td></tr>
<tr class="memdesc:ac7a59f03f943f1c79a5339331fc15abe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enumeration of mipmap modes supported for a sampler <a href="namespacepvr.html#ac7a59f03f943f1c79a5339331fc15abe">More...</a><br/></td></tr>
<tr class="separator:ac7a59f03f943f1c79a5339331fc15abe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5c2a4d46bb7aa6a877a0ed8c5ba3ac8"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr.html#af5c2a4d46bb7aa6a877a0ed8c5ba3ac8">pvr::ShaderType</a> { <br/>
&#160;&#160;<a class="el" href="namespacepvr.html#af5c2a4d46bb7aa6a877a0ed8c5ba3ac8a05c0d061c57b467a86d66f7529f19bb5">pvr::ShaderType::UnknownShader</a> = 0, 
<a class="el" href="namespacepvr.html#af5c2a4d46bb7aa6a877a0ed8c5ba3ac8aeb3ca4dac3e206977e0b7d998eefcc33">pvr::ShaderType::VertexShader</a>, 
<a class="el" href="namespacepvr.html#af5c2a4d46bb7aa6a877a0ed8c5ba3ac8a90a9bb4e665932b1781da33fc2f32922">pvr::ShaderType::FragmentShader</a>, 
<a class="el" href="namespacepvr.html#af5c2a4d46bb7aa6a877a0ed8c5ba3ac8a2216355d14abbc1a80dadd4f881c0f39">pvr::ShaderType::ComputeShader</a>, 
<br/>
&#160;&#160;<b>TessControlShader</b>, 
<b>TessEvaluationShader</b>, 
<b>GeometryShader</b>, 
<b>RayShader</b>, 
<br/>
&#160;&#160;<b>FrameShader</b>, 
<b>Count</b>
<br/>
 }</td></tr>
<tr class="memdesc:af5c2a4d46bb7aa6a877a0ed8c5ba3ac8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enumeration of all supported shader types. <a href="namespacepvr.html#af5c2a4d46bb7aa6a877a0ed8c5ba3ac8">More...</a><br/></td></tr>
<tr class="separator:af5c2a4d46bb7aa6a877a0ed8c5ba3ac8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adaffc1ac547687d86eef4bb51d0533aa"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr.html#adaffc1ac547687d86eef4bb51d0533aa">pvr::StencilOp</a> : uint8_t { <br/>
&#160;&#160;<a class="el" href="namespacepvr.html#adaffc1ac547687d86eef4bb51d0533aaa02bce93bff905887ad2233110bf9c49e">pvr::StencilOp::Keep</a>, 
<a class="el" href="namespacepvr.html#adaffc1ac547687d86eef4bb51d0533aaad7ed4ee1df437474d005188535f74875">pvr::StencilOp::Zero</a>, 
<a class="el" href="namespacepvr.html#adaffc1ac547687d86eef4bb51d0533aaa0ebe6df8a3ac338e0512acc741823fdb">pvr::StencilOp::Replace</a>, 
<a class="el" href="namespacepvr.html#adaffc1ac547687d86eef4bb51d0533aaa39f5ed1c9a1e48cc90401d52864202ab">pvr::StencilOp::IncrementClamp</a>, 
<br/>
&#160;&#160;<a class="el" href="namespacepvr.html#adaffc1ac547687d86eef4bb51d0533aaa669ecd4a04c7b2cda3fbf54f62e180f1">pvr::StencilOp::DecrementClamp</a>, 
<a class="el" href="namespacepvr.html#adaffc1ac547687d86eef4bb51d0533aaa9b8958acb7be504bb5f55f17c0eea366">pvr::StencilOp::Invert</a>, 
<a class="el" href="namespacepvr.html#adaffc1ac547687d86eef4bb51d0533aaaaa91cb7f033b90dec9582dc5e9611732">pvr::StencilOp::IncrementWrap</a>, 
<a class="el" href="namespacepvr.html#adaffc1ac547687d86eef4bb51d0533aaa6ec565c329385c8d59333abc6a1003d1">pvr::StencilOp::DecrementWrap</a>, 
<br/>
&#160;&#160;<b>NumStencilOp</b>, 
<b>Default</b> = Keep
<br/>
 }</td></tr>
<tr class="memdesc:adaffc1ac547687d86eef4bb51d0533aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enumeration of the different stencil operations. <a href="namespacepvr.html#adaffc1ac547687d86eef4bb51d0533aa">More...</a><br/></td></tr>
<tr class="separator:adaffc1ac547687d86eef4bb51d0533aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6fffa33db4623ece1088010c6f78bc9f"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr.html#a6fffa33db4623ece1088010c6f78bc9f">pvr::StepRate</a> : uint32_t { <a class="el" href="namespacepvr.html#a6fffa33db4623ece1088010c6f78bc9fab22b929ba52471a02d18bb3a4e4472e6">pvr::StepRate::Vertex</a>, 
<a class="el" href="namespacepvr.html#a6fffa33db4623ece1088010c6f78bc9fad9a17c1c9e8ef6866e4dbeef41c741b2">pvr::StepRate::Instance</a>, 
<b>Default</b> = Vertex
 }</td></tr>
<tr class="memdesc:a6fffa33db4623ece1088010c6f78bc9f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Step rate for a vertex attribute when drawing: Per vertex, per instance, per draw. <a href="namespacepvr.html#a6fffa33db4623ece1088010c6f78bc9f">More...</a><br/></td></tr>
<tr class="separator:a6fffa33db4623ece1088010c6f78bc9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff3aa99e1b21f38c32bce768d56b2198"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1_gpu_datatypes_helper.html#aff3aa99e1b21f38c32bce768d56b2198">pvr::GpuDatatypesHelper::VectorWidth</a> { <b>Scalar</b> = 0, 
<b>Vec2</b> = 1, 
<b>Vec3</b> = 2, 
<b>Vec4</b> = 3
 }</td></tr>
<tr class="memdesc:aff3aa99e1b21f38c32bce768d56b2198"><td class="mdescLeft">&#160;</td><td class="mdescRight">Two bits, representing the number of vector components (from scalar up to 4) <a href="namespacepvr_1_1_gpu_datatypes_helper.html#aff3aa99e1b21f38c32bce768d56b2198">More...</a><br/></td></tr>
<tr class="separator:aff3aa99e1b21f38c32bce768d56b2198"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a3dc927ae582f3ec00005bf32ceb97830"><td class="memTemplParams" colspan="2">template&lt;typename t1 , typename t2 &gt; </td></tr>
<tr class="memitem:a3dc927ae582f3ec00005bf32ceb97830"><td class="memTemplItemLeft" align="right" valign="top">t1&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepvr.html#a3dc927ae582f3ec00005bf32ceb97830">pvr::align</a> (t1 numberToAlign, t2 alignment)</td></tr>
<tr class="memdesc:a3dc927ae582f3ec00005bf32ceb97830"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aligns a given number based on the given alignment <a href="#a3dc927ae582f3ec00005bf32ceb97830">More...</a><br/></td></tr>
<tr class="separator:a3dc927ae582f3ec00005bf32ceb97830"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0303f68824c30e29b02875302cd75d96"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr.html#a0303f68824c30e29b02875302cd75d96">pvr::apiCode</a> (Api api)</td></tr>
<tr class="memdesc:a0303f68824c30e29b02875302cd75d96"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a string of the specific api enum <a href="#a0303f68824c30e29b02875302cd75d96">More...</a><br/></td></tr>
<tr class="separator:a0303f68824c30e29b02875302cd75d96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e39bf9a267425bc06d61d9a0130f6ea"><td class="memItemLeft" align="right" valign="top">Api&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr.html#a6e39bf9a267425bc06d61d9a0130f6ea">pvr::apiFamilyMax</a> (Api api)</td></tr>
<tr class="memdesc:a6e39bf9a267425bc06d61d9a0130f6ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the highest api version that is of the same family as the parameter <a href="#a6e39bf9a267425bc06d61d9a0130f6ea">More...</a><br/></td></tr>
<tr class="separator:a6e39bf9a267425bc06d61d9a0130f6ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ec9f9921823c5b479a99d3a5f8a3457"><td class="memItemLeft" align="right" valign="top">Api&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr.html#a8ec9f9921823c5b479a99d3a5f8a3457">pvr::apiFamilyMin</a> (Api api)</td></tr>
<tr class="memdesc:a8ec9f9921823c5b479a99d3a5f8a3457"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get minimum api that is the same family as the parameter. (e.g. Vulkan returns Vulkan, while OpenGLES31 returns OpenGLES2) api family min version <a href="#a8ec9f9921823c5b479a99d3a5f8a3457">More...</a><br/></td></tr>
<tr class="separator:a8ec9f9921823c5b479a99d3a5f8a3457"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0940447f72ad2b8777a37cd3181b5c9"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr.html#ac0940447f72ad2b8777a37cd3181b5c9">pvr::apiName</a> (Api api)</td></tr>
<tr class="memdesc:ac0940447f72ad2b8777a37cd3181b5c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the api name std::string of the given Enumeration <a href="#ac0940447f72ad2b8777a37cd3181b5c9">More...</a><br/></td></tr>
<tr class="separator:ac0940447f72ad2b8777a37cd3181b5c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32304b6fe8a8ebcfdaa03d5b227da809"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr.html#a32304b6fe8a8ebcfdaa03d5b227da809">pvr::dataTypeIsNormalised</a> (DataType type)</td></tr>
<tr class="memdesc:a32304b6fe8a8ebcfdaa03d5b227da809"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return if the format is Normalized (represents a range between 0..1 for unsigned types or between -1..1 for signed types) <a href="#a32304b6fe8a8ebcfdaa03d5b227da809">More...</a><br/></td></tr>
<tr class="separator:a32304b6fe8a8ebcfdaa03d5b227da809"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4bbe49ea1e5ffbeaf1463379ff1adcfc"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr.html#a4bbe49ea1e5ffbeaf1463379ff1adcfc">pvr::dataTypeSize</a> (DataType type)</td></tr>
<tr class="memdesc:a4bbe49ea1e5ffbeaf1463379ff1adcfc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the Size of a DataType. <a href="#a4bbe49ea1e5ffbeaf1463379ff1adcfc">More...</a><br/></td></tr>
<tr class="separator:a4bbe49ea1e5ffbeaf1463379ff1adcfc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4676d56d2f795d4c4f5b7a094af90c9"><td class="memItemLeft" align="right" valign="top">BufferUsageFlags&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr.html#af4676d56d2f795d4c4f5b7a094af90c9">pvr::descriptorTypeToBufferUsage</a> (DescriptorType descType)</td></tr>
<tr class="memdesc:af4676d56d2f795d4c4f5b7a094af90c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Infer the BufferUsageFlags that are suitable for the typical use of an object <a href="#af4676d56d2f795d4c4f5b7a094af90c9">More...</a><br/></td></tr>
<tr class="separator:af4676d56d2f795d4c4f5b7a094af90c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43dd44f92c0013d2ed1dd13363070770"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr.html#a43dd44f92c0013d2ed1dd13363070770">pvr::getAlignment</a> (GpuDatatypes type)</td></tr>
<tr class="memdesc:a43dd44f92c0013d2ed1dd13363070770"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get required alignment of this type as demanded by std140 rules <a href="#a43dd44f92c0013d2ed1dd13363070770">More...</a><br/></td></tr>
<tr class="separator:a43dd44f92c0013d2ed1dd13363070770"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe1ac49f71337e1cfd4e6436b3bb9ca6"><td class="memItemLeft" align="right" valign="top">GpuDatatypesHelper::BaseType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr.html#abe1ac49f71337e1cfd4e6436b3bb9ca6">pvr::getBaseType</a> (GpuDatatypes type)</td></tr>
<tr class="memdesc:abe1ac49f71337e1cfd4e6436b3bb9ca6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the underlying element of a type (integer or float) <a href="#abe1ac49f71337e1cfd4e6436b3bb9ca6">More...</a><br/></td></tr>
<tr class="separator:abe1ac49f71337e1cfd4e6436b3bb9ca6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6bc2716579dfbeade26021e2628dd7a7"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr.html#a6bc2716579dfbeade26021e2628dd7a7">pvr::getCpuPackedSize</a> (GpuDatatypes type, uint32_t arrayElements=1)</td></tr>
<tr class="memdesc:a6bc2716579dfbeade26021e2628dd7a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the size of n array members of a type, packed in CPU <a href="#a6bc2716579dfbeade26021e2628dd7a7">More...</a><br/></td></tr>
<tr class="separator:a6bc2716579dfbeade26021e2628dd7a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65076be9fba2c986f80ffe1eb64aa29a"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr.html#a65076be9fba2c986f80ffe1eb64aa29a">pvr::getNumMatrixColumns</a> (GpuDatatypes type)</td></tr>
<tr class="memdesc:a65076be9fba2c986f80ffe1eb64aa29a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of colums (1..4) of the type <a href="#a65076be9fba2c986f80ffe1eb64aa29a">More...</a><br/></td></tr>
<tr class="separator:a65076be9fba2c986f80ffe1eb64aa29a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8277a30a2c9fa98ba8c66c2c8516f923"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr.html#a8277a30a2c9fa98ba8c66c2c8516f923">pvr::getNumVecElements</a> (GpuDatatypes type)</td></tr>
<tr class="memdesc:a8277a30a2c9fa98ba8c66c2c8516f923"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of vector elements (i.e. Rows) of a type. (e.g. vec2=&gt;2) <a href="#a8277a30a2c9fa98ba8c66c2c8516f923">More...</a><br/></td></tr>
<tr class="separator:a8277a30a2c9fa98ba8c66c2c8516f923"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b67db200cee4a4078676dc5f3622ec0"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr.html#a5b67db200cee4a4078676dc5f3622ec0">pvr::getOffsetAfter</a> (GpuDatatypes type, uint64_t previousTotalSize)</td></tr>
<tr class="memdesc:a5b67db200cee4a4078676dc5f3622ec0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aligns an address/offset with the alignment of a type &ndash; equivalently, assuming you want to place a type after a known offset (i.e. calculating the offset of an item inside a struct having already calculated its previous element) (i.e. aligning a vec4 after an item that ends at 30 bytes returns 32 bytes...)  <a href="#a5b67db200cee4a4078676dc5f3622ec0">More...</a><br/></td></tr>
<tr class="separator:a5b67db200cee4a4078676dc5f3622ec0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10f119283374e989cd179f6831fe1e36"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr.html#a10f119283374e989cd179f6831fe1e36">pvr::getResultCodeString</a> (Result result)</td></tr>
<tr class="memdesc:a10f119283374e989cd179f6831fe1e36"><td class="mdescLeft">&#160;</td><td class="mdescRight">Use this function to convert a Result into a std::string that is suitable for outputting. <a href="#a10f119283374e989cd179f6831fe1e36">More...</a><br/></td></tr>
<tr class="separator:a10f119283374e989cd179f6831fe1e36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7caef391618cc1a3ebab73d8ffe90a47"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr.html#a7caef391618cc1a3ebab73d8ffe90a47">pvr::getSelfAlignedArraySize</a> (GpuDatatypes type)</td></tr>
<tr class="memdesc:a7caef391618cc1a3ebab73d8ffe90a47"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns "how many bytes will an object of this type take", if it is an array member (arrays have potentially stricter requirements). <a href="#a7caef391618cc1a3ebab73d8ffe90a47">More...</a><br/></td></tr>
<tr class="separator:a7caef391618cc1a3ebab73d8ffe90a47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a239df321236ac77da04fe9d58f5efe55"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr.html#a239df321236ac77da04fe9d58f5efe55">pvr::getSelfAlignedSize</a> (GpuDatatypes type)</td></tr>
<tr class="memdesc:a239df321236ac77da04fe9d58f5efe55"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns "how many bytes will an object of this type take", if not an array. <a href="#a239df321236ac77da04fe9d58f5efe55">More...</a><br/></td></tr>
<tr class="separator:a239df321236ac77da04fe9d58f5efe55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e17c970a2a4965269fcb9e3e55049dd"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr.html#a7e17c970a2a4965269fcb9e3e55049dd">pvr::getSize</a> (GpuDatatypes type, uint32_t arrayElements=1)</td></tr>
<tr class="memdesc:a7e17c970a2a4965269fcb9e3e55049dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns how many bytes an array of n objects of this type take, but arrayElements = 1 is NOT considered an array (is aligned as a single object, NOT an array of 1) <a href="#a7e17c970a2a4965269fcb9e3e55049dd">More...</a><br/></td></tr>
<tr class="separator:a7e17c970a2a4965269fcb9e3e55049dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6bc881503cace7cf8d883d54905aa462"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr.html#a6bc881503cace7cf8d883d54905aa462">pvr::getTotalSizeAfter</a> (GpuDatatypes type, uint32_t arrayElements, uint64_t previousTotalSize)</td></tr>
<tr class="memdesc:a6bc881503cace7cf8d883d54905aa462"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the new size of a hypothetical struct whose old size was previousTotalSize, and to which "arrayElement" new items of type "type" are added <a href="#a6bc881503cace7cf8d883d54905aa462">More...</a><br/></td></tr>
<tr class="separator:a6bc881503cace7cf8d883d54905aa462"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c310f549c8db9647eeeef82a0a56af0"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr.html#a4c310f549c8db9647eeeef82a0a56af0">pvr::getVectorSelfAlignedSize</a> (GpuDatatypes type)</td></tr>
<tr class="memdesc:a4c310f549c8db9647eeeef82a0a56af0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the size of a type, including padding, assuming the next item is of the same type <a href="#a4c310f549c8db9647eeeef82a0a56af0">More...</a><br/></td></tr>
<tr class="separator:a4c310f549c8db9647eeeef82a0a56af0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3cbe7fd082e1089dc162d9afdacdd6f1"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr.html#a3cbe7fd082e1089dc162d9afdacdd6f1">pvr::getVectorUnalignedSize</a> (GpuDatatypes type)</td></tr>
<tr class="memdesc:a3cbe7fd082e1089dc162d9afdacdd6f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the cpu-packed size of each vector element a type (disregarding matrix columns if they exist) <a href="#a3cbe7fd082e1089dc162d9afdacdd6f1">More...</a><br/></td></tr>
<tr class="separator:a3cbe7fd082e1089dc162d9afdacdd6f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a128900aeb6815de42a6d6d2c59f67a6e"><td class="memItemLeft" align="right" valign="top">ImageType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr.html#a128900aeb6815de42a6d6d2c59f67a6e">pvr::imageViewTypeToImageBaseType</a> (ImageViewType viewtype)</td></tr>
<tr class="memdesc:a128900aeb6815de42a6d6d2c59f67a6e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Map an ImageViewType (2dCube etc) to its base type (1d/2d/3d) <a href="#a128900aeb6815de42a6d6d2c59f67a6e">More...</a><br/></td></tr>
<tr class="separator:a128900aeb6815de42a6d6d2c59f67a6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3fd0cfec4d261dd1caa2ce5eefcc2a53"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr.html#a3fd0cfec4d261dd1caa2ce5eefcc2a53">pvr::indexTypeSizeInBytes</a> (const IndexType type)</td></tr>
<tr class="memdesc:a3fd0cfec4d261dd1caa2ce5eefcc2a53"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the Size of an IndexType in bytes. <a href="#a3fd0cfec4d261dd1caa2ce5eefcc2a53">More...</a><br/></td></tr>
<tr class="separator:a3fd0cfec4d261dd1caa2ce5eefcc2a53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff2eee1ed23143ae72185a5472ea765a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr.html#aff2eee1ed23143ae72185a5472ea765a">pvr::isDescriptorTypeDynamic</a> (DescriptorType descType)</td></tr>
<tr class="memdesc:aff2eee1ed23143ae72185a5472ea765a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if a descriptor type is dynamic (a dynamic UBO or dynamic SSBO) <a href="#aff2eee1ed23143ae72185a5472ea765a">More...</a><br/></td></tr>
<tr class="separator:aff2eee1ed23143ae72185a5472ea765a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac73ce628e547374c22057ff8e3a89bb3"><td class="memItemLeft" align="right" valign="top">GpuDatatypes&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr.html#ac73ce628e547374c22057ff8e3a89bb3">pvr::mergeDatatypesBigger</a> (GpuDatatypes type1, GpuDatatypes type2)</td></tr>
<tr class="memdesc:ac73ce628e547374c22057ff8e3a89bb3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a datatype that is larger or equal to both of two types: 1) Has the most permissive base type (float&gt;int) 2) Has the largest of the two vector widths 3) Has the most of the two matrix colums heights <a href="#ac73ce628e547374c22057ff8e3a89bb3">More...</a><br/></td></tr>
<tr class="separator:ac73ce628e547374c22057ff8e3a89bb3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ef5be44f3a11eac1a122cafd4a217db"><td class="memItemLeft" align="right" valign="top">GpuDatatypes&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr.html#a7ef5be44f3a11eac1a122cafd4a217db">pvr::mergeDatatypesSmaller</a> (GpuDatatypes type1, GpuDatatypes type2)</td></tr>
<tr class="memdesc:a7ef5be44f3a11eac1a122cafd4a217db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a datatype that is smaller or equal to both of two types: 1) Has the most permissive base type (float&gt;int) 2) Has the smaller of the two vector widths 3) Has the least of the two matrix colums heights <a href="#a7ef5be44f3a11eac1a122cafd4a217db">More...</a><br/></td></tr>
<tr class="separator:a7ef5be44f3a11eac1a122cafd4a217db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33df3732a0a48b5274ac3938a7e570b0"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr.html#a33df3732a0a48b5274ac3938a7e570b0">pvr::numDataTypeComponents</a> (DataType type)</td></tr>
<tr class="memdesc:a33df3732a0a48b5274ac3938a7e570b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the number of components in a datatype. <a href="#a33df3732a0a48b5274ac3938a7e570b0">More...</a><br/></td></tr>
<tr class="separator:a33df3732a0a48b5274ac3938a7e570b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb9d4eda8ff979cd4e5ae394aa9321c6"><td class="memItemLeft" align="right" valign="top">GpuDatatypes&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr.html#acb9d4eda8ff979cd4e5ae394aa9321c6">pvr::operator&amp;</a> (GpuDatatypes lhs, GpuDatatypesHelper::Bits rhs)</td></tr>
<tr class="memdesc:acb9d4eda8ff979cd4e5ae394aa9321c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bitwise operator AND. Typical semantics. Allows AND between GpuDatatypes and Bits <a href="#acb9d4eda8ff979cd4e5ae394aa9321c6">More...</a><br/></td></tr>
<tr class="separator:acb9d4eda8ff979cd4e5ae394aa9321c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6830359c957ddaf92782874bb70e825"><td class="memItemLeft" align="right" valign="top">GpuDatatypes&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr.html#ae6830359c957ddaf92782874bb70e825">pvr::operator&lt;&lt;</a> (GpuDatatypes lhs, GpuDatatypesHelper::Bits rhs)</td></tr>
<tr class="memdesc:ae6830359c957ddaf92782874bb70e825"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bitwise operator LEFT SHIFT. Typical semantics. Allows LEFT SHIFT of GpuDatatypes by Bits <a href="#ae6830359c957ddaf92782874bb70e825">More...</a><br/></td></tr>
<tr class="separator:ae6830359c957ddaf92782874bb70e825"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab32d83bd296ef37d4c646b2552e276e7"><td class="memItemLeft" align="right" valign="top">GpuDatatypes&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr.html#ab32d83bd296ef37d4c646b2552e276e7">pvr::operator&gt;&gt;</a> (GpuDatatypes lhs, GpuDatatypesHelper::Bits rhs)</td></tr>
<tr class="memdesc:ab32d83bd296ef37d4c646b2552e276e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bitwise operator RIGHT SHIFT. Typical semantics. Allows RIGHT SHIFT of GpuDatatypes by Bits <a href="#ab32d83bd296ef37d4c646b2552e276e7">More...</a><br/></td></tr>
<tr class="separator:ab32d83bd296ef37d4c646b2552e276e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abbe45548f9e676d52b1645ea21ba4d11"><td class="memItemLeft" align="right" valign="top">PackedSamplerFilter&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr.html#abbe45548f9e676d52b1645ea21ba4d11">pvr::packSamplerFilter</a> (Filter mini, Filter magni, SamplerMipmapMode mip)</td></tr>
<tr class="memdesc:abbe45548f9e676d52b1645ea21ba4d11"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pack a minification filter, a magnification filter and a mipmap filter into an 8 bit value <a href="#abbe45548f9e676d52b1645ea21ba4d11">More...</a><br/></td></tr>
<tr class="separator:abbe45548f9e676d52b1645ea21ba4d11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7cc135f8fc78f66cf936fd87efc7fccf"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr.html#a7cc135f8fc78f66cf936fd87efc7fccf">pvr::randomrange</a> (float min, float max)</td></tr>
<tr class="memdesc:a7cc135f8fc78f66cf936fd87efc7fccf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a random Number between min and max <a href="#a7cc135f8fc78f66cf936fd87efc7fccf">More...</a><br/></td></tr>
<tr class="separator:a7cc135f8fc78f66cf936fd87efc7fccf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a547738cbdb228eba2d1d4b58d2c142c9"><td class="memItemLeft" align="right" valign="top">DataType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr.html#a547738cbdb228eba2d1d4b58d2c142c9">pvr::toDataType</a> (GpuDatatypes type)</td></tr>
<tr class="memdesc:a547738cbdb228eba2d1d4b58d2c142c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the Cpu Datatype <em>type</em>  refers to (i.e. which CPU datatype must you load in the data you upload to the GPU to correctly upload the same value in the shader). <a href="#a547738cbdb228eba2d1d4b58d2c142c9">More...</a><br/></td></tr>
<tr class="separator:a547738cbdb228eba2d1d4b58d2c142c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea8728868bc6c9fa07c48f1f6d0e2f37"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr.html#aea8728868bc6c9fa07c48f1f6d0e2f37">pvr::toString</a> (GpuDatatypes type)</td></tr>
<tr class="memdesc:aea8728868bc6c9fa07c48f1f6d0e2f37"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a string with the glsl variable name of a type <a href="#aea8728868bc6c9fa07c48f1f6d0e2f37">More...</a><br/></td></tr>
<tr class="separator:aea8728868bc6c9fa07c48f1f6d0e2f37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93997dab7a634e84d3ac4cdd4bb7fa33"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr.html#a93997dab7a634e84d3ac4cdd4bb7fa33">pvr::unpackSamplerFilter</a> (PackedSamplerFilter packed, Filter &amp;mini, Filter &amp;magni, SamplerMipmapMode &amp;mip)</td></tr>
<tr class="memdesc:a93997dab7a634e84d3ac4cdd4bb7fa33"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unpack a 8 bit PackedSamplerFilter value into a minification, magnification and mip filter mode <a href="#a93997dab7a634e84d3ac4cdd4bb7fa33">More...</a><br/></td></tr>
<tr class="separator:a93997dab7a634e84d3ac4cdd4bb7fa33"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Basic file used in the PowerVR Framework. Defines several types used throughout the Framework (sized arithmetic types, enumerations, character types). </p>
<dl class="section author"><dt>Author</dt><dd>PowerVR by Imagination, Developer Technology Team </dd></dl>
<dl class="section user"><dt>Copyright:</dt><dd>Copyright (c) Imagination Technologies Limited. </dd></dl>
</div><h2 class="groupheader">Macro Definition Documentation</h2>
<a class="anchor" id="a6242a25f9d996f0cc4f4cdb911218b75"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ARRAY_SIZE</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">x</td><td>)</td>
          <td>&#160;&#160;&#160;(sizeof(x) / sizeof(x[0]))</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="_types_8h.html#a6242a25f9d996f0cc4f4cdb911218b75" title="ARRAY_SIZE(a) is a compile-time constant which represents the number of elements of the given array...">ARRAY_SIZE(a)</a> is a compile-time constant which represents the number of elements of the given array. ONLY use ARRAY_SIZE for statically allocated arrays.</p>

</div>
</div>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.4-->
<!-- start footer part (NON TREEVIEW ONLY!!) -->
<!--BEGIN GENERATE_TREEVIEW-->
<div id="FooterMainContainer">
	<div id="FooterContainer">
		<div class="footerlogo">
			<a href="http://www.imgtec.com" target="_blank"><img src="img-footer-logo-grey.png" width="100%" height="100%" border="none" /></a>
		</div>
		<div class="copyright"><p>&copy; Imagination Technologies Limited<br> All rights reserved</p></div>
	</div>
</div>
</body>
</html>
