<!-- HTML header for doxygen 1.8.4-->
<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="generator" content="Doxygen 1.8.6"/>
<title>PVRCore: pvr::TypedMem Struct Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="IMGdoxygen.css" rel="stylesheet" type="text/css"/>
<link rel="shortcut icon" href="http://www.imgtec.com/images/img.ico">
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
  <div class="headercontent">
    <div class="PVRlogo">
      <a href="http://www.powervrinsider.com" target="_blank"><img src="PVRlogo.png" width="40%" height="40%"  border="none" /></a>
    </div>
    <a class="SiteTitle"><span id="projectname">PVRCore</span> Documentation</a>
   <tbody>
  </div>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="inherits.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Macros</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacepvr.html">pvr</a></li><li class="navelem"><a class="el" href="structpvr_1_1_typed_mem.html">TypedMem</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="structpvr_1_1_typed_mem-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">pvr::TypedMem Struct Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Represents Free Value View that is backed by a (usually small) dynamically allocated block. 
 <a href="structpvr_1_1_typed_mem.html#details">More...</a></p>
<div class="dynheader">
Inheritance diagram for pvr::TypedMem:</div>
<div class="dyncontent">
<div class="center"><img src="structpvr_1_1_typed_mem__inherit__graph.png" border="0" usemap="#pvr_1_1_typed_mem_inherit__map" alt="Inheritance graph"/></div>
<map name="pvr_1_1_typed_mem_inherit__map" id="pvr_1_1_typed_mem_inherit__map">
<area shape="rect" id="node2" href="classpvr_1_1_free_value_view.html" title="Represents a runtime&#45;known number of elements of a runtime&#45;known type, with functions to handle and c..." alt="" coords="4,5,139,32"/></map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a97af394a81c5b663d9bdfd9be7cdef95"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpvr_1_1_typed_mem.html#a97af394a81c5b663d9bdfd9be7cdef95">TypedMem</a> ()</td></tr>
<tr class="memdesc:a97af394a81c5b663d9bdfd9be7cdef95"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor. <a href="#a97af394a81c5b663d9bdfd9be7cdef95">More...</a><br/></td></tr>
<tr class="separator:a97af394a81c5b663d9bdfd9be7cdef95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86eb61f333d8370d7b909d6906f251b7"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpvr_1_1_typed_mem.html#a86eb61f333d8370d7b909d6906f251b7">TypedMem</a> (const <a class="el" href="structpvr_1_1_typed_mem.html">TypedMem</a> &amp;rhs)</td></tr>
<tr class="memdesc:a86eb61f333d8370d7b909d6906f251b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy assignment from another <a class="el" href="structpvr_1_1_typed_mem.html" title="Represents Free Value View that is backed by a (usually small) dynamically allocated block...">TypedMem</a>. <a href="#a86eb61f333d8370d7b909d6906f251b7">More...</a><br/></td></tr>
<tr class="separator:a86eb61f333d8370d7b909d6906f251b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa46cda4a003b402daab223dbc9f7bf1a"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpvr_1_1_typed_mem.html#aa46cda4a003b402daab223dbc9f7bf1a">~TypedMem</a> ()</td></tr>
<tr class="memdesc:aa46cda4a003b402daab223dbc9f7bf1a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor. Frees any allocated memory. <a href="#aa46cda4a003b402daab223dbc9f7bf1a">More...</a><br/></td></tr>
<tr class="separator:aa46cda4a003b402daab223dbc9f7bf1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b5134af879d8ef8450d03a1a4a0387c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpvr_1_1_typed_mem.html#a3b5134af879d8ef8450d03a1a4a0387c">allocate</a> (<a class="el" href="namespacepvr.html#aa4440f5fd1256889bd3b3822002208b6">GpuDatatypes</a> <a class="el" href="classpvr_1_1_free_value_view.html#a8dfbe83db91fe5bfb1dbccbe8834cab8">dataType</a>, uint32_t <a class="el" href="classpvr_1_1_free_value_view.html#a8af557adeae312867dd3e24edd39b176">arrayElements</a>=1)</td></tr>
<tr class="memdesc:a3b5134af879d8ef8450d03a1a4a0387c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate the <a class="el" href="structpvr_1_1_typed_mem.html" title="Represents Free Value View that is backed by a (usually small) dynamically allocated block...">TypedMem</a> to contain the specified type and number of items. Grows only, does not shrink memory. <a href="#a3b5134af879d8ef8450d03a1a4a0387c">More...</a><br/></td></tr>
<tr class="separator:a3b5134af879d8ef8450d03a1a4a0387c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8af557adeae312867dd3e24edd39b176"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1_free_value_view.html#a8af557adeae312867dd3e24edd39b176">arrayElements</a> () const </td></tr>
<tr class="memdesc:a8af557adeae312867dd3e24edd39b176"><td class="mdescLeft">&#160;</td><td class="mdescRight">Size of the data contained. For unformatted data (Datatype==None) this is the total bytes contained. <a href="#a8af557adeae312867dd3e24edd39b176">More...</a><br/></td></tr>
<tr class="separator:a8af557adeae312867dd3e24edd39b176"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ae6d323c9224b5cd4322e8630e5fbbf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpvr_1_1_typed_mem.html#a8ae6d323c9224b5cd4322e8630e5fbbf">assign</a> (const <a class="el" href="structpvr_1_1_typed_mem.html">TypedMem</a> &amp;rhs)</td></tr>
<tr class="memdesc:a8ae6d323c9224b5cd4322e8630e5fbbf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor from another <a class="el" href="structpvr_1_1_typed_mem.html" title="Represents Free Value View that is backed by a (usually small) dynamically allocated block...">TypedMem</a>. <a href="#a8ae6d323c9224b5cd4322e8630e5fbbf">More...</a><br/></td></tr>
<tr class="separator:a8ae6d323c9224b5cd4322e8630e5fbbf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abcb6de4cde92ff94863334b5a95c8ece"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpvr_1_1_typed_mem.html#abcb6de4cde92ff94863334b5a95c8ece">clear</a> ()</td></tr>
<tr class="memdesc:abcb6de4cde92ff94863334b5a95c8ece"><td class="mdescLeft">&#160;</td><td class="mdescRight">Empty this object. Does NOT free the memory. <a href="#abcb6de4cde92ff94863334b5a95c8ece">More...</a><br/></td></tr>
<tr class="separator:abcb6de4cde92ff94863334b5a95c8ece"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0aa9115211adc67014c867a69b12c87e"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1_free_value_view.html#a0aa9115211adc67014c867a69b12c87e">dataSize</a> () const </td></tr>
<tr class="memdesc:a0aa9115211adc67014c867a69b12c87e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Size of the data contained. <a href="#a0aa9115211adc67014c867a69b12c87e">More...</a><br/></td></tr>
<tr class="separator:a0aa9115211adc67014c867a69b12c87e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8dfbe83db91fe5bfb1dbccbe8834cab8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacepvr.html#aa4440f5fd1256889bd3b3822002208b6">GpuDatatypes</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1_free_value_view.html#a8dfbe83db91fe5bfb1dbccbe8834cab8">dataType</a> () const </td></tr>
<tr class="memdesc:a8dfbe83db91fe5bfb1dbccbe8834cab8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the datatype of the value contained. "None" means unformatted data, in which case ArraySize represents the number of bytes <a href="#a8dfbe83db91fe5bfb1dbccbe8834cab8">More...</a><br/></td></tr>
<tr class="separator:a8dfbe83db91fe5bfb1dbccbe8834cab8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ac935ba500cc7f87622768e702924ff"><td class="memTemplParams" colspan="2">template&lt;typename Type_ &gt; </td></tr>
<tr class="memitem:a2ac935ba500cc7f87622768e702924ff"><td class="memTemplItemLeft" align="right" valign="top">Type_ &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classpvr_1_1_free_value_view.html#a2ac935ba500cc7f87622768e702924ff">interpretValueAs</a> (uint32_t entryIndex=0)</td></tr>
<tr class="memdesc:a2ac935ba500cc7f87622768e702924ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interpret the value as (an array of) a specified type and retrieve the item at a specific position. <a href="#a2ac935ba500cc7f87622768e702924ff">More...</a><br/></td></tr>
<tr class="separator:a2ac935ba500cc7f87622768e702924ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a314aaf3913932dbc02c725a35498912d"><td class="memTemplParams" colspan="2">template&lt;typename Type_ &gt; </td></tr>
<tr class="memitem:a314aaf3913932dbc02c725a35498912d"><td class="memTemplItemLeft" align="right" valign="top">const Type_ &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classpvr_1_1_free_value_view.html#a314aaf3913932dbc02c725a35498912d">interpretValueAs</a> (uint32_t entryIndex=0) const </td></tr>
<tr class="memdesc:a314aaf3913932dbc02c725a35498912d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interpret the value as (an array of) a specified type and retrieve the item at a specific position. <a href="#a314aaf3913932dbc02c725a35498912d">More...</a><br/></td></tr>
<tr class="separator:a314aaf3913932dbc02c725a35498912d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf69b24f29827d5adc8793fba1fa7bb3"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1_free_value_view.html#acf69b24f29827d5adc8793fba1fa7bb3">isDataCompatible</a> (const <a class="el" href="classpvr_1_1_free_value_view.html">FreeValueView</a> &amp;rhs) const </td></tr>
<tr class="memdesc:acf69b24f29827d5adc8793fba1fa7bb3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if two free values only differ in value (i.e. they are of the same type and elements). <a href="#acf69b24f29827d5adc8793fba1fa7bb3">More...</a><br/></td></tr>
<tr class="separator:acf69b24f29827d5adc8793fba1fa7bb3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f1dd506853b601db4f648a8e006e3f4"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structpvr_1_1_typed_mem.html">TypedMem</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpvr_1_1_typed_mem.html#a2f1dd506853b601db4f648a8e006e3f4">operator=</a> (const <a class="el" href="structpvr_1_1_typed_mem.html">TypedMem</a> &amp;rhs) const </td></tr>
<tr class="memdesc:a2f1dd506853b601db4f648a8e006e3f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy assignment from another <a class="el" href="structpvr_1_1_typed_mem.html" title="Represents Free Value View that is backed by a (usually small) dynamically allocated block...">TypedMem</a>. <a href="#a2f1dd506853b601db4f648a8e006e3f4">More...</a><br/></td></tr>
<tr class="separator:a2f1dd506853b601db4f648a8e006e3f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9fd19dade0d850c42faf9baec57cb716"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1_free_value_view.html#a9fd19dade0d850c42faf9baec57cb716">raw</a> (uint32_t arrayIndex)</td></tr>
<tr class="memdesc:a9fd19dade0d850c42faf9baec57cb716"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a pointer to the raw data value at the specified index. <a href="#a9fd19dade0d850c42faf9baec57cb716">More...</a><br/></td></tr>
<tr class="separator:a9fd19dade0d850c42faf9baec57cb716"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae63b4e2d052ceec5e75c44ff85afd100"><td class="memItemLeft" align="right" valign="top">const void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1_free_value_view.html#ae63b4e2d052ceec5e75c44ff85afd100">raw</a> (uint32_t arrayIndex) const </td></tr>
<tr class="memdesc:ae63b4e2d052ceec5e75c44ff85afd100"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a pointer to the raw data value at the specified index. <a href="#ae63b4e2d052ceec5e75c44ff85afd100">More...</a><br/></td></tr>
<tr class="separator:ae63b4e2d052ceec5e75c44ff85afd100"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21d779d44a8d844527384fe31ac9108c"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1_free_value_view.html#a21d779d44a8d844527384fe31ac9108c">raw</a> ()</td></tr>
<tr class="memdesc:a21d779d44a8d844527384fe31ac9108c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a pointer to the raw data value. <a href="#a21d779d44a8d844527384fe31ac9108c">More...</a><br/></td></tr>
<tr class="separator:a21d779d44a8d844527384fe31ac9108c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab442095838fcca7064e0d25afa23eacb"><td class="memItemLeft" align="right" valign="top">const void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1_free_value_view.html#ab442095838fcca7064e0d25afa23eacb">raw</a> () const </td></tr>
<tr class="memdesc:ab442095838fcca7064e0d25afa23eacb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a pointer to the raw data value. <a href="#ab442095838fcca7064e0d25afa23eacb">More...</a><br/></td></tr>
<tr class="separator:ab442095838fcca7064e0d25afa23eacb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01b2c977555afc3a5dea1fd3c33f0370"><td class="memTemplParams" colspan="2">template&lt;typename Type_ &gt; </td></tr>
<tr class="memitem:a01b2c977555afc3a5dea1fd3c33f0370"><td class="memTemplItemLeft" align="right" valign="top">Type_ *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classpvr_1_1_free_value_view.html#a01b2c977555afc3a5dea1fd3c33f0370">rawAs</a> ()</td></tr>
<tr class="memdesc:a01b2c977555afc3a5dea1fd3c33f0370"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a pointer to the raw data value as a specified type <a href="#a01b2c977555afc3a5dea1fd3c33f0370">More...</a><br/></td></tr>
<tr class="separator:a01b2c977555afc3a5dea1fd3c33f0370"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a595a7d73210dd5b9d9e093066e5314ea"><td class="memTemplParams" colspan="2">template&lt;typename Type_ &gt; </td></tr>
<tr class="memitem:a595a7d73210dd5b9d9e093066e5314ea"><td class="memTemplItemLeft" align="right" valign="top">const Type_ *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classpvr_1_1_free_value_view.html#a595a7d73210dd5b9d9e093066e5314ea">rawAs</a> () const </td></tr>
<tr class="memdesc:a595a7d73210dd5b9d9e093066e5314ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a pointer to the data value as a specified type <a href="#a595a7d73210dd5b9d9e093066e5314ea">More...</a><br/></td></tr>
<tr class="separator:a595a7d73210dd5b9d9e093066e5314ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0aa930c8331665e9069d391d6a22f05f"><td class="memItemLeft" align="right" valign="top">unsigned char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1_free_value_view.html#a0aa930c8331665e9069d391d6a22f05f">rawChars</a> ()</td></tr>
<tr class="memdesc:a0aa930c8331665e9069d391d6a22f05f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a pointer to the data value as (an array of) unsigned chars <a href="#a0aa930c8331665e9069d391d6a22f05f">More...</a><br/></td></tr>
<tr class="separator:a0aa930c8331665e9069d391d6a22f05f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82f492b50d88d6ee8ce8717b78d75854"><td class="memItemLeft" align="right" valign="top">const unsigned char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1_free_value_view.html#a82f492b50d88d6ee8ce8717b78d75854">rawChars</a> () const </td></tr>
<tr class="memdesc:a82f492b50d88d6ee8ce8717b78d75854"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a pointer to the data value as (an array of) unsigned chars <a href="#a82f492b50d88d6ee8ce8717b78d75854">More...</a><br/></td></tr>
<tr class="separator:a82f492b50d88d6ee8ce8717b78d75854"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84c09ef6be023a2d5a33d7a81cb58f79"><td class="memItemLeft" align="right" valign="top">float *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1_free_value_view.html#a84c09ef6be023a2d5a33d7a81cb58f79">rawFloats</a> ()</td></tr>
<tr class="memdesc:a84c09ef6be023a2d5a33d7a81cb58f79"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a pointer to the data value as (an array of) 32 bit floating point numbers <a href="#a84c09ef6be023a2d5a33d7a81cb58f79">More...</a><br/></td></tr>
<tr class="separator:a84c09ef6be023a2d5a33d7a81cb58f79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5e897ced6d892bd9aa968f8a1d8acf9"><td class="memItemLeft" align="right" valign="top">const float *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1_free_value_view.html#af5e897ced6d892bd9aa968f8a1d8acf9">rawFloats</a> () const </td></tr>
<tr class="memdesc:af5e897ced6d892bd9aa968f8a1d8acf9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a pointer to the data value as (an array of) 32 bit floating point numbers <a href="#af5e897ced6d892bd9aa968f8a1d8acf9">More...</a><br/></td></tr>
<tr class="separator:af5e897ced6d892bd9aa968f8a1d8acf9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add1e448ef96059927c9de1c2406be8ec"><td class="memItemLeft" align="right" valign="top">int32_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1_free_value_view.html#add1e448ef96059927c9de1c2406be8ec">rawInts</a> ()</td></tr>
<tr class="memdesc:add1e448ef96059927c9de1c2406be8ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a pointer to the data value as (an array of) 32 bit integers <a href="#add1e448ef96059927c9de1c2406be8ec">More...</a><br/></td></tr>
<tr class="separator:add1e448ef96059927c9de1c2406be8ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50e7ba68c9c5c80645e5190d0e7dc8ed"><td class="memItemLeft" align="right" valign="top">const int32_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1_free_value_view.html#a50e7ba68c9c5c80645e5190d0e7dc8ed">rawInts</a> () const </td></tr>
<tr class="memdesc:a50e7ba68c9c5c80645e5190d0e7dc8ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a pointer to the data value as (an array of) 32 bit integers <a href="#a50e7ba68c9c5c80645e5190d0e7dc8ed">More...</a><br/></td></tr>
<tr class="separator:a50e7ba68c9c5c80645e5190d0e7dc8ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a740197b14b16ac33defd36d7a91c2b1d"><td class="memTemplParams" colspan="2">template&lt;typename Type_ &gt; </td></tr>
<tr class="memitem:a740197b14b16ac33defd36d7a91c2b1d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structpvr_1_1_typed_mem.html#a740197b14b16ac33defd36d7a91c2b1d">setValue</a> (const Type_ &amp;rawvalue)</td></tr>
<tr class="memdesc:a740197b14b16ac33defd36d7a91c2b1d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set this object to contain the specified item, allocating as needed. Sets the type to the type of rawvalue, and array elements to 1. <a href="#a740197b14b16ac33defd36d7a91c2b1d">More...</a><br/></td></tr>
<tr class="separator:a740197b14b16ac33defd36d7a91c2b1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1a72eb4cfb65ed6664f2752f53214f2"><td class="memTemplParams" colspan="2">template&lt;typename Type_ &gt; </td></tr>
<tr class="memitem:ab1a72eb4cfb65ed6664f2752f53214f2"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structpvr_1_1_typed_mem.html#ab1a72eb4cfb65ed6664f2752f53214f2">setValue</a> (const Type_ &amp;rawvalue, uint32_t arrayIndex)</td></tr>
<tr class="memdesc:ab1a72eb4cfb65ed6664f2752f53214f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">**Before calling this function, allocate the required number of items of the type you need, as this function does NOT allocate** Sets this object to contain the specified item at the specified index. Does not allocate, so if the type is wrong or the array index is wrong, the behaviour is undefined. <a href="#ab1a72eb4cfb65ed6664f2752f53214f2">More...</a><br/></td></tr>
<tr class="separator:ab1a72eb4cfb65ed6664f2752f53214f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd476fe07986ba59c9a343012db55cb0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpvr_1_1_typed_mem.html#acd476fe07986ba59c9a343012db55cb0">setValue</a> (const char *c_string_value)</td></tr>
<tr class="memdesc:acd476fe07986ba59c9a343012db55cb0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the value from a null-terminated c-style string. Allocates as necessary. <a href="#acd476fe07986ba59c9a343012db55cb0">More...</a><br/></td></tr>
<tr class="separator:acd476fe07986ba59c9a343012db55cb0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a386d8140def9e8d54c5f602b4ac72ad8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpvr_1_1_typed_mem.html#a386d8140def9e8d54c5f602b4ac72ad8">setValue</a> (const std::string &amp;rawvalue)</td></tr>
<tr class="memdesc:a386d8140def9e8d54c5f602b4ac72ad8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the value from a c++ string. Allocates as necessary. <a href="#a386d8140def9e8d54c5f602b4ac72ad8">More...</a><br/></td></tr>
<tr class="separator:a386d8140def9e8d54c5f602b4ac72ad8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9914a50101c960c51aecb63503e69a11"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpvr_1_1_typed_mem.html#a9914a50101c960c51aecb63503e69a11">shrink</a> (uint32_t <a class="el" href="classpvr_1_1_free_value_view.html#a8af557adeae312867dd3e24edd39b176">arrayElements</a>)</td></tr>
<tr class="memdesc:a9914a50101c960c51aecb63503e69a11"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set this TypedMen to the specified number of items, reallocating as needed. Use this method instead of <a class="el" href="structpvr_1_1_typed_mem.html#abcb6de4cde92ff94863334b5a95c8ece" title="Empty this object. Does NOT free the memory.">clear()</a> if you actually need to physically free the memory. <a href="#a9914a50101c960c51aecb63503e69a11">More...</a><br/></td></tr>
<tr class="separator:a9914a50101c960c51aecb63503e69a11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4aa0fc525fa1c1099193969806ea69a2"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpvr_1_1_typed_mem.html#a4aa0fc525fa1c1099193969806ea69a2">totalSize</a> () const </td></tr>
<tr class="memdesc:a4aa0fc525fa1c1099193969806ea69a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the size of this value in bytes. <a href="#a4aa0fc525fa1c1099193969806ea69a2">More...</a><br/></td></tr>
<tr class="separator:a4aa0fc525fa1c1099193969806ea69a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:a89658aa74c776988d645834907983352"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a89658aa74c776988d645834907983352"></a>
uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1_free_value_view.html#a89658aa74c776988d645834907983352">arrayElements_</a></td></tr>
<tr class="memdesc:a89658aa74c776988d645834907983352"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of array elements. <br/></td></tr>
<tr class="separator:a89658aa74c776988d645834907983352"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7cb6084a7d5c18a295a3bd76635db43d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7cb6084a7d5c18a295a3bd76635db43d"></a>
<a class="el" href="namespacepvr.html#aa4440f5fd1256889bd3b3822002208b6">GpuDatatypes</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1_free_value_view.html#a7cb6084a7d5c18a295a3bd76635db43d">dataType_</a></td></tr>
<tr class="memdesc:a7cb6084a7d5c18a295a3bd76635db43d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Semantic data type. <br/></td></tr>
<tr class="separator:a7cb6084a7d5c18a295a3bd76635db43d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab41e2a359c462bfa3de81ab9da59a021"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab41e2a359c462bfa3de81ab9da59a021"></a>
unsigned char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1_free_value_view.html#ab41e2a359c462bfa3de81ab9da59a021">value_</a></td></tr>
<tr class="memdesc:ab41e2a359c462bfa3de81ab9da59a021"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dynamically allocated, data is carried here. <br/></td></tr>
<tr class="separator:ab41e2a359c462bfa3de81ab9da59a021"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Represents Free Value View that is backed by a (usually small) dynamically allocated block.</p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a97af394a81c5b663d9bdfd9be7cdef95"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">pvr::TypedMem::TypedMem </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructor.</p>

</div>
</div>
<a class="anchor" id="aa46cda4a003b402daab223dbc9f7bf1a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">pvr::TypedMem::~TypedMem </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destructor. Frees any allocated memory.</p>

</div>
</div>
<a class="anchor" id="a86eb61f333d8370d7b909d6906f251b7"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">pvr::TypedMem::TypedMem </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structpvr_1_1_typed_mem.html">TypedMem</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy assignment from another <a class="el" href="structpvr_1_1_typed_mem.html" title="Represents Free Value View that is backed by a (usually small) dynamically allocated block...">TypedMem</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td>The object to copy from</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This object</dd></dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a3b5134af879d8ef8450d03a1a4a0387c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pvr::TypedMem::allocate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacepvr.html#aa4440f5fd1256889bd3b3822002208b6">GpuDatatypes</a>&#160;</td>
          <td class="paramname"><em>dataType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>arrayElements</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Allocate the <a class="el" href="structpvr_1_1_typed_mem.html" title="Represents Free Value View that is backed by a (usually small) dynamically allocated block...">TypedMem</a> to contain the specified type and number of items. Grows only, does not shrink memory.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dataType</td><td>The type of the data. Use "none" for raw bytes</td></tr>
    <tr><td class="paramname">arrayElements</td><td>The number of array elements.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a8af557adeae312867dd3e24edd39b176"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t pvr::FreeValueView::arrayElements </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Size of the data contained. For unformatted data (Datatype==None) this is the total bytes contained.</p>
<dl class="section return"><dt>Returns</dt><dd>The size of data contained.</dd></dl>

</div>
</div>
<a class="anchor" id="a8ae6d323c9224b5cd4322e8630e5fbbf"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pvr::TypedMem::assign </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structpvr_1_1_typed_mem.html">TypedMem</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy constructor from another <a class="el" href="structpvr_1_1_typed_mem.html" title="Represents Free Value View that is backed by a (usually small) dynamically allocated block...">TypedMem</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td>The object to copy from</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="abcb6de4cde92ff94863334b5a95c8ece"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pvr::TypedMem::clear </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Empty this object. Does NOT free the memory.</p>

</div>
</div>
<a class="anchor" id="a0aa9115211adc67014c867a69b12c87e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t pvr::FreeValueView::dataSize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Size of the data contained.</p>
<dl class="section return"><dt>Returns</dt><dd>The size of data contained.</dd></dl>

</div>
</div>
<a class="anchor" id="a8dfbe83db91fe5bfb1dbccbe8834cab8"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacepvr.html#aa4440f5fd1256889bd3b3822002208b6">GpuDatatypes</a> pvr::FreeValueView::dataType </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the datatype of the value contained. "None" means unformatted data, in which case ArraySize represents the number of bytes</p>
<dl class="section return"><dt>Returns</dt><dd>The datatype of this value.</dd></dl>

</div>
</div>
<a class="anchor" id="a2ac935ba500cc7f87622768e702924ff"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type_ &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Type_&amp; pvr::FreeValueView::interpretValueAs </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>entryIndex</em> = <code>0</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Interpret the value as (an array of) a specified type and retrieve the item at a specific position.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Type_</td><td>The type as which the value is interpreted</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">entryIndex</td><td>If an array, which item to retrieve (default 0)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A value of type <em>Type_</em>  at index <em>entryIndex</em> </dd></dl>

</div>
</div>
<a class="anchor" id="a314aaf3913932dbc02c725a35498912d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type_ &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const Type_&amp; pvr::FreeValueView::interpretValueAs </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>entryIndex</em> = <code>0</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Interpret the value as (an array of) a specified type and retrieve the item at a specific position.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Type_</td><td>The type as which the value is interpreted</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">entryIndex</td><td>If an array, which item to retrieve (default 0)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A value of type <em>Type_</em>  at index <em>entryIndex</em> </dd></dl>

</div>
</div>
<a class="anchor" id="acf69b24f29827d5adc8793fba1fa7bb3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool pvr::FreeValueView::isDataCompatible </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpvr_1_1_free_value_view.html">FreeValueView</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if two free values only differ in value (i.e. they are of the same type and elements).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td>The value against which to compare</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if datatype and arrayelements are the same between this and rhs, otherwise false.</dd></dl>

</div>
</div>
<a class="anchor" id="a2f1dd506853b601db4f648a8e006e3f4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structpvr_1_1_typed_mem.html">TypedMem</a>&amp; pvr::TypedMem::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structpvr_1_1_typed_mem.html">TypedMem</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy assignment from another <a class="el" href="structpvr_1_1_typed_mem.html" title="Represents Free Value View that is backed by a (usually small) dynamically allocated block...">TypedMem</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td>The object to copy from</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This object</dd></dl>

</div>
</div>
<a class="anchor" id="a9fd19dade0d850c42faf9baec57cb716"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void* pvr::FreeValueView::raw </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>arrayIndex</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a pointer to the raw data value at the specified index.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">arrayIndex</td><td>The array index of which to take the pointer</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to the raw value.</dd></dl>

</div>
</div>
<a class="anchor" id="ae63b4e2d052ceec5e75c44ff85afd100"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const void* pvr::FreeValueView::raw </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>arrayIndex</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a pointer to the raw data value at the specified index.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">arrayIndex</td><td>The array index of which to take the pointer</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to the raw value.</dd></dl>

</div>
</div>
<a class="anchor" id="a21d779d44a8d844527384fe31ac9108c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void* pvr::FreeValueView::raw </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a pointer to the raw data value.</p>
<dl class="section return"><dt>Returns</dt><dd>Pointer to the raw value.</dd></dl>

</div>
</div>
<a class="anchor" id="ab442095838fcca7064e0d25afa23eacb"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const void* pvr::FreeValueView::raw </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a pointer to the raw data value.</p>
<dl class="section return"><dt>Returns</dt><dd>Pointer to the raw value.</dd></dl>

</div>
</div>
<a class="anchor" id="a01b2c977555afc3a5dea1fd3c33f0370"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type_ &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Type_* pvr::FreeValueView::rawAs </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a pointer to the raw data value as a specified type</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Type_</td><td>The type as which the data are interpreted</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to the raw value.</dd></dl>

</div>
</div>
<a class="anchor" id="a595a7d73210dd5b9d9e093066e5314ea"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type_ &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const Type_* pvr::FreeValueView::rawAs </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a pointer to the data value as a specified type</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Type_</td><td>The type as which the data are interpreted</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to the raw value.</dd></dl>

</div>
</div>
<a class="anchor" id="a0aa930c8331665e9069d391d6a22f05f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned char* pvr::FreeValueView::rawChars </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a pointer to the data value as (an array of) unsigned chars</p>
<dl class="section return"><dt>Returns</dt><dd>Pointer to the data as unsigned char*.</dd></dl>

</div>
</div>
<a class="anchor" id="a82f492b50d88d6ee8ce8717b78d75854"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const unsigned char* pvr::FreeValueView::rawChars </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a pointer to the data value as (an array of) unsigned chars</p>
<dl class="section return"><dt>Returns</dt><dd>Pointer to the data as unsigned char*.</dd></dl>

</div>
</div>
<a class="anchor" id="a84c09ef6be023a2d5a33d7a81cb58f79"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float* pvr::FreeValueView::rawFloats </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a pointer to the data value as (an array of) 32 bit floating point numbers</p>
<dl class="section return"><dt>Returns</dt><dd>Pointer to the data as float*.</dd></dl>

</div>
</div>
<a class="anchor" id="af5e897ced6d892bd9aa968f8a1d8acf9"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const float* pvr::FreeValueView::rawFloats </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a pointer to the data value as (an array of) 32 bit floating point numbers</p>
<dl class="section return"><dt>Returns</dt><dd>Pointer to the data as float*.</dd></dl>

</div>
</div>
<a class="anchor" id="add1e448ef96059927c9de1c2406be8ec"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int32_t* pvr::FreeValueView::rawInts </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a pointer to the data value as (an array of) 32 bit integers</p>
<dl class="section return"><dt>Returns</dt><dd>Pointer to the data as int*.</dd></dl>

</div>
</div>
<a class="anchor" id="a50e7ba68c9c5c80645e5190d0e7dc8ed"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const int32_t* pvr::FreeValueView::rawInts </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a pointer to the data value as (an array of) 32 bit integers</p>
<dl class="section return"><dt>Returns</dt><dd>Pointer to the data as int*.</dd></dl>

</div>
</div>
<a class="anchor" id="a740197b14b16ac33defd36d7a91c2b1d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type_ &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pvr::TypedMem::setValue </td>
          <td>(</td>
          <td class="paramtype">const Type_ &amp;&#160;</td>
          <td class="paramname"><em>rawvalue</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set this object to contain the specified item, allocating as needed. Sets the type to the type of rawvalue, and array elements to 1.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rawvalue</td><td>The value to set</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ab1a72eb4cfb65ed6664f2752f53214f2"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type_ &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pvr::TypedMem::setValue </td>
          <td>(</td>
          <td class="paramtype">const Type_ &amp;&#160;</td>
          <td class="paramname"><em>rawvalue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>arrayIndex</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>**Before calling this function, allocate the required number of items of the type you need, as this function does NOT allocate** Sets this object to contain the specified item at the specified index. Does not allocate, so if the type is wrong or the array index is wrong, the behaviour is undefined.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rawvalue</td><td>The value to set</td></tr>
    <tr><td class="paramname">arrayIndex</td><td>The index where to set the value</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="acd476fe07986ba59c9a343012db55cb0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pvr::TypedMem::setValue </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>c_string_value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the value from a null-terminated c-style string. Allocates as necessary.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">c_string_value</td><td>A null-terminated c-string</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a386d8140def9e8d54c5f602b4ac72ad8"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pvr::TypedMem::setValue </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>rawvalue</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the value from a c++ string. Allocates as necessary.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rawvalue</td><td>A c++ string</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a9914a50101c960c51aecb63503e69a11"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pvr::TypedMem::shrink </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>arrayElements</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set this TypedMen to the specified number of items, reallocating as needed. Use this method instead of <a class="el" href="structpvr_1_1_typed_mem.html#abcb6de4cde92ff94863334b5a95c8ece" title="Empty this object. Does NOT free the memory.">clear()</a> if you actually need to physically free the memory.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">arrayElements</td><td>Number of elemets</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a4aa0fc525fa1c1099193969806ea69a2"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t pvr::TypedMem::totalSize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the size of this value in bytes.</p>
<dl class="section return"><dt>Returns</dt><dd>The size of this value in bytes</dd></dl>

</div>
</div>
<hr/>The documentation for this struct was generated from the following file:<ul>
<li>/usr/buildxl/buildroot/sdk/branch/SDK/framework/PVRCore/DataStructures/<a class="el" href="_free_value_8h_source.html">FreeValue.h</a></li>
</ul>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.4-->
<!-- start footer part (NON TREEVIEW ONLY!!) -->
<!--BEGIN GENERATE_TREEVIEW-->
<div id="FooterMainContainer">
	<div id="FooterContainer">
		<div class="footerlogo">
			<a href="http://www.imgtec.com" target="_blank"><img src="img-footer-logo-grey.png" width="100%" height="100%" border="none" /></a>
		</div>
		<div class="copyright"><p>&copy; Imagination Technologies Limited<br> All rights reserved</p></div>
	</div>
</div>
</body>
</html>
