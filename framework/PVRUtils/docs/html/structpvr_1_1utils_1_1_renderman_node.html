<!-- HTML header for doxygen 1.8.4-->
<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="generator" content="Doxygen 1.8.6"/>
<title>PVRUtils: pvr::utils::RendermanNode Struct Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="IMGdoxygen.css" rel="stylesheet" type="text/css"/>
<link rel="shortcut icon" href="http://www.imgtec.com/images/img.ico">
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
  <div class="headercontent">
    <div class="PVRlogo">
      <a href="http://www.powervrinsider.com" target="_blank"><img src="PVRlogo.png" width="40%" height="40%"  border="none" /></a>
    </div>
    <a class="SiteTitle"><span id="projectname">PVRUtils</span> Documentation</a>
   <tbody>
  </div>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="inherits.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Macros</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacepvr.html">pvr</a></li><li class="navelem"><a class="el" href="namespacepvr_1_1utils.html">utils</a></li><li class="navelem"><a class="el" href="structpvr_1_1utils_1_1_renderman_node.html">RendermanNode</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="structpvr_1_1utils_1_1_renderman_node-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">pvr::utils::RendermanNode Struct Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Part of <a class="el" href="structpvr_1_1utils_1_1_renderman_structure.html" title="Internal class containing the Render Manager tree structure representation of a scene">RendermanStructure</a>. This class matches everything together: A pipelineMaterial, with a RendermanMeshSubpass, to render. Unique per rendering node AND mesh bone batch combination. NOTE: if bone batching is used, then multiple nodes will be generated per meshnode. Contains a reference to the mesh, the material, and also contains the dynamic offsets required to render with it. Loop through those to render.  
 <a href="structpvr_1_1utils_1_1_renderman_node.html#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a13f007922c8a1475ce5cd805806287f9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpvr_1_1utils_1_1_renderman_node.html#a13f007922c8a1475ce5cd805806287f9">createAutomaticSemantics</a> ()</td></tr>
<tr class="memdesc:a13f007922c8a1475ce5cd805806287f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates a list of all the semantics that this node's pipeline requires, that are defined per-node (e.g. MV/MVP matrices etc). Then, searches the connected asset node (model, mesh, material etc.) for these semantics, and creates connections between them so that when updateAutomaticSemantics is called, the updated values are updated in the semantics so that they can be read (with setUniformPtr, or updating buffers etc.).  <a href="#a13f007922c8a1475ce5cd805806287f9">More...</a><br/></td></tr>
<tr class="separator:a13f007922c8a1475ce5cd805806287f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab137b5e249b778963ac93730a9905c09"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpvr_1_1utils_1_1_renderman_node.html#ab137b5e249b778963ac93730a9905c09">getDynamicOffset</a> (uint32_t setId, uint32_t swapchainId, uint32_t <a class="el" href="structpvr_1_1utils_1_1_renderman_node.html#a1442f4c0fb89fd2f569217b415bfdcdc">dynamicClientId</a>) const </td></tr>
<tr class="memdesc:ab137b5e249b778963ac93730a9905c09"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the list of dynamic offsets in use. <a href="#ab137b5e249b778963ac93730a9905c09">More...</a><br/></td></tr>
<tr class="separator:ab137b5e249b778963ac93730a9905c09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d6e51048f2dfab5baa792ee1c01d188"><td class="memItemLeft" align="right" valign="top">const DynamicArray&lt; uint32_t &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpvr_1_1utils_1_1_renderman_node.html#a6d6e51048f2dfab5baa792ee1c01d188">getDynamicOffsets</a> (uint32_t setId, uint32_t swapchainId)</td></tr>
<tr class="memdesc:a6d6e51048f2dfab5baa792ee1c01d188"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the list of dynamic offsets in use. <a href="#a6d6e51048f2dfab5baa792ee1c01d188">More...</a><br/></td></tr>
<tr class="separator:a6d6e51048f2dfab5baa792ee1c01d188"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a209a83d3e78362d39577ef749eb72574"><td class="memItemLeft" align="right" valign="top">const uint32_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpvr_1_1utils_1_1_renderman_node.html#a209a83d3e78362d39577ef749eb72574">getDynamicOffsetsPtr</a> (uint32_t setId, uint32_t swapchainId) const </td></tr>
<tr class="memdesc:a209a83d3e78362d39577ef749eb72574"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves a pointer to the list of dynamic offsets in use. <a href="#a209a83d3e78362d39577ef749eb72574">More...</a><br/></td></tr>
<tr class="separator:a209a83d3e78362d39577ef749eb72574"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:accc81316acab998a488ebdb340ef7b0c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpvr_1_1utils_1_1_renderman_node.html#accc81316acab998a488ebdb340ef7b0c">getNodeSemantic</a> (const StringHash &amp;semantic, TypedMem &amp;memory) const </td></tr>
<tr class="memdesc:accc81316acab998a488ebdb340ef7b0c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a reference of the semantic of this node. The value is saved in a provided memory object.  <a href="#accc81316acab998a488ebdb340ef7b0c">More...</a><br/></td></tr>
<tr class="separator:accc81316acab998a488ebdb340ef7b0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e495098d61201bb016b1bdcb45ce639"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacepvr_1_1utils.html#a52ce711be6305e9237b2513013656b90">NodeSemanticSetter</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpvr_1_1utils_1_1_renderman_node.html#a6e495098d61201bb016b1bdcb45ce639">getNodeSemanticSetter</a> (const StringHash &amp;semantic) const </td></tr>
<tr class="memdesc:a6e495098d61201bb016b1bdcb45ce639"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the function object (NodeSemanticSetter) that will be used for a specific semantic <a href="#a6e495098d61201bb016b1bdcb45ce639">More...</a><br/></td></tr>
<tr class="separator:a6e495098d61201bb016b1bdcb45ce639"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb72d4db1f95fb70eccfbd836f3e7cf1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpvr_1_1utils_1_1_renderman_node.html#adb72d4db1f95fb70eccfbd836f3e7cf1">recordRenderingCommands</a> (pvrvk::CommandBufferBase cbuff, uint16_t swapIdx, bool recordBindPipeline=true, bool *recordBindDescriptorSets=nullptr, bool recordBindVboIbo=true, bool recordDrawCalls=true)</td></tr>
<tr class="memdesc:adb72d4db1f95fb70eccfbd836f3e7cf1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the commands necessary to render this node (bind pipeline, descriptor sets, draw commands etc.) Assumes correctly begun render passes, subpasses etc. All commands generated can be enabled/disabled in order to allow custom rendering. <a href="#adb72d4db1f95fb70eccfbd836f3e7cf1">More...</a><br/></td></tr>
<tr class="separator:adb72d4db1f95fb70eccfbd836f3e7cf1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7b85b909e761f1e9169d53397119264"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structpvr_1_1utils_1_1_renderman_mesh.html">RendermanMesh</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpvr_1_1utils_1_1_renderman_node.html#ad7b85b909e761f1e9169d53397119264">toRendermanMesh</a> ()</td></tr>
<tr class="memdesc:ad7b85b909e761f1e9169d53397119264"><td class="mdescLeft">&#160;</td><td class="mdescRight">Navigate(in the Rendering structure) to the <a class="el" href="structpvr_1_1utils_1_1_renderman_mesh.html" title="Part of RendermanStructure. This class is used to store VBOs/IBOs. Unique per mesh RendermanNodes ins...">RendermanMesh</a> object that is used by this node <a href="#ad7b85b909e761f1e9169d53397119264">More...</a><br/></td></tr>
<tr class="separator:ad7b85b909e761f1e9169d53397119264"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9642c9b72882f936e0e924d9a9365526"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structpvr_1_1utils_1_1_renderman_mesh.html">RendermanMesh</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpvr_1_1utils_1_1_renderman_node.html#a9642c9b72882f936e0e924d9a9365526">toRendermanMesh</a> () const </td></tr>
<tr class="memdesc:a9642c9b72882f936e0e924d9a9365526"><td class="mdescLeft">&#160;</td><td class="mdescRight">Navigate(in the Rendering structure) to the <a class="el" href="structpvr_1_1utils_1_1_renderman_mesh.html" title="Part of RendermanStructure. This class is used to store VBOs/IBOs. Unique per mesh RendermanNodes ins...">RendermanMesh</a> object that is used by this node <a href="#a9642c9b72882f936e0e924d9a9365526">More...</a><br/></td></tr>
<tr class="separator:a9642c9b72882f936e0e924d9a9365526"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a942f2a727db5f46077ed7e9f310e1c9e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structpvr_1_1utils_1_1_renderman_pipeline.html">RendermanPipeline</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpvr_1_1utils_1_1_renderman_node.html#a942f2a727db5f46077ed7e9f310e1c9e">toRendermanPipeline</a> ()</td></tr>
<tr class="memdesc:a942f2a727db5f46077ed7e9f310e1c9e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Navigate(in the Rendering structure) to the <a class="el" href="structpvr_1_1utils_1_1_renderman_pipeline.html" title="Part of RendermanStructure. This class is a cooked EffectPipeline, exactly mirroring the PFX pipeline...">RendermanPipeline</a> object that is used by this node <a href="#a942f2a727db5f46077ed7e9f310e1c9e">More...</a><br/></td></tr>
<tr class="separator:a942f2a727db5f46077ed7e9f310e1c9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a824f1ded7c3edcdeb49ea9decf0b84d1"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structpvr_1_1utils_1_1_renderman_pipeline.html">RendermanPipeline</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpvr_1_1utils_1_1_renderman_node.html#a824f1ded7c3edcdeb49ea9decf0b84d1">toRendermanPipeline</a> () const </td></tr>
<tr class="memdesc:a824f1ded7c3edcdeb49ea9decf0b84d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Navigate(in the Rendering structure) to the <a class="el" href="structpvr_1_1utils_1_1_renderman_pipeline.html" title="Part of RendermanStructure. This class is a cooked EffectPipeline, exactly mirroring the PFX pipeline...">RendermanPipeline</a> object that is used by this node <a href="#a824f1ded7c3edcdeb49ea9decf0b84d1">More...</a><br/></td></tr>
<tr class="separator:a824f1ded7c3edcdeb49ea9decf0b84d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5b2eb7fe29cacb691a9aa32b9cab294"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpvr_1_1utils_1_1_renderman_node.html#aa5b2eb7fe29cacb691a9aa32b9cab294">updateAutomaticSemantics</a> (uint32_t swapidx)</td></tr>
<tr class="memdesc:aa5b2eb7fe29cacb691a9aa32b9cab294"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterates any per-node semantics, and updates their values to their automatic per-node values. In order for this function to work, createAutomaticSemantics needs to have been called before to create the connections of the automatic semantics. <a href="#aa5b2eb7fe29cacb691a9aa32b9cab294">More...</a><br/></td></tr>
<tr class="separator:aa5b2eb7fe29cacb691a9aa32b9cab294"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f7e5ccb5fb2032cfbaf05b5e2aed403"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpvr_1_1utils_1_1_renderman_node.html#a0f7e5ccb5fb2032cfbaf05b5e2aed403">updateNodeValueSemantic</a> (const StringHash &amp;semantic, const FreeValue &amp;value, uint32_t swapid)</td></tr>
<tr class="memdesc:a0f7e5ccb5fb2032cfbaf05b5e2aed403"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update the value of a semantic of this node <a href="#a0f7e5ccb5fb2032cfbaf05b5e2aed403">More...</a><br/></td></tr>
<tr class="separator:a0f7e5ccb5fb2032cfbaf05b5e2aed403"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:acd1be42ac9911ea0ade9bde7b7eb55ba"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="acd1be42ac9911ea0ade9bde7b7eb55ba"></a>
assets::NodeHandle&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpvr_1_1utils_1_1_renderman_node.html#acd1be42ac9911ea0ade9bde7b7eb55ba">assetNode</a></td></tr>
<tr class="memdesc:acd1be42ac9911ea0ade9bde7b7eb55ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reference to the PVRAssets Node this object refers to. <br/></td></tr>
<tr class="separator:acd1be42ac9911ea0ade9bde7b7eb55ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6329cb853ddf6be91487d3138d342c30"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6329cb853ddf6be91487d3138d342c30"></a>
uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpvr_1_1utils_1_1_renderman_node.html#a6329cb853ddf6be91487d3138d342c30">assetNodeId</a></td></tr>
<tr class="memdesc:a6329cb853ddf6be91487d3138d342c30"><td class="mdescLeft">&#160;</td><td class="mdescRight">The NodeID of the PVRAssets node. <br/></td></tr>
<tr class="separator:a6329cb853ddf6be91487d3138d342c30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a626b6514323b3d3474dc5b09abe870de"><td class="memItemLeft" align="right" valign="top">std::vector<br class="typebreak"/>
&lt; <a class="el" href="structpvr_1_1utils_1_1_automatic_node_buffer_entry_semantic.html">AutomaticNodeBufferEntrySemantic</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpvr_1_1utils_1_1_renderman_node.html#a626b6514323b3d3474dc5b09abe870de">automaticEntrySemantics</a></td></tr>
<tr class="separator:a626b6514323b3d3474dc5b09abe870de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ad0a2ecfcffbec848a0a368973579bf"><td class="memItemLeft" align="right" valign="top">std::vector<br class="typebreak"/>
&lt; <a class="el" href="structpvr_1_1utils_1_1_automatic_node_uniform_semantic.html">AutomaticNodeUniformSemantic</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpvr_1_1utils_1_1_renderman_node.html#a0ad0a2ecfcffbec848a0a368973579bf">automaticUniformSemantics</a></td></tr>
<tr class="separator:a0ad0a2ecfcffbec848a0a368973579bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afbe95cc70d9b040faf82a2a230ed7fdd"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afbe95cc70d9b040faf82a2a230ed7fdd"></a>
uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpvr_1_1utils_1_1_renderman_node.html#afbe95cc70d9b040faf82a2a230ed7fdd">batchId</a></td></tr>
<tr class="memdesc:afbe95cc70d9b040faf82a2a230ed7fdd"><td class="mdescLeft">&#160;</td><td class="mdescRight">The Bone Batch ID - if not using Bone Batching, always 0. <br/></td></tr>
<tr class="separator:afbe95cc70d9b040faf82a2a230ed7fdd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6fbb33a10182e1c500fdd25a55445f98"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6fbb33a10182e1c500fdd25a55445f98"></a>
DynamicArray<br class="typebreak"/>
&lt; <a class="el" href="structpvr_1_1utils_1_1_renderman_buffer_definition.html">RendermanBufferDefinition</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpvr_1_1utils_1_1_renderman_node.html#a6fbb33a10182e1c500fdd25a55445f98">dynamicBuffer</a> [4]</td></tr>
<tr class="memdesc:a6fbb33a10182e1c500fdd25a55445f98"><td class="mdescLeft">&#160;</td><td class="mdescRight">The Dynamic Buffers that this node is being contained in. Fixed index is pvrvk::DescriptorSet. <br/></td></tr>
<tr class="separator:a6fbb33a10182e1c500fdd25a55445f98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1442f4c0fb89fd2f569217b415bfdcdc"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1442f4c0fb89fd2f569217b415bfdcdc"></a>
DynamicArray&lt; uint32_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpvr_1_1utils_1_1_renderman_node.html#a1442f4c0fb89fd2f569217b415bfdcdc">dynamicClientId</a> [4]</td></tr>
<tr class="memdesc:a1442f4c0fb89fd2f569217b415bfdcdc"><td class="mdescLeft">&#160;</td><td class="mdescRight">The indexes of each dynamic slice that this node owns in its buffers, respectively. Fixed index is pvrvk::DescriptorSet. <br/></td></tr>
<tr class="separator:a1442f4c0fb89fd2f569217b415bfdcdc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a692adc822991d09e1724885c316597b0"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a692adc822991d09e1724885c316597b0"></a>
DynamicArray&lt; uint32_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpvr_1_1utils_1_1_renderman_node.html#a692adc822991d09e1724885c316597b0">dynamicOffset</a> [4][pvrvk::FrameworkCaps::MaxSwapChains]</td></tr>
<tr class="memdesc:a692adc822991d09e1724885c316597b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">The (pre-calculated) byte offsets of the dynamic slices that this node owns in its buffers, respectively. Fixed index is pvrvk::DescriptorSet. <br/></td></tr>
<tr class="separator:a692adc822991d09e1724885c316597b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc8ed241c43a739c315252d11180577d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="adc8ed241c43a739c315252d11180577d"></a>
DynamicArray&lt; uint32_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpvr_1_1utils_1_1_renderman_node.html#adc8ed241c43a739c315252d11180577d">dynamicSliceId</a> [4][pvrvk::FrameworkCaps::MaxSwapChains]</td></tr>
<tr class="memdesc:adc8ed241c43a739c315252d11180577d"><td class="mdescLeft">&#160;</td><td class="mdescRight">The (pre-calculated) byte offsets of the dynamic slices that this node owns in its buffers, respectively. Fixed index is pvrvk::DescriptorSet. <br/></td></tr>
<tr class="separator:adc8ed241c43a739c315252d11180577d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20df7e889b0cf5b7a1f20180688e58dc"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a20df7e889b0cf5b7a1f20180688e58dc"></a>
<a class="el" href="structpvr_1_1utils_1_1_renderman_material_subpass_pipeline.html">RendermanMaterialSubpassPipeline</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpvr_1_1utils_1_1_renderman_node.html#a20df7e889b0cf5b7a1f20180688e58dc">pipelineMaterial_</a></td></tr>
<tr class="memdesc:a20df7e889b0cf5b7a1f20180688e58dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">The parent PipelineMaterial. <br/></td></tr>
<tr class="separator:a20df7e889b0cf5b7a1f20180688e58dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1388780a857c3756ec6bc411023c1db"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad1388780a857c3756ec6bc411023c1db"></a>
<a class="el" href="structpvr_1_1utils_1_1_renderman_subpass_mesh.html">RendermanSubpassMesh</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpvr_1_1utils_1_1_renderman_node.html#ad1388780a857c3756ec6bc411023c1db">subpassMesh_</a></td></tr>
<tr class="memdesc:ad1388780a857c3756ec6bc411023c1db"><td class="mdescLeft">&#160;</td><td class="mdescRight">The parent SubpassMesh combination. <br/></td></tr>
<tr class="separator:ad1388780a857c3756ec6bc411023c1db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc00c162b35f5c7ea2576091371dc961"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abc00c162b35f5c7ea2576091371dc961"></a>
pvr::ContiguousMap&lt; StringHash, <br class="typebreak"/>
<a class="el" href="structpvr_1_1utils_1_1_uniform_semantic.html">UniformSemantic</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpvr_1_1utils_1_1_renderman_node.html#abc00c162b35f5c7ea2576091371dc961">uniformSemantics</a></td></tr>
<tr class="memdesc:abc00c162b35f5c7ea2576091371dc961"><td class="mdescLeft">&#160;</td><td class="mdescRight">Uniform semantics used by this node. <br/></td></tr>
<tr class="separator:abc00c162b35f5c7ea2576091371dc961"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Part of <a class="el" href="structpvr_1_1utils_1_1_renderman_structure.html" title="Internal class containing the Render Manager tree structure representation of a scene">RendermanStructure</a>. This class matches everything together: A pipelineMaterial, with a RendermanMeshSubpass, to render. Unique per rendering node AND mesh bone batch combination. NOTE: if bone batching is used, then multiple nodes will be generated per meshnode. Contains a reference to the mesh, the material, and also contains the dynamic offsets required to render with it. Loop through those to render. </p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a13f007922c8a1475ce5cd805806287f9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pvr::utils::RendermanNode::createAutomaticSemantics </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generates a list of all the semantics that this node's pipeline requires, that are defined per-node (e.g. MV/MVP matrices etc). Then, searches the connected asset node (model, mesh, material etc.) for these semantics, and creates connections between them so that when updateAutomaticSemantics is called, the updated values are updated in the semantics so that they can be read (with setUniformPtr, or updating buffers etc.). </p>

</div>
</div>
<a class="anchor" id="ab137b5e249b778963ac93730a9905c09"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t pvr::utils::RendermanNode::getDynamicOffset </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>setId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>swapchainId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>dynamicClientId</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieves the list of dynamic offsets in use.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">setId</td><td>The descriptor set identifier to find dynamic offsets for</td></tr>
    <tr><td class="paramname">swapchainId</td><td>The swapchain identifier to find dynamic offsets for</td></tr>
    <tr><td class="paramname">dynamicClientId</td><td>The dynamic client identifier to find dynamic offsets for</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The list of dynamic offsets in use by the specified descriptor set, swapchain and dynamic client id</dd></dl>

</div>
</div>
<a class="anchor" id="a6d6e51048f2dfab5baa792ee1c01d188"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const DynamicArray&lt;uint32_t&gt;&amp; pvr::utils::RendermanNode::getDynamicOffsets </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>setId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>swapchainId</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieves the list of dynamic offsets in use.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">setId</td><td>The descriptor set identifier to find dynamic offsets for</td></tr>
    <tr><td class="paramname">swapchainId</td><td>The swapchain identifier to find dynamic offsets for</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The list of dynamic offsets in use by the specified descriptor set and swapchain</dd></dl>

</div>
</div>
<a class="anchor" id="a209a83d3e78362d39577ef749eb72574"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const uint32_t* pvr::utils::RendermanNode::getDynamicOffsetsPtr </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>setId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>swapchainId</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieves a pointer to the list of dynamic offsets in use.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">setId</td><td>The descriptor set identifier to find dynamic offsets for</td></tr>
    <tr><td class="paramname">swapchainId</td><td>The swapchain identifier to find dynamic offsets for</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the list of dynamic offsets in use by the specified descriptor set and swapchain</dd></dl>

</div>
</div>
<a class="anchor" id="accc81316acab998a488ebdb340ef7b0c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool pvr::utils::RendermanNode::getNodeSemantic </td>
          <td>(</td>
          <td class="paramtype">const StringHash &amp;&#160;</td>
          <td class="paramname"><em>semantic</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TypedMem &amp;&#160;</td>
          <td class="paramname"><em>memory</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a reference of the semantic of this node. The value is saved in a provided memory object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">semantic</td><td>The semantic name to get the value of</td></tr>
    <tr><td class="paramname">memory</td><td>The semantic value is returned here</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Return true if found, otherwise false</dd></dl>

</div>
</div>
<a class="anchor" id="a6e495098d61201bb016b1bdcb45ce639"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacepvr_1_1utils.html#a52ce711be6305e9237b2513013656b90">NodeSemanticSetter</a> pvr::utils::RendermanNode::getNodeSemanticSetter </td>
          <td>(</td>
          <td class="paramtype">const StringHash &amp;&#160;</td>
          <td class="paramname"><em>semantic</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the function object (NodeSemanticSetter) that will be used for a specific semantic</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">semantic</td><td>A node-specific semantic name (WORLDMATRIX, BONECOUNT, BONEMATRIXARRAY0 etc.) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A NodeSemanticSetter function object that can be called to set this node semantic.</dd></dl>

</div>
</div>
<a class="anchor" id="adb72d4db1f95fb70eccfbd836f3e7cf1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pvr::utils::RendermanNode::recordRenderingCommands </td>
          <td>(</td>
          <td class="paramtype">pvrvk::CommandBufferBase&#160;</td>
          <td class="paramname"><em>cbuff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>swapIdx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>recordBindPipeline</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool *&#160;</td>
          <td class="paramname"><em>recordBindDescriptorSets</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>recordBindVboIbo</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>recordDrawCalls</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the commands necessary to render this node (bind pipeline, descriptor sets, draw commands etc.) Assumes correctly begun render passes, subpasses etc. All commands generated can be enabled/disabled in order to allow custom rendering.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cbuff</td><td>A command buffer to record the commands into</td></tr>
    <tr><td class="paramname">swapIdx</td><td>The current swap chain (framebuffer image) index to record commands for.</td></tr>
    <tr><td class="paramname">recordBindPipeline</td><td>If set to false, do not generate any the bind pipeline command (use to optimize nodes rendered with the same pipelines)</td></tr>
    <tr><td class="paramname">recordBindDescriptorSets</td><td>If set to false, do not generate the bind descriptor sets commands (use to optimize nodes rendered with the same sets)</td></tr>
    <tr><td class="paramname">recordBindVboIbo</td><td>If set to false, skip the generation of the bind vertex / index buffer commands (use to optimize nodes rendering the same mesh)</td></tr>
    <tr><td class="paramname">recordDrawCalls</td><td>If set to false, skip the generation of the draw calls.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ad7b85b909e761f1e9169d53397119264"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structpvr_1_1utils_1_1_renderman_mesh.html">RendermanMesh</a>&amp; pvr::utils::RendermanNode::toRendermanMesh </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Navigate(in the Rendering structure) to the <a class="el" href="structpvr_1_1utils_1_1_renderman_mesh.html" title="Part of RendermanStructure. This class is used to store VBOs/IBOs. Unique per mesh RendermanNodes ins...">RendermanMesh</a> object that is used by this node</p>
<dl class="section return"><dt>Returns</dt><dd>A reference to the mesh object that is used by this node</dd></dl>

</div>
</div>
<a class="anchor" id="a9642c9b72882f936e0e924d9a9365526"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structpvr_1_1utils_1_1_renderman_mesh.html">RendermanMesh</a>&amp; pvr::utils::RendermanNode::toRendermanMesh </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Navigate(in the Rendering structure) to the <a class="el" href="structpvr_1_1utils_1_1_renderman_mesh.html" title="Part of RendermanStructure. This class is used to store VBOs/IBOs. Unique per mesh RendermanNodes ins...">RendermanMesh</a> object that is used by this node</p>
<dl class="section return"><dt>Returns</dt><dd>A reference to the mesh object that is used by this node</dd></dl>

</div>
</div>
<a class="anchor" id="a942f2a727db5f46077ed7e9f310e1c9e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structpvr_1_1utils_1_1_renderman_pipeline.html">RendermanPipeline</a>&amp; pvr::utils::RendermanNode::toRendermanPipeline </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Navigate(in the Rendering structure) to the <a class="el" href="structpvr_1_1utils_1_1_renderman_pipeline.html" title="Part of RendermanStructure. This class is a cooked EffectPipeline, exactly mirroring the PFX pipeline...">RendermanPipeline</a> object that is used by this node</p>
<dl class="section return"><dt>Returns</dt><dd>A reference to the pipeline object that is used by this node</dd></dl>

</div>
</div>
<a class="anchor" id="a824f1ded7c3edcdeb49ea9decf0b84d1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structpvr_1_1utils_1_1_renderman_pipeline.html">RendermanPipeline</a>&amp; pvr::utils::RendermanNode::toRendermanPipeline </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Navigate(in the Rendering structure) to the <a class="el" href="structpvr_1_1utils_1_1_renderman_pipeline.html" title="Part of RendermanStructure. This class is a cooked EffectPipeline, exactly mirroring the PFX pipeline...">RendermanPipeline</a> object that is used by this node</p>
<dl class="section return"><dt>Returns</dt><dd>A reference to the pipeline object that is used by this node</dd></dl>

</div>
</div>
<a class="anchor" id="aa5b2eb7fe29cacb691a9aa32b9cab294"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pvr::utils::RendermanNode::updateAutomaticSemantics </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>swapidx</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Iterates any per-node semantics, and updates their values to their automatic per-node values. In order for this function to work, createAutomaticSemantics needs to have been called before to create the connections of the automatic semantics.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">swapidx</td><td>The current swapchain (framebuffer) image.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a0f7e5ccb5fb2032cfbaf05b5e2aed403"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool pvr::utils::RendermanNode::updateNodeValueSemantic </td>
          <td>(</td>
          <td class="paramtype">const StringHash &amp;&#160;</td>
          <td class="paramname"><em>semantic</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const FreeValue &amp;&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>swapid</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Update the value of a semantic of this node</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">semantic</td><td>The semantic's name</td></tr>
    <tr><td class="paramname">value</td><td>The value to set the semantic to</td></tr>
    <tr><td class="paramname">swapid</td><td>The swapchain id to set the value for. You should always pass the current swapchain index<ul>
<li>even if the semantic is not in multibuffered storage, the case will be handled correctly.</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Return true if successful.</dd></dl>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a class="anchor" id="a626b6514323b3d3474dc5b09abe870de"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="structpvr_1_1utils_1_1_automatic_node_buffer_entry_semantic.html">AutomaticNodeBufferEntrySemantic</a>&gt; pvr::utils::RendermanNode::automaticEntrySemantics</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Automatic pvrvk::Buffer Entry semantics that were generated for this node. Used for auto-updating of shader buffer variables. (Automatic variables can be generated when an effect and a model's Semantics match, each such match can generate an automatic semantic.) </p>

</div>
</div>
<a class="anchor" id="a0ad0a2ecfcffbec848a0a368973579bf"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="structpvr_1_1utils_1_1_automatic_node_uniform_semantic.html">AutomaticNodeUniformSemantic</a>&gt; pvr::utils::RendermanNode::automaticUniformSemantics</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Automatic Uniform semantics that were generated for this node. Used for auto-updating of shader uniform variables(Automatic variables can be generated when an effect and a model's Semantics match, each such match can generate an automatic semantic.) </p>

</div>
</div>
<hr/>The documentation for this struct was generated from the following file:<ul>
<li>/usr/buildxl/buildroot/sdk/branch/SDK/framework/PVRUtils/Vulkan/<a class="el" href="_render_manager_vk_8h_source.html">RenderManagerVk.h</a></li>
</ul>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.4-->
<!-- start footer part (NON TREEVIEW ONLY!!) -->
<!--BEGIN GENERATE_TREEVIEW-->
<div id="FooterMainContainer">
	<div id="FooterContainer">
		<div class="footerlogo">
			<a href="http://www.imgtec.com" target="_blank"><img src="img-footer-logo-grey.png" width="100%" height="100%" border="none" /></a>
		</div>
		<div class="copyright"><p>&copy; Imagination Technologies Limited<br> All rights reserved</p></div>
	</div>
</div>
</body>
</html>
