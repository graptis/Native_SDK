<!-- HTML header for doxygen 1.8.4-->
<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="generator" content="Doxygen 1.8.6"/>
<title>PVRUtils: pvr::utils Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="IMGdoxygen.css" rel="stylesheet" type="text/css"/>
<link rel="shortcut icon" href="http://www.imgtec.com/images/img.ico">
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
  <div class="headercontent">
    <div class="PVRlogo">
      <a href="http://www.powervrinsider.com" target="_blank"><img src="PVRlogo.png" width="40%" height="40%"  border="none" /></a>
    </div>
    <a class="SiteTitle"><span id="projectname">PVRUtils</span> Documentation</a>
   <tbody>
  </div>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="inherits.html"><span>Class&#160;Hierarchy</span></a></li>
      <li class="current"><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Macros</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacepvr.html">pvr</a></li><li class="navelem"><a class="el" href="namespacepvr_1_1utils.html">utils</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">pvr::utils Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Main namespace for the PVRUtils Library  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpvr_1_1utils_1_1_attribute.html">Attribute</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Information about an attribute layout. <a href="structpvr_1_1utils_1_1_attribute.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpvr_1_1utils_1_1_attribute_layout.html">AttributeLayout</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Information about a set of attribute layouts. <a href="structpvr_1_1utils_1_1_attribute_layout.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpvr_1_1utils_1_1_automatic_model_buffer_entry_semantic.html">AutomaticModelBufferEntrySemantic</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An Automatic Model Semantic is a semantic that has been defined in the Effect ("consumed" by the effect) and that at the same time is defined somewhere in the Model ( is "produced" in the model). This class contains information about a Per-Model semantic that the effect uses as a pvrvk::Buffer Entry(is a variable inside a pvrvk::Buffer). For example, if "LIGHTPOSITION0" (a "default" Model Semantic) was defined in the effect as a pvrvk::Buffer Entry, an <a class="el" href="structpvr_1_1utils_1_1_automatic_model_buffer_entry_semantic.html" title="An Automatic Model Semantic is a semantic that has been defined in the Effect (&quot;consumed&quot; by the effe...">AutomaticModelBufferEntrySemantic</a> could then be automatically generated by a corresponding createAutomaticModelSemantics() call, and that will in turn be used to auto-update the Uniform when calling updateAutomaticModelsSemantics(). <a href="structpvr_1_1utils_1_1_automatic_model_buffer_entry_semantic.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpvr_1_1utils_1_1_automatic_model_uniform_semantic.html">AutomaticModelUniformSemantic</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An Automatic Model Semantic is a semantic that has been defined in the Effect ("consumed" by the effect) and that at the same time is defined somewhere in the Model ( is "produced" in the model). This class contains information about a Per-Model semantic that the effect uses as a Uniform. For example, if "PROJECTIONMATRIX" was defined in the effect as a Uniform, and was accessible as a Model Semantic in the model, an automatic semantic can be automatically generated (by a corresponding createAutomaticModelSemantics() call) that will then be used to auto-update the uniforms with updateAutomaticModelsSemantics(). <a href="structpvr_1_1utils_1_1_automatic_model_uniform_semantic.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpvr_1_1utils_1_1_automatic_node_buffer_entry_semantic.html">AutomaticNodeBufferEntrySemantic</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An Automatic Node Semantic is a semantic that has been defined in the Effect ("consumed" by the effect) and that at the same time is defined in each Node of a Model (is "produced" in the node). This class contains information about a Per-Node semantic that the effect uses as a pvrvk::Buffer Entry. For example, if "MODELVIEWPROJECTION" (a "default" Model Semantic) was defined in the effect as a variable inside a Uniform pvrvk::Buffer, an <a class="el" href="structpvr_1_1utils_1_1_automatic_node_uniform_semantic.html" title="An Automatic Node Semantic is a semantic that has been defined in the Effect (&quot;consumed&quot; by the effec...">AutomaticNodeUniformSemantic</a> could then be automatically generated by a corresponding createAutomaticNodeSemantics() call, and that will in turn be used to auto-update the buffer entry when calling updateAutomaticNodeSemantics(). <a href="structpvr_1_1utils_1_1_automatic_node_buffer_entry_semantic.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpvr_1_1utils_1_1_automatic_node_uniform_semantic.html">AutomaticNodeUniformSemantic</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An Automatic Node Semantic is a semantic that has been defined in the Effect ("consumed" by the effect) and that at the same time is defined in each Node of a Model (is "produced" in the node). This class contains information about a Per-Node semantic that the effect uses as a Uniform. For example, if "MODELVIEWPROJECTION" (a "default" Model Semantic) was defined in the effect as a Uniform, an <a class="el" href="structpvr_1_1utils_1_1_automatic_node_uniform_semantic.html" title="An Automatic Node Semantic is a semantic that has been defined in the Effect (&quot;consumed&quot; by the effec...">AutomaticNodeUniformSemantic</a> could then be automatically generated by a corresponding createAutomaticNodeSemantics() call, and that will in turn be used to auto-update the buffer entry when calling updateAutomaticNodeSemantics(). <a href="structpvr_1_1utils_1_1_automatic_node_uniform_semantic.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpvr_1_1utils_1_1_buffer_entry_semantic.html">BufferEntrySemantic</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class contains information for an Effect Semantic that is used as a variable in a pvrvk::Buffer, and stores the connections between all necessary components: The actual buffer, the descriptor set bound to, the layout of the buffer, the dynamic id (if part of a buffer, which slice this object refers to) and so on. Will normally be used with the actual Semantic as a key in a map, hence it does not contain it.  <a href="structpvr_1_1utils_1_1_buffer_entry_semantic.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpvr_1_1utils_1_1_device_extensions.html">DeviceExtensions</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Container for a list of device extensions to be used for initiailising a device using the helper function 'createDeviceAndQueues'. <a href="structpvr_1_1utils_1_1_device_extensions.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpvr_1_1utils_1_1_image_update_info.html">ImageUpdateInfo</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="structpvr_1_1utils_1_1_image_update_info.html" title="The ImageUpdateInfo struct.">ImageUpdateInfo</a> struct. <a href="structpvr_1_1utils_1_1_image_update_info.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpvr_1_1utils_1_1_instance_extensions.html">InstanceExtensions</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Container for a list of instance extensions to be used for initiailising an instance using the helper function 'createInstanceAndSurface'. <a href="structpvr_1_1utils_1_1_instance_extensions.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpvr_1_1utils_1_1_instance_layers.html">InstanceLayers</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Container for a list of instance layers to be used for initiailising an instance using the helper function 'createInstanceAndSurface'. <a href="structpvr_1_1utils_1_1_instance_layers.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1utils_1_1_model_gles.html">ModelGles</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="classpvr_1_1utils_1_1_model_gles.html" title="The ModelGles class provides the functionality for creating all of the buffers (vbos and ibos) and te...">ModelGles</a> class provides the functionality for creating all of the buffers (vbos and ibos) and textures required for basic rendering of a pvr::assets::Model using OpenGL ES. <a href="classpvr_1_1utils_1_1_model_gles.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpvr_1_1utils_1_1_queue_access_info.html">QueueAccessInfo</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A structure encapsulating the family id and queue id of a particular queue retrieved via the helper function 'createDeviceAndQueues'. The family id corresponds to the family id the queue was retrieved from. The queue id corresponds to the particular queue index for the retrieved queue. <a href="structpvr_1_1utils_1_1_queue_access_info.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpvr_1_1utils_1_1_queue_populate_info.html">QueuePopulateInfo</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A structure encapsulating the set of queue flags required for a particular queue retrieved via the helper function 'createDeviceAndQueues'. Optionally additionally providing a surface will indicate that the queue must support presentation via the provided surface. <a href="structpvr_1_1utils_1_1_queue_populate_info.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1utils_1_1_render_manager.html">RenderManager</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="classpvr_1_1utils_1_1_render_manager.html" title="The RenderManager is a rendering automation class, with class responsibilities such as: - Putting tog...">RenderManager</a> is a rendering automation class, with class responsibilities such as: - Putting together PFX files (Effects) with POD models (Models) to render - Creating Graphics Pipelines, Descriptor Sets, VBOs, IBOs, UBOs, etc. - Creating and configuring render - to - texture targets - Automatically generate command buffers for rendering - Automatically update textures/uniforms/buffers in the rendering api with info provided by the the model (textures, matrices etc) <a href="classpvr_1_1utils_1_1_render_manager.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpvr_1_1utils_1_1_renderman_buffer_binding.html">RendermanBufferBinding</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Contains information to bind a buffer to a specific pipeline's descriptor sets. <a href="structpvr_1_1utils_1_1_renderman_buffer_binding.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpvr_1_1utils_1_1_renderman_buffer_definition.html">RendermanBufferDefinition</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">INTERNAL. This struct is used to internally store buffers such as ubo and ssbo, with all the necessary binding info.  <a href="structpvr_1_1utils_1_1_renderman_buffer_definition.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpvr_1_1utils_1_1_renderman_effect.html">RendermanEffect</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Part of <a class="el" href="structpvr_1_1utils_1_1_renderman_structure.html" title="Internal class containing the Render Manager tree structure representation of a scene">RendermanStructure</a>. This class contains the different passes, exactly mirroring the PFX effect. Contains the original EffectApi. <a href="structpvr_1_1utils_1_1_renderman_effect.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpvr_1_1utils_1_1_renderman_material.html">RendermanMaterial</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This struct is used to store a material. <a href="structpvr_1_1utils_1_1_renderman_material.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpvr_1_1utils_1_1_renderman_material_subpass_pipeline.html">RendermanMaterialSubpassPipeline</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Part of <a class="el" href="structpvr_1_1utils_1_1_renderman_structure.html" title="Internal class containing the Render Manager tree structure representation of a scene">RendermanStructure</a>. This class is a Material's instances as used by a pipeline <a href="structpvr_1_1utils_1_1_renderman_material_subpass_pipeline.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpvr_1_1utils_1_1_renderman_mesh.html">RendermanMesh</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Part of <a class="el" href="structpvr_1_1utils_1_1_renderman_structure.html" title="Internal class containing the Render Manager tree structure representation of a scene">RendermanStructure</a>. This class is used to store VBOs/IBOs. Unique per mesh RendermanNodes inside passes/subpasses reference these items by pointer. <a href="structpvr_1_1utils_1_1_renderman_mesh.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpvr_1_1utils_1_1_renderman_model.html">RendermanModel</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Part of <a class="el" href="structpvr_1_1utils_1_1_renderman_structure.html" title="Internal class containing the Render Manager tree structure representation of a scene">RendermanStructure</a>. This class is used to store RendermanMeshes. Unique per model RendermanModelEffects inside passes/subpasses reference these items by pointer. <a href="structpvr_1_1utils_1_1_renderman_model.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpvr_1_1utils_1_1_renderman_node.html">RendermanNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Part of <a class="el" href="structpvr_1_1utils_1_1_renderman_structure.html" title="Internal class containing the Render Manager tree structure representation of a scene">RendermanStructure</a>. This class matches everything together: A pipelineMaterial, with a RendermanMeshSubpass, to render. Unique per rendering node AND mesh bone batch combination. NOTE: if bone batching is used, then multiple nodes will be generated per meshnode. Contains a reference to the mesh, the material, and also contains the dynamic offsets required to render with it. Loop through those to render.  <a href="structpvr_1_1utils_1_1_renderman_node.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpvr_1_1utils_1_1_renderman_pass.html">RendermanPass</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Part of <a class="el" href="structpvr_1_1utils_1_1_renderman_structure.html" title="Internal class containing the Render Manager tree structure representation of a scene">RendermanStructure</a>. This class contains the different subpasses, exactly mirroring the PFX pass. <a href="structpvr_1_1utils_1_1_renderman_pass.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpvr_1_1utils_1_1_renderman_pipeline.html">RendermanPipeline</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Part of <a class="el" href="structpvr_1_1utils_1_1_renderman_structure.html" title="Internal class containing the Render Manager tree structure representation of a scene">RendermanStructure</a>. This class is a cooked EffectPipeline, exactly mirroring the PFX pipelines. It is affected on creation time by the meshes that use it (for the Vertex Input configuration) but after that it is used for rendering directly when traversing the scene. <a href="structpvr_1_1utils_1_1_renderman_pipeline.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpvr_1_1utils_1_1_renderman_structure.html">RendermanStructure</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Internal class containing the Render Manager tree structure representation of a scene <a href="structpvr_1_1utils_1_1_renderman_structure.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpvr_1_1utils_1_1_renderman_subpass.html">RendermanSubpass</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Part of <a class="el" href="structpvr_1_1utils_1_1_renderman_structure.html" title="Internal class containing the Render Manager tree structure representation of a scene">RendermanStructure</a>. This struct groups the Renderpass subpass group. <a href="structpvr_1_1utils_1_1_renderman_subpass.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpvr_1_1utils_1_1_renderman_subpass_group.html">RendermanSubpassGroup</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Part of <a class="el" href="structpvr_1_1utils_1_1_renderman_structure.html" title="Internal class containing the Render Manager tree structure representation of a scene">RendermanStructure</a>. This class groups the Renderman pipeline and Models of a single <a class="el" href="structpvr_1_1utils_1_1_renderman_subpass.html" title="Part of RendermanStructure. This struct groups the Renderpass subpass group.">RendermanSubpass</a>. This grouping is to be able to separate and order different parts of rendering and different objects that might potentially have the same conditions, inside the same subpass (for example, a user might want to draw different objects with a different effect although the objects have the same conditions. <a href="structpvr_1_1utils_1_1_renderman_subpass_group.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpvr_1_1utils_1_1_renderman_subpass_group_model.html">RendermanSubpassGroupModel</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Part of <a class="el" href="structpvr_1_1utils_1_1_renderman_structure.html" title="Internal class containing the Render Manager tree structure representation of a scene">RendermanStructure</a>. This class stores RendermanNodes and RendermanMaterialEffects The list of nodes here references the list of materials. It references the Models in the original RendermanModelStore list.  <a href="structpvr_1_1utils_1_1_renderman_subpass_group_model.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpvr_1_1utils_1_1_renderman_subpass_material.html">RendermanSubpassMaterial</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Part of <a class="el" href="structpvr_1_1utils_1_1_renderman_structure.html" title="Internal class containing the Render Manager tree structure representation of a scene">RendermanStructure</a>. This class contains the Material's instances that are used by a pipeline The reason is that a pipeline is selected BOTH by material AND by mesh, making it possible for one material in one subpass to be used by different pipelines. <a href="structpvr_1_1utils_1_1_renderman_subpass_material.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpvr_1_1utils_1_1_renderman_subpass_mesh.html">RendermanSubpassMesh</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Part of <a class="el" href="structpvr_1_1utils_1_1_renderman_structure.html" title="Internal class containing the Render Manager tree structure representation of a scene">RendermanStructure</a>. This class is a Mesh's instances as used by a pipeline The "usedByPipelines" is only a helper. <a href="structpvr_1_1utils_1_1_renderman_subpass_mesh.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1utils_1_1_structured_buffer_view.html">StructuredBufferView</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A structured buffer view is a class that can be used to define an explicit structure to an object that is usually accessed as raw memory. For example, a GPU-side buffer is mapped to a void pointer, but a <a class="el" href="classpvr_1_1utils_1_1_structured_buffer_view.html" title="A structured buffer view is a class that can be used to define an explicit structure to an object tha...">StructuredBufferView</a> can be used to create a runtime structure for it, and set its entries one by one. Example usage for accessing a <a class="el" href="classpvr_1_1utils_1_1_structured_buffer_view.html" title="A structured buffer view is a class that can be used to define an explicit structure to an object tha...">StructuredBufferView</a> defined for the buffer bonesUbo defined below: struct Bone{ highp mat4 boneMatrix; highp mat3 boneMatrixIT; }; layout(std140, binding = i) uniform bonesUbo { mediump int BoneCount; // a name or index can be used to retrieve a particular element Bone bones[]; // elementArrayIndex is used to index into an arrays of elements } boneBuffer; getElementByName("BoneCount") = boneBuffer.BoneCount getElementByName("bones") = boneBuffer.Bone[0] getElementByName("bones", 1) = boneBuffer.Bone[1]  <a href="classpvr_1_1utils_1_1_structured_buffer_view.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1utils_1_1_structured_buffer_view_element.html">StructuredBufferViewElement</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines a <a class="el" href="classpvr_1_1utils_1_1_structured_buffer_view_element.html" title="Defines a StructuredBufferViewElement. A StructuredBufferViewElement handles the public interface use...">StructuredBufferViewElement</a>. A <a class="el" href="classpvr_1_1utils_1_1_structured_buffer_view_element.html" title="Defines a StructuredBufferViewElement. A StructuredBufferViewElement handles the public interface use...">StructuredBufferViewElement</a> handles the public interface used for working with a <a class="el" href="classpvr_1_1utils_1_1_structured_memory_entry.html" title="Defines a StructuredMemoryEntry element. A StructuredMemoryEntry defines an actual element entry in a...">StructuredMemoryEntry</a>. <a href="classpvr_1_1utils_1_1_structured_buffer_view_element.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1utils_1_1_structured_memory_description.html">StructuredMemoryDescription</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines a memory element description. The element will be provided with a name, type and number of array elements. The element itself may also contain child memory elements  <a href="classpvr_1_1utils_1_1_structured_memory_description.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1utils_1_1_structured_memory_entry.html">StructuredMemoryEntry</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines a <a class="el" href="classpvr_1_1utils_1_1_structured_memory_entry.html" title="Defines a StructuredMemoryEntry element. A StructuredMemoryEntry defines an actual element entry in a...">StructuredMemoryEntry</a> element. A <a class="el" href="classpvr_1_1utils_1_1_structured_memory_entry.html" title="Defines a StructuredMemoryEntry element. A StructuredMemoryEntry defines an actual element entry in a...">StructuredMemoryEntry</a> defines an actual element entry in a structured buffer view. WARNING: Arrays of size 1 not supported - they are considered non-arrays. WARNING: Due to pointers to parents, no reallocations must <em>ever</em> happen. Once initialized, the lists must be final. WARNING: THE ENTIRE PUBLIC INTERFACE OF THIS CLASS EXCEPT FOR INIT, IS CONST. WARNING: IT IS NOT INTENDED FOR THIS CLASS TO BE EVER MODIFIABLE. <a href="classpvr_1_1utils_1_1_structured_memory_entry.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpvr_1_1utils_1_1_texture_upload_results.html">TextureUploadResults</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="structpvr_1_1utils_1_1_texture_upload_results.html" title="The TextureUploadResults structure provides the results for texture upload functions in a simple to u...">TextureUploadResults</a> structure provides the results for texture upload functions in a simple to use structure <a href="structpvr_1_1utils_1_1_texture_upload_results.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpvr_1_1utils_1_1_uniform_semantic.html">UniformSemantic</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class contains information for an Effect Semantic that is used as a Uniform or PushConstant, and keeps the memory where this value will be intermediately kept (i.e. the "memory" variable is updated by the application or automatic semantics, and then can be uploaded to the shader. Will normally be used with the actual Semantic as a key in a map, hence it does not contain it. <a href="structpvr_1_1utils_1_1_uniform_semantic.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpvr_1_1utils_1_1_vertex_bindings.html">VertexBindings</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a shader Explicit binding, tying a Semantic name to an <a class="el" href="structpvr_1_1utils_1_1_attribute.html" title="Information about an attribute layout.">Attribute</a> Index. <a href="structpvr_1_1utils_1_1_vertex_bindings.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpvr_1_1utils_1_1_vertex_bindings___name.html">VertexBindings_Name</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a shader Reflective binding, tying a Semantic name to an <a class="el" href="structpvr_1_1utils_1_1_attribute.html" title="Information about an attribute layout.">Attribute</a> variable name. <a href="structpvr_1_1utils_1_1_vertex_bindings___name.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpvr_1_1utils_1_1_vulkan_version.html">VulkanVersion</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="structpvr_1_1utils_1_1_vulkan_version.html" title="The VulkanVersion structure provides an easy mechanism for constructing the Vulkan version for use wh...">VulkanVersion</a> structure provides an easy mechanism for constructing the Vulkan version for use when creating a Vulkan instance. <a href="structpvr_1_1utils_1_1_vulkan_version.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a363e04b38078d8c423b35185195f614a"><td class="memItemLeft" align="right" valign="top">typedef <br class="typebreak"/>
EmbeddedRefCountedResource<br class="typebreak"/>
&lt; async::IFrameworkAsyncResult<br class="typebreak"/>
&lt; pvrvk::ImageView &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1utils.html#a363e04b38078d8c423b35185195f614a">AsyncApiTexture</a></td></tr>
<tr class="memdesc:a363e04b38078d8c423b35185195f614a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides a reference counted pointer to a IFrameworkAsyncResult specialised by an ImageView which will be used as the main interface for using API specific asynchronous textures. <a href="#a363e04b38078d8c423b35185195f614a">More...</a><br/></td></tr>
<tr class="separator:a363e04b38078d8c423b35185195f614a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f0838b4c2b77e12986b54da8b3bef7b"><td class="memItemLeft" align="right" valign="top">typedef <br class="typebreak"/>
EmbeddedRefCountedResource<br class="typebreak"/>
&lt; async::IFrameworkAsyncResult<br class="typebreak"/>
&lt; <a class="el" href="namespacepvr_1_1utils.html#a29b5f19aa83276c6b2699da0912d9f84">TexturePtr</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1utils.html#a3f0838b4c2b77e12986b54da8b3bef7b">AsyncTexture</a></td></tr>
<tr class="memdesc:a3f0838b4c2b77e12986b54da8b3bef7b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides a reference counted pointer to a IFrameworkAsyncResult specialised by a TexturePtr which will be used as the main interface for using API agnostic asynchronous textures. <a href="#a3f0838b4c2b77e12986b54da8b3bef7b">More...</a><br/></td></tr>
<tr class="separator:a3f0838b4c2b77e12986b54da8b3bef7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d76ff5c44e70698baef1dfd19dd90e3"><td class="memItemLeft" align="right" valign="top">typedef bool(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1utils.html#a6d76ff5c44e70698baef1dfd19dd90e3">ModelSemanticSetter</a> )(TypedMem &amp;mem, const <a class="el" href="structpvr_1_1utils_1_1_renderman_model.html">RendermanModel</a> &amp;model)</td></tr>
<tr class="memdesc:a6d76ff5c44e70698baef1dfd19dd90e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">A pointer to a function that sets a specific Model Semantic from the model to the provided memory object <a href="#a6d76ff5c44e70698baef1dfd19dd90e3">More...</a><br/></td></tr>
<tr class="separator:a6d76ff5c44e70698baef1dfd19dd90e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52ce711be6305e9237b2513013656b90"><td class="memItemLeft" align="right" valign="top">typedef bool(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1utils.html#a52ce711be6305e9237b2513013656b90">NodeSemanticSetter</a> )(TypedMem &amp;mem, const <a class="el" href="structpvr_1_1utils_1_1_renderman_node.html">RendermanNode</a> &amp;node)</td></tr>
<tr class="memdesc:a52ce711be6305e9237b2513013656b90"><td class="mdescLeft">&#160;</td><td class="mdescRight">A NodeSemanticSetter is a function that sets a specified Semantic to a value. It always applies to a specific semantic, and sources all required information from the node parameter, then writes the new updated value in the mem parameter <a href="#a52ce711be6305e9237b2513013656b90">More...</a><br/></td></tr>
<tr class="separator:a52ce711be6305e9237b2513013656b90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29b5f19aa83276c6b2699da0912d9f84"><td class="memItemLeft" align="right" valign="top">typedef RefCountedResource<br class="typebreak"/>
&lt; Texture &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1utils.html#a29b5f19aa83276c6b2699da0912d9f84">TexturePtr</a></td></tr>
<tr class="memdesc:a29b5f19aa83276c6b2699da0912d9f84"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides a reference counted pointer to a pvr::Texture which will be used for loading API agnostic texture data to disk. <a href="#a29b5f19aa83276c6b2699da0912d9f84">More...</a><br/></td></tr>
<tr class="separator:a29b5f19aa83276c6b2699da0912d9f84"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ac66fa9a9c7f8232c3f5aa3f41106cfea"><td class="memTemplParams" colspan="2">template&lt;typename VboContainer_ , typename IboContainer_ &gt; </td></tr>
<tr class="memitem:ac66fa9a9c7f8232c3f5aa3f41106cfea"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1utils.html#ac66fa9a9c7f8232c3f5aa3f41106cfea">appendSingleBuffersFromModel</a> (pvrvk::Device &amp;device, const assets::Model &amp;model, VboContainer_ &amp;vbos, IboContainer_ &amp;ibos, pvrvk::CommandBuffer &amp;uploadCmdBuffer, bool &amp;requiresCommandBufferSubmission, vma::Allocator *bufferAllocator=nullptr, vma::AllocationCreateFlags vmaAllocationCreateFlags=vma::AllocationCreateFlags::e_MAPPED_BIT)</td></tr>
<tr class="memdesc:ac66fa9a9c7f8232c3f5aa3f41106cfea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Auto generates a set of VBOs and a set of IBOs from the vertex data of the meshes of a model and appends them at the end of containers provided by the user. <a href="#ac66fa9a9c7f8232c3f5aa3f41106cfea">More...</a><br/></td></tr>
<tr class="separator:ac66fa9a9c7f8232c3f5aa3f41106cfea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aafce526b759924e9114572d863b5b8f6"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1utils.html#aafce526b759924e9114572d863b5b8f6">checkApiError</a> (std::string *errOutStr=NULL)</td></tr>
<tr class="memdesc:aafce526b759924e9114572d863b5b8f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks and returns api error if appropriate. <a href="#aafce526b759924e9114572d863b5b8f6">More...</a><br/></td></tr>
<tr class="separator:aafce526b759924e9114572d863b5b8f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b92cb613310549a5b748d1f5c4b4557"><td class="memItemLeft" align="right" valign="top">GLenum&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1utils.html#a7b92cb613310549a5b748d1f5c4b4557">convertToGles</a> (IndexType type)</td></tr>
<tr class="memdesc:a7b92cb613310549a5b748d1f5c4b4557"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts from a pvr::IndexType to its OpenGL ES GLenum counterpart. <a href="#a7b92cb613310549a5b748d1f5c4b4557">More...</a><br/></td></tr>
<tr class="separator:a7b92cb613310549a5b748d1f5c4b4557"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aabfe42ed26ab9fcb99118de82013eedb"><td class="memItemLeft" align="right" valign="top">GLenum&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1utils.html#aabfe42ed26ab9fcb99118de82013eedb">convertToGles</a> (Face face)</td></tr>
<tr class="memdesc:aabfe42ed26ab9fcb99118de82013eedb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert to opengl face. <a href="#aabfe42ed26ab9fcb99118de82013eedb">More...</a><br/></td></tr>
<tr class="separator:aabfe42ed26ab9fcb99118de82013eedb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2cf730a0573373abb18dcefa9390e840"><td class="memItemLeft" align="right" valign="top">GLenum&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1utils.html#a2cf730a0573373abb18dcefa9390e840">convertToGles</a> (PolygonWindingOrder windingOrder)</td></tr>
<tr class="memdesc:a2cf730a0573373abb18dcefa9390e840"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert to opengl winding-order. <a href="#a2cf730a0573373abb18dcefa9390e840">More...</a><br/></td></tr>
<tr class="separator:a2cf730a0573373abb18dcefa9390e840"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a196375d06b5173798e46037c7b8eb890"><td class="memItemLeft" align="right" valign="top">GLenum&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1utils.html#a196375d06b5173798e46037c7b8eb890">convertToGles</a> (CompareOp func)</td></tr>
<tr class="memdesc:a196375d06b5173798e46037c7b8eb890"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert to opengl comparison mode. <a href="#a196375d06b5173798e46037c7b8eb890">More...</a><br/></td></tr>
<tr class="separator:a196375d06b5173798e46037c7b8eb890"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a648788eddea6a26479db4a04cdeedf55"><td class="memItemLeft" align="right" valign="top">GLenum&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1utils.html#a648788eddea6a26479db4a04cdeedf55">convertToGles</a> (ImageAspectFlags type)</td></tr>
<tr class="memdesc:a648788eddea6a26479db4a04cdeedf55"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert to an opengl image aspect type. <a href="#a648788eddea6a26479db4a04cdeedf55">More...</a><br/></td></tr>
<tr class="separator:a648788eddea6a26479db4a04cdeedf55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d36f28640fc36caaed25f8935a48229"><td class="memItemLeft" align="right" valign="top">GLenum&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1utils.html#a7d36f28640fc36caaed25f8935a48229">convertToGles</a> (ImageViewType texType)</td></tr>
<tr class="memdesc:a7d36f28640fc36caaed25f8935a48229"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert to opengl texture type. <a href="#a7d36f28640fc36caaed25f8935a48229">More...</a><br/></td></tr>
<tr class="separator:a7d36f28640fc36caaed25f8935a48229"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad86cd8604c6d3c155b531d7a1784581f"><td class="memItemLeft" align="right" valign="top">GLenum&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1utils.html#ad86cd8604c6d3c155b531d7a1784581f">convertToGles</a> (DataType dataType)</td></tr>
<tr class="memdesc:ad86cd8604c6d3c155b531d7a1784581f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert to opengl data type. <a href="#ad86cd8604c6d3c155b531d7a1784581f">More...</a><br/></td></tr>
<tr class="separator:ad86cd8604c6d3c155b531d7a1784581f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4848cd91db829306bc8a1ed929762aad"><td class="memItemLeft" align="right" valign="top">GLenum&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1utils.html#a4848cd91db829306bc8a1ed929762aad">convertToGles</a> (PrimitiveTopology primitiveType)</td></tr>
<tr class="memdesc:a4848cd91db829306bc8a1ed929762aad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert to opengl priitive type. <a href="#a4848cd91db829306bc8a1ed929762aad">More...</a><br/></td></tr>
<tr class="separator:a4848cd91db829306bc8a1ed929762aad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c41ff094638c4216cb39bf821408fe5"><td class="memItemLeft" align="right" valign="top">GLenum&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1utils.html#a3c41ff094638c4216cb39bf821408fe5">convertToGles</a> (SamplerAddressMode addressMode)</td></tr>
<tr class="memdesc:a3c41ff094638c4216cb39bf821408fe5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert to opengl sampler wrap. <a href="#a3c41ff094638c4216cb39bf821408fe5">More...</a><br/></td></tr>
<tr class="separator:a3c41ff094638c4216cb39bf821408fe5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1dc4d95376bb577dd85455028527815"><td class="memItemLeft" align="right" valign="top">GLenum&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1utils.html#af1dc4d95376bb577dd85455028527815">convertToGles</a> (StencilOp stencilOp)</td></tr>
<tr class="memdesc:af1dc4d95376bb577dd85455028527815"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert to opengl stencil op output. <a href="#af1dc4d95376bb577dd85455028527815">More...</a><br/></td></tr>
<tr class="separator:af1dc4d95376bb577dd85455028527815"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe32fb89dfe5e37513af651055cdef15"><td class="memItemLeft" align="right" valign="top">GLenum&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1utils.html#afe32fb89dfe5e37513af651055cdef15">convertToGles</a> (BlendOp blendOp)</td></tr>
<tr class="memdesc:afe32fb89dfe5e37513af651055cdef15"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert to opengl blend op output. <a href="#afe32fb89dfe5e37513af651055cdef15">More...</a><br/></td></tr>
<tr class="separator:afe32fb89dfe5e37513af651055cdef15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20ca18b411c83be99cc9b83137cef4d8"><td class="memItemLeft" align="right" valign="top">GLenum&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1utils.html#a20ca18b411c83be99cc9b83137cef4d8">convertToGles</a> (BlendFactor blendFactor)</td></tr>
<tr class="memdesc:a20ca18b411c83be99cc9b83137cef4d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert to opengl blend factor output. <a href="#a20ca18b411c83be99cc9b83137cef4d8">More...</a><br/></td></tr>
<tr class="separator:a20ca18b411c83be99cc9b83137cef4d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0c9ce4267ec635305fc87aba0b9d9c2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1utils.html#ad0c9ce4267ec635305fc87aba0b9d9c2">create3dPlaneMesh</a> (uint32_t width, uint32_t depth, bool generateTexCoords, bool generateNormalCoords, assets::Mesh &amp;outMesh)</td></tr>
<tr class="memdesc:ad0c9ce4267ec635305fc87aba0b9d9c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a 3d plane mesh based on the width and depth specified. Texture coordinates and normal coordinates can also optionally be generated based on the generateTexCoords and generateNormalCoords flags respectively. The generated mesh will be returned as a pvr::assets::Mesh. <a href="#ad0c9ce4267ec635305fc87aba0b9d9c2">More...</a><br/></td></tr>
<tr class="separator:ad0c9ce4267ec635305fc87aba0b9d9c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acecac80786da19a6303dbf72345c16a9"><td class="memItemLeft" align="right" valign="top">pvrvk::Buffer&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1utils.html#acecac80786da19a6303dbf72345c16a9">createBuffer</a> (pvrvk::Device device, VkDeviceSize size, pvrvk::BufferUsageFlags bufferUsage, pvrvk::MemoryPropertyFlags requiredMemoryFlags, pvrvk::MemoryPropertyFlags optimalMemoryFlags=pvrvk::MemoryPropertyFlags::e_NONE, vma::Allocator *bufferAllocator=nullptr, vma::AllocationCreateFlags vmaAllocationCreateFlags=vma::AllocationCreateFlags::e_MAPPED_BIT, pvrvk::BufferCreateFlags bufferCreateFlags=pvrvk::BufferCreateFlags(0), pvrvk::SharingMode sharingMode=pvrvk::SharingMode::e_EXCLUSIVE, const uint32_t *queueFamilyIndices=nullptr, uint32_t numQueueFamilyIndices=0)</td></tr>
<tr class="memdesc:acecac80786da19a6303dbf72345c16a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new buffer object and (optionally) allocate and bind memory for it <a href="#acecac80786da19a6303dbf72345c16a9">More...</a><br/></td></tr>
<tr class="separator:acecac80786da19a6303dbf72345c16a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04b412166c06b4293b7eaa1bf6857f50"><td class="memItemLeft" align="right" valign="top">pvrvk::DebugReportCallback&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1utils.html#a04b412166c06b4293b7eaa1bf6857f50">createDebugReportCallback</a> (pvrvk::Instance &amp;instance, pvrvk::DebugReportFlagsEXT flags=pvrvk::DebugReportFlagsEXT::e_ERROR_BIT_EXT|pvrvk::DebugReportFlagsEXT::e_PERFORMANCE_WARNING_BIT_EXT|pvrvk::DebugReportFlagsEXT::e_WARNING_BIT_EXT, PFN_vkDebugReportCallbackEXT callback=<a class="el" href="namespacepvr_1_1utils.html#a1cbbbd1665449ea70d772de63595c806">pvr::utils::logMessageDebugReportCallback</a>, void *userData=nullptr)</td></tr>
<tr class="memdesc:a04b412166c06b4293b7eaa1bf6857f50"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a DebugReportCallback providing an application callback for events of interest to the application. <a href="#a04b412166c06b4293b7eaa1bf6857f50">More...</a><br/></td></tr>
<tr class="separator:a04b412166c06b4293b7eaa1bf6857f50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42affc049a44dc37070da0d0a88d1ee5"><td class="memItemLeft" align="right" valign="top">pvrvk::Device&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1utils.html#a42affc049a44dc37070da0d0a88d1ee5">createDeviceAndQueues</a> (pvrvk::PhysicalDevice physicalDevice, const <a class="el" href="structpvr_1_1utils_1_1_queue_populate_info.html">QueuePopulateInfo</a> *queueCreateFlags, uint32_t numQueueCreateFlags, <a class="el" href="structpvr_1_1utils_1_1_queue_access_info.html">QueueAccessInfo</a> *outAccessInfo, const <a class="el" href="structpvr_1_1utils_1_1_device_extensions.html">DeviceExtensions</a> &amp;deviceExtensions=<a class="el" href="structpvr_1_1utils_1_1_device_extensions.html">DeviceExtensions</a>())</td></tr>
<tr class="memdesc:a42affc049a44dc37070da0d0a88d1ee5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create the pvrvk::Device and the queues <a href="#a42affc049a44dc37070da0d0a88d1ee5">More...</a><br/></td></tr>
<tr class="separator:a42affc049a44dc37070da0d0a88d1ee5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ea80135aa97006c881f5d3fface1563"><td class="memItemLeft" align="right" valign="top">pvrvk::Image&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1utils.html#a2ea80135aa97006c881f5d3fface1563">createImage</a> (pvrvk::Device device, pvrvk::ImageType imageType, pvrvk::Format format, const pvrvk::Extent3D &amp;dimension, pvrvk::ImageUsageFlags usage, pvrvk::ImageCreateFlags flags=pvrvk::ImageCreateFlags(0), const pvrvk::ImageLayersSize &amp;layerSize=pvrvk::ImageLayersSize(), pvrvk::SampleCountFlags samples=pvrvk::SampleCountFlags::e_1_BIT, pvrvk::MemoryPropertyFlags requiredMemoryFlags=pvrvk::MemoryPropertyFlags::e_DEVICE_LOCAL_BIT, pvrvk::MemoryPropertyFlags optimalMemoryFlags=pvrvk::MemoryPropertyFlags::e_NONE, vma::Allocator *imageAllocator=nullptr, vma::AllocationCreateFlags vmaAllocationCreateFlags=vma::AllocationCreateFlags::e_NONE, pvrvk::SharingMode sharingMode=pvrvk::SharingMode::e_EXCLUSIVE, pvrvk::ImageTiling tiling=pvrvk::ImageTiling::e_OPTIMAL, pvrvk::ImageLayout initialLayout=pvrvk::ImageLayout::e_UNDEFINED, const uint32_t *queueFamilyIndices=nullptr, uint32_t numQueueFamilyIndices=0)</td></tr>
<tr class="memdesc:a2ea80135aa97006c881f5d3fface1563"><td class="mdescLeft">&#160;</td><td class="mdescRight">create a new Image(sparse or with memory backing, depending on <em>flags</em> . The user should not call bindMemory on the image if sparse flags are used. <em>requiredMemoryFlags</em>  is ignored if <em>flags</em>  contains sparse binding flags. <a href="#a2ea80135aa97006c881f5d3fface1563">More...</a><br/></td></tr>
<tr class="separator:a2ea80135aa97006c881f5d3fface1563"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a680ef5943947e565f7d14aa9ff0393d9"><td class="memItemLeft" align="right" valign="top">pvrvk::Instance&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1utils.html#a680ef5943947e565f7d14aa9ff0393d9">createInstance</a> (const std::string &amp;applicationName, <a class="el" href="structpvr_1_1utils_1_1_vulkan_version.html">VulkanVersion</a> apiVersion=<a class="el" href="structpvr_1_1utils_1_1_vulkan_version.html">VulkanVersion</a>(), const <a class="el" href="structpvr_1_1utils_1_1_instance_extensions.html">InstanceExtensions</a> &amp;instanceExtensions=<a class="el" href="structpvr_1_1utils_1_1_instance_extensions.html">InstanceExtensions</a>(), const <a class="el" href="structpvr_1_1utils_1_1_instance_layers.html">InstanceLayers</a> &amp;instanceLayers=<a class="el" href="structpvr_1_1utils_1_1_instance_layers.html">InstanceLayers</a>())</td></tr>
<tr class="memdesc:a680ef5943947e565f7d14aa9ff0393d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility function for creating a Vulkan instance and supported physical devices using the appropriately set parameters. <a href="#a680ef5943947e565f7d14aa9ff0393d9">More...</a><br/></td></tr>
<tr class="separator:a680ef5943947e565f7d14aa9ff0393d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95e0a5be7c444548e52a74c2f40faaa5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1utils.html#a95e0a5be7c444548e52a74c2f40faaa5">createMultipleBuffersFromMesh</a> (pvrvk::Device &amp;device, const assets::Mesh &amp;mesh, std::vector&lt; pvrvk::Buffer &gt; &amp;outVbos, pvrvk::Buffer &amp;outIbo, pvrvk::CommandBuffer &amp;uploadCmdBuffer, bool &amp;requiresCommandBufferSubmission, vma::Allocator *bufferAllocator, vma::AllocationCreateFlags vmaAllocationCreateFlags=vma::AllocationCreateFlags::e_MAPPED_BIT)</td></tr>
<tr class="memdesc:a95e0a5be7c444548e52a74c2f40faaa5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Auto generates a set of VBOs and a single IBO from all the vertex data of a mesh. <a href="#a95e0a5be7c444548e52a74c2f40faaa5">More...</a><br/></td></tr>
<tr class="separator:a95e0a5be7c444548e52a74c2f40faaa5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a021b5205f52c9a4d0cdd26ce9e1f03a7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1utils.html#a021b5205f52c9a4d0cdd26ce9e1f03a7">createOnscreenFramebufferAndRenderpass</a> (pvrvk::Swapchain &amp;swapchain, pvrvk::ImageView *depthStencilImages, Multi&lt; pvrvk::Framebuffer &gt; &amp;outFramebuffers, pvrvk::RenderPass &amp;outRenderPass, pvrvk::ImageLayout initialSwapchainLayout=pvrvk::ImageLayout::e_UNDEFINED, pvrvk::ImageLayout initialDepthStencilLayout=pvrvk::ImageLayout::e_UNDEFINED)</td></tr>
<tr class="memdesc:a021b5205f52c9a4d0cdd26ce9e1f03a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a pvrvk::Framebuffer and Renderpass to use for 'default' rendering to the 'onscreen' color images with following config Renderpass: Attachment0: ColorAttachment swapchain image, finalLayout - PresentSrcKHR LoadOp - Clear StoreOp - Store Attachment1: DepthStencilAttachment finalLayout - DepthStencilAttachmentOptimal LoadOp - Clear StoreOp - Store  <a href="#a021b5205f52c9a4d0cdd26ce9e1f03a7">More...</a><br/></td></tr>
<tr class="separator:a021b5205f52c9a4d0cdd26ce9e1f03a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aecfe23b63ffc4cc0fae6624b389f9572"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1utils.html#aecfe23b63ffc4cc0fae6624b389f9572">createOnscreenFramebufferAndRenderpass</a> (pvrvk::Swapchain &amp;swapchain, pvrvk::ImageView *depthStencilImages, Multi&lt; pvrvk::Framebuffer &gt; &amp;outFramebuffers, pvrvk::ImageLayout initialSwapchainLayout=pvrvk::ImageLayout::e_UNDEFINED, pvrvk::ImageLayout initialDepthStencilLayout=pvrvk::ImageLayout::e_UNDEFINED)</td></tr>
<tr class="memdesc:aecfe23b63ffc4cc0fae6624b389f9572"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a pvrvk::Framebuffer and Renderpass to use for 'default' rendering to the 'onscreen' color images with following config Renderpass: ColorAttachment0: swapchain image, finalLayout - PresentSrcKHR LoadOp - Clear StoreOp - Store DepthStencilAttachment: finalLayout - DepthStencilAttachmentOptimal LoadOp - Clear StoreOp - Store Subpass0  <a href="#aecfe23b63ffc4cc0fae6624b389f9572">More...</a><br/></td></tr>
<tr class="separator:aecfe23b63ffc4cc0fae6624b389f9572"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a558c97111c1acd50a97db4307d0de11a"><td class="memItemLeft" align="right" valign="top">GLuint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1utils.html#a558c97111c1acd50a97db4307d0de11a">createShaderProgram</a> (const GLuint pShaders[], uint32_t count, const char **const attribNames, const uint16_t *attribIndices, uint32_t attribsCount, std::string *infolog=NULL)</td></tr>
<tr class="memdesc:a558c97111c1acd50a97db4307d0de11a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a native shader program from an array of native shader handles. Will implicitly load on the current context. <a href="#a558c97111c1acd50a97db4307d0de11a">More...</a><br/></td></tr>
<tr class="separator:a558c97111c1acd50a97db4307d0de11a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6934715b675cba2e0a7454813b431a3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1utils.html#ae6934715b675cba2e0a7454813b431a3">createSingleBuffersFromMesh</a> (pvrvk::Device &amp;device, const assets::Mesh &amp;mesh, pvrvk::Buffer &amp;outVbo, pvrvk::Buffer &amp;outIbo, pvrvk::CommandBuffer &amp;uploadCmdBuffer, bool &amp;requiresCommandBufferSubmission, vma::Allocator *bufferAllocator=nullptr, vma::AllocationCreateFlags vmaAllocationCreateFlags=vma::AllocationCreateFlags::e_MAPPED_BIT)</td></tr>
<tr class="memdesc:ae6934715b675cba2e0a7454813b431a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Auto generates a single VBO and a single IBO from all the vertex data of a mesh. <a href="#ae6934715b675cba2e0a7454813b431a3">More...</a><br/></td></tr>
<tr class="separator:ae6934715b675cba2e0a7454813b431a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06f94be9a865755c8bafaac56f286b01"><td class="memTemplParams" colspan="2">template&lt;typename MeshIterator_ , typename VboInsertIterator_ , typename IboInsertIterator_ &gt; </td></tr>
<tr class="memitem:a06f94be9a865755c8bafaac56f286b01"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1utils.html#a06f94be9a865755c8bafaac56f286b01">createSingleBuffersFromMeshes</a> (pvrvk::Device &amp;device, MeshIterator_ meshIter, MeshIterator_ meshIterEnd, VboInsertIterator_ outVbos, IboInsertIterator_ outIbos, pvrvk::CommandBuffer &amp;uploadCmdBuffer, bool &amp;requiresCommandBufferSubmission, vma::Allocator *bufferAllocator=nullptr, vma::AllocationCreateFlags vmaAllocationCreateFlags=vma::AllocationCreateFlags::e_MAPPED_BIT)</td></tr>
<tr class="memdesc:a06f94be9a865755c8bafaac56f286b01"><td class="mdescLeft">&#160;</td><td class="mdescRight">Auto generates a set of VBOs and a set of IBOs from the vertex data of multiple meshes and uses std::inserter provided by the user to insert them to any container. <a href="#a06f94be9a865755c8bafaac56f286b01">More...</a><br/></td></tr>
<tr class="separator:a06f94be9a865755c8bafaac56f286b01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4493b0c69e45e8b7af4d2fa32f763f23"><td class="memTemplParams" colspan="2">template&lt;typename MeshIterator_ , typename VboContainer_ , typename IboContainer_ &gt; </td></tr>
<tr class="memitem:a4493b0c69e45e8b7af4d2fa32f763f23"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1utils.html#a4493b0c69e45e8b7af4d2fa32f763f23">createSingleBuffersFromMeshes</a> (pvrvk::Device &amp;device, MeshIterator_ meshIter, MeshIterator_ meshIterEnd, VboContainer_ &amp;outVbos, typename VboContainer_::iterator vbos_where, IboContainer_ &amp;outIbos, typename IboContainer_::iterator ibos_where, pvrvk::CommandBuffer &amp;uploadCmdBuffer, bool &amp;requiresCommandBufferSubmission, vma::Allocator *bufferAllocator=nullptr, vma::AllocationCreateFlags vmaAllocationCreateFlags=vma::AllocationCreateFlags::e_MAPPED_BIT)</td></tr>
<tr class="memdesc:a4493b0c69e45e8b7af4d2fa32f763f23"><td class="mdescLeft">&#160;</td><td class="mdescRight">Auto generates a set of VBOs and a set of IBOs from the vertex data of multiple meshes and insert them at the specified spot in a user-provided container. <a href="#a4493b0c69e45e8b7af4d2fa32f763f23">More...</a><br/></td></tr>
<tr class="separator:a4493b0c69e45e8b7af4d2fa32f763f23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b77d306417876f431ed11fffde3a84f"><td class="memTemplParams" colspan="2">template&lt;typename VboInsertIterator_ , typename IboInsertIterator_ &gt; </td></tr>
<tr class="memitem:a8b77d306417876f431ed11fffde3a84f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1utils.html#a8b77d306417876f431ed11fffde3a84f">createSingleBuffersFromModel</a> (pvrvk::Device &amp;device, const assets::Model &amp;model, VboInsertIterator_ vbos, IboInsertIterator_ ibos, pvrvk::CommandBuffer &amp;uploadCmdBuffer, bool &amp;requiresCommandBufferSubmission, vma::Allocator *bufferAllocator=nullptr, vma::AllocationCreateFlags vmaAllocationCreateFlags=vma::AllocationCreateFlags::e_MAPPED_BIT)</td></tr>
<tr class="memdesc:a8b77d306417876f431ed11fffde3a84f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Auto generates a set of VBOs and a set of IBOs from the vertex data of the meshes of a model and inserts them into containers provided by the user using std::inserters. <a href="#a8b77d306417876f431ed11fffde3a84f">More...</a><br/></td></tr>
<tr class="separator:a8b77d306417876f431ed11fffde3a84f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa583027696be258fc78dd3156ffaece5"><td class="memItemLeft" align="right" valign="top">pvrvk::Surface&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1utils.html#aa583027696be258fc78dd3156ffaece5">createSurface</a> (pvrvk::Instance &amp;instance, pvrvk::PhysicalDevice &amp;physicalDevice, void *window, void *display)</td></tr>
<tr class="memdesc:aa583027696be258fc78dd3156ffaece5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an abstract vulkan native platform surface. <a href="#aa583027696be258fc78dd3156ffaece5">More...</a><br/></td></tr>
<tr class="separator:aa583027696be258fc78dd3156ffaece5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31577c3e0b7564dde7e0e46c252317d3"><td class="memItemLeft" align="right" valign="top">pvrvk::Swapchain&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1utils.html#a31577c3e0b7564dde7e0e46c252317d3">createSwapchain</a> (pvrvk::Device &amp;device, const pvrvk::Surface &amp;surface, pvr::DisplayAttributes &amp;displayAttributes, pvrvk::Format *preferredColorFormats, uint32_t numColorFormats, pvrvk::ImageUsageFlags swapchainImageUsageFlags=pvrvk::ImageUsageFlags::e_COLOR_ATTACHMENT_BIT)</td></tr>
<tr class="memdesc:a31577c3e0b7564dde7e0e46c252317d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a pvrvk::Swapchain using a pre-initialised pvrvk::Device and pvrvk::Surface choosing the color format of the swapchain images created from the specified list of preferred color formats. <a href="#a31577c3e0b7564dde7e0e46c252317d3">More...</a><br/></td></tr>
<tr class="separator:a31577c3e0b7564dde7e0e46c252317d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb02e95824004b5bf3b80049ec0a3e40"><td class="memItemLeft" align="right" valign="top">pvrvk::Swapchain&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1utils.html#acb02e95824004b5bf3b80049ec0a3e40">createSwapchain</a> (pvrvk::Device &amp;device, const pvrvk::Surface &amp;surface, pvr::DisplayAttributes &amp;displayAttributes, pvrvk::ImageUsageFlags swapchainImageUsageFlags=pvrvk::ImageUsageFlags::e_COLOR_ATTACHMENT_BIT)</td></tr>
<tr class="memdesc:acb02e95824004b5bf3b80049ec0a3e40"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a pvrvk::Swapchain using a pre-initialised pvrvk::Device and pvrvk::Surface. <a href="#acb02e95824004b5bf3b80049ec0a3e40">More...</a><br/></td></tr>
<tr class="separator:acb02e95824004b5bf3b80049ec0a3e40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21012ef6146e3eb4d55ac09d0be368fd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1utils.html#a21012ef6146e3eb4d55ac09d0be368fd">createSwapchainAndDepthStencilImageAndViews</a> (pvrvk::Device &amp;device, const pvrvk::Surface &amp;surface, pvr::DisplayAttributes &amp;displayAttributes, pvrvk::Swapchain &amp;outSwapchain, Multi&lt; pvrvk::ImageView &gt; &amp;outDepthStencil, pvrvk::Format *preferredColorFormats, uint32_t numColorFormats, pvrvk::Format *preferredDepthStencilFormats, uint32_t numDepthStencilFormats, const pvrvk::ImageUsageFlags &amp;swapchainImageUsageFlags=pvrvk::ImageUsageFlags::e_COLOR_ATTACHMENT_BIT, const pvrvk::ImageUsageFlags &amp;dsImageUsageFlags=pvrvk::ImageUsageFlags::e_DEPTH_STENCIL_ATTACHMENT_BIT|pvrvk::ImageUsageFlags::e_TRANSIENT_ATTACHMENT_BIT, vma::Allocator *dsImageAllocator=nullptr, vma::AllocationCreateFlags dsImageAllocationCreateFlags=vma::AllocationCreateFlags::e_DEDICATED_MEMORY_BIT)</td></tr>
<tr class="memdesc:a21012ef6146e3eb4d55ac09d0be368fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a pvrvk::Swapchain and corresponding number of depth stencil images using a pre-initialised pvrvk::Device and pvrvk::Surface choosing the color and depth stencil format of the images created from the specified list of preferred color and depth stencil formats. <a href="#a21012ef6146e3eb4d55ac09d0be368fd">More...</a><br/></td></tr>
<tr class="separator:a21012ef6146e3eb4d55ac09d0be368fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac465db7e64f04859a445aa67db5020b3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1utils.html#ac465db7e64f04859a445aa67db5020b3">createSwapchainAndDepthStencilImageAndViews</a> (pvrvk::Device &amp;device, const pvrvk::Surface &amp;surface, pvr::DisplayAttributes &amp;displayAttributes, pvrvk::Swapchain &amp;outSwapchain, Multi&lt; pvrvk::ImageView &gt; &amp;outDepthStencil, const pvrvk::ImageUsageFlags &amp;swapchainImageUsageFlags=pvrvk::ImageUsageFlags::e_COLOR_ATTACHMENT_BIT, const pvrvk::ImageUsageFlags &amp;dsImageUsageFlags=pvrvk::ImageUsageFlags::e_DEPTH_STENCIL_ATTACHMENT_BIT|pvrvk::ImageUsageFlags::e_TRANSIENT_ATTACHMENT_BIT, vma::Allocator *dsImageAllocator=nullptr, vma::AllocationCreateFlags dsImageAllocationCreateFlags=vma::AllocationCreateFlags::e_DEDICATED_MEMORY_BIT)</td></tr>
<tr class="memdesc:ac465db7e64f04859a445aa67db5020b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a pvrvk::Swapchain and corresponding number of depth stencil images using a pre-initialised pvrvk::Device and pvrvk::Surface. <a href="#ac465db7e64f04859a445aa67db5020b3">More...</a><br/></td></tr>
<tr class="separator:ac465db7e64f04859a445aa67db5020b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d3d1522b9db9f69b91090f918ccc8c0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1utils.html#a5d3d1522b9db9f69b91090f918ccc8c0">generateTextureAtlas</a> (pvrvk::Device &amp;device, const pvrvk::Image *inputImages, pvrvk::Rect2Df *outUVs, uint32_t numImages, pvrvk::ImageLayout inputImageLayout, pvrvk::ImageView *outImageView, TextureHeader *outDescriptor, pvrvk::CommandBufferBase cmdBuffer, pvrvk::ImageLayout finalLayout=pvrvk::ImageLayout::e_SHADER_READ_ONLY_OPTIMAL, vma::Allocator *imageAllocator=nullptr, vma::AllocationCreateFlags imageAllocationCreateFlags=vma::AllocationCreateFlags::e_NONE)</td></tr>
<tr class="memdesc:a5d3d1522b9db9f69b91090f918ccc8c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility function for generating a texture atlas based on a set of images. <a href="#a5d3d1522b9db9f69b91090f918ccc8c0">More...</a><br/></td></tr>
<tr class="separator:a5d3d1522b9db9f69b91090f918ccc8c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a811320035b806bb4e727d9ffc7f68873"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1utils.html#a811320035b806bb4e727d9ffc7f68873">getGlErrorString</a> (GLuint apiError)</td></tr>
<tr class="memdesc:a811320035b806bb4e727d9ffc7f68873"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves a string representation of an OpenGLES error code. <a href="#a811320035b806bb4e727d9ffc7f68873">More...</a><br/></td></tr>
<tr class="separator:a811320035b806bb4e727d9ffc7f68873"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6bbf98fde377992e9e7e0d23f38a9dcc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1utils.html#a6bbf98fde377992e9e7e0d23f38a9dcc">getMemoryTypeIndex</a> (const pvrvk::PhysicalDevice &amp;physicalDevice, const uint32_t allowedMemoryTypeBits, const pvrvk::MemoryPropertyFlags requiredMemoryProperties, const pvrvk::MemoryPropertyFlags optimalMemoryProperties, uint32_t &amp;outMemoryTypeIndex, pvrvk::MemoryPropertyFlags &amp;outMemoryPropertyFlags)</td></tr>
<tr class="memdesc:a6bbf98fde377992e9e7e0d23f38a9dcc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility function for retrieving a memory type index for a suitable memory type which supports the memory type bits specified. If the optimal set of memory properties are supported then return the corresponding memory type index otherwise check for availablility of the required set of memory properties. This allows for implementations to optionally request the use of a more optimal set of memory properties whilst still preserving the ability to retrieve the required set of memory properties as a fallback. <a href="#a6bbf98fde377992e9e7e0d23f38a9dcc">More...</a><br/></td></tr>
<tr class="separator:a6bbf98fde377992e9e7e0d23f38a9dcc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad17214254f1b21d40271dac7b2a4b691"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1utils.html#ad17214254f1b21d40271dac7b2a4b691">getOpenGLFormat</a> (PixelFormat pixelFormat, ColorSpace colorSpace, VariableType dataType, uint32_t &amp;glInternalFormat, uint32_t &amp;glFormat, uint32_t &amp;glType, uint32_t &amp;glTypeSize, bool &amp;isCompressedFormat)</td></tr>
<tr class="memdesc:ad17214254f1b21d40271dac7b2a4b691"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the OpenGL ES texture formats for a texture with pvr::PixelFormat pixelFormat, pvr::ColorSpace colorSpace and pvr::VariableType dataType. <a href="#ad17214254f1b21d40271dac7b2a4b691">More...</a><br/></td></tr>
<tr class="separator:ad17214254f1b21d40271dac7b2a4b691"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a291e4ede9083ee35cc595b7775a6f41c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1utils.html#a291e4ede9083ee35cc595b7775a6f41c">getOpenGLFormat</a> (ImageStorageFormat storageFormat, uint32_t &amp;glInternalFormat, uint32_t &amp;glFormat, uint32_t &amp;glType, uint32_t &amp;glTypeSize, bool &amp;isCompressedFormat)</td></tr>
<tr class="memdesc:a291e4ede9083ee35cc595b7775a6f41c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the OpenGL ES texture formats for a texture with the provided ImageStorageFormat. <a href="#a291e4ede9083ee35cc595b7775a6f41c">More...</a><br/></td></tr>
<tr class="separator:a291e4ede9083ee35cc595b7775a6f41c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9faeae4c6a35b0080b0b6031151e53e2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1utils.html#a9faeae4c6a35b0080b0b6031151e53e2">getOpenGLStorageFormat</a> (PixelFormat pixelFormat, ColorSpace colorSpace, VariableType dataType, GLenum &amp;glInternalFormat)</td></tr>
<tr class="memdesc:a9faeae4c6a35b0080b0b6031151e53e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the internal OpenGL ES texture format for a texture with pvr::PixelFormat pixelFormat, pvr::ColorSpace colorSpace and pvr::VariableType dataType. <a href="#a9faeae4c6a35b0080b0b6031151e53e2">More...</a><br/></td></tr>
<tr class="separator:a9faeae4c6a35b0080b0b6031151e53e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71a6472c33618ce49ded8e029b463429"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1utils.html#a71a6472c33618ce49ded8e029b463429">getOpenGLStorageFormat</a> (ImageStorageFormat storageFormat, GLenum &amp;glInternalFormat)</td></tr>
<tr class="memdesc:a71a6472c33618ce49ded8e029b463429"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the internal OpenGL ES texture formats for a texture with the provided ImageStorageFormat. <a href="#a71a6472c33618ce49ded8e029b463429">More...</a><br/></td></tr>
<tr class="separator:a71a6472c33618ce49ded8e029b463429"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3555f264beaaf83ff1b84853a87a40fe"><td class="memItemLeft" align="right" valign="top">glm::mat4&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1utils.html#a3555f264beaaf83ff1b84853a87a40fe">getPerspectiveMatrix</a> (float fovy, float aspect, float near1, float far1, float rotate=.0f)</td></tr>
<tr class="memdesc:a3555f264beaaf83ff1b84853a87a40fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create perspective matrix that trasform scenes that use Opengl Convention (+y up) to Vulkan Convention (+y down). <a href="#a3555f264beaaf83ff1b84853a87a40fe">More...</a><br/></td></tr>
<tr class="separator:a3555f264beaaf83ff1b84853a87a40fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86a73e3d7095724bd6d9bf4771413323"><td class="memItemLeft" align="right" valign="top">const pvrvk::ImageView &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1utils.html#a86a73e3d7095724bd6d9bf4771413323">getResult</a> ()</td></tr>
<tr class="memdesc:a86a73e3d7095724bd6d9bf4771413323"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the result of the asynchronous image upload. <a href="#a86a73e3d7095724bd6d9bf4771413323">More...</a><br/></td></tr>
<tr class="separator:a86a73e3d7095724bd6d9bf4771413323"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7151c7b74ff657fc17ff09c0ab114a07"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1utils.html#a7151c7b74ff657fc17ff09c0ab114a07">isFormatDepthStencil</a> (pvrvk::Format format)</td></tr>
<tr class="memdesc:a7151c7b74ff657fc17ff09c0ab114a07"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if the format is a depth stencil format <a href="#a7151c7b74ff657fc17ff09c0ab114a07">More...</a><br/></td></tr>
<tr class="separator:a7151c7b74ff657fc17ff09c0ab114a07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59222cc49624a76fab4d4f65e3337ac3"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1utils.html#a59222cc49624a76fab4d4f65e3337ac3">isImageUsageSupportedBySurface</a> (const pvrvk::SurfaceCapabilitiesKHR &amp;surfaceCapabilities, pvrvk::ImageUsageFlags imageUsage)</td></tr>
<tr class="memdesc:a59222cc49624a76fab4d4f65e3337ac3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility function used to determine whether the SurfaceCapabilitiesKHR supportedUsageFlags member contains the specified image usage and therefore can be used in the intended way. <a href="#a59222cc49624a76fab4d4f65e3337ac3">More...</a><br/></td></tr>
<tr class="separator:a59222cc49624a76fab4d4f65e3337ac3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ad37dc22982184696fa727a91a4d463"><td class="memItemLeft" align="right" valign="top">pvrvk::Image&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1utils.html#a7ad37dc22982184696fa727a91a4d463">loadAndUploadImage</a> (pvrvk::Device &amp;device, const char *fileName, bool allowDecompress, pvrvk::CommandBuffer &amp;commandBuffer, IAssetProvider &amp;assetProvider, pvrvk::ImageUsageFlags usageFlags=pvrvk::ImageUsageFlags::e_SAMPLED_BIT, pvrvk::ImageLayout finalLayout=pvrvk::ImageLayout::e_GENERAL, Texture *outAssetTexture=nullptr, vma::Allocator *stagingBufferAllocator=nullptr, vma::Allocator *imageAllocator=nullptr, vma::AllocationCreateFlags imageAllocationCreateFlags=vma::AllocationCreateFlags::e_NONE)</td></tr>
<tr class="memdesc:a7ad37dc22982184696fa727a91a4d463"><td class="mdescLeft">&#160;</td><td class="mdescRight">Load and upload image to gpu. The upload command and staging buffers are recorded in the commandbuffer. <a href="#a7ad37dc22982184696fa727a91a4d463">More...</a><br/></td></tr>
<tr class="separator:a7ad37dc22982184696fa727a91a4d463"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad7564a93a69f0c6abe5eaa255f73067"><td class="memItemLeft" align="right" valign="top">pvrvk::Image&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1utils.html#aad7564a93a69f0c6abe5eaa255f73067">loadAndUploadImage</a> (pvrvk::Device &amp;device, const char *fileName, bool allowDecompress, pvrvk::SecondaryCommandBuffer &amp;commandBuffer, IAssetProvider &amp;assetProvider, pvrvk::ImageUsageFlags usageFlags=pvrvk::ImageUsageFlags::e_SAMPLED_BIT, pvrvk::ImageLayout finalLayout=pvrvk::ImageLayout::e_GENERAL, Texture *outAssetTexture=nullptr, vma::Allocator *stagingBufferAllocator=nullptr, vma::Allocator *imageAllocator=nullptr, vma::AllocationCreateFlags imageAllocationCreateFlags=vma::AllocationCreateFlags::e_NONE)</td></tr>
<tr class="memdesc:aad7564a93a69f0c6abe5eaa255f73067"><td class="mdescLeft">&#160;</td><td class="mdescRight">Load and upload image to gpu. The upload command and staging buffers are recorded in the commandbuffer. <a href="#aad7564a93a69f0c6abe5eaa255f73067">More...</a><br/></td></tr>
<tr class="separator:aad7564a93a69f0c6abe5eaa255f73067"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8540d26fd007bdb7043485ae4d5d3f7"><td class="memItemLeft" align="right" valign="top">pvrvk::ImageView&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1utils.html#ae8540d26fd007bdb7043485ae4d5d3f7">loadAndUploadImageAndView</a> (pvrvk::Device &amp;device, const char *fileName, bool allowDecompress, pvrvk::CommandBuffer &amp;commandBuffer, IAssetProvider &amp;assetProvider, pvrvk::ImageUsageFlags usageFlags=pvrvk::ImageUsageFlags::e_SAMPLED_BIT, pvrvk::ImageLayout finalLayout=pvrvk::ImageLayout::e_GENERAL, Texture *outAssetTexture=nullptr, vma::Allocator *stagingBufferAllocator=nullptr, vma::Allocator *imageAllocator=nullptr, vma::AllocationCreateFlags imageAllocationCreateFlags=vma::AllocationCreateFlags::e_NONE)</td></tr>
<tr class="memdesc:ae8540d26fd007bdb7043485ae4d5d3f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Load and upload image to gpu. The upload command and staging buffers are recorded in the commandbuffer. <a href="#ae8540d26fd007bdb7043485ae4d5d3f7">More...</a><br/></td></tr>
<tr class="separator:ae8540d26fd007bdb7043485ae4d5d3f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5eab64fb48adc7ccfb4a08224bc6f538"><td class="memItemLeft" align="right" valign="top">pvrvk::ImageView&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1utils.html#a5eab64fb48adc7ccfb4a08224bc6f538">loadAndUploadImageAndView</a> (pvrvk::Device &amp;device, const char *fileName, bool allowDecompress, pvrvk::SecondaryCommandBuffer &amp;commandBuffer, IAssetProvider &amp;assetProvider, pvrvk::ImageUsageFlags usageFlags=pvrvk::ImageUsageFlags::e_SAMPLED_BIT, pvrvk::ImageLayout finalLayout=pvrvk::ImageLayout::e_GENERAL, Texture *outAssetTexture=nullptr, vma::Allocator *stagingBufferAllocator=nullptr, vma::Allocator *imageAllocator=nullptr, vma::AllocationCreateFlags imageAllocationCreateFlags=vma::AllocationCreateFlags::e_NONE)</td></tr>
<tr class="memdesc:a5eab64fb48adc7ccfb4a08224bc6f538"><td class="mdescLeft">&#160;</td><td class="mdescRight">Load and upload image to gpu. The upload command and staging buffers are recorded in the commandbuffer. <a href="#a5eab64fb48adc7ccfb4a08224bc6f538">More...</a><br/></td></tr>
<tr class="separator:a5eab64fb48adc7ccfb4a08224bc6f538"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4067540852cf8dd4277248b1d0170683"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1utils.html#a4067540852cf8dd4277248b1d0170683">loadNow</a> ()</td></tr>
<tr class="memdesc:a4067540852cf8dd4277248b1d0170683"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initiates the asynchronous image upload. <a href="#a4067540852cf8dd4277248b1d0170683">More...</a><br/></td></tr>
<tr class="separator:a4067540852cf8dd4277248b1d0170683"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6587db0405c15cfceeb768f0a740dca"><td class="memItemLeft" align="right" valign="top">GLuint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1utils.html#ab6587db0405c15cfceeb768f0a740dca">loadShader</a> (const Stream &amp;shaderSource, ShaderType shaderType, const char *const *defines, uint32_t numDefines)</td></tr>
<tr class="memdesc:ab6587db0405c15cfceeb768f0a740dca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Load shader from shader source. Will implicitly load on the current context. <a href="#ab6587db0405c15cfceeb768f0a740dca">More...</a><br/></td></tr>
<tr class="separator:ab6587db0405c15cfceeb768f0a740dca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1cbbbd1665449ea70d772de63595c806"><td class="memItemLeft" align="right" valign="top">VKAPI_ATTR VkBool32 VKAPI_CALL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1utils.html#a1cbbbd1665449ea70d772de63595c806">logMessageDebugReportCallback</a> (VkDebugReportFlagsEXT flags, VkDebugReportObjectTypeEXT objectType, uint64_t object, size_t location, int32_t messageCode, const char *pLayerPrefix, const char *pMessage, void *pUserData)</td></tr>
<tr class="memdesc:a1cbbbd1665449ea70d772de63595c806"><td class="mdescLeft">&#160;</td><td class="mdescRight">An application DebugReportCallback function providing logging for various events. <a href="#a1cbbbd1665449ea70d772de63595c806">More...</a><br/></td></tr>
<tr class="separator:a1cbbbd1665449ea70d772de63595c806"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adca914d6eedd686a81a4f0e4cbbc3390"><td class="memItemLeft" align="right" valign="top">LogLevel&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1utils.html#adca914d6eedd686a81a4f0e4cbbc3390">mapValidationTypeToLogLevel</a> (pvrvk::DebugReportFlagsEXT flags)</td></tr>
<tr class="memdesc:adca914d6eedd686a81a4f0e4cbbc3390"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maps a set of VkDebugReportFlagsEXT to a particular type of log message. <a href="#adca914d6eedd686a81a4f0e4cbbc3390">More...</a><br/></td></tr>
<tr class="separator:adca914d6eedd686a81a4f0e4cbbc3390"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98e4ac9990af6eaf6b9bf0928f2bd07d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1utils.html#a98e4ac9990af6eaf6b9bf0928f2bd07d">populateClearValues</a> (const pvrvk::RenderPass &amp;renderpass, const pvrvk::ClearValue &amp;clearColor, const pvrvk::ClearValue &amp;clearDepthStencilValue, pvrvk::ClearValue *outClearValues)</td></tr>
<tr class="memdesc:a98e4ac9990af6eaf6b9bf0928f2bd07d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Populate color and depthstencil clear values <a href="#a98e4ac9990af6eaf6b9bf0928f2bd07d">More...</a><br/></td></tr>
<tr class="separator:a98e4ac9990af6eaf6b9bf0928f2bd07d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40ca7bc0dc1b494e3b13e654bf582012"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1utils.html#a40ca7bc0dc1b494e3b13e654bf582012">populateInputAssemblyFromMesh</a> (const assets::Mesh &amp;mesh, const <a class="el" href="structpvr_1_1utils_1_1_vertex_bindings.html">VertexBindings</a> *bindingMap, uint16_t numBindings, pvrvk::PipelineVertexInputStateCreateInfo &amp;vertexCreateInfo, pvrvk::InputAssemblerStateCreateInfo &amp;inputAssemblerCreateInfo, uint16_t *numOutBuffers=nullptr)</td></tr>
<tr class="memdesc:a40ca7bc0dc1b494e3b13e654bf582012"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fills out input assembly and vertex input state structures using a mesh and a list of corresponding <a class="el" href="structpvr_1_1utils_1_1_vertex_bindings.html" title="Represents a shader Explicit binding, tying a Semantic name to an Attribute Index.">VertexBindings</a>. <a href="#a40ca7bc0dc1b494e3b13e654bf582012">More...</a><br/></td></tr>
<tr class="separator:a40ca7bc0dc1b494e3b13e654bf582012"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf7346cd6cd2ef2705d14ab35284f045"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1utils.html#adf7346cd6cd2ef2705d14ab35284f045">populateInputAssemblyFromMesh</a> (const assets::Mesh &amp;mesh, const <a class="el" href="structpvr_1_1utils_1_1_vertex_bindings___name.html">VertexBindings_Name</a> *bindingMap, uint16_t numBindings, pvrvk::PipelineVertexInputStateCreateInfo &amp;vertexCreateInfo, pvrvk::InputAssemblerStateCreateInfo &amp;inputAssemblerCreateInfo, uint16_t *numOutBuffers=nullptr)</td></tr>
<tr class="memdesc:adf7346cd6cd2ef2705d14ab35284f045"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fills out input assembly and vertex input state structures using a mesh and a list of corresponding <a class="el" href="structpvr_1_1utils_1_1_vertex_bindings___name.html" title="Represents a shader Reflective binding, tying a Semantic name to an Attribute variable name...">VertexBindings_Name</a>. <a href="#adf7346cd6cd2ef2705d14ab35284f045">More...</a><br/></td></tr>
<tr class="separator:adf7346cd6cd2ef2705d14ab35284f045"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0688d6e1f181259f4000994896d5157b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1utils.html#a0688d6e1f181259f4000994896d5157b">populateViewportStateCreateInfo</a> (const pvrvk::Framebuffer &amp;framebuffer, pvrvk::ViewportStateCreateInfo &amp;outCreateInfo)</td></tr>
<tr class="memdesc:a0688d6e1f181259f4000994896d5157b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fills out a pvrvk::ViewportStateCreateInfo structure setting parameters for a 'default' viewport and scissor based on the specified frame buffer dimensions. <a href="#a0688d6e1f181259f4000994896d5157b">More...</a><br/></td></tr>
<tr class="separator:a0688d6e1f181259f4000994896d5157b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abca543a0c306d801f96b0cc6af848371"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1utils.html#abca543a0c306d801f96b0cc6af848371">saveImage</a> (pvrvk::Image image, const pvrvk::ImageLayout imageInitialLayout, const pvrvk::ImageLayout imageFinalLayout, pvrvk::CommandPool &amp;pool, pvrvk::Queue &amp;queue, const std::string &amp;filename, vma::Allocator *bufferAllocator=nullptr, vma::Allocator *imageAllocator=nullptr, const uint32_t screenshotScale=1)</td></tr>
<tr class="memdesc:abca543a0c306d801f96b0cc6af848371"><td class="mdescLeft">&#160;</td><td class="mdescRight">Saves the input image as a TGA file with the filename specified. Note that the image must have been created with the pvrvk::ImageUsageFlags::e_TRANSFER_SRC_BIT set. <a href="#abca543a0c306d801f96b0cc6af848371">More...</a><br/></td></tr>
<tr class="separator:abca543a0c306d801f96b0cc6af848371"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a199d0b69632a76610e1f3f5c92289cfd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1utils.html#a199d0b69632a76610e1f3f5c92289cfd">setCallBack</a> (CallbackType callback)</td></tr>
<tr class="memdesc:a199d0b69632a76610e1f3f5c92289cfd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets a callback which will be called after the image upload has completed. <a href="#a199d0b69632a76610e1f3f5c92289cfd">More...</a><br/></td></tr>
<tr class="separator:a199d0b69632a76610e1f3f5c92289cfd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ea166ded6ff46a11573815a99f42869"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1utils.html#a8ea166ded6ff46a11573815a99f42869">setImageLayout</a> (pvrvk::Image image, pvrvk::ImageLayout oldLayout, pvrvk::ImageLayout newLayout, pvrvk::CommandBufferBase transitionCmdBuffer)</td></tr>
<tr class="memdesc:a8ea166ded6ff46a11573815a99f42869"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set image layout <a href="#a8ea166ded6ff46a11573815a99f42869">More...</a><br/></td></tr>
<tr class="separator:a8ea166ded6ff46a11573815a99f42869"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5aa9ef93f949ec94122ac1f5d915f8a0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1utils.html#a5aa9ef93f949ec94122ac1f5d915f8a0">setImageLayoutAndQueueFamilyOwnership</a> (pvrvk::CommandBufferBase srccmd, pvrvk::CommandBufferBase dstcmd, uint32_t srcQueueFamily, uint32_t dstQueueFamily, pvrvk::ImageLayout oldLayout, pvrvk::ImageLayout newLayout, pvrvk::Image image, uint32_t baseMipLevel, uint32_t numMipLevels, uint32_t baseArrayLayer, uint32_t numArrayLayers, pvrvk::ImageAspectFlags aspect)</td></tr>
<tr class="memdesc:a5aa9ef93f949ec94122ac1f5d915f8a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set image layout and queue family ownership <a href="#a5aa9ef93f949ec94122ac1f5d915f8a0">More...</a><br/></td></tr>
<tr class="separator:a5aa9ef93f949ec94122ac1f5d915f8a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22821a94e895873a43ffa097381a1415"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1utils.html#a22821a94e895873a43ffa097381a1415">takeScreenshot</a> (pvrvk::Swapchain &amp;swapChain, const uint32_t swapIndex, pvrvk::CommandPool &amp;pool, pvrvk::Queue &amp;queue, const std::string &amp;screenshotFileName, vma::Allocator *bufferAllocator=nullptr, vma::Allocator *imageAllocator=nullptr, const uint32_t screenshotScale=1)</td></tr>
<tr class="memdesc:a22821a94e895873a43ffa097381a1415"><td class="mdescLeft">&#160;</td><td class="mdescRight">Saves a particular swapchain image corresponding to the swapchain image at index swapIndex for the swapChain. <a href="#a22821a94e895873a43ffa097381a1415">More...</a><br/></td></tr>
<tr class="separator:a22821a94e895873a43ffa097381a1415"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adac9f0af2d041d5efe3f668f87c6932b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structpvr_1_1utils_1_1_texture_upload_results.html">TextureUploadResults</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1utils.html#adac9f0af2d041d5efe3f668f87c6932b">textureUpload</a> (const Texture &amp;texture, bool isEs2, bool allowDecompress)</td></tr>
<tr class="memdesc:adac9f0af2d041d5efe3f668f87c6932b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Upload a texture to the GPU on the current context, and return it as part of the <a class="el" href="structpvr_1_1utils_1_1_texture_upload_results.html" title="The TextureUploadResults structure provides the results for texture upload functions in a simple to u...">TextureUploadResults</a> structure. <a href="#adac9f0af2d041d5efe3f668f87c6932b">More...</a><br/></td></tr>
<tr class="separator:adac9f0af2d041d5efe3f668f87c6932b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54f2bb511b50d2c11ddc7377a60714ad"><td class="memItemLeft" align="right" valign="top">VKAPI_ATTR VkBool32 VKAPI_CALL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1utils.html#a54f2bb511b50d2c11ddc7377a60714ad">throwOnErrorDebugReportCallback</a> (VkDebugReportFlagsEXT flags, VkDebugReportObjectTypeEXT objectType, uint64_t object, size_t location, int32_t messageCode, const char *pLayerPrefix, const char *pMessage, void *pUserData)</td></tr>
<tr class="memdesc:a54f2bb511b50d2c11ddc7377a60714ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">An application DebugReportCallback function providing logging for various events. The callback will also throw an exception when VkDebugReportFlagsEXT includes the VK_DEBUG_REPORT_ERROR_BIT_EXT. <a href="#a54f2bb511b50d2c11ddc7377a60714ad">More...</a><br/></td></tr>
<tr class="separator:a54f2bb511b50d2c11ddc7377a60714ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60f28cc84ae08ec7d3c050c8f9725d88"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1utils.html#a60f28cc84ae08ec7d3c050c8f9725d88">throwOnGlError</a> (const char *note, LogLevel severity=LogLevel::Error)</td></tr>
<tr class="memdesc:a60f28cc84ae08ec7d3c050c8f9725d88"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks and logs api errors if appropriate. <a href="#a60f28cc84ae08ec7d3c050c8f9725d88">More...</a><br/></td></tr>
<tr class="separator:a60f28cc84ae08ec7d3c050c8f9725d88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac885b6f537cb86c114be6696c3dc2fb6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1utils.html#ac885b6f537cb86c114be6696c3dc2fb6">updateBufferUsingStagingBuffer</a> (pvrvk::Device &amp;device, pvrvk::Buffer &amp;buffer, pvrvk::CommandBufferBase uploadCmdBuffer, const void *data, VkDeviceSize offset=0, VkDeviceSize size=VK_WHOLE_SIZE, vma::Allocator *stagingBufferAllocator=nullptr)</td></tr>
<tr class="memdesc:ac885b6f537cb86c114be6696c3dc2fb6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility function to update a buffer's data via an indirect copy from a temporary staging buffer. Updating memory via the use of a staging buffer is necessary when using memory without e_HOST_VISIBLE_BIT memory property flags meaning the buffer itself cannot be mapped to host memory. <a href="#ac885b6f537cb86c114be6696c3dc2fb6">More...</a><br/></td></tr>
<tr class="separator:ac885b6f537cb86c114be6696c3dc2fb6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a618e4160bd8c24d9e0d394dc9511f4a3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1utils.html#a618e4160bd8c24d9e0d394dc9511f4a3">updateHostVisibleBuffer</a> (pvrvk::Buffer &amp;buffer, const void *data, VkDeviceSize offset=0, VkDeviceSize size=VK_WHOLE_SIZE, bool flushMemory=false)</td></tr>
<tr class="memdesc:a618e4160bd8c24d9e0d394dc9511f4a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility function to update a buffer's data. This function maps and unmap the buffer only if the buffer is not already mapped. <a href="#a618e4160bd8c24d9e0d394dc9511f4a3">More...</a><br/></td></tr>
<tr class="separator:a618e4160bd8c24d9e0d394dc9511f4a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71cc4019e6c6315a8a714f4103bfe503"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1utils.html#a71cc4019e6c6315a8a714f4103bfe503">updateImage</a> (pvrvk::Device &amp;device, pvrvk::CommandBufferBase transferCommandBuffer, <a class="el" href="structpvr_1_1utils_1_1_image_update_info.html">ImageUpdateInfo</a> *updateInfos, uint32_t numUpdateInfos, pvrvk::Format format, pvrvk::ImageLayout layout, bool isCubeMap, pvrvk::Image &amp;image, vma::Allocator *bufferAllocator=nullptr)</td></tr>
<tr class="memdesc:a71cc4019e6c6315a8a714f4103bfe503"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility function to update an image's data. This function will record the update of the image in the supplied command buffer but NOT submit the command buffer, hence allowing the user to submit it at his own time. IMPORTANT. Assumes image layout is pvrvk::ImageLayout::e_DST_OPTIMAL IMPORTANT. The cleanup object that is the return value of the function must be kept alive as long until the moment that the relevant command buffer submission is finished. Then it can be destroyed (or the cleanup function be called) to free any relevant resources. <a href="#a71cc4019e6c6315a8a714f4103bfe503">More...</a><br/></td></tr>
<tr class="separator:a71cc4019e6c6315a8a714f4103bfe503"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23e2bd58f63311d085500c45a565368e"><td class="memItemLeft" align="right" valign="top">pvrvk::ImageView&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1utils.html#a23e2bd58f63311d085500c45a565368e">uploadImageAndView</a> (pvrvk::Device &amp;device, const Texture &amp;texture, bool allowDecompress, pvrvk::SecondaryCommandBuffer &amp;commandBuffer, pvrvk::ImageUsageFlags usageFlags=pvrvk::ImageUsageFlags::e_SAMPLED_BIT, pvrvk::ImageLayout finalLayout=pvrvk::ImageLayout::e_GENERAL, vma::Allocator *stagingBufferAllocator=nullptr, vma::Allocator *imageAllocator=nullptr, vma::AllocationCreateFlags imageAllocationCreateFlags=vma::AllocationCreateFlags::e_NONE)</td></tr>
<tr class="memdesc:a23e2bd58f63311d085500c45a565368e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Uploads an image to gpu. The upload command and staging buffers are recorded in the commandbuffer. <a href="#a23e2bd58f63311d085500c45a565368e">More...</a><br/></td></tr>
<tr class="separator:a23e2bd58f63311d085500c45a565368e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ada7cce97f2cb51b083c26b5b0cfa09"><td class="memItemLeft" align="right" valign="top">pvrvk::ImageView&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1utils.html#a6ada7cce97f2cb51b083c26b5b0cfa09">uploadImageAndView</a> (pvrvk::Device &amp;device, const Texture &amp;texture, bool allowDecompress, pvrvk::CommandBuffer &amp;commandBuffer, pvrvk::ImageUsageFlags usageFlags=pvrvk::ImageUsageFlags::e_SAMPLED_BIT, pvrvk::ImageLayout finalLayout=pvrvk::ImageLayout::e_GENERAL, vma::Allocator *stagingBufferAllocator=nullptr, vma::Allocator *imageAllocator=nullptr, vma::AllocationCreateFlags imageAllocationCreateFlags=vma::AllocationCreateFlags::e_NONE)</td></tr>
<tr class="memdesc:a6ada7cce97f2cb51b083c26b5b0cfa09"><td class="mdescLeft">&#160;</td><td class="mdescRight">Upload image to gpu. The upload command and staging buffers are recorded in the commandbuffer. <a href="#a6ada7cce97f2cb51b083c26b5b0cfa09">More...</a><br/></td></tr>
<tr class="separator:a6ada7cce97f2cb51b083c26b5b0cfa09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59dd0ec7054d10491117326027890b2d"><td class="memItemLeft" align="right" valign="top">pvrvk::ImageView&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1utils.html#a59dd0ec7054d10491117326027890b2d">uploadImageAndViewSubmit</a> (pvrvk::Device &amp;device, const Texture &amp;texture, bool allowDecompress, pvrvk::CommandPool &amp;cmdPool, pvrvk::Queue &amp;queue, pvrvk::ImageUsageFlags usageFlags=pvrvk::ImageUsageFlags::e_SAMPLED_BIT, pvrvk::ImageLayout finalLayout=pvrvk::ImageLayout::e_GENERAL, vma::Allocator *stagingBufferAllocator=nullptr, vma::Allocator *imageAllocator=nullptr, vma::AllocationCreateFlags imageAllocationCreateFlags=vma::AllocationCreateFlags::e_NONE)</td></tr>
<tr class="memdesc:a59dd0ec7054d10491117326027890b2d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Uploads an image to GPU memory and returns the created image view and associated image. <a href="#a59dd0ec7054d10491117326027890b2d">More...</a><br/></td></tr>
<tr class="separator:a59dd0ec7054d10491117326027890b2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:aacd4b515e14632522eae706ff158bd86"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1utils.html#aacd4b515e14632522eae706ff158bd86">_allowDecompress</a></td></tr>
<tr class="memdesc:aacd4b515e14632522eae706ff158bd86"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specifies whether the uploaded texture can be decompressed as it is uploaded. <a href="#aacd4b515e14632522eae706ff158bd86">More...</a><br/></td></tr>
<tr class="separator:aacd4b515e14632522eae706ff158bd86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6d2b1c139e95706757d4732dddf1f9c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1utils.html#ae6d2b1c139e95706757d4732dddf1f9c">_callbackBeforeSignal</a></td></tr>
<tr class="memdesc:ae6d2b1c139e95706757d4732dddf1f9c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specifies whether the callback should be called prior to signalling the completion of the image upload. <a href="#ae6d2b1c139e95706757d4732dddf1f9c">More...</a><br/></td></tr>
<tr class="separator:ae6d2b1c139e95706757d4732dddf1f9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19d81d0ce15542804a4581ea0d31a3fd"><td class="memItemLeft" align="right" valign="top">pvrvk::CommandPool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1utils.html#a19d81d0ce15542804a4581ea0d31a3fd">_cmdPool</a></td></tr>
<tr class="memdesc:a19d81d0ce15542804a4581ea0d31a3fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">A command pool from which comand buffers will be allocated to record image upload operations. <a href="#a19d81d0ce15542804a4581ea0d31a3fd">More...</a><br/></td></tr>
<tr class="separator:a19d81d0ce15542804a4581ea0d31a3fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64d41557fce438c8d8a841ebba30d03a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a64d41557fce438c8d8a841ebba30d03a"></a>
async::Mutex *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1utils.html#a64d41557fce438c8d8a841ebba30d03a">_cmdQueueMutex</a></td></tr>
<tr class="memdesc:a64d41557fce438c8d8a841ebba30d03a"><td class="mdescLeft">&#160;</td><td class="mdescRight">A semaphore used to guard access to submitting to the CommandQueue. <br/></td></tr>
<tr class="separator:a64d41557fce438c8d8a841ebba30d03a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad4b96895412bd162eccba2a845d55b0"><td class="memItemLeft" align="right" valign="top">pvrvk::Device&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1utils.html#aad4b96895412bd162eccba2a845d55b0">_device</a></td></tr>
<tr class="memdesc:aad4b96895412bd162eccba2a845d55b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">A _device to be used for creating temporary resources required for uploading an image. <a href="#aad4b96895412bd162eccba2a845d55b0">More...</a><br/></td></tr>
<tr class="separator:aad4b96895412bd162eccba2a845d55b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3de060441aca544adf3e57040fb26d0"><td class="memItemLeft" align="right" valign="top">pvrvk::Queue&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1utils.html#ab3de060441aca544adf3e57040fb26d0">_queue</a></td></tr>
<tr class="memdesc:ab3de060441aca544adf3e57040fb26d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">A queue to be used to submit image upload operations. <a href="#ab3de060441aca544adf3e57040fb26d0">More...</a><br/></td></tr>
<tr class="separator:ab3de060441aca544adf3e57040fb26d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0cf21868c56c418e1d7d58b046ae8a7b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0cf21868c56c418e1d7d58b046ae8a7b"></a>
pvrvk::ImageView&#160;</td><td class="memItemRight" valign="bottom"><b>_result</b></td></tr>
<tr class="separator:a0cf21868c56c418e1d7d58b046ae8a7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18aec86ff303d8fff3bacea5c2c0880d"><td class="memItemLeft" align="right" valign="top">async::SemaphorePtr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1utils.html#a18aec86ff303d8fff3bacea5c2c0880d">_resultSemaphore</a></td></tr>
<tr class="memdesc:a18aec86ff303d8fff3bacea5c2c0880d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specifies a semaphore which will be signalled at the point the upload of the texture is finished. <a href="#a18aec86ff303d8fff3bacea5c2c0880d">More...</a><br/></td></tr>
<tr class="separator:a18aec86ff303d8fff3bacea5c2c0880d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d05dae5b25d13ac9f23c80c1e4afbb9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacepvr_1_1utils.html#a3f0838b4c2b77e12986b54da8b3bef7b">AsyncTexture</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1utils.html#a2d05dae5b25d13ac9f23c80c1e4afbb9">_texture</a></td></tr>
<tr class="memdesc:a2d05dae5b25d13ac9f23c80c1e4afbb9"><td class="mdescLeft">&#160;</td><td class="mdescRight">A pvr::Texture to asynchronously upload to the Gpu. <a href="#a2d05dae5b25d13ac9f23c80c1e4afbb9">More...</a><br/></td></tr>
<tr class="separator:a2d05dae5b25d13ac9f23c80c1e4afbb9"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Main namespace for the PVRUtils Library </p>
</div><h2 class="groupheader">Typedef Documentation</h2>
<a class="anchor" id="a363e04b38078d8c423b35185195f614a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef EmbeddedRefCountedResource&lt;async::IFrameworkAsyncResult&lt;pvrvk::ImageView&gt; &gt; <a class="el" href="namespacepvr_1_1utils.html#a363e04b38078d8c423b35185195f614a">pvr::utils::AsyncApiTexture</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Provides a reference counted pointer to a IFrameworkAsyncResult specialised by an ImageView which will be used as the main interface for using API specific asynchronous textures.</p>

</div>
</div>
<a class="anchor" id="a3f0838b4c2b77e12986b54da8b3bef7b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef EmbeddedRefCountedResource&lt;async::IFrameworkAsyncResult&lt;<a class="el" href="namespacepvr_1_1utils.html#a29b5f19aa83276c6b2699da0912d9f84">TexturePtr</a>&gt; &gt; <a class="el" href="namespacepvr_1_1utils.html#a3f0838b4c2b77e12986b54da8b3bef7b">pvr::utils::AsyncTexture</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Provides a reference counted pointer to a IFrameworkAsyncResult specialised by a TexturePtr which will be used as the main interface for using API agnostic asynchronous textures.</p>

</div>
</div>
<a class="anchor" id="a6d76ff5c44e70698baef1dfd19dd90e3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef bool(* pvr::utils::ModelSemanticSetter)(TypedMem &amp;mem, const <a class="el" href="structpvr_1_1utils_1_1_renderman_model.html">RendermanModel</a> &amp;model)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A pointer to a function that sets a specific Model Semantic from the model to the provided memory object</p>

</div>
</div>
<a class="anchor" id="a52ce711be6305e9237b2513013656b90"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef bool(* pvr::utils::NodeSemanticSetter)(TypedMem &amp;mem, const <a class="el" href="structpvr_1_1utils_1_1_renderman_node.html">RendermanNode</a> &amp;node)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A NodeSemanticSetter is a function that sets a specified Semantic to a value. It always applies to a specific semantic, and sources all required information from the node parameter, then writes the new updated value in the mem parameter</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mem</td><td>Output: The new value of the semantic will be written here</td></tr>
    <tr><td class="paramname">node</td><td>The node to get the semantic from</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a29b5f19aa83276c6b2699da0912d9f84"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef RefCountedResource&lt;Texture&gt; <a class="el" href="namespacepvr_1_1utils.html#a29b5f19aa83276c6b2699da0912d9f84">pvr::utils::TexturePtr</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Provides a reference counted pointer to a pvr::Texture which will be used for loading API agnostic texture data to disk.</p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="ac66fa9a9c7f8232c3f5aa3f41106cfea"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VboContainer_ , typename IboContainer_ &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pvr::utils::appendSingleBuffersFromModel </td>
          <td>(</td>
          <td class="paramtype">pvrvk::Device &amp;&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const assets::Model &amp;&#160;</td>
          <td class="paramname"><em>model</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VboContainer_ &amp;&#160;</td>
          <td class="paramname"><em>vbos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IboContainer_ &amp;&#160;</td>
          <td class="paramname"><em>ibos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pvrvk::CommandBuffer &amp;&#160;</td>
          <td class="paramname"><em>uploadCmdBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &amp;&#160;</td>
          <td class="paramname"><em>requiresCommandBufferSubmission</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vma::Allocator *&#160;</td>
          <td class="paramname"><em>bufferAllocator</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vma::AllocationCreateFlags&#160;</td>
          <td class="paramname"><em>vmaAllocationCreateFlags</em> = <code>vma::AllocationCreateFlags::e_MAPPED_BIT</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Auto generates a set of VBOs and a set of IBOs from the vertex data of the meshes of a model and appends them at the end of containers provided by the user.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">device</td><td>The device device where the buffers will be generated on</td></tr>
    <tr><td class="paramname">model</td><td>The model whose meshes will be used to generate the Buffers</td></tr>
    <tr><td class="paramname">vbos</td><td>A container of pvrvk::Buffer handles. The VBOs will be inserted at the end of this container.</td></tr>
    <tr><td class="paramname">ibos</td><td>A container of pvrvk::Buffer handles. The IBOs will be inserted at the end of this container.</td></tr>
    <tr><td class="paramname">uploadCmdBuffer</td><td>A command buffer into which commands may be recorded for uploading mesh data to the created buffers. This command buffer will only be used when memory without e_HOST_VISIBLE_BIT memory property flags was allocated for the vbos or ibos.</td></tr>
    <tr><td class="paramname">requiresCommandBufferSubmission</td><td>Indicates whether commands have been recorded into the given command buffer.</td></tr>
    <tr><td class="paramname">bufferAllocator</td><td>A VMA allocator used to allocate memory for the created buffer.</td></tr>
    <tr><td class="paramname">vmaAllocationCreateFlags</td><td>VMA Allocation creation flags. These flags can be used to control how and where the memory is allocated from. Valid flags include e_DEDICATED_MEMORY_BIT and e_MAPPED_BIT. e_DEDICATED_MEMORY_BIT indicates that the allocation should have its own memory block. e_MAPPED_BIT indicates memory will be persistently mapped respectively. The default vma::AllocationCreateFlags::e_MAPPED_BIT is valid even if HOST_VISIBLE is not used - these flags will be ignored in this case.</td></tr>
  </table>
  </dd>
</dl>
<p>This utility function will read all vertex data from the VBO. It is usually preferred for meshes meshes containing a single set of interleaved data. If multiple data elements (i.e. sets of interleaved data), each block will be successively placed after the other.</p>

</div>
</div>
<a class="anchor" id="aafce526b759924e9114572d863b5b8f6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int pvr::utils::checkApiError </td>
          <td>(</td>
          <td class="paramtype">std::string *&#160;</td>
          <td class="paramname"><em>errOutStr</em> = <code>NULL</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks and returns api error if appropriate.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">errOutStr</td><td>error std::string to be output.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>api error code</dd></dl>

</div>
</div>
<a class="anchor" id="a7b92cb613310549a5b748d1f5c4b4557"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">GLenum pvr::utils::convertToGles </td>
          <td>(</td>
          <td class="paramtype">IndexType&#160;</td>
          <td class="paramname"><em>type</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts from a pvr::IndexType to its OpenGL ES GLenum counterpart.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">type</td><td>The pvr::IndexType to convert.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The OpenGL ES GLenum counterpart to a pvr::IndexType.</dd></dl>

</div>
</div>
<a class="anchor" id="aabfe42ed26ab9fcb99118de82013eedb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GLenum pvr::utils::convertToGles </td>
          <td>(</td>
          <td class="paramtype">Face&#160;</td>
          <td class="paramname"><em>face</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert to opengl face.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">face</td><td>A Face enum</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A GLenum representing a face (GL_FRONT, GL_BACK, GL_FRONT_AND_BACK, GL_NONE)</dd></dl>

</div>
</div>
<a class="anchor" id="a2cf730a0573373abb18dcefa9390e840"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GLenum pvr::utils::convertToGles </td>
          <td>(</td>
          <td class="paramtype">PolygonWindingOrder&#160;</td>
          <td class="paramname"><em>windingOrder</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert to opengl winding-order.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">windingOrder</td><td>A PolygonWindingOrder enum</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A GLenum representing a winding order (GL_CW, GL_CCW)</dd></dl>

</div>
</div>
<a class="anchor" id="a196375d06b5173798e46037c7b8eb890"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GLenum pvr::utils::convertToGles </td>
          <td>(</td>
          <td class="paramtype">CompareOp&#160;</td>
          <td class="paramname"><em>func</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert to opengl comparison mode.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">func</td><td>A ComparisonMode enum</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A GLenum representing a ComparisonMode (GL_LESS, GL_EQUAL etc)</dd></dl>

</div>
</div>
<a class="anchor" id="a648788eddea6a26479db4a04cdeedf55"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GLenum pvr::utils::convertToGles </td>
          <td>(</td>
          <td class="paramtype">ImageAspectFlags&#160;</td>
          <td class="paramname"><em>type</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert to an opengl image aspect type.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">type</td><td>An ImageAspectFlags enum</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A GLenum representing the ImageAspectFlags</dd></dl>

</div>
</div>
<a class="anchor" id="a7d36f28640fc36caaed25f8935a48229"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GLenum pvr::utils::convertToGles </td>
          <td>(</td>
          <td class="paramtype">ImageViewType&#160;</td>
          <td class="paramname"><em>texType</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert to opengl texture type.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">texType</td><td>A TextureDimension enum</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A GLenum representing a texture dimension (GL_TEXTURE_2D, GL_TEXTURE_3D, GL_TEXTURE_CUBE_MAP, GL_TEXTURE_2D_ARRAY)</dd></dl>

</div>
</div>
<a class="anchor" id="ad86cd8604c6d3c155b531d7a1784581f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GLenum pvr::utils::convertToGles </td>
          <td>(</td>
          <td class="paramtype">DataType&#160;</td>
          <td class="paramname"><em>dataType</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert to opengl data type.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dataType</td><td>A DataType enum</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A GLenum representing a DataType (GL_FLOAT, GL_UNSIGNED_BYTE etc)</dd></dl>

</div>
</div>
<a class="anchor" id="a4848cd91db829306bc8a1ed929762aad"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GLenum pvr::utils::convertToGles </td>
          <td>(</td>
          <td class="paramtype">PrimitiveTopology&#160;</td>
          <td class="paramname"><em>primitiveType</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert to opengl priitive type.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">primitiveType</td><td>a PrimitiveTopology enum</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A GLenum representing a primitive type (GL_TRIANGLES, GL_TRIANGLE_STRIP, GL_POINTS etc)</dd></dl>

</div>
</div>
<a class="anchor" id="a3c41ff094638c4216cb39bf821408fe5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GLenum pvr::utils::convertToGles </td>
          <td>(</td>
          <td class="paramtype">SamplerAddressMode&#160;</td>
          <td class="paramname"><em>addressMode</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert to opengl sampler wrap.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">addressMode</td><td>A SamplerAddressMode enum</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A GLenum representing a Sampler Wrap mode (GL_CLAMP_TO_EDGE, GL_REPEAT etc)</dd></dl>

</div>
</div>
<a class="anchor" id="af1dc4d95376bb577dd85455028527815"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GLenum pvr::utils::convertToGles </td>
          <td>(</td>
          <td class="paramtype">StencilOp&#160;</td>
          <td class="paramname"><em>stencilOp</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert to opengl stencil op output.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stencilOp</td><td>A StencilOp enum</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A GLenum representing a Stencil Operation (GL_INC_WRAP, GL_ZERO etc)</dd></dl>

</div>
</div>
<a class="anchor" id="afe32fb89dfe5e37513af651055cdef15"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GLenum pvr::utils::convertToGles </td>
          <td>(</td>
          <td class="paramtype">BlendOp&#160;</td>
          <td class="paramname"><em>blendOp</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert to opengl blend op output.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">blendOp</td><td>Α BlendOp enum</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A GLenum representing a Blend Operation (GL_FUNC_ADD, GL_MIN etc)</dd></dl>

</div>
</div>
<a class="anchor" id="a20ca18b411c83be99cc9b83137cef4d8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GLenum pvr::utils::convertToGles </td>
          <td>(</td>
          <td class="paramtype">BlendFactor&#160;</td>
          <td class="paramname"><em>blendFactor</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert to opengl blend factor output.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">blendFactor</td><td>A BlendFactor enum</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A GLenum representing a BlendFactor (GL_ZERO, GL_SRC_COLOR, GL_ONE_MINUS_SRC_ALPHA etc)</dd></dl>

</div>
</div>
<a class="anchor" id="ad0c9ce4267ec635305fc87aba0b9d9c2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pvr::utils::create3dPlaneMesh </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>depth</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>generateTexCoords</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>generateNormalCoords</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">assets::Mesh &amp;&#160;</td>
          <td class="paramname"><em>outMesh</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a 3d plane mesh based on the width and depth specified. Texture coordinates and normal coordinates can also optionally be generated based on the generateTexCoords and generateNormalCoords flags respectively. The generated mesh will be returned as a pvr::assets::Mesh.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">width</td><td>The width of the plane to generate.</td></tr>
    <tr><td class="paramname">depth</td><td>The depth of the plane to generate.</td></tr>
    <tr><td class="paramname">generateTexCoords</td><td>Specifies whether to generate texture coordinates for the plane.</td></tr>
    <tr><td class="paramname">generateNormalCoords</td><td>Specifies whether to generate normal coordinates for the plane.</td></tr>
    <tr><td class="paramname">outMesh</td><td>The generated pvr::assets::Mesh.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="acecac80786da19a6303dbf72345c16a9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pvrvk::Buffer pvr::utils::createBuffer </td>
          <td>(</td>
          <td class="paramtype">pvrvk::Device&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VkDeviceSize&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pvrvk::BufferUsageFlags&#160;</td>
          <td class="paramname"><em>bufferUsage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pvrvk::MemoryPropertyFlags&#160;</td>
          <td class="paramname"><em>requiredMemoryFlags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pvrvk::MemoryPropertyFlags&#160;</td>
          <td class="paramname"><em>optimalMemoryFlags</em> = <code>pvrvk::MemoryPropertyFlags::e_NONE</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vma::Allocator *&#160;</td>
          <td class="paramname"><em>bufferAllocator</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vma::AllocationCreateFlags&#160;</td>
          <td class="paramname"><em>vmaAllocationCreateFlags</em> = <code>vma::AllocationCreateFlags::e_MAPPED_BIT</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pvrvk::BufferCreateFlags&#160;</td>
          <td class="paramname"><em>bufferCreateFlags</em> = <code>pvrvk::BufferCreateFlags(0)</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pvrvk::SharingMode&#160;</td>
          <td class="paramname"><em>sharingMode</em> = <code>pvrvk::SharingMode::e_EXCLUSIVE</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t *&#160;</td>
          <td class="paramname"><em>queueFamilyIndices</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>numQueueFamilyIndices</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a new buffer object and (optionally) allocate and bind memory for it</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">device</td><td>The device on which to create the buffer</td></tr>
    <tr><td class="paramname">size</td><td>The total size of the buffer</td></tr>
    <tr><td class="paramname">bufferUsage</td><td>All buffer usages for which this buffer will be valid</td></tr>
    <tr><td class="paramname">requiredMemoryFlags</td><td>The minimal set of memory property flags which are required for the PVRVk buffer to be created. If pvrvk::MemoryPropertyFlags::e_NONE is passed, no memory will be allocated for this buffer.</td></tr>
    <tr><td class="paramname">optimalMemoryFlags</td><td>The most optimal set of memory property flags which could be used by the memory backing the returned PVRVk buffer. If pvrvk::MemoryPropertyFlags::e_NONE is passed optimalMemoryFlags will be set to match requiredMemoryFlags.</td></tr>
    <tr><td class="paramname">bufferAllocator</td><td>A VMA allocator used to allocate memory for the created buffer.</td></tr>
    <tr><td class="paramname">vmaAllocationCreateFlags</td><td>VMA Allocation creation flags. These flags can be used to control how and where the memory is allocated from. Valid flags include e_DEDICATED_MEMORY_BIT and e_MAPPED_BIT. e_DEDICATED_MEMORY_BIT indicates that the allocation should have its own memory block. e_MAPPED_BIT indicates memory will be persistently mapped respectively. The default vma::AllocationCreateFlags::e_MAPPED_BIT is valid even if HOST_VISIBLE is not used - these flags will be ignored in this case.</td></tr>
    <tr><td class="paramname">bufferCreateFlags</td><td>Buffer creation flags (see Vulkan spec)</td></tr>
    <tr><td class="paramname">sharingMode</td><td>indicates whether the buffer is exclusive for some queues or can be used simultaneously multiple queues</td></tr>
    <tr><td class="paramname">queueFamilyIndices</td><td>If not exclusive, indicates which queue families the buffer can be used by</td></tr>
    <tr><td class="paramname">numQueueFamilyIndices</td><td>If not exclusive, the number of queue families for which this buffer is valid</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Return a valid object if success</dd></dl>
<p>. </p>

</div>
</div>
<a class="anchor" id="a04b412166c06b4293b7eaa1bf6857f50"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pvrvk::DebugReportCallback pvr::utils::createDebugReportCallback </td>
          <td>(</td>
          <td class="paramtype">pvrvk::Instance &amp;&#160;</td>
          <td class="paramname"><em>instance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pvrvk::DebugReportFlagsEXT&#160;</td>
          <td class="paramname"><em>flags</em> = <code>pvrvk::DebugReportFlagsEXT::e_ERROR_BIT_EXT|pvrvk::DebugReportFlagsEXT::e_PERFORMANCE_WARNING_BIT_EXT|pvrvk::DebugReportFlagsEXT::e_WARNING_BIT_EXT</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PFN_vkDebugReportCallbackEXT&#160;</td>
          <td class="paramname"><em>callback</em> = <code><a class="el" href="namespacepvr_1_1utils.html#a1cbbbd1665449ea70d772de63595c806">pvr::utils::logMessageDebugReportCallback</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>userData</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a DebugReportCallback providing an application callback for events of interest to the application.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">instance</td><td>The instance to create the DebugReportCallback from.</td></tr>
    <tr><td class="paramname">flags</td><td>The flags specifying the events the application is interested in receiving a callback for.</td></tr>
    <tr><td class="paramname">callback</td><td>The application callback function</td></tr>
    <tr><td class="paramname">userData</td><td>User data which will be passed to the callback</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pvrvk::DebugReportCallback object</dd></dl>

</div>
</div>
<a class="anchor" id="a42affc049a44dc37070da0d0a88d1ee5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pvrvk::Device pvr::utils::createDeviceAndQueues </td>
          <td>(</td>
          <td class="paramtype">pvrvk::PhysicalDevice&#160;</td>
          <td class="paramname"><em>physicalDevice</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const QueuePopulateInfo *&#160;</td>
          <td class="paramname"><em>queueCreateFlags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>numQueueCreateFlags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">QueueAccessInfo *&#160;</td>
          <td class="paramname"><em>outAccessInfo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DeviceExtensions &amp;&#160;</td>
          <td class="paramname"><em>deviceExtensions</em> = <code>DeviceExtensions()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create the pvrvk::Device and the queues</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">physicalDevice</td><td>A physical device to use for creating the logical device.</td></tr>
    <tr><td class="paramname">queueCreateFlags</td><td>A pointer to a list of <a class="el" href="structpvr_1_1utils_1_1_queue_populate_info.html" title="A structure encapsulating the set of queue flags required for a particular queue retrieved via the he...">QueuePopulateInfo</a> structures specifying the required properties for each of the queues retrieved.</td></tr>
    <tr><td class="paramname">numQueueCreateFlags</td><td>The number of <a class="el" href="structpvr_1_1utils_1_1_queue_populate_info.html" title="A structure encapsulating the set of queue flags required for a particular queue retrieved via the he...">QueuePopulateInfo</a> structures provided.</td></tr>
    <tr><td class="paramname">outAccessInfo</td><td>A pointer to a list of <a class="el" href="structpvr_1_1utils_1_1_queue_access_info.html" title="A structure encapsulating the family id and queue id of a particular queue retrieved via the helper f...">QueueAccessInfo</a> structures specifying the properties for each of the queues retrieved.</td></tr>
    <tr><td class="paramname">deviceExtensions</td><td>A <a class="el" href="structpvr_1_1utils_1_1_device_extensions.html" title="Container for a list of device extensions to be used for initiailising a device using the helper func...">DeviceExtensions</a> structure which specifyies a list device extensions to try to enable.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the created device</dd></dl>

</div>
</div>
<a class="anchor" id="a2ea80135aa97006c881f5d3fface1563"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pvrvk::Image pvr::utils::createImage </td>
          <td>(</td>
          <td class="paramtype">pvrvk::Device&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pvrvk::ImageType&#160;</td>
          <td class="paramname"><em>imageType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pvrvk::Format&#160;</td>
          <td class="paramname"><em>format</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const pvrvk::Extent3D &amp;&#160;</td>
          <td class="paramname"><em>dimension</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pvrvk::ImageUsageFlags&#160;</td>
          <td class="paramname"><em>usage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pvrvk::ImageCreateFlags&#160;</td>
          <td class="paramname"><em>flags</em> = <code>pvrvk::ImageCreateFlags(0)</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const pvrvk::ImageLayersSize &amp;&#160;</td>
          <td class="paramname"><em>layerSize</em> = <code>pvrvk::ImageLayersSize()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pvrvk::SampleCountFlags&#160;</td>
          <td class="paramname"><em>samples</em> = <code>pvrvk::SampleCountFlags::e_1_BIT</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pvrvk::MemoryPropertyFlags&#160;</td>
          <td class="paramname"><em>requiredMemoryFlags</em> = <code>pvrvk::MemoryPropertyFlags::e_DEVICE_LOCAL_BIT</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pvrvk::MemoryPropertyFlags&#160;</td>
          <td class="paramname"><em>optimalMemoryFlags</em> = <code>pvrvk::MemoryPropertyFlags::e_NONE</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vma::Allocator *&#160;</td>
          <td class="paramname"><em>imageAllocator</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vma::AllocationCreateFlags&#160;</td>
          <td class="paramname"><em>vmaAllocationCreateFlags</em> = <code>vma::AllocationCreateFlags::e_NONE</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pvrvk::SharingMode&#160;</td>
          <td class="paramname"><em>sharingMode</em> = <code>pvrvk::SharingMode::e_EXCLUSIVE</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pvrvk::ImageTiling&#160;</td>
          <td class="paramname"><em>tiling</em> = <code>pvrvk::ImageTiling::e_OPTIMAL</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pvrvk::ImageLayout&#160;</td>
          <td class="paramname"><em>initialLayout</em> = <code>pvrvk::ImageLayout::e_UNDEFINED</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t *&#160;</td>
          <td class="paramname"><em>queueFamilyIndices</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>numQueueFamilyIndices</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>create a new Image(sparse or with memory backing, depending on <em>flags</em> . The user should not call bindMemory on the image if sparse flags are used. <em>requiredMemoryFlags</em>  is ignored if <em>flags</em>  contains sparse binding flags.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">device</td><td>The device on which to create the image</td></tr>
    <tr><td class="paramname">imageType</td><td>The type of the created image (1D/2D/3D etc)</td></tr>
    <tr><td class="paramname">format</td><td>The Image format</td></tr>
    <tr><td class="paramname">dimension</td><td>Image dimension</td></tr>
    <tr><td class="paramname">usage</td><td>Image usage flags</td></tr>
    <tr><td class="paramname">flags</td><td>Image create flags</td></tr>
    <tr><td class="paramname">layerSize</td><td>Image layer size</td></tr>
    <tr><td class="paramname">samples</td><td>Number of samples</td></tr>
    <tr><td class="paramname">requiredMemoryFlags</td><td>The minimal set of memory property flags which are required for the PVRVk Image to be created. If pvrvk::MemoryPropertyFlags::e_NONE is passed, no memory will be allocated for this Image.</td></tr>
    <tr><td class="paramname">optimalMemoryFlags</td><td>The most optimal set of memory property flags which could be used by the memory backing the returned PVRVk Image. If pvrvk::MemoryPropertyFlags::e_NONE is passed optimalMemoryFlags will be set to match requiredMemoryFlags.</td></tr>
    <tr><td class="paramname">imageAllocator</td><td>A VMA allocator used to allocate memory for the created image.</td></tr>
    <tr><td class="paramname">vmaAllocationCreateFlags</td><td>VMA Allocation creation flags. These flags can be used to control how and where the memory is allocated from. Valid flags include e_DEDICATED_MEMORY_BIT and e_MAPPED_BIT. e_DEDICATED_MEMORY_BIT indicates that the allocation should have its own memory block. e_MAPPED_BIT indicates memory will be persistently mapped respectively. The default vma::AllocationCreateFlags::e_MAPPED_BIT is valid even if HOST_VISIBLE is not used - these flags will be ignored in this case.</td></tr>
    <tr><td class="paramname">sharingMode</td><td>Specifying the sharing mode of this image. Setting it exclusive means that only a single queue can access it therefore the calle must exclusively transfer queue ownership of this image if they want separate queue family to access this image and the <em>queueFamilyIndices</em> , <em>numQueueFamilyIndices</em>  is ignored. Setting it to concurrent means multiple queue family can access this image at any point in time and requires <em>queueFamilyIndices</em> , <em>numQueueFamilyIndices</em> </td></tr>
    <tr><td class="paramname">queueFamilyIndices</td><td>A c-style array containing the queue family indices that this image is exclusive to</td></tr>
    <tr><td class="paramname">tiling</td><td>Specifies the tiling mode which defines the tiling arrangement of data elements in memory</td></tr>
    <tr><td class="paramname">initialLayout</td><td>Is a ImageLayout value specifying the initial ImageLayout of all image subresources of the image</td></tr>
    <tr><td class="paramname">numQueueFamilyIndices</td><td>The number of queues in <em>queueFamilyIndices</em> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The created Imageobject on success, null Image on failure</dd></dl>

</div>
</div>
<a class="anchor" id="a680ef5943947e565f7d14aa9ff0393d9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pvrvk::Instance pvr::utils::createInstance </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>applicationName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VulkanVersion&#160;</td>
          <td class="paramname"><em>apiVersion</em> = <code>VulkanVersion()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const InstanceExtensions &amp;&#160;</td>
          <td class="paramname"><em>instanceExtensions</em> = <code>InstanceExtensions()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const InstanceLayers &amp;&#160;</td>
          <td class="paramname"><em>instanceLayers</em> = <code>InstanceLayers()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Utility function for creating a Vulkan instance and supported physical devices using the appropriately set parameters.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">applicationName</td><td>Used for setting the pApplicationName of the pvrvk::ApplicationInfo structure used when calling vkCreateInstance.</td></tr>
    <tr><td class="paramname">apiVersion</td><td>A <a class="el" href="structpvr_1_1utils_1_1_vulkan_version.html" title="The VulkanVersion structure provides an easy mechanism for constructing the Vulkan version for use wh...">VulkanVersion</a> structure used for setting the apiVersion of the pvrvk::ApplicationInfo structure used when creating the Vulkan instance.</td></tr>
    <tr><td class="paramname">instanceExtensions</td><td>An <a class="el" href="structpvr_1_1utils_1_1_instance_extensions.html" title="Container for a list of instance extensions to be used for initiailising an instance using the helper...">InstanceExtensions</a> structure which holds a list of instance extensions which will be checked for compatibility with the current Vulkan implementation before setting as the ppEnabledExtensionNames member of the pvrvk::InstanceCreateInfo used when creating the Vulkan instance.</td></tr>
    <tr><td class="paramname">instanceLayers</td><td>An <a class="el" href="structpvr_1_1utils_1_1_instance_layers.html" title="Container for a list of instance layers to be used for initiailising an instance using the helper fun...">InstanceLayers</a> structure which holds a list of instance layers which will be checked for compatibility with the current Vulkan implementation before setting as the ppEnabledLayerNames member of the pvrvk::InstanceCreateInfo used when creating the Vulkan instance.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the created Instance.</dd></dl>

</div>
</div>
<a class="anchor" id="a95e0a5be7c444548e52a74c2f40faaa5"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pvr::utils::createMultipleBuffersFromMesh </td>
          <td>(</td>
          <td class="paramtype">pvrvk::Device &amp;&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const assets::Mesh &amp;&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; pvrvk::Buffer &gt; &amp;&#160;</td>
          <td class="paramname"><em>outVbos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pvrvk::Buffer &amp;&#160;</td>
          <td class="paramname"><em>outIbo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pvrvk::CommandBuffer &amp;&#160;</td>
          <td class="paramname"><em>uploadCmdBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &amp;&#160;</td>
          <td class="paramname"><em>requiresCommandBufferSubmission</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vma::Allocator *&#160;</td>
          <td class="paramname"><em>bufferAllocator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vma::AllocationCreateFlags&#160;</td>
          <td class="paramname"><em>vmaAllocationCreateFlags</em> = <code>vma::AllocationCreateFlags::e_MAPPED_BIT</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Auto generates a set of VBOs and a single IBO from all the vertex data of a mesh.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">device</td><td>The device where the buffers will be generated on</td></tr>
    <tr><td class="paramname">mesh</td><td>The mesh whose data will populate the buffers</td></tr>
    <tr><td class="paramname">outVbos</td><td>Reference to a std::vector of VBO handles where the data will be put. Buffers will be appended at the end.</td></tr>
    <tr><td class="paramname">outIbo</td><td>The IBO handle where the data will be put. No buffer needs to have been created on the handle. If no face data is present on the mesh, the handle will be null.</td></tr>
    <tr><td class="paramname">uploadCmdBuffer</td><td>A command buffer into which commands may be recorded for uploading mesh data to the created buffers. This command buffer will only be used when memory without e_HOST_VISIBLE_BIT memory property flags was allocated for the vbos or ibos.</td></tr>
    <tr><td class="paramname">requiresCommandBufferSubmission</td><td>Indicates whether commands have been recorded into the given command buffer.</td></tr>
    <tr><td class="paramname">bufferAllocator</td><td>A VMA allocator used to allocate memory for the created buffer.</td></tr>
    <tr><td class="paramname">vmaAllocationCreateFlags</td><td>VMA Allocation creation flags. These flags can be used to control how and where the memory is allocated from. Valid flags include e_DEDICATED_MEMORY_BIT and e_MAPPED_BIT. e_DEDICATED_MEMORY_BIT indicates that the allocation should have its own memory block. e_MAPPED_BIT indicates memory will be persistently mapped respectively. The default vma::AllocationCreateFlags::e_MAPPED_BIT is valid even if HOST_VISIBLE is not used - these flags will be ignored in this case.</td></tr>
  </table>
  </dd>
</dl>
<p>This utility function will read all vertex data from the mesh and create one pvrvk::Buffer for each data element (block of interleaved data) in the mesh. It is thus commonly used for for meshes containing multiple sets of interleaved data (for example, a VBO with static and a VBO with streaming data).</p>

</div>
</div>
<a class="anchor" id="a021b5205f52c9a4d0cdd26ce9e1f03a7"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pvr::utils::createOnscreenFramebufferAndRenderpass </td>
          <td>(</td>
          <td class="paramtype">pvrvk::Swapchain &amp;&#160;</td>
          <td class="paramname"><em>swapchain</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pvrvk::ImageView *&#160;</td>
          <td class="paramname"><em>depthStencilImages</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Multi&lt; pvrvk::Framebuffer &gt; &amp;&#160;</td>
          <td class="paramname"><em>outFramebuffers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pvrvk::RenderPass &amp;&#160;</td>
          <td class="paramname"><em>outRenderPass</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pvrvk::ImageLayout&#160;</td>
          <td class="paramname"><em>initialSwapchainLayout</em> = <code>pvrvk::ImageLayout::e_UNDEFINED</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pvrvk::ImageLayout&#160;</td>
          <td class="paramname"><em>initialDepthStencilLayout</em> = <code>pvrvk::ImageLayout::e_UNDEFINED</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a pvrvk::Framebuffer and Renderpass to use for 'default' rendering to the 'onscreen' color images with following config Renderpass: Attachment0: ColorAttachment swapchain image, finalLayout - PresentSrcKHR LoadOp - Clear StoreOp - Store Attachment1: DepthStencilAttachment finalLayout - DepthStencilAttachmentOptimal LoadOp - Clear StoreOp - Store </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">swapchain</td><td>A pre-created swapchain object from which the device will be taken for creating the framebuffer and renderpass. The swapchain image formats and dimensions will also be taken from the swapchain.</td></tr>
    <tr><td class="paramname">depthStencilImages</td><td>A pointer to an array of pvrvk::ImageView objects corresponding to an image to use as the depth stencil image per swap chain.</td></tr>
    <tr><td class="paramname">outFramebuffers</td><td>The created framebuffers will be returned by reference as part of outFramebuffers with each framebuffer corresponding to a single swap chain.</td></tr>
    <tr><td class="paramname">outRenderPass</td><td>The created renderpass will be returned by reference.</td></tr>
    <tr><td class="paramname">initialSwapchainLayout</td><td>Initial Layouts of the swapchain image</td></tr>
    <tr><td class="paramname">initialDepthStencilLayout</td><td>Initial Layouts of the depthstencil image</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aecfe23b63ffc4cc0fae6624b389f9572"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pvr::utils::createOnscreenFramebufferAndRenderpass </td>
          <td>(</td>
          <td class="paramtype">pvrvk::Swapchain &amp;&#160;</td>
          <td class="paramname"><em>swapchain</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pvrvk::ImageView *&#160;</td>
          <td class="paramname"><em>depthStencilImages</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Multi&lt; pvrvk::Framebuffer &gt; &amp;&#160;</td>
          <td class="paramname"><em>outFramebuffers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pvrvk::ImageLayout&#160;</td>
          <td class="paramname"><em>initialSwapchainLayout</em> = <code>pvrvk::ImageLayout::e_UNDEFINED</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pvrvk::ImageLayout&#160;</td>
          <td class="paramname"><em>initialDepthStencilLayout</em> = <code>pvrvk::ImageLayout::e_UNDEFINED</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a pvrvk::Framebuffer and Renderpass to use for 'default' rendering to the 'onscreen' color images with following config Renderpass: ColorAttachment0: swapchain image, finalLayout - PresentSrcKHR LoadOp - Clear StoreOp - Store DepthStencilAttachment: finalLayout - DepthStencilAttachmentOptimal LoadOp - Clear StoreOp - Store Subpass0 </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">swapchain</td><td>A pre-created swapchain object from which the device will be taken for creating the framebuffer and renderpass. The swapchain image formats and dimensions will also be taken from the swapchain.</td></tr>
    <tr><td class="paramname">depthStencilImages</td><td>A pointer to an array of pvrvk::ImageView objects corresponding to an image to use as the depth stencil image per swap chain.</td></tr>
    <tr><td class="paramname">outFramebuffers</td><td>The created framebuffers will be returned by reference as part of outFramebuffers with each framebuffer corresponding to a single swap chain.</td></tr>
    <tr><td class="paramname">initialSwapchainLayout</td><td>Initial Layouts of the swapchain image</td></tr>
    <tr><td class="paramname">initialDepthStencilLayout</td><td>Initial Layouts of the depthstencil image</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Return 'True' if the framebuffer and renderpass were created successfully.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">initialSwapchainLayout</td><td>Initial Layouts of the swapchain image</td></tr>
    <tr><td class="paramname">initialDepthStencilLayout</td><td>Initial Layouts of the depthstencil image</td></tr>
  </table>
  </dd>
</dl>
<p>The renderpass will not be returned directly but can instead be retrieved via a call to outFramebuffers[i].getRenderpass()</p>

</div>
</div>
<a class="anchor" id="a558c97111c1acd50a97db4307d0de11a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GLuint pvr::utils::createShaderProgram </td>
          <td>(</td>
          <td class="paramtype">const GLuint&#160;</td>
          <td class="paramname"><em>pShaders</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char **const&#160;</td>
          <td class="paramname"><em>attribNames</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint16_t *&#160;</td>
          <td class="paramname"><em>attribIndices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>attribsCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string *&#160;</td>
          <td class="paramname"><em>infolog</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a native shader program from an array of native shader handles. Will implicitly load on the current context.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pShaders</td><td>An array of shaders</td></tr>
    <tr><td class="paramname">count</td><td>The number shaders in <em>pShaders</em> pShaders</td></tr>
    <tr><td class="paramname">attribNames</td><td>The list of names of the attributes in the shader, as a c-style array of c-style strings</td></tr>
    <tr><td class="paramname">attribIndices</td><td>The list of attribute binding indices, corresponding to <em>attribNames</em> attribNames</td></tr>
    <tr><td class="paramname">attribsCount</td><td>Number of attributes in <em>attribNames</em> attribNames and <em>attribIndices</em> attribIndices.</td></tr>
    <tr><td class="paramname">infolog</td><td>OPTIONAL Output, the infolog of the shader</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The program object</dd></dl>

</div>
</div>
<a class="anchor" id="ae6934715b675cba2e0a7454813b431a3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pvr::utils::createSingleBuffersFromMesh </td>
          <td>(</td>
          <td class="paramtype">pvrvk::Device &amp;&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const assets::Mesh &amp;&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pvrvk::Buffer &amp;&#160;</td>
          <td class="paramname"><em>outVbo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pvrvk::Buffer &amp;&#160;</td>
          <td class="paramname"><em>outIbo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pvrvk::CommandBuffer &amp;&#160;</td>
          <td class="paramname"><em>uploadCmdBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &amp;&#160;</td>
          <td class="paramname"><em>requiresCommandBufferSubmission</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vma::Allocator *&#160;</td>
          <td class="paramname"><em>bufferAllocator</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vma::AllocationCreateFlags&#160;</td>
          <td class="paramname"><em>vmaAllocationCreateFlags</em> = <code>vma::AllocationCreateFlags::e_MAPPED_BIT</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Auto generates a single VBO and a single IBO from all the vertex data of a mesh.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">device</td><td>The device where the buffers will be generated on</td></tr>
    <tr><td class="paramname">mesh</td><td>The mesh whose data will populate the buffers</td></tr>
    <tr><td class="paramname">outVbo</td><td>The VBO handle where the data will be put.</td></tr>
    <tr><td class="paramname">outIbo</td><td>The IBO handle where the data will be put. If no face data is present on the mesh, the handle will be null.</td></tr>
    <tr><td class="paramname">uploadCmdBuffer</td><td>A command buffer into which commands may be recorded for uploading mesh data to the created buffers. This command buffer will only be used when memory without e_HOST_VISIBLE_BIT memory property flags was allocated for the vbos or ibos.</td></tr>
    <tr><td class="paramname">requiresCommandBufferSubmission</td><td>Indicates whether commands have been recorded into the given command buffer.</td></tr>
    <tr><td class="paramname">bufferAllocator</td><td>A VMA allocator used to allocate memory for the created buffer.</td></tr>
    <tr><td class="paramname">vmaAllocationCreateFlags</td><td>VMA Allocation creation flags. These flags can be used to control how and where the memory is allocated from. Valid flags include e_DEDICATED_MEMORY_BIT and e_MAPPED_BIT. e_DEDICATED_MEMORY_BIT indicates that the allocation should have its own memory block. e_MAPPED_BIT indicates memory will be persistently mapped respectively. The default vma::AllocationCreateFlags::e_MAPPED_BIT is valid even if HOST_VISIBLE is not used - these flags will be ignored in this case.</td></tr>
  </table>
  </dd>
</dl>
<p>This utility function will read all vertex data from a mesh's data elements and create a single VBO. It is commonly used for a single set of interleaved data. If data are not interleaved, they will be packed on the same VBO, each interleaved block (Data element on the mesh) will be appended at the end of the buffer, and the offsets will need to be calculated by the user when binding the buffer.</p>

</div>
</div>
<a class="anchor" id="a06f94be9a865755c8bafaac56f286b01"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MeshIterator_ , typename VboInsertIterator_ , typename IboInsertIterator_ &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pvr::utils::createSingleBuffersFromMeshes </td>
          <td>(</td>
          <td class="paramtype">pvrvk::Device &amp;&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MeshIterator_&#160;</td>
          <td class="paramname"><em>meshIter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MeshIterator_&#160;</td>
          <td class="paramname"><em>meshIterEnd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VboInsertIterator_&#160;</td>
          <td class="paramname"><em>outVbos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IboInsertIterator_&#160;</td>
          <td class="paramname"><em>outIbos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pvrvk::CommandBuffer &amp;&#160;</td>
          <td class="paramname"><em>uploadCmdBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &amp;&#160;</td>
          <td class="paramname"><em>requiresCommandBufferSubmission</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vma::Allocator *&#160;</td>
          <td class="paramname"><em>bufferAllocator</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vma::AllocationCreateFlags&#160;</td>
          <td class="paramname"><em>vmaAllocationCreateFlags</em> = <code>vma::AllocationCreateFlags::e_MAPPED_BIT</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Auto generates a set of VBOs and a set of IBOs from the vertex data of multiple meshes and uses std::inserter provided by the user to insert them to any container.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">device</td><td>The device where the buffers will be generated on</td></tr>
    <tr><td class="paramname">meshIter</td><td>Iterator for a collection of meshes.</td></tr>
    <tr><td class="paramname">meshIterEnd</td><td>End Iterator for meshIter.</td></tr>
    <tr><td class="paramname">outVbos</td><td>std::inserter for a collection of pvrvk::Buffer handles. It will be used to insert one VBO per mesh. </td></tr>
    <tr><td class="paramname">outIbos</td><td>std::inserter for a collection of pvrvk::Buffer handles. It will be used to insert one IBO per mesh. If face data is not present on the mesh, a null handle will be inserted.</td></tr>
    <tr><td class="paramname">uploadCmdBuffer</td><td>A command buffer into which commands may be recorded for uploading mesh data to the created buffers. This command buffer will only be used when memory without e_HOST_VISIBLE_BIT memory property flags was allocated for the vbos or ibos.</td></tr>
    <tr><td class="paramname">requiresCommandBufferSubmission</td><td>Indicates whether commands have been recorded into the given command buffer.</td></tr>
    <tr><td class="paramname">bufferAllocator</td><td>A VMA allocator used to allocate memory for the created buffer.</td></tr>
    <tr><td class="paramname">vmaAllocationCreateFlags</td><td>VMA Allocation creation flags. These flags can be used to control how and where the memory is allocated from. Valid flags include e_DEDICATED_MEMORY_BIT and e_MAPPED_BIT. e_DEDICATED_MEMORY_BIT indicates that the allocation should have its own memory block. e_MAPPED_BIT indicates memory will be persistently mapped respectively. The default vma::AllocationCreateFlags::e_MAPPED_BIT is valid even if HOST_VISIBLE is not used - these flags will be ignored in this case.</td></tr>
  </table>
  </dd>
</dl>
<p>This utility function will read all vertex data from a mesh's data elements and create a single VBO. It is commonly used for a single set of interleaved data (mesh.getNumDataElements() == 1). If more data elements are present (i.e. more than a single interleaved data element) , they will be packed in the sameVBO, with each interleaved block (Data element ) appended at the end of the buffer. It is then the user's responsibility to use the buffer correctly with the API (for example use bindbufferbase and similar) with the correct offsets. The std::inserter this function requires can be created from any container with an insert() function with (for example, for insertion at the end of a vector) std::inserter(std::vector, std::vector::end()) .</p>

</div>
</div>
<a class="anchor" id="a4493b0c69e45e8b7af4d2fa32f763f23"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MeshIterator_ , typename VboContainer_ , typename IboContainer_ &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pvr::utils::createSingleBuffersFromMeshes </td>
          <td>(</td>
          <td class="paramtype">pvrvk::Device &amp;&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MeshIterator_&#160;</td>
          <td class="paramname"><em>meshIter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MeshIterator_&#160;</td>
          <td class="paramname"><em>meshIterEnd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VboContainer_ &amp;&#160;</td>
          <td class="paramname"><em>outVbos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename VboContainer_::iterator&#160;</td>
          <td class="paramname"><em>vbos_where</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IboContainer_ &amp;&#160;</td>
          <td class="paramname"><em>outIbos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename IboContainer_::iterator&#160;</td>
          <td class="paramname"><em>ibos_where</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pvrvk::CommandBuffer &amp;&#160;</td>
          <td class="paramname"><em>uploadCmdBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &amp;&#160;</td>
          <td class="paramname"><em>requiresCommandBufferSubmission</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vma::Allocator *&#160;</td>
          <td class="paramname"><em>bufferAllocator</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vma::AllocationCreateFlags&#160;</td>
          <td class="paramname"><em>vmaAllocationCreateFlags</em> = <code>vma::AllocationCreateFlags::e_MAPPED_BIT</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Auto generates a set of VBOs and a set of IBOs from the vertex data of multiple meshes and insert them at the specified spot in a user-provided container.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">device</td><td>The device where the buffers will be generated on</td></tr>
    <tr><td class="paramname">meshIter</td><td>Iterator for a collection of meshes.</td></tr>
    <tr><td class="paramname">meshIterEnd</td><td>End Iterator for meshIter.</td></tr>
    <tr><td class="paramname">outVbos</td><td>Collection of pvrvk::Buffer handles. It will be used to insert one VBO per mesh.</td></tr>
    <tr><td class="paramname">outIbos</td><td>Collection of pvrvk::Buffer handles. It will be used to insert one IBO per mesh. If face data is not present on the mesh, a null handle will be inserted.</td></tr>
    <tr><td class="paramname">vbos_where</td><td>Iterator on outVbos - the position where the insertion will happen.</td></tr>
    <tr><td class="paramname">ibos_where</td><td>Iterator on outIbos - the position where the insertion will happen.</td></tr>
    <tr><td class="paramname">uploadCmdBuffer</td><td>A command buffer into which commands may be recorded for uploading mesh data to the created buffers. This command buffer will only be used when memory without e_HOST_VISIBLE_BIT memory property flags was allocated for the vbos or ibos.</td></tr>
    <tr><td class="paramname">requiresCommandBufferSubmission</td><td>Indicates whether commands have been recorded into the given command buffer.</td></tr>
    <tr><td class="paramname">bufferAllocator</td><td>A VMA allocator used to allocate memory for the created buffer.</td></tr>
    <tr><td class="paramname">vmaAllocationCreateFlags</td><td>VMA Allocation creation flags. These flags can be used to control how and where the memory is allocated from. Valid flags include e_DEDICATED_MEMORY_BIT and e_MAPPED_BIT. e_DEDICATED_MEMORY_BIT indicates that the allocation should have its own memory block. e_MAPPED_BIT indicates memory will be persistently mapped respectively. The default vma::AllocationCreateFlags::e_MAPPED_BIT is valid even if HOST_VISIBLE is not used - these flags will be ignored in this case.</td></tr>
  </table>
  </dd>
</dl>
<p>This utility function will read all vertex data from a mesh's data elements and create a single VBO. It is commonly used for a single set of interleaved data (mesh.getNumDataElements() == 1). If more data elements are present (i.e. more than a single interleaved data element) , they will be packed in the sameVBO, with each interleaved block (Data element ) appended at the end of the buffer. It is then the user's responsibility to use the buffer correctly with the API (for example use bindbufferbase and similar) with the correct offsets.</p>

</div>
</div>
<a class="anchor" id="a8b77d306417876f431ed11fffde3a84f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VboInsertIterator_ , typename IboInsertIterator_ &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pvr::utils::createSingleBuffersFromModel </td>
          <td>(</td>
          <td class="paramtype">pvrvk::Device &amp;&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const assets::Model &amp;&#160;</td>
          <td class="paramname"><em>model</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VboInsertIterator_&#160;</td>
          <td class="paramname"><em>vbos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IboInsertIterator_&#160;</td>
          <td class="paramname"><em>ibos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pvrvk::CommandBuffer &amp;&#160;</td>
          <td class="paramname"><em>uploadCmdBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &amp;&#160;</td>
          <td class="paramname"><em>requiresCommandBufferSubmission</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vma::Allocator *&#160;</td>
          <td class="paramname"><em>bufferAllocator</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vma::AllocationCreateFlags&#160;</td>
          <td class="paramname"><em>vmaAllocationCreateFlags</em> = <code>vma::AllocationCreateFlags::e_MAPPED_BIT</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Auto generates a set of VBOs and a set of IBOs from the vertex data of the meshes of a model and inserts them into containers provided by the user using std::inserters.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">device</td><td>The device device where the buffers will be generated on</td></tr>
    <tr><td class="paramname">model</td><td>The model whose meshes will be used to generate the Buffers</td></tr>
    <tr><td class="paramname">vbos</td><td>An insert iterator to a std::pvrvk::Buffer container for the VBOs. Vbos will be inserted using this iterator.</td></tr>
    <tr><td class="paramname">ibos</td><td>An insert iterator to an std::pvrvk::Buffer container for the IBOs. Ibos will be inserted using this iterator.</td></tr>
    <tr><td class="paramname">uploadCmdBuffer</td><td>A command buffer into which commands may be recorded for uploading mesh data to the created buffers. This command buffer will only be used when memory without e_HOST_VISIBLE_BIT memory property flags was allocated for the vbos or ibos.</td></tr>
    <tr><td class="paramname">requiresCommandBufferSubmission</td><td>Indicates whether commands have been recorded into the given command buffer.</td></tr>
    <tr><td class="paramname">bufferAllocator</td><td>A VMA allocator used to allocate memory for the created buffer.</td></tr>
    <tr><td class="paramname">vmaAllocationCreateFlags</td><td>VMA Allocation creation flags. These flags can be used to control how and where the memory is allocated from. Valid flags include e_DEDICATED_MEMORY_BIT and e_MAPPED_BIT. e_DEDICATED_MEMORY_BIT indicates that the allocation should have its own memory block. e_MAPPED_BIT indicates memory will be persistently mapped respectively. The default vma::AllocationCreateFlags::e_MAPPED_BIT is valid even if HOST_VISIBLE is not used - these flags will be ignored in this case.</td></tr>
  </table>
  </dd>
</dl>
<p>This utility function will read all vertex data from the VBO. It is usually preferred for meshes meshes containing a single set of interleaved data. If multiple data elements (i.e. sets of interleaved data), each block will be successively placed after the other. The std::inserter this function requires can be created from any container with an insert() function with (for example, for insertion at the end of a vector) std::inserter(std::vector, std::vector::end()) .</p>

</div>
</div>
<a class="anchor" id="aa583027696be258fc78dd3156ffaece5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pvrvk::Surface pvr::utils::createSurface </td>
          <td>(</td>
          <td class="paramtype">pvrvk::Instance &amp;&#160;</td>
          <td class="paramname"><em>instance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pvrvk::PhysicalDevice &amp;&#160;</td>
          <td class="paramname"><em>physicalDevice</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>window</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>display</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates an abstract vulkan native platform surface.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">instance</td><td>The instance from which to create the native platform surface.</td></tr>
    <tr><td class="paramname">physicalDevice</td><td>A physical device from which to create the native platform surface.</td></tr>
    <tr><td class="paramname">window</td><td>A pointer to a NativeWindow used to create the windowing surface.</td></tr>
    <tr><td class="paramname">display</td><td>A pointer to a NativeDisplay used to create the windowing surface.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to an abstract vulkan native platform surface.</dd></dl>

</div>
</div>
<a class="anchor" id="a31577c3e0b7564dde7e0e46c252317d3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pvrvk::Swapchain pvr::utils::createSwapchain </td>
          <td>(</td>
          <td class="paramtype">pvrvk::Device &amp;&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const pvrvk::Surface &amp;&#160;</td>
          <td class="paramname"><em>surface</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pvr::DisplayAttributes &amp;&#160;</td>
          <td class="paramname"><em>displayAttributes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pvrvk::Format *&#160;</td>
          <td class="paramname"><em>preferredColorFormats</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>numColorFormats</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pvrvk::ImageUsageFlags&#160;</td>
          <td class="paramname"><em>swapchainImageUsageFlags</em> = <code>pvrvk::ImageUsageFlags::e_COLOR_ATTACHMENT_BIT</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a pvrvk::Swapchain using a pre-initialised pvrvk::Device and pvrvk::Surface choosing the color format of the swapchain images created from the specified list of preferred color formats.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">device</td><td>A logical device to use for creating the pvrvk::Swapchain.</td></tr>
    <tr><td class="paramname">surface</td><td>A pvrvk::Surface from which surface capabilities, supported formats and presentation modes will be derived.</td></tr>
    <tr><td class="paramname">displayAttributes</td><td>A set of display attributes from which certain properties will be taken such as width, height, vsync mode and preferences for the number of pixels per channel.</td></tr>
    <tr><td class="paramname">preferredColorFormats</td><td>A pointer to a list of preferred color formats from which the pvrvk::Swapchain color image format will be taken. Note that this list must be exhaustive as if none are supported then no pvrvk::Swapchain will be created.</td></tr>
    <tr><td class="paramname">numColorFormats</td><td>The number of color formats specified in the array pointed to by preferredColorFormats.</td></tr>
    <tr><td class="paramname">swapchainImageUsageFlags</td><td>Specifies for what the swapchain images can be used for.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Return the created pvrvk::Swapchain</dd></dl>

</div>
</div>
<a class="anchor" id="acb02e95824004b5bf3b80049ec0a3e40"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pvrvk::Swapchain pvr::utils::createSwapchain </td>
          <td>(</td>
          <td class="paramtype">pvrvk::Device &amp;&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const pvrvk::Surface &amp;&#160;</td>
          <td class="paramname"><em>surface</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pvr::DisplayAttributes &amp;&#160;</td>
          <td class="paramname"><em>displayAttributes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pvrvk::ImageUsageFlags&#160;</td>
          <td class="paramname"><em>swapchainImageUsageFlags</em> = <code>pvrvk::ImageUsageFlags::e_COLOR_ATTACHMENT_BIT</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a pvrvk::Swapchain using a pre-initialised pvrvk::Device and pvrvk::Surface.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">device</td><td>A logical device to use for creating the pvrvk::Swapchain.</td></tr>
    <tr><td class="paramname">surface</td><td>A pvrvk::Surface from which surface capabilities, supported formats and presentation modes will be derived.</td></tr>
    <tr><td class="paramname">displayAttributes</td><td>A set of display attributes from which certain properties will be taken such as width, height, vsync mode and preferences for the number of pixels per channel.</td></tr>
    <tr><td class="paramname">swapchainImageUsageFlags</td><td>Specifies for what the swapchain images can be used for.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Return the created pvrvk::Swapchain</dd></dl>

</div>
</div>
<a class="anchor" id="a21012ef6146e3eb4d55ac09d0be368fd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pvr::utils::createSwapchainAndDepthStencilImageAndViews </td>
          <td>(</td>
          <td class="paramtype">pvrvk::Device &amp;&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const pvrvk::Surface &amp;&#160;</td>
          <td class="paramname"><em>surface</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pvr::DisplayAttributes &amp;&#160;</td>
          <td class="paramname"><em>displayAttributes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pvrvk::Swapchain &amp;&#160;</td>
          <td class="paramname"><em>outSwapchain</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Multi&lt; pvrvk::ImageView &gt; &amp;&#160;</td>
          <td class="paramname"><em>outDepthStencil</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pvrvk::Format *&#160;</td>
          <td class="paramname"><em>preferredColorFormats</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>numColorFormats</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pvrvk::Format *&#160;</td>
          <td class="paramname"><em>preferredDepthStencilFormats</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>numDepthStencilFormats</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const pvrvk::ImageUsageFlags &amp;&#160;</td>
          <td class="paramname"><em>swapchainImageUsageFlags</em> = <code>pvrvk::ImageUsageFlags::e_COLOR_ATTACHMENT_BIT</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const pvrvk::ImageUsageFlags &amp;&#160;</td>
          <td class="paramname"><em>dsImageUsageFlags</em> = <code>pvrvk::ImageUsageFlags::e_DEPTH_STENCIL_ATTACHMENT_BIT|pvrvk::ImageUsageFlags::e_TRANSIENT_ATTACHMENT_BIT</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vma::Allocator *&#160;</td>
          <td class="paramname"><em>dsImageAllocator</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vma::AllocationCreateFlags&#160;</td>
          <td class="paramname"><em>dsImageAllocationCreateFlags</em> = <code>vma::AllocationCreateFlags::e_DEDICATED_MEMORY_BIT</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a pvrvk::Swapchain and corresponding number of depth stencil images using a pre-initialised pvrvk::Device and pvrvk::Surface choosing the color and depth stencil format of the images created from the specified list of preferred color and depth stencil formats.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">device</td><td>A logical device to use for creating the pvrvk::Swapchain and depth stencil images.</td></tr>
    <tr><td class="paramname">surface</td><td>A pvrvk::Surface from which surface capabilities, supported formats and presentation modes will be derived.</td></tr>
    <tr><td class="paramname">displayAttributes</td><td>A set of display attributes from which certain properties will be taken such as width, height, vsync mode and preferences for the number of pixels per channel.</td></tr>
    <tr><td class="paramname">outSwapchain</td><td>The created swapchain will be returned by reference.</td></tr>
    <tr><td class="paramname">outDepthStencil</td><td>A Multi&lt;pvrvk::ImageView&gt; containing the created depth stencil images. This Multi will have size equal to the number of swapchain images.</td></tr>
    <tr><td class="paramname">preferredColorFormats</td><td>A pointer to a list of preferred color formats from which the pvrvk::Swapchain color image format will be taken. Note that this list must be exhaustive as if none are supported then no pvrvk::Swapchain will be created.</td></tr>
    <tr><td class="paramname">numColorFormats</td><td>The number of color formats specified in the array pointed to by preferredColorFormats.</td></tr>
    <tr><td class="paramname">preferredDepthStencilFormats</td><td>A pointer to a list of preferred depth stencil formats from which the depth stencil image format will be taken. Note that this list must be exhaustive as if none are supported then no depth stencil images will be created.</td></tr>
    <tr><td class="paramname">numDepthStencilFormats</td><td>The number of depth stencil formats specified in the array pointed to by preferredDepthStencilFormats.</td></tr>
    <tr><td class="paramname">swapchainImageUsageFlags</td><td>Specifies for what the swapchain images can be used for.</td></tr>
    <tr><td class="paramname">dsImageUsageFlags</td><td>Specifies for what the depth stencil images can be used for.</td></tr>
    <tr><td class="paramname">dsImageAllocator</td><td>A VMA allocator used to allocate memory for the created image.</td></tr>
    <tr><td class="paramname">dsImageAllocationCreateFlags</td><td>VMA Allocation creation flags. These flags can be used to control how and where the memory is allocated from. Valid flags include e_DEDICATED_MEMORY_BIT and e_MAPPED_BIT. e_DEDICATED_MEMORY_BIT indicates that the allocation should have its own memory block. e_MAPPED_BIT indicates memory will be persistently mapped respectively.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ac465db7e64f04859a445aa67db5020b3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pvr::utils::createSwapchainAndDepthStencilImageAndViews </td>
          <td>(</td>
          <td class="paramtype">pvrvk::Device &amp;&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const pvrvk::Surface &amp;&#160;</td>
          <td class="paramname"><em>surface</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pvr::DisplayAttributes &amp;&#160;</td>
          <td class="paramname"><em>displayAttributes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pvrvk::Swapchain &amp;&#160;</td>
          <td class="paramname"><em>outSwapchain</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Multi&lt; pvrvk::ImageView &gt; &amp;&#160;</td>
          <td class="paramname"><em>outDepthStencil</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const pvrvk::ImageUsageFlags &amp;&#160;</td>
          <td class="paramname"><em>swapchainImageUsageFlags</em> = <code>pvrvk::ImageUsageFlags::e_COLOR_ATTACHMENT_BIT</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const pvrvk::ImageUsageFlags &amp;&#160;</td>
          <td class="paramname"><em>dsImageUsageFlags</em> = <code>pvrvk::ImageUsageFlags::e_DEPTH_STENCIL_ATTACHMENT_BIT|pvrvk::ImageUsageFlags::e_TRANSIENT_ATTACHMENT_BIT</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vma::Allocator *&#160;</td>
          <td class="paramname"><em>dsImageAllocator</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vma::AllocationCreateFlags&#160;</td>
          <td class="paramname"><em>dsImageAllocationCreateFlags</em> = <code>vma::AllocationCreateFlags::e_DEDICATED_MEMORY_BIT</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a pvrvk::Swapchain and corresponding number of depth stencil images using a pre-initialised pvrvk::Device and pvrvk::Surface.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">device</td><td>A logical device to use for creating the pvrvk::Swapchain.</td></tr>
    <tr><td class="paramname">surface</td><td>A pvrvk::Surface from which surface capabilities, supported formats and presentation modes will be derived.</td></tr>
    <tr><td class="paramname">displayAttributes</td><td>A set of display attributes from which certain properties will be taken such as width, height, vsync mode and preferences for the number of pixels per channel.</td></tr>
    <tr><td class="paramname">outSwapchain</td><td>The created swapchain will be returned by reference.</td></tr>
    <tr><td class="paramname">outDepthStencil</td><td>A Multi&lt;pvrvk::ImageView&gt; containing the created depth stencil images. This Multi will have size equal to the number of swapchain images.</td></tr>
    <tr><td class="paramname">swapchainImageUsageFlags</td><td>Specifies for what the swapchain images can be used for.</td></tr>
    <tr><td class="paramname">dsImageUsageFlags</td><td>Specifies for what the depth stencil images can be used for.</td></tr>
    <tr><td class="paramname">dsImageAllocator</td><td>A VMA allocator used to allocate memory for the created image.</td></tr>
    <tr><td class="paramname">dsImageAllocationCreateFlags</td><td>VMA Allocation creation flags. These flags can be used to control how and where the memory is allocated from. Valid flags include e_DEDICATED_MEMORY_BIT and e_MAPPED_BIT. e_DEDICATED_MEMORY_BIT indicates that the allocation should have its own memory block. e_MAPPED_BIT indicates memory will be persistently mapped respectively.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a5d3d1522b9db9f69b91090f918ccc8c0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pvr::utils::generateTextureAtlas </td>
          <td>(</td>
          <td class="paramtype">pvrvk::Device &amp;&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const pvrvk::Image *&#160;</td>
          <td class="paramname"><em>inputImages</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pvrvk::Rect2Df *&#160;</td>
          <td class="paramname"><em>outUVs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>numImages</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pvrvk::ImageLayout&#160;</td>
          <td class="paramname"><em>inputImageLayout</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pvrvk::ImageView *&#160;</td>
          <td class="paramname"><em>outImageView</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TextureHeader *&#160;</td>
          <td class="paramname"><em>outDescriptor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pvrvk::CommandBufferBase&#160;</td>
          <td class="paramname"><em>cmdBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pvrvk::ImageLayout&#160;</td>
          <td class="paramname"><em>finalLayout</em> = <code>pvrvk::ImageLayout::e_SHADER_READ_ONLY_OPTIMAL</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vma::Allocator *&#160;</td>
          <td class="paramname"><em>imageAllocator</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vma::AllocationCreateFlags&#160;</td>
          <td class="paramname"><em>imageAllocationCreateFlags</em> = <code>vma::AllocationCreateFlags::e_NONE</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Utility function for generating a texture atlas based on a set of images.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">device</td><td>The device used to create the texture atlas.</td></tr>
    <tr><td class="paramname">inputImages</td><td>A list of input images used to generate the texture atlas from.</td></tr>
    <tr><td class="paramname">outUVs</td><td>A pointer to a set of UVs corresponding to the position of the images within the generated texture atlas.</td></tr>
    <tr><td class="paramname">numImages</td><td>The number of textures used for generating the texture atlas.</td></tr>
    <tr><td class="paramname">inputImageLayout</td><td>The current layout of the input images. All input images must be in the layout specified.</td></tr>
    <tr><td class="paramname">outImageView</td><td>The generated texture atlas returned by the function</td></tr>
    <tr><td class="paramname">outDescriptor</td><td>The texture header for the generated texture atlas</td></tr>
    <tr><td class="paramname">cmdBuffer</td><td>A previously constructured command buffer which will be used by the utility function for various operations such as creating images.</td></tr>
    <tr><td class="paramname">finalLayout</td><td>The final image layout the image will be transitioned to.</td></tr>
    <tr><td class="paramname">imageAllocator</td><td>A VMA allocator used to allocate memory for the created image.</td></tr>
    <tr><td class="paramname">imageAllocationCreateFlags</td><td>VMA Allocation creation flags. These flags can be used to control how and where the memory is allocated from. Valid flags include e_DEDICATED_MEMORY_BIT and e_MAPPED_BIT. e_DEDICATED_MEMORY_BIT indicates that the allocation should have its own memory block. e_MAPPED_BIT indicates memory will be persistently mapped respectively.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Return true if success</dd></dl>

</div>
</div>
<a class="anchor" id="a811320035b806bb4e727d9ffc7f68873"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* pvr::utils::getGlErrorString </td>
          <td>(</td>
          <td class="paramtype">GLuint&#160;</td>
          <td class="paramname"><em>apiError</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieves a string representation of an OpenGLES error code.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">apiError</td><td>The OpenGLES error code to stringify.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The string representation of the given OpenGLES error code.</dd></dl>

</div>
</div>
<a class="anchor" id="a6bbf98fde377992e9e7e0d23f38a9dcc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pvr::utils::getMemoryTypeIndex </td>
          <td>(</td>
          <td class="paramtype">const pvrvk::PhysicalDevice &amp;&#160;</td>
          <td class="paramname"><em>physicalDevice</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>allowedMemoryTypeBits</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const pvrvk::MemoryPropertyFlags&#160;</td>
          <td class="paramname"><em>requiredMemoryProperties</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const pvrvk::MemoryPropertyFlags&#160;</td>
          <td class="paramname"><em>optimalMemoryProperties</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t &amp;&#160;</td>
          <td class="paramname"><em>outMemoryTypeIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pvrvk::MemoryPropertyFlags &amp;&#160;</td>
          <td class="paramname"><em>outMemoryPropertyFlags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Utility function for retrieving a memory type index for a suitable memory type which supports the memory type bits specified. If the optimal set of memory properties are supported then return the corresponding memory type index otherwise check for availablility of the required set of memory properties. This allows for implementations to optionally request the use of a more optimal set of memory properties whilst still preserving the ability to retrieve the required set of memory properties as a fallback.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">physicalDevice</td><td>The physical device whose set of pvrvk::PhysicalDeviceMemoryProperties will be used to determine support for the requested memory properties.</td></tr>
    <tr><td class="paramname">allowedMemoryTypeBits</td><td>The memory type bits allowed. The required memory type chosen must be one of those allowed.</td></tr>
    <tr><td class="paramname">optimalMemoryProperties</td><td>A set of optimal memory properties which may be preferred by the application.</td></tr>
    <tr><td class="paramname">requiredMemoryProperties</td><td>The set of memory properties which must be present.</td></tr>
    <tr><td class="paramname">outMemoryTypeIndex</td><td>The returned memory type index.</td></tr>
    <tr><td class="paramname">outMemoryPropertyFlags</td><td>The returned set of memory property flags.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ad17214254f1b21d40271dac7b2a4b691"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pvr::utils::getOpenGLFormat </td>
          <td>(</td>
          <td class="paramtype">PixelFormat&#160;</td>
          <td class="paramname"><em>pixelFormat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ColorSpace&#160;</td>
          <td class="paramname"><em>colorSpace</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VariableType&#160;</td>
          <td class="paramname"><em>dataType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t &amp;&#160;</td>
          <td class="paramname"><em>glInternalFormat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t &amp;&#160;</td>
          <td class="paramname"><em>glFormat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t &amp;&#160;</td>
          <td class="paramname"><em>glType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t &amp;&#160;</td>
          <td class="paramname"><em>glTypeSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &amp;&#160;</td>
          <td class="paramname"><em>isCompressedFormat</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieves the OpenGL ES texture formats for a texture with pvr::PixelFormat pixelFormat, pvr::ColorSpace colorSpace and pvr::VariableType dataType.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pixelFormat</td><td>The pvr::PixelFormat to retrieve a corresponding set of OpenGL ES texture formats for.</td></tr>
    <tr><td class="paramname">colorSpace</td><td>The pvr::ColorSpace to retrieve a corresponding set of OpenGL ES texture formats for.</td></tr>
    <tr><td class="paramname">dataType</td><td>The pvr::VariableTypeto retrieve a corresponding set of OpenGL ES texture formats for.</td></tr>
    <tr><td class="paramname">glInternalFormat</td><td>The internal OpenGL ES format corresponding to the provided pvr::PixelFormat pixelFormat, pvr::ColorSpace colorSpace and pvr::VariableType dataType.</td></tr>
    <tr><td class="paramname">glFormat</td><td>The OpenGL ES format corresponding to the provided pvr::PixelFormat pixelFormat, pvr::ColorSpace colorSpace and pvr::VariableType dataType.</td></tr>
    <tr><td class="paramname">glType</td><td>The OpenGL ES type corresponding to the provided pvr::PixelFormat pixelFormat, pvr::ColorSpace colorSpace and pvr::VariableType dataType.</td></tr>
    <tr><td class="paramname">glTypeSize</td><td>The OpenGL ES type size corresponding to the provided pvr::PixelFormat pixelFormat, pvr::ColorSpace colorSpace and pvr::VariableType dataType.</td></tr>
    <tr><td class="paramname">isCompressedFormat</td><td>Specifies whether the OpenGL ES format retrieved is a compressed format.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a291e4ede9083ee35cc595b7775a6f41c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pvr::utils::getOpenGLFormat </td>
          <td>(</td>
          <td class="paramtype">ImageStorageFormat&#160;</td>
          <td class="paramname"><em>storageFormat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t &amp;&#160;</td>
          <td class="paramname"><em>glInternalFormat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t &amp;&#160;</td>
          <td class="paramname"><em>glFormat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t &amp;&#160;</td>
          <td class="paramname"><em>glType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t &amp;&#160;</td>
          <td class="paramname"><em>glTypeSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &amp;&#160;</td>
          <td class="paramname"><em>isCompressedFormat</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieves the OpenGL ES texture formats for a texture with the provided ImageStorageFormat.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">storageFormat</td><td>The pvr::ImageStorageFormat to retrieve a corresponding set of OpenGL ES texture formats for.</td></tr>
    <tr><td class="paramname">glInternalFormat</td><td>The internal OpenGL ES format corresponding to the provided pvr::ImageStorageFormat storageFormat</td></tr>
    <tr><td class="paramname">glFormat</td><td>The OpenGL ES format corresponding to the provided pvr::ImageStorageFormat storageFormat</td></tr>
    <tr><td class="paramname">glType</td><td>The OpenGL ES type corresponding to the provided pvr::ImageStorageFormat storageFormat</td></tr>
    <tr><td class="paramname">glTypeSize</td><td>The OpenGL ES type size corresponding to the provided pvr::ImageStorageFormat storageFormat</td></tr>
    <tr><td class="paramname">isCompressedFormat</td><td>Specifies whether the OpenGL ES format retrieved is a compressed format.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a9faeae4c6a35b0080b0b6031151e53e2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pvr::utils::getOpenGLStorageFormat </td>
          <td>(</td>
          <td class="paramtype">PixelFormat&#160;</td>
          <td class="paramname"><em>pixelFormat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ColorSpace&#160;</td>
          <td class="paramname"><em>colorSpace</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VariableType&#160;</td>
          <td class="paramname"><em>dataType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GLenum &amp;&#160;</td>
          <td class="paramname"><em>glInternalFormat</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieves the internal OpenGL ES texture format for a texture with pvr::PixelFormat pixelFormat, pvr::ColorSpace colorSpace and pvr::VariableType dataType.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pixelFormat</td><td>The pvr::PixelFormat to retrieve a corresponding internal OpenGL ES texture format for.</td></tr>
    <tr><td class="paramname">colorSpace</td><td>The pvr::ColorSpace to retrieve a corresponding internal OpenGL ES texture format for.</td></tr>
    <tr><td class="paramname">dataType</td><td>The pvr::VariableTypeto retrieve a corresponding internal OpenGL ES texture format for.</td></tr>
    <tr><td class="paramname">glInternalFormat</td><td>The internal OpenGL ES format corresponding to the provided pvr::PixelFormat pixelFormat, pvr::ColorSpace colorSpace and pvr::VariableType dataType</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a71a6472c33618ce49ded8e029b463429"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pvr::utils::getOpenGLStorageFormat </td>
          <td>(</td>
          <td class="paramtype">ImageStorageFormat&#160;</td>
          <td class="paramname"><em>storageFormat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GLenum &amp;&#160;</td>
          <td class="paramname"><em>glInternalFormat</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieves the internal OpenGL ES texture formats for a texture with the provided ImageStorageFormat.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">storageFormat</td><td>The pvr::ImageStorageFormat to retrieve a the internal OpenGL ES texture format for.</td></tr>
    <tr><td class="paramname">glInternalFormat</td><td>The internal OpenGL ES format corresponding to the provided pvr::ImageStorageFormat storageFormat</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns 'True' if the utility function was able to successfully determin the internal OpenGL ES format corresponding to the provided pvr::ImageStorageFormat storageFormat.</dd></dl>

</div>
</div>
<a class="anchor" id="a3555f264beaaf83ff1b84853a87a40fe"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">glm::mat4 pvr::utils::getPerspectiveMatrix </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>fovy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>aspect</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>near1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>far1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>rotate</em> = <code>.0f</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create perspective matrix that trasform scenes that use Opengl Convention (+y up) to Vulkan Convention (+y down).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fovy</td><td>The field of view in the y dimension or the vertical angle.</td></tr>
    <tr><td class="paramname">aspect</td><td>The aspect ratio.</td></tr>
    <tr><td class="paramname">near1</td><td>The near z plane.</td></tr>
    <tr><td class="paramname">far1</td><td>The far z plane.</td></tr>
    <tr><td class="paramname">rotate</td><td>An amount to rotate the generated matrix by around the z axis.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A created perspective matrix based on the fovy, aspect, near, far and rotated values.</dd></dl>

</div>
</div>
<a class="anchor" id="a86a73e3d7095724bd6d9bf4771413323"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const pvrvk::ImageView&amp; pvr::utils::getResult </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the result of the asynchronous image upload.</p>
<dl class="section return"><dt>Returns</dt><dd>The result of the asynchronous image upload which is an ImageView.</dd></dl>

</div>
</div>
<a class="anchor" id="a7151c7b74ff657fc17ff09c0ab114a07"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool pvr::utils::isFormatDepthStencil </td>
          <td>(</td>
          <td class="paramtype">pvrvk::Format&#160;</td>
          <td class="paramname"><em>format</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return true if the format is a depth stencil format</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">format</td><td>Format to querry</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the pvrvk::Format specified is a depth or stencil format</dd></dl>

</div>
</div>
<a class="anchor" id="a59222cc49624a76fab4d4f65e3337ac3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool pvr::utils::isImageUsageSupportedBySurface </td>
          <td>(</td>
          <td class="paramtype">const pvrvk::SurfaceCapabilitiesKHR &amp;&#160;</td>
          <td class="paramname"><em>surfaceCapabilities</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pvrvk::ImageUsageFlags&#160;</td>
          <td class="paramname"><em>imageUsage</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Utility function used to determine whether the SurfaceCapabilitiesKHR supportedUsageFlags member contains the specified image usage and therefore can be used in the intended way.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">surfaceCapabilities</td><td>A SurfaceCapabilitiesKHR structure returned via a call to PhysicalDevice-&gt;getSurfaceCapabilities().</td></tr>
    <tr><td class="paramname">imageUsage</td><td>A set of image usage flags which should be checked for support.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>"true" if the supportedUsageFlags member of the SurfaceCapabilitiesKHR structure contains the specified imageUsage flag bits.</dd></dl>

</div>
</div>
<a class="anchor" id="a7ad37dc22982184696fa727a91a4d463"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pvrvk::Image pvr::utils::loadAndUploadImage </td>
          <td>(</td>
          <td class="paramtype">pvrvk::Device &amp;&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>fileName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>allowDecompress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pvrvk::CommandBuffer &amp;&#160;</td>
          <td class="paramname"><em>commandBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IAssetProvider &amp;&#160;</td>
          <td class="paramname"><em>assetProvider</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pvrvk::ImageUsageFlags&#160;</td>
          <td class="paramname"><em>usageFlags</em> = <code>pvrvk::ImageUsageFlags::e_SAMPLED_BIT</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pvrvk::ImageLayout&#160;</td>
          <td class="paramname"><em>finalLayout</em> = <code>pvrvk::ImageLayout::e_GENERAL</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Texture *&#160;</td>
          <td class="paramname"><em>outAssetTexture</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vma::Allocator *&#160;</td>
          <td class="paramname"><em>stagingBufferAllocator</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vma::Allocator *&#160;</td>
          <td class="paramname"><em>imageAllocator</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vma::AllocationCreateFlags&#160;</td>
          <td class="paramname"><em>imageAllocationCreateFlags</em> = <code>vma::AllocationCreateFlags::e_NONE</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Load and upload image to gpu. The upload command and staging buffers are recorded in the commandbuffer.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">device</td><td>The device to use to create the image and image view.</td></tr>
    <tr><td class="paramname">fileName</td><td>The filename of a source texture from which to take the texture data.</td></tr>
    <tr><td class="paramname">allowDecompress</td><td>Specifies whether the texture can be decompressed as part of the image upload.</td></tr>
    <tr><td class="paramname">commandBuffer</td><td>A command buffer to which the upload operations should be added. Note that the upload will not be guranteed to be complete until the command buffer is submitted to a queue with appropriate synchronisation.</td></tr>
    <tr><td class="paramname">assetProvider</td><td>Specifies an asset provider to use for loading the texture from system memory.</td></tr>
    <tr><td class="paramname">usageFlags</td><td>Specifies the usage flags for the image being created.</td></tr>
    <tr><td class="paramname">finalLayout</td><td>The final image layout the image will be transitioned to.</td></tr>
    <tr><td class="paramname">outAssetTexture</td><td>A pointer to a created pvr::assets::Texture.</td></tr>
    <tr><td class="paramname">stagingBufferAllocator</td><td>A VMA allocator used to allocate memory for the created staging buffer.</td></tr>
    <tr><td class="paramname">imageAllocator</td><td>A VMA allocator used to allocate memory for the created image.</td></tr>
    <tr><td class="paramname">imageAllocationCreateFlags</td><td>VMA Allocation creation flags. These flags can be used to control how and where the memory is allocated from. Valid flags include e_DEDICATED_MEMORY_BIT and e_MAPPED_BIT. e_DEDICATED_MEMORY_BIT indicates that the allocation should have its own memory block. e_MAPPED_BIT indicates memory will be persistently mapped respectively.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The Image Object uploaded.</dd></dl>

</div>
</div>
<a class="anchor" id="aad7564a93a69f0c6abe5eaa255f73067"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pvrvk::Image pvr::utils::loadAndUploadImage </td>
          <td>(</td>
          <td class="paramtype">pvrvk::Device &amp;&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>fileName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>allowDecompress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pvrvk::SecondaryCommandBuffer &amp;&#160;</td>
          <td class="paramname"><em>commandBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IAssetProvider &amp;&#160;</td>
          <td class="paramname"><em>assetProvider</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pvrvk::ImageUsageFlags&#160;</td>
          <td class="paramname"><em>usageFlags</em> = <code>pvrvk::ImageUsageFlags::e_SAMPLED_BIT</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pvrvk::ImageLayout&#160;</td>
          <td class="paramname"><em>finalLayout</em> = <code>pvrvk::ImageLayout::e_GENERAL</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Texture *&#160;</td>
          <td class="paramname"><em>outAssetTexture</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vma::Allocator *&#160;</td>
          <td class="paramname"><em>stagingBufferAllocator</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vma::Allocator *&#160;</td>
          <td class="paramname"><em>imageAllocator</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vma::AllocationCreateFlags&#160;</td>
          <td class="paramname"><em>imageAllocationCreateFlags</em> = <code>vma::AllocationCreateFlags::e_NONE</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Load and upload image to gpu. The upload command and staging buffers are recorded in the commandbuffer.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">device</td><td>The device to use to create the image and image view.</td></tr>
    <tr><td class="paramname">fileName</td><td>The filename of a source texture from which to take the texture data.</td></tr>
    <tr><td class="paramname">allowDecompress</td><td>Specifies whether the texture can be decompressed as part of the image upload.</td></tr>
    <tr><td class="paramname">commandBuffer</td><td>A secondary command buffer to which the upload operations should be added. Note that the upload will not be guranteed to be complete until the command buffer is submitted to a queue with appropriate synchronisation.</td></tr>
    <tr><td class="paramname">assetProvider</td><td>Specifies an asset provider to use for loading the texture from system memory.</td></tr>
    <tr><td class="paramname">usageFlags</td><td>Specifies the usage flags for the image being created.</td></tr>
    <tr><td class="paramname">finalLayout</td><td>The final image layout the image will be transitioned to.</td></tr>
    <tr><td class="paramname">outAssetTexture</td><td>A pointer to a created pvr::assets::Texture.</td></tr>
    <tr><td class="paramname">stagingBufferAllocator</td><td>A VMA allocator used to allocate memory for the created staging buffer.</td></tr>
    <tr><td class="paramname">imageAllocator</td><td>A VMA allocator used to allocate memory for the created image.</td></tr>
    <tr><td class="paramname">imageAllocationCreateFlags</td><td>VMA Allocation creation flags. These flags can be used to control how and where the memory is allocated from. Valid flags include e_DEDICATED_MEMORY_BIT and e_MAPPED_BIT. e_DEDICATED_MEMORY_BIT indicates that the allocation should have its own memory block. e_MAPPED_BIT indicates memory will be persistently mapped respectively.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The Image Object uploaded.</dd></dl>

</div>
</div>
<a class="anchor" id="ae8540d26fd007bdb7043485ae4d5d3f7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pvrvk::ImageView pvr::utils::loadAndUploadImageAndView </td>
          <td>(</td>
          <td class="paramtype">pvrvk::Device &amp;&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>fileName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>allowDecompress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pvrvk::CommandBuffer &amp;&#160;</td>
          <td class="paramname"><em>commandBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IAssetProvider &amp;&#160;</td>
          <td class="paramname"><em>assetProvider</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pvrvk::ImageUsageFlags&#160;</td>
          <td class="paramname"><em>usageFlags</em> = <code>pvrvk::ImageUsageFlags::e_SAMPLED_BIT</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pvrvk::ImageLayout&#160;</td>
          <td class="paramname"><em>finalLayout</em> = <code>pvrvk::ImageLayout::e_GENERAL</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Texture *&#160;</td>
          <td class="paramname"><em>outAssetTexture</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vma::Allocator *&#160;</td>
          <td class="paramname"><em>stagingBufferAllocator</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vma::Allocator *&#160;</td>
          <td class="paramname"><em>imageAllocator</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vma::AllocationCreateFlags&#160;</td>
          <td class="paramname"><em>imageAllocationCreateFlags</em> = <code>vma::AllocationCreateFlags::e_NONE</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Load and upload image to gpu. The upload command and staging buffers are recorded in the commandbuffer.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">device</td><td>The device to use to create the image and image view.</td></tr>
    <tr><td class="paramname">fileName</td><td>The filename of a source texture from which to take the texture data.</td></tr>
    <tr><td class="paramname">allowDecompress</td><td>Specifies whether the texture can be decompressed as part of the image upload.</td></tr>
    <tr><td class="paramname">commandBuffer</td><td>A command buffer to which the upload operations should be added. Note that the upload will not be guranteed to be complete until the command buffer is submitted to a queue with appropriate synchronisation.</td></tr>
    <tr><td class="paramname">assetProvider</td><td>Specifies an asset provider to use for loading the texture from system memory.</td></tr>
    <tr><td class="paramname">usageFlags</td><td>Specifies the usage flags for the image being created.</td></tr>
    <tr><td class="paramname">finalLayout</td><td>The final image layout the image will be transitioned to.</td></tr>
    <tr><td class="paramname">outAssetTexture</td><td>A pointer to a created pvr::assets::Texture.</td></tr>
    <tr><td class="paramname">stagingBufferAllocator</td><td>A VMA allocator used to allocate memory for the created staging buffer.</td></tr>
    <tr><td class="paramname">imageAllocator</td><td>A VMA allocator used to allocate memory for the created image.</td></tr>
    <tr><td class="paramname">imageAllocationCreateFlags</td><td>VMA Allocation creation flags. These flags can be used to control how and where the memory is allocated from. Valid flags include e_DEDICATED_MEMORY_BIT and e_MAPPED_BIT. e_DEDICATED_MEMORY_BIT indicates that the allocation should have its own memory block. e_MAPPED_BIT indicates memory will be persistently mapped respectively.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The Image Object uploaded.</dd></dl>

</div>
</div>
<a class="anchor" id="a5eab64fb48adc7ccfb4a08224bc6f538"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pvrvk::ImageView pvr::utils::loadAndUploadImageAndView </td>
          <td>(</td>
          <td class="paramtype">pvrvk::Device &amp;&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>fileName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>allowDecompress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pvrvk::SecondaryCommandBuffer &amp;&#160;</td>
          <td class="paramname"><em>commandBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IAssetProvider &amp;&#160;</td>
          <td class="paramname"><em>assetProvider</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pvrvk::ImageUsageFlags&#160;</td>
          <td class="paramname"><em>usageFlags</em> = <code>pvrvk::ImageUsageFlags::e_SAMPLED_BIT</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pvrvk::ImageLayout&#160;</td>
          <td class="paramname"><em>finalLayout</em> = <code>pvrvk::ImageLayout::e_GENERAL</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Texture *&#160;</td>
          <td class="paramname"><em>outAssetTexture</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vma::Allocator *&#160;</td>
          <td class="paramname"><em>stagingBufferAllocator</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vma::Allocator *&#160;</td>
          <td class="paramname"><em>imageAllocator</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vma::AllocationCreateFlags&#160;</td>
          <td class="paramname"><em>imageAllocationCreateFlags</em> = <code>vma::AllocationCreateFlags::e_NONE</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Load and upload image to gpu. The upload command and staging buffers are recorded in the commandbuffer.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">device</td><td>The device to use to create the image and image view.</td></tr>
    <tr><td class="paramname">fileName</td><td>The filename of a source texture from which to take the texture data.</td></tr>
    <tr><td class="paramname">allowDecompress</td><td>Specifies whether the texture can be decompressed as part of the image upload.</td></tr>
    <tr><td class="paramname">commandBuffer</td><td>A secondary command buffer to which the upload operations should be added. Note that the upload will not be guranteed to be complete until the command buffer is submitted to a queue with appropriate synchronisation.</td></tr>
    <tr><td class="paramname">assetProvider</td><td>Specifies an asset provider to use for loading the texture from system memory.</td></tr>
    <tr><td class="paramname">usageFlags</td><td>Specifies the usage flags for the image being created.</td></tr>
    <tr><td class="paramname">finalLayout</td><td>The final image layout the image will be transitioned to.</td></tr>
    <tr><td class="paramname">outAssetTexture</td><td>A pointer to a created pvr::assets::Texture.</td></tr>
    <tr><td class="paramname">stagingBufferAllocator</td><td>A VMA allocator used to allocate memory for the created staging buffer.</td></tr>
    <tr><td class="paramname">imageAllocator</td><td>A VMA allocator used to allocate memory for the created image.</td></tr>
    <tr><td class="paramname">imageAllocationCreateFlags</td><td>VMA Allocation creation flags. These flags can be used to control how and where the memory is allocated from. Valid flags include e_DEDICATED_MEMORY_BIT and e_MAPPED_BIT. e_DEDICATED_MEMORY_BIT indicates that the allocation should have its own memory block. e_MAPPED_BIT indicates memory will be persistently mapped respectively.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The Image Object uploaded.</dd></dl>

</div>
</div>
<a class="anchor" id="a4067540852cf8dd4277248b1d0170683"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pvr::utils::loadNow </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initiates the asynchronous image upload.</p>

</div>
</div>
<a class="anchor" id="ab6587db0405c15cfceeb768f0a740dca"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GLuint pvr::utils::loadShader </td>
          <td>(</td>
          <td class="paramtype">const Stream &amp;&#160;</td>
          <td class="paramname"><em>shaderSource</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ShaderType&#160;</td>
          <td class="paramname"><em>shaderType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *const *&#160;</td>
          <td class="paramname"><em>defines</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>numDefines</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Load shader from shader source. Will implicitly load on the current context.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">shaderSource</td><td>A stream containing the shader source text data</td></tr>
    <tr><td class="paramname">shaderType</td><td>The type (stage) of the shader (vertex, fragment...)</td></tr>
    <tr><td class="paramname">defines</td><td>A number of preprocessor definitions that will be passed to the shader</td></tr>
    <tr><td class="paramname">numDefines</td><td>The number of defines</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The shader object</dd></dl>

</div>
</div>
<a class="anchor" id="a1cbbbd1665449ea70d772de63595c806"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VKAPI_ATTR VkBool32 VKAPI_CALL pvr::utils::logMessageDebugReportCallback </td>
          <td>(</td>
          <td class="paramtype">VkDebugReportFlagsEXT&#160;</td>
          <td class="paramname"><em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VkDebugReportObjectTypeEXT&#160;</td>
          <td class="paramname"><em>objectType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>object</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>location</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>messageCode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pLayerPrefix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pMessage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>pUserData</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>An application DebugReportCallback function providing logging for various events.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">flags</td><td>Indicates the VkDebugReportFlagsEXT triggering the callback.</td></tr>
    <tr><td class="paramname">objectType</td><td>The type of the object being used/created when the event was triggered.</td></tr>
    <tr><td class="paramname">object</td><td>The object where the issue was detected</td></tr>
    <tr><td class="paramname">location</td><td>A component defined value indicating the location of the trigger</td></tr>
    <tr><td class="paramname">messageCode</td><td>A layer defined value indicating the test which triggered the callback</td></tr>
    <tr><td class="paramname">pLayerPrefix</td><td>Abbreviation of the component making the callback</td></tr>
    <tr><td class="paramname">pMessage</td><td>String detailing the trigger conditions</td></tr>
    <tr><td class="paramname">pUserData</td><td>User data given when the callback was created</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns an indication to the calling layer as to whether the Vulkan call should be aborted or not. Applications should always return VK_FALSE so that they see the same behavior with and without validation layers enabled.</dd></dl>

</div>
</div>
<a class="anchor" id="adca914d6eedd686a81a4f0e4cbbc3390"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">LogLevel pvr::utils::mapValidationTypeToLogLevel </td>
          <td>(</td>
          <td class="paramtype">pvrvk::DebugReportFlagsEXT&#160;</td>
          <td class="paramname"><em>flags</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Maps a set of VkDebugReportFlagsEXT to a particular type of log message.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">flags</td><td>The VkDebugReportFlagsEXT to map to a LogLevel.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a LogLevel deemed to correspond to the given pvrvk::DebugReportFlagsEXT.</dd></dl>

</div>
</div>
<a class="anchor" id="a98e4ac9990af6eaf6b9bf0928f2bd07d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pvr::utils::populateClearValues </td>
          <td>(</td>
          <td class="paramtype">const pvrvk::RenderPass &amp;&#160;</td>
          <td class="paramname"><em>renderpass</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const pvrvk::ClearValue &amp;&#160;</td>
          <td class="paramname"><em>clearColor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const pvrvk::ClearValue &amp;&#160;</td>
          <td class="paramname"><em>clearDepthStencilValue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pvrvk::ClearValue *&#160;</td>
          <td class="paramname"><em>outClearValues</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Populate color and depthstencil clear values</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">renderpass</td><td>The renderpass is used to determine the number of attachments and their formats from which a decision will be as to whether the provided clearColor or clearDepthStencilValue will be used for the corresponding pvrvk::ClearValue structure for each attachment.</td></tr>
    <tr><td class="paramname">clearColor</td><td>A pvrvk::ClearValue which will be used as the clear color value for the renderpass attachments with color formats</td></tr>
    <tr><td class="paramname">clearDepthStencilValue</td><td>A pvrvk::ClearValue which will be used as the depth stencil value for the renderpass attachments with depth stencil formats</td></tr>
    <tr><td class="paramname">outClearValues</td><td>A pointer to an array of pvrvk::ClearValue structures which should have size greater than or equal to the number of renderpass attachments.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a40ca7bc0dc1b494e3b13e654bf582012"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pvr::utils::populateInputAssemblyFromMesh </td>
          <td>(</td>
          <td class="paramtype">const assets::Mesh &amp;&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const VertexBindings *&#160;</td>
          <td class="paramname"><em>bindingMap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>numBindings</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pvrvk::PipelineVertexInputStateCreateInfo &amp;&#160;</td>
          <td class="paramname"><em>vertexCreateInfo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pvrvk::InputAssemblerStateCreateInfo &amp;&#160;</td>
          <td class="paramname"><em>inputAssemblerCreateInfo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t *&#160;</td>
          <td class="paramname"><em>numOutBuffers</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Fills out input assembly and vertex input state structures using a mesh and a list of corresponding <a class="el" href="structpvr_1_1utils_1_1_vertex_bindings.html" title="Represents a shader Explicit binding, tying a Semantic name to an Attribute Index.">VertexBindings</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mesh</td><td>A mesh from which to retrieve vertex attributes, vertex buffer strides and primitive topology information from.</td></tr>
    <tr><td class="paramname">bindingMap</td><td>A pointer to an array of <a class="el" href="structpvr_1_1utils_1_1_vertex_bindings.html" title="Represents a shader Explicit binding, tying a Semantic name to an Attribute Index.">VertexBindings</a> structures which specify the semantic names and binding indices of any vertex attributes to retrieve.</td></tr>
    <tr><td class="paramname">numBindings</td><td>Specifies the number of <a class="el" href="structpvr_1_1utils_1_1_vertex_bindings.html" title="Represents a shader Explicit binding, tying a Semantic name to an Attribute Index.">VertexBindings</a> structures in the array pointed to by bindingMap.</td></tr>
    <tr><td class="paramname">vertexCreateInfo</td><td>A pvrvk::PipelineVertexInputStateCreateInfo structure which will be filled by this utility function.</td></tr>
    <tr><td class="paramname">inputAssemblerCreateInfo</td><td>A pvrvk::InputAssemblerStateCreateInfo structure which will be filled by this utility function.</td></tr>
    <tr><td class="paramname">numOutBuffers</td><td>A pointer to an unsigned integer which will set to specify the number of buffers required to create buffers for to use the mesh vertex attributes.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="adf7346cd6cd2ef2705d14ab35284f045"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pvr::utils::populateInputAssemblyFromMesh </td>
          <td>(</td>
          <td class="paramtype">const assets::Mesh &amp;&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const VertexBindings_Name *&#160;</td>
          <td class="paramname"><em>bindingMap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>numBindings</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pvrvk::PipelineVertexInputStateCreateInfo &amp;&#160;</td>
          <td class="paramname"><em>vertexCreateInfo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pvrvk::InputAssemblerStateCreateInfo &amp;&#160;</td>
          <td class="paramname"><em>inputAssemblerCreateInfo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t *&#160;</td>
          <td class="paramname"><em>numOutBuffers</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Fills out input assembly and vertex input state structures using a mesh and a list of corresponding <a class="el" href="structpvr_1_1utils_1_1_vertex_bindings___name.html" title="Represents a shader Reflective binding, tying a Semantic name to an Attribute variable name...">VertexBindings_Name</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mesh</td><td>A mesh from which to retrieve vertex attributes, vertex buffer strides and primitive topology information from.</td></tr>
    <tr><td class="paramname">bindingMap</td><td>A pointer to an array of <a class="el" href="structpvr_1_1utils_1_1_vertex_bindings___name.html" title="Represents a shader Reflective binding, tying a Semantic name to an Attribute variable name...">VertexBindings_Name</a> structures which specify the semantic and binding names of any vertex attributes to retrieve.</td></tr>
    <tr><td class="paramname">numBindings</td><td>Specifies the number of <a class="el" href="structpvr_1_1utils_1_1_vertex_bindings.html" title="Represents a shader Explicit binding, tying a Semantic name to an Attribute Index.">VertexBindings</a> structures in the array pointed to by bindingMap.</td></tr>
    <tr><td class="paramname">vertexCreateInfo</td><td>A pvrvk::PipelineVertexInputStateCreateInfo structure which will be filled by this utility function.</td></tr>
    <tr><td class="paramname">inputAssemblerCreateInfo</td><td>A pvrvk::InputAssemblerStateCreateInfo structure which will be filled by this utility function.</td></tr>
    <tr><td class="paramname">numOutBuffers</td><td>A pointer to an unsigned integer which will set to specify the number of buffers required to create buffers for to use the mesh vertex attributes.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a0688d6e1f181259f4000994896d5157b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pvr::utils::populateViewportStateCreateInfo </td>
          <td>(</td>
          <td class="paramtype">const pvrvk::Framebuffer &amp;&#160;</td>
          <td class="paramname"><em>framebuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pvrvk::ViewportStateCreateInfo &amp;&#160;</td>
          <td class="paramname"><em>outCreateInfo</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Fills out a pvrvk::ViewportStateCreateInfo structure setting parameters for a 'default' viewport and scissor based on the specified frame buffer dimensions.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">framebuffer</td><td>An input Framebuffer object from which to take dimensions used to initialise a pvrvk::ViewportStateCreateInfo structure.</td></tr>
    <tr><td class="paramname">outCreateInfo</td><td>A pvrvk::ViewportStateCreateInfo structure which will have its viewport and scissor members set based on the framebuffers dimensions.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="abca543a0c306d801f96b0cc6af848371"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pvr::utils::saveImage </td>
          <td>(</td>
          <td class="paramtype">pvrvk::Image&#160;</td>
          <td class="paramname"><em>image</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const pvrvk::ImageLayout&#160;</td>
          <td class="paramname"><em>imageInitialLayout</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const pvrvk::ImageLayout&#160;</td>
          <td class="paramname"><em>imageFinalLayout</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pvrvk::CommandPool &amp;&#160;</td>
          <td class="paramname"><em>pool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pvrvk::Queue &amp;&#160;</td>
          <td class="paramname"><em>queue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vma::Allocator *&#160;</td>
          <td class="paramname"><em>bufferAllocator</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vma::Allocator *&#160;</td>
          <td class="paramname"><em>imageAllocator</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>screenshotScale</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Saves the input image as a TGA file with the filename specified. Note that the image must have been created with the pvrvk::ImageUsageFlags::e_TRANSFER_SRC_BIT set.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">image</td><td>The image to save as a TGA file.</td></tr>
    <tr><td class="paramname">imageInitialLayout</td><td>The initial layout of the image from which a transition will be made to pvrvk::ImageLayout::e_TRANSFER_SRC_OPTIMAL.</td></tr>
    <tr><td class="paramname">imageFinalLayout</td><td>The final layout of the image to which a transition will be made.</td></tr>
    <tr><td class="paramname">pool</td><td>A command pool from which to allocate a temporary command buffer to carry out the transfer operations.</td></tr>
    <tr><td class="paramname">queue</td><td>A queue to submit the generated command buffer to. This queue must be compatible with the command pool provided.</td></tr>
    <tr><td class="paramname">filename</td><td>The filename to use for the saved TGA image.</td></tr>
    <tr><td class="paramname">bufferAllocator</td><td>A VMA allocator used to allocate memory for the created the buffer used as the target of an imageToBufferCopy.</td></tr>
    <tr><td class="paramname">imageAllocator</td><td>A VMA allocator used to allocate memory for the created image.</td></tr>
    <tr><td class="paramname">screenshotScale</td><td>A scaling factor to use for increasing the size of the saved screenshot.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a199d0b69632a76610e1f3f5c92289cfd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pvr::utils::setCallBack </td>
          <td>(</td>
          <td class="paramtype">CallbackType&#160;</td>
          <td class="paramname"><em>callback</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets a callback which will be called after the image upload has completed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">callback</td><td>Specifies a callback to call when the image upload has completed.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a8ea166ded6ff46a11573815a99f42869"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pvr::utils::setImageLayout </td>
          <td>(</td>
          <td class="paramtype">pvrvk::Image&#160;</td>
          <td class="paramname"><em>image</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pvrvk::ImageLayout&#160;</td>
          <td class="paramname"><em>oldLayout</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pvrvk::ImageLayout&#160;</td>
          <td class="paramname"><em>newLayout</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pvrvk::CommandBufferBase&#160;</td>
          <td class="paramname"><em>transitionCmdBuffer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set image layout</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">image</td><td>The image to transition</td></tr>
    <tr><td class="paramname">oldLayout</td><td>An old image layout to transition from</td></tr>
    <tr><td class="paramname">newLayout</td><td>A new image layout to transition to</td></tr>
    <tr><td class="paramname">transitionCmdBuffer</td><td>A command buffer to add the pipelineBarrier for the image transition.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a5aa9ef93f949ec94122ac1f5d915f8a0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pvr::utils::setImageLayoutAndQueueFamilyOwnership </td>
          <td>(</td>
          <td class="paramtype">pvrvk::CommandBufferBase&#160;</td>
          <td class="paramname"><em>srccmd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pvrvk::CommandBufferBase&#160;</td>
          <td class="paramname"><em>dstcmd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>srcQueueFamily</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>dstQueueFamily</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pvrvk::ImageLayout&#160;</td>
          <td class="paramname"><em>oldLayout</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pvrvk::ImageLayout&#160;</td>
          <td class="paramname"><em>newLayout</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pvrvk::Image&#160;</td>
          <td class="paramname"><em>image</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>baseMipLevel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>numMipLevels</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>baseArrayLayer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>numArrayLayers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pvrvk::ImageAspectFlags&#160;</td>
          <td class="paramname"><em>aspect</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set image layout and queue family ownership</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">srccmd</td><td>The source command buffer from which to transition the image from.</td></tr>
    <tr><td class="paramname">dstcmd</td><td>The destination command buffer from which to transition the image to.</td></tr>
    <tr><td class="paramname">srcQueueFamily</td><td>srcQueueFamily is the source queue family for a queue family ownership transfer.</td></tr>
    <tr><td class="paramname">dstQueueFamily</td><td>dstQueueFamily is the destination queue family for a queue family ownership transfer.</td></tr>
    <tr><td class="paramname">oldLayout</td><td>An old image layout to transition from</td></tr>
    <tr><td class="paramname">newLayout</td><td>A new image layout to transition to</td></tr>
    <tr><td class="paramname">image</td><td>The image to transition</td></tr>
    <tr><td class="paramname">baseMipLevel</td><td>The base mip level of the image to transition</td></tr>
    <tr><td class="paramname">numMipLevels</td><td>The number of mip levels of the image to transition</td></tr>
    <tr><td class="paramname">baseArrayLayer</td><td>The base array layer level of the image to transition</td></tr>
    <tr><td class="paramname">numArrayLayers</td><td>The number of array layers of the image to transition</td></tr>
    <tr><td class="paramname">aspect</td><td>The pvrvk::ImageAspectFlags of the image to transition</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a22821a94e895873a43ffa097381a1415"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool pvr::utils::takeScreenshot </td>
          <td>(</td>
          <td class="paramtype">pvrvk::Swapchain &amp;&#160;</td>
          <td class="paramname"><em>swapChain</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>swapIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pvrvk::CommandPool &amp;&#160;</td>
          <td class="paramname"><em>pool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pvrvk::Queue &amp;&#160;</td>
          <td class="paramname"><em>queue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>screenshotFileName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vma::Allocator *&#160;</td>
          <td class="paramname"><em>bufferAllocator</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vma::Allocator *&#160;</td>
          <td class="paramname"><em>imageAllocator</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>screenshotScale</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Saves a particular swapchain image corresponding to the swapchain image at index swapIndex for the swapChain.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">swapChain</td><td>The swapchain from which a particular image will be saved.</td></tr>
    <tr><td class="paramname">swapIndex</td><td>The swapchain image at index swapIndex will be saved as a TGA file.</td></tr>
    <tr><td class="paramname">pool</td><td>A command pool from which to allocate a temporary command buffer to carry out the transfer operations.</td></tr>
    <tr><td class="paramname">queue</td><td>A queue to submit the generated command buffer to. This queue must be compatible with the command pool provided.</td></tr>
    <tr><td class="paramname">screenshotFileName</td><td>The filename to use for the saved TGA image.</td></tr>
    <tr><td class="paramname">bufferAllocator</td><td>A VMA allocator used to allocate memory for the created the buffer used as the target of an imageToBufferCopy.</td></tr>
    <tr><td class="paramname">imageAllocator</td><td>A VMA allocator used to allocate memory for the created image.</td></tr>
    <tr><td class="paramname">screenshotScale</td><td>A scaling factor to use for increasing the size of the saved screenshot.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the screenshot could be taken successfully</dd></dl>

</div>
</div>
<a class="anchor" id="adac9f0af2d041d5efe3f668f87c6932b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structpvr_1_1utils_1_1_texture_upload_results.html">TextureUploadResults</a> pvr::utils::textureUpload </td>
          <td>(</td>
          <td class="paramtype">const Texture &amp;&#160;</td>
          <td class="paramname"><em>texture</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>isEs2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>allowDecompress</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Upload a texture to the GPU on the current context, and return it as part of the <a class="el" href="structpvr_1_1utils_1_1_texture_upload_results.html" title="The TextureUploadResults structure provides the results for texture upload functions in a simple to u...">TextureUploadResults</a> structure.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">texture</td><td>The pvr::assets::texture to upload to the GPU</td></tr>
    <tr><td class="paramname">isEs2</td><td>Signifies whether the current context being used for the texture upload is ES2 only. If the context is ES2 only then the texture upload should not use ES3+ functionality as it will be unsupported via this context.</td></tr>
    <tr><td class="paramname">allowDecompress</td><td>Set to true to allow to attempt to de-compress unsupported compressed textures. The textures will be decompressed if ALL of the following are true: The texture is in a compressed format that can be decompressed by the framework (PVRTC), the platform does NOT support this format (if it is hardware supported, it will never be decompressed), and this flag is set to true. Default:true.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="structpvr_1_1utils_1_1_texture_upload_results.html" title="The TextureUploadResults structure provides the results for texture upload functions in a simple to u...">TextureUploadResults</a> object containing the uploaded texture and all necessary information (size, formats, whether it was actually decompressed. The "result" field will contain Result::Success on success, errorcode otherwise. See the Texture</dd></dl>

</div>
</div>
<a class="anchor" id="a54f2bb511b50d2c11ddc7377a60714ad"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VKAPI_ATTR VkBool32 VKAPI_CALL pvr::utils::throwOnErrorDebugReportCallback </td>
          <td>(</td>
          <td class="paramtype">VkDebugReportFlagsEXT&#160;</td>
          <td class="paramname"><em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VkDebugReportObjectTypeEXT&#160;</td>
          <td class="paramname"><em>objectType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>object</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>location</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>messageCode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pLayerPrefix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pMessage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>pUserData</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>An application DebugReportCallback function providing logging for various events. The callback will also throw an exception when VkDebugReportFlagsEXT includes the VK_DEBUG_REPORT_ERROR_BIT_EXT.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">flags</td><td>Indicates the VkDebugReportFlagsEXT triggering the callback.</td></tr>
    <tr><td class="paramname">objectType</td><td>The type of the object being used/created when the event was triggered.</td></tr>
    <tr><td class="paramname">object</td><td>The object where the issue was detected</td></tr>
    <tr><td class="paramname">location</td><td>A component defined value indicating the location of the trigger</td></tr>
    <tr><td class="paramname">messageCode</td><td>A layer defined value indicating the test which triggered the callback</td></tr>
    <tr><td class="paramname">pLayerPrefix</td><td>Abbreviation of the component making the callback</td></tr>
    <tr><td class="paramname">pMessage</td><td>String detailing the trigger conditions</td></tr>
    <tr><td class="paramname">pUserData</td><td>User data given when the callback was created</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns an indication to the calling layer as to whether the Vulkan call should be aborted or not. Applications should always return VK_FALSE so that they see the same behavior with and without validation layers enabled.</dd></dl>

</div>
</div>
<a class="anchor" id="a60f28cc84ae08ec7d3c050c8f9725d88"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pvr::utils::throwOnGlError </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>note</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">LogLevel&#160;</td>
          <td class="paramname"><em>severity</em> = <code>LogLevel::Error</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks and logs api errors if appropriate.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">note</td><td>A c-style std::string that will be prepended to the error description if an error is found.</td></tr>
    <tr><td class="paramname">severity</td><td>that the error will be reported with, if an error is found</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ac885b6f537cb86c114be6696c3dc2fb6"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pvr::utils::updateBufferUsingStagingBuffer </td>
          <td>(</td>
          <td class="paramtype">pvrvk::Device &amp;&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pvrvk::Buffer &amp;&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pvrvk::CommandBufferBase&#160;</td>
          <td class="paramname"><em>uploadCmdBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VkDeviceSize&#160;</td>
          <td class="paramname"><em>offset</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VkDeviceSize&#160;</td>
          <td class="paramname"><em>size</em> = <code>VK_WHOLE_SIZE</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vma::Allocator *&#160;</td>
          <td class="paramname"><em>stagingBufferAllocator</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Utility function to update a buffer's data via an indirect copy from a temporary staging buffer. Updating memory via the use of a staging buffer is necessary when using memory without e_HOST_VISIBLE_BIT memory property flags meaning the buffer itself cannot be mapped to host memory.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">device</td><td>The device used to create the staging buffer</td></tr>
    <tr><td class="paramname">buffer</td><td>The destination buffer.</td></tr>
    <tr><td class="paramname">uploadCmdBuffer</td><td>A command buffer into which commands will be recorded for carrying out the buffer copy</td></tr>
    <tr><td class="paramname">data</td><td>The data to use in the update</td></tr>
    <tr><td class="paramname">offset</td><td>The offset to use for the map -&gt; update -&gt; unmap</td></tr>
    <tr><td class="paramname">size</td><td>The size of the data to be updated</td></tr>
    <tr><td class="paramname">stagingBufferAllocator</td><td>A VMA allocator used to allocate memory for the created staging buffer.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a618e4160bd8c24d9e0d394dc9511f4a3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pvr::utils::updateHostVisibleBuffer </td>
          <td>(</td>
          <td class="paramtype">pvrvk::Buffer &amp;&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VkDeviceSize&#160;</td>
          <td class="paramname"><em>offset</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VkDeviceSize&#160;</td>
          <td class="paramname"><em>size</em> = <code>VK_WHOLE_SIZE</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>flushMemory</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Utility function to update a buffer's data. This function maps and unmap the buffer only if the buffer is not already mapped.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buffer</td><td>The buffer to map -&gt; update -&gt; unmap.</td></tr>
    <tr><td class="paramname">data</td><td>The data to use in the update</td></tr>
    <tr><td class="paramname">offset</td><td>The offset to use for the map -&gt; update -&gt; unmap</td></tr>
    <tr><td class="paramname">size</td><td>The size of the data to be updated</td></tr>
    <tr><td class="paramname">flushMemory</td><td>Boolean flag determining whether to flush the memory prior to the unmap</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a71cc4019e6c6315a8a714f4103bfe503"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pvr::utils::updateImage </td>
          <td>(</td>
          <td class="paramtype">pvrvk::Device &amp;&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pvrvk::CommandBufferBase&#160;</td>
          <td class="paramname"><em>transferCommandBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ImageUpdateInfo *&#160;</td>
          <td class="paramname"><em>updateInfos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>numUpdateInfos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pvrvk::Format&#160;</td>
          <td class="paramname"><em>format</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pvrvk::ImageLayout&#160;</td>
          <td class="paramname"><em>layout</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>isCubeMap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pvrvk::Image &amp;&#160;</td>
          <td class="paramname"><em>image</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vma::Allocator *&#160;</td>
          <td class="paramname"><em>bufferAllocator</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Utility function to update an image's data. This function will record the update of the image in the supplied command buffer but NOT submit the command buffer, hence allowing the user to submit it at his own time. IMPORTANT. Assumes image layout is pvrvk::ImageLayout::e_DST_OPTIMAL IMPORTANT. The cleanup object that is the return value of the function must be kept alive as long until the moment that the relevant command buffer submission is finished. Then it can be destroyed (or the cleanup function be called) to free any relevant resources.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">device</td><td>The device used to create the image</td></tr>
    <tr><td class="paramname">transferCommandBuffer</td><td>The command buffer into which the image update operations will be added.</td></tr>
    <tr><td class="paramname">updateInfos</td><td>This object is a c-style array of areas and the data to upload.</td></tr>
    <tr><td class="paramname">numUpdateInfos</td><td>The number of <a class="el" href="structpvr_1_1utils_1_1_image_update_info.html" title="The ImageUpdateInfo struct.">ImageUpdateInfo</a> objects in </td></tr>
    <tr><td class="paramname">format</td><td>The format of the image.</td></tr>
    <tr><td class="paramname">layout</td><td>The final image layout for the image being updated.</td></tr>
    <tr><td class="paramname">isCubeMap</td><td>Is the image a cubemap</td></tr>
    <tr><td class="paramname">image</td><td>The image to update</td></tr>
    <tr><td class="paramname">bufferAllocator</td><td>A VMA allocator used to allocate memory for the created buffer.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns an pvrvk::Image update results structure - ImageUpdateResults</dd></dl>

</div>
</div>
<a class="anchor" id="a23e2bd58f63311d085500c45a565368e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pvrvk::ImageView pvr::utils::uploadImageAndView </td>
          <td>(</td>
          <td class="paramtype">pvrvk::Device &amp;&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Texture &amp;&#160;</td>
          <td class="paramname"><em>texture</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>allowDecompress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pvrvk::SecondaryCommandBuffer &amp;&#160;</td>
          <td class="paramname"><em>commandBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pvrvk::ImageUsageFlags&#160;</td>
          <td class="paramname"><em>usageFlags</em> = <code>pvrvk::ImageUsageFlags::e_SAMPLED_BIT</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pvrvk::ImageLayout&#160;</td>
          <td class="paramname"><em>finalLayout</em> = <code>pvrvk::ImageLayout::e_GENERAL</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vma::Allocator *&#160;</td>
          <td class="paramname"><em>stagingBufferAllocator</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vma::Allocator *&#160;</td>
          <td class="paramname"><em>imageAllocator</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vma::AllocationCreateFlags&#160;</td>
          <td class="paramname"><em>imageAllocationCreateFlags</em> = <code>vma::AllocationCreateFlags::e_NONE</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Uploads an image to gpu. The upload command and staging buffers are recorded in the commandbuffer.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">device</td><td>The device to use to create the image and image view.</td></tr>
    <tr><td class="paramname">texture</td><td>The source pvr::assets::Texture object from which to take the texture data.</td></tr>
    <tr><td class="paramname">allowDecompress</td><td>Specifies whether the texture can be decompressed as part of the image upload.</td></tr>
    <tr><td class="paramname">commandBuffer</td><td>A secondary command buffer to which the upload operations are be added. Note that the upload will not be guranteed to be complete until the command buffer is submitted to a queue with appropriate synchronisation.</td></tr>
    <tr><td class="paramname">usageFlags</td><td>A command buffer to add the pipelineBarrier for the image transition.</td></tr>
    <tr><td class="paramname">finalLayout</td><td>The final image layout the image will be transitioned to.</td></tr>
    <tr><td class="paramname">stagingBufferAllocator</td><td>A VMA allocator used to allocate memory for the created staging buffer.</td></tr>
    <tr><td class="paramname">imageAllocator</td><td>A VMA allocator used to allocate memory for the created image.</td></tr>
    <tr><td class="paramname">imageAllocationCreateFlags</td><td>VMA Allocation creation flags. These flags can be used to control how and where the memory is allocated from. Valid flags include e_DEDICATED_MEMORY_BIT and e_MAPPED_BIT. e_DEDICATED_MEMORY_BIT indicates that the allocation should have its own memory block. e_MAPPED_BIT indicates memory will be persistently mapped respectively.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The loaded image object.</dd></dl>

</div>
</div>
<a class="anchor" id="a6ada7cce97f2cb51b083c26b5b0cfa09"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pvrvk::ImageView pvr::utils::uploadImageAndView </td>
          <td>(</td>
          <td class="paramtype">pvrvk::Device &amp;&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Texture &amp;&#160;</td>
          <td class="paramname"><em>texture</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>allowDecompress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pvrvk::CommandBuffer &amp;&#160;</td>
          <td class="paramname"><em>commandBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pvrvk::ImageUsageFlags&#160;</td>
          <td class="paramname"><em>usageFlags</em> = <code>pvrvk::ImageUsageFlags::e_SAMPLED_BIT</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pvrvk::ImageLayout&#160;</td>
          <td class="paramname"><em>finalLayout</em> = <code>pvrvk::ImageLayout::e_GENERAL</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vma::Allocator *&#160;</td>
          <td class="paramname"><em>stagingBufferAllocator</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vma::Allocator *&#160;</td>
          <td class="paramname"><em>imageAllocator</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vma::AllocationCreateFlags&#160;</td>
          <td class="paramname"><em>imageAllocationCreateFlags</em> = <code>vma::AllocationCreateFlags::e_NONE</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Upload image to gpu. The upload command and staging buffers are recorded in the commandbuffer.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">device</td><td>The device to use to create the image and image view.</td></tr>
    <tr><td class="paramname">texture</td><td>The source pvr::assets::Texture object from which to take the texture data.</td></tr>
    <tr><td class="paramname">allowDecompress</td><td>Specifies whether the texture can be decompressed as part of the image upload.</td></tr>
    <tr><td class="paramname">commandBuffer</td><td>A command buffer to which the upload operations should be added. Note that the upload will not be guranteed to be complete until the command buffer is submitted to a queue with appropriate synchronisation.</td></tr>
    <tr><td class="paramname">usageFlags</td><td>A command buffer to add the pipelineBarrier for the image transition.</td></tr>
    <tr><td class="paramname">finalLayout</td><td>The final image layout the image will be transitioned to.</td></tr>
    <tr><td class="paramname">stagingBufferAllocator</td><td>A VMA allocator used to allocate memory for the created staging buffer.</td></tr>
    <tr><td class="paramname">imageAllocator</td><td>A VMA allocator used to allocate memory for the created image.</td></tr>
    <tr><td class="paramname">imageAllocationCreateFlags</td><td>VMA Allocation creation flags. These flags can be used to control how and where the memory is allocated from. Valid flags include e_DEDICATED_MEMORY_BIT and e_MAPPED_BIT. e_DEDICATED_MEMORY_BIT indicates that the allocation should have its own memory block. e_MAPPED_BIT indicates memory will be persistently mapped respectively.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The image object.</dd></dl>

</div>
</div>
<a class="anchor" id="a59dd0ec7054d10491117326027890b2d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pvrvk::ImageView pvr::utils::uploadImageAndViewSubmit </td>
          <td>(</td>
          <td class="paramtype">pvrvk::Device &amp;&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Texture &amp;&#160;</td>
          <td class="paramname"><em>texture</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>allowDecompress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pvrvk::CommandPool &amp;&#160;</td>
          <td class="paramname"><em>cmdPool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pvrvk::Queue &amp;&#160;</td>
          <td class="paramname"><em>queue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pvrvk::ImageUsageFlags&#160;</td>
          <td class="paramname"><em>usageFlags</em> = <code>pvrvk::ImageUsageFlags::e_SAMPLED_BIT</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pvrvk::ImageLayout&#160;</td>
          <td class="paramname"><em>finalLayout</em> = <code>pvrvk::ImageLayout::e_GENERAL</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vma::Allocator *&#160;</td>
          <td class="paramname"><em>stagingBufferAllocator</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vma::Allocator *&#160;</td>
          <td class="paramname"><em>imageAllocator</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vma::AllocationCreateFlags&#160;</td>
          <td class="paramname"><em>imageAllocationCreateFlags</em> = <code>vma::AllocationCreateFlags::e_NONE</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Uploads an image to GPU memory and returns the created image view and associated image.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">device</td><td>The device to use to create the image and image view.</td></tr>
    <tr><td class="paramname">texture</td><td>The source pvr::assets::Texture object from which to take the texture data.</td></tr>
    <tr><td class="paramname">allowDecompress</td><td>Specifies whether the texture can be decompressed as part of the image upload.</td></tr>
    <tr><td class="paramname">cmdPool</td><td>A command pool from which to allocate a temporary command buffer to carry out the upload operations.</td></tr>
    <tr><td class="paramname">queue</td><td>A queue to which the upload operations should be submitted to.</td></tr>
    <tr><td class="paramname">usageFlags</td><td>A set of image usage flags for which the created image can be used for.</td></tr>
    <tr><td class="paramname">finalLayout</td><td>The final image layout the image will be transitioned to.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The result of the image upload will be a created image view with its associated pvrvk::Image.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stagingBufferAllocator</td><td>A VMA allocator used to allocate memory for the created staging buffer.</td></tr>
    <tr><td class="paramname">imageAllocator</td><td>A VMA allocator used to allocate memory for the created image.</td></tr>
    <tr><td class="paramname">imageAllocationCreateFlags</td><td>VMA Allocation creation flags. These flags can be used to control how and where the memory is allocated from. Valid flags include e_DEDICATED_MEMORY_BIT and e_MAPPED_BIT. e_DEDICATED_MEMORY_BIT indicates that the allocation should have its own memory block. e_MAPPED_BIT indicates memory will be persistently mapped respectively.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a class="anchor" id="aacd4b515e14632522eae706ff158bd86"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool pvr::utils::_allowDecompress</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Specifies whether the uploaded texture can be decompressed as it is uploaded.</p>

</div>
</div>
<a class="anchor" id="ae6d2b1c139e95706757d4732dddf1f9c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool pvr::utils::_callbackBeforeSignal</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Specifies whether the callback should be called prior to signalling the completion of the image upload.</p>

</div>
</div>
<a class="anchor" id="a19d81d0ce15542804a4581ea0d31a3fd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pvrvk::CommandPool pvr::utils::_cmdPool</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A command pool from which comand buffers will be allocated to record image upload operations.</p>

</div>
</div>
<a class="anchor" id="aad4b96895412bd162eccba2a845d55b0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pvrvk::Device pvr::utils::_device</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A _device to be used for creating temporary resources required for uploading an image.</p>

</div>
</div>
<a class="anchor" id="ab3de060441aca544adf3e57040fb26d0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pvrvk::Queue pvr::utils::_queue</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A queue to be used to submit image upload operations.</p>

</div>
</div>
<a class="anchor" id="a18aec86ff303d8fff3bacea5c2c0880d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">async::SemaphorePtr pvr::utils::_resultSemaphore</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">mutable</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Specifies a semaphore which will be signalled at the point the upload of the texture is finished.</p>

</div>
</div>
<a class="anchor" id="a2d05dae5b25d13ac9f23c80c1e4afbb9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacepvr_1_1utils.html#a3f0838b4c2b77e12986b54da8b3bef7b">AsyncTexture</a> pvr::utils::_texture</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A pvr::Texture to asynchronously upload to the Gpu.</p>

</div>
</div>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.4-->
<!-- start footer part (NON TREEVIEW ONLY!!) -->
<!--BEGIN GENERATE_TREEVIEW-->
<div id="FooterMainContainer">
	<div id="FooterContainer">
		<div class="footerlogo">
			<a href="http://www.imgtec.com" target="_blank"><img src="img-footer-logo-grey.png" width="100%" height="100%" border="none" /></a>
		</div>
		<div class="copyright"><p>&copy; Imagination Technologies Limited<br> All rights reserved</p></div>
	</div>
</div>
</body>
</html>
