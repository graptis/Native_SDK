<!-- HTML header for doxygen 1.8.4-->
<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="generator" content="Doxygen 1.8.6"/>
<title>PVRUtils: /usr/buildxl/buildroot/sdk/branch/SDK/framework/PVRUtils/Vulkan/RenderManagerVk.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="IMGdoxygen.css" rel="stylesheet" type="text/css"/>
<link rel="shortcut icon" href="http://www.imgtec.com/images/img.ico">
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
  <div class="headercontent">
    <div class="PVRlogo">
      <a href="http://www.powervrinsider.com" target="_blank"><img src="PVRlogo.png" width="40%" height="40%"  border="none" /></a>
    </div>
    <a class="SiteTitle"><span id="projectname">PVRUtils</span> Documentation</a>
   <tbody>
  </div>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="inherits.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Macros</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_687531cb5acd5e736601deea3ef3b7c0.html">SDK</a></li><li class="navelem"><a class="el" href="dir_407ce59cc93389552d4bbf4df897abf8.html">framework</a></li><li class="navelem"><a class="el" href="dir_56a6b2806f907a59546ae220133253ab.html">PVRUtils</a></li><li class="navelem"><a class="el" href="dir_2a4e396b2e69f22c2b04ad2a158af6a3.html">Vulkan</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#namespaces">Namespaces</a> &#124;
<a href="#typedef-members">Typedefs</a>  </div>
  <div class="headertitle">
<div class="title">RenderManagerVk.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Contains the implementations for the PowerVR RenderManager and other Rendering helpers.  
<a href="#details">More...</a></p>

<p><a href="_render_manager_vk_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpvr_1_1utils_1_1_attribute.html">pvr::utils::Attribute</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Information about an attribute layout. <a href="structpvr_1_1utils_1_1_attribute.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpvr_1_1utils_1_1_attribute_layout.html">pvr::utils::AttributeLayout</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Information about a set of attribute layouts. <a href="structpvr_1_1utils_1_1_attribute_layout.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpvr_1_1utils_1_1_automatic_model_buffer_entry_semantic.html">pvr::utils::AutomaticModelBufferEntrySemantic</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An Automatic Model Semantic is a semantic that has been defined in the Effect ("consumed" by the effect) and that at the same time is defined somewhere in the Model ( is "produced" in the model). This class contains information about a Per-Model semantic that the effect uses as a pvrvk::Buffer Entry(is a variable inside a pvrvk::Buffer). For example, if "LIGHTPOSITION0" (a "default" Model Semantic) was defined in the effect as a pvrvk::Buffer Entry, an <a class="el" href="structpvr_1_1utils_1_1_automatic_model_buffer_entry_semantic.html" title="An Automatic Model Semantic is a semantic that has been defined in the Effect (&quot;consumed&quot; by the effe...">AutomaticModelBufferEntrySemantic</a> could then be automatically generated by a corresponding createAutomaticModelSemantics() call, and that will in turn be used to auto-update the Uniform when calling updateAutomaticModelsSemantics(). <a href="structpvr_1_1utils_1_1_automatic_model_buffer_entry_semantic.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpvr_1_1utils_1_1_automatic_model_uniform_semantic.html">pvr::utils::AutomaticModelUniformSemantic</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An Automatic Model Semantic is a semantic that has been defined in the Effect ("consumed" by the effect) and that at the same time is defined somewhere in the Model ( is "produced" in the model). This class contains information about a Per-Model semantic that the effect uses as a Uniform. For example, if "PROJECTIONMATRIX" was defined in the effect as a Uniform, and was accessible as a Model Semantic in the model, an automatic semantic can be automatically generated (by a corresponding createAutomaticModelSemantics() call) that will then be used to auto-update the uniforms with updateAutomaticModelsSemantics(). <a href="structpvr_1_1utils_1_1_automatic_model_uniform_semantic.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpvr_1_1utils_1_1_automatic_node_buffer_entry_semantic.html">pvr::utils::AutomaticNodeBufferEntrySemantic</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An Automatic Node Semantic is a semantic that has been defined in the Effect ("consumed" by the effect) and that at the same time is defined in each Node of a Model (is "produced" in the node). This class contains information about a Per-Node semantic that the effect uses as a pvrvk::Buffer Entry. For example, if "MODELVIEWPROJECTION" (a "default" Model Semantic) was defined in the effect as a variable inside a Uniform pvrvk::Buffer, an <a class="el" href="structpvr_1_1utils_1_1_automatic_node_uniform_semantic.html" title="An Automatic Node Semantic is a semantic that has been defined in the Effect (&quot;consumed&quot; by the effec...">AutomaticNodeUniformSemantic</a> could then be automatically generated by a corresponding createAutomaticNodeSemantics() call, and that will in turn be used to auto-update the buffer entry when calling updateAutomaticNodeSemantics(). <a href="structpvr_1_1utils_1_1_automatic_node_buffer_entry_semantic.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpvr_1_1utils_1_1_automatic_node_uniform_semantic.html">pvr::utils::AutomaticNodeUniformSemantic</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An Automatic Node Semantic is a semantic that has been defined in the Effect ("consumed" by the effect) and that at the same time is defined in each Node of a Model (is "produced" in the node). This class contains information about a Per-Node semantic that the effect uses as a Uniform. For example, if "MODELVIEWPROJECTION" (a "default" Model Semantic) was defined in the effect as a Uniform, an <a class="el" href="structpvr_1_1utils_1_1_automatic_node_uniform_semantic.html" title="An Automatic Node Semantic is a semantic that has been defined in the Effect (&quot;consumed&quot; by the effec...">AutomaticNodeUniformSemantic</a> could then be automatically generated by a corresponding createAutomaticNodeSemantics() call, and that will in turn be used to auto-update the buffer entry when calling updateAutomaticNodeSemantics(). <a href="structpvr_1_1utils_1_1_automatic_node_uniform_semantic.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpvr_1_1utils_1_1_buffer_entry_semantic.html">pvr::utils::BufferEntrySemantic</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class contains information for an Effect Semantic that is used as a variable in a pvrvk::Buffer, and stores the connections between all necessary components: The actual buffer, the descriptor set bound to, the layout of the buffer, the dynamic id (if part of a buffer, which slice this object refers to) and so on. Will normally be used with the actual Semantic as a key in a map, hence it does not contain it.  <a href="structpvr_1_1utils_1_1_buffer_entry_semantic.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1utils_1_1_render_manager.html">pvr::utils::RenderManager</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="classpvr_1_1utils_1_1_render_manager.html" title="The RenderManager is a rendering automation class, with class responsibilities such as: - Putting tog...">RenderManager</a> is a rendering automation class, with class responsibilities such as: - Putting together PFX files (Effects) with POD models (Models) to render - Creating Graphics Pipelines, Descriptor Sets, VBOs, IBOs, UBOs, etc. - Creating and configuring render - to - texture targets - Automatically generate command buffers for rendering - Automatically update textures/uniforms/buffers in the rendering api with info provided by the the model (textures, matrices etc) <a href="classpvr_1_1utils_1_1_render_manager.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpvr_1_1utils_1_1_render_manager_1_1_render_manager_node_iterator_adapter.html">pvr::utils::RenderManager::RenderManagerNodeIteratorAdapter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class is a dummy container that provides <a class="el" href="structpvr_1_1utils_1_1_render_manager_1_1_render_manager_node_iterator_adapter.html#a0d639ac3fac681eba85a42edb6854a38" title="Returns an iterator pointing to the first RendermanNode element">begin()</a> and <a class="el" href="structpvr_1_1utils_1_1_render_manager_1_1_render_manager_node_iterator_adapter.html#a37efbdbbeb31d1d076840ff1ffbbcd7a" title="Returns an iterator pointing to the first RendermanNode element">end()</a> methods to iterate through all nodes of the <a class="el" href="classpvr_1_1utils_1_1_render_manager.html" title="The RenderManager is a rendering automation class, with class responsibilities such as: - Putting tog...">RenderManager</a>. Extremely useful to use in C++11 range based for: for (auto&amp; node : renderManager.renderables()) <a href="structpvr_1_1utils_1_1_render_manager_1_1_render_manager_node_iterator_adapter.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpvr_1_1utils_1_1_render_manager_1_1_renderman_node_iterator.html">pvr::utils::RenderManager::RendermanNodeIterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A special iterator class that is used to iterate through ALL renderable objects (nodes) of the entire render manager. Unidirectional, sequential. Provides methods to know when the pass, subpass or pipeline changed with the last advance. The effect of iterating with this class is identical to iterating for each pass, each subpass, each subpassmodel, each node. <a href="structpvr_1_1utils_1_1_render_manager_1_1_renderman_node_iterator.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpvr_1_1utils_1_1_renderman_buffer_binding.html">pvr::utils::RendermanBufferBinding</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Contains information to bind a buffer to a specific pipeline's descriptor sets. <a href="structpvr_1_1utils_1_1_renderman_buffer_binding.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpvr_1_1utils_1_1_renderman_buffer_definition.html">pvr::utils::RendermanBufferDefinition</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">INTERNAL. This struct is used to internally store buffers such as ubo and ssbo, with all the necessary binding info.  <a href="structpvr_1_1utils_1_1_renderman_buffer_definition.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpvr_1_1utils_1_1_renderman_effect.html">pvr::utils::RendermanEffect</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Part of <a class="el" href="structpvr_1_1utils_1_1_renderman_structure.html" title="Internal class containing the Render Manager tree structure representation of a scene">RendermanStructure</a>. This class contains the different passes, exactly mirroring the PFX effect. Contains the original EffectApi. <a href="structpvr_1_1utils_1_1_renderman_effect.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpvr_1_1utils_1_1_renderman_material.html">pvr::utils::RendermanMaterial</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This struct is used to store a material. <a href="structpvr_1_1utils_1_1_renderman_material.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpvr_1_1utils_1_1_renderman_material_subpass_pipeline.html">pvr::utils::RendermanMaterialSubpassPipeline</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Part of <a class="el" href="structpvr_1_1utils_1_1_renderman_structure.html" title="Internal class containing the Render Manager tree structure representation of a scene">RendermanStructure</a>. This class is a Material's instances as used by a pipeline <a href="structpvr_1_1utils_1_1_renderman_material_subpass_pipeline.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpvr_1_1utils_1_1_renderman_mesh.html">pvr::utils::RendermanMesh</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Part of <a class="el" href="structpvr_1_1utils_1_1_renderman_structure.html" title="Internal class containing the Render Manager tree structure representation of a scene">RendermanStructure</a>. This class is used to store VBOs/IBOs. Unique per mesh RendermanNodes inside passes/subpasses reference these items by pointer. <a href="structpvr_1_1utils_1_1_renderman_mesh.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpvr_1_1utils_1_1_renderman_model.html">pvr::utils::RendermanModel</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Part of <a class="el" href="structpvr_1_1utils_1_1_renderman_structure.html" title="Internal class containing the Render Manager tree structure representation of a scene">RendermanStructure</a>. This class is used to store RendermanMeshes. Unique per model RendermanModelEffects inside passes/subpasses reference these items by pointer. <a href="structpvr_1_1utils_1_1_renderman_model.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpvr_1_1utils_1_1_renderman_node.html">pvr::utils::RendermanNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Part of <a class="el" href="structpvr_1_1utils_1_1_renderman_structure.html" title="Internal class containing the Render Manager tree structure representation of a scene">RendermanStructure</a>. This class matches everything together: A pipelineMaterial, with a RendermanMeshSubpass, to render. Unique per rendering node AND mesh bone batch combination. NOTE: if bone batching is used, then multiple nodes will be generated per meshnode. Contains a reference to the mesh, the material, and also contains the dynamic offsets required to render with it. Loop through those to render.  <a href="structpvr_1_1utils_1_1_renderman_node.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpvr_1_1utils_1_1_renderman_pass.html">pvr::utils::RendermanPass</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Part of <a class="el" href="structpvr_1_1utils_1_1_renderman_structure.html" title="Internal class containing the Render Manager tree structure representation of a scene">RendermanStructure</a>. This class contains the different subpasses, exactly mirroring the PFX pass. <a href="structpvr_1_1utils_1_1_renderman_pass.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpvr_1_1utils_1_1_renderman_pipeline.html">pvr::utils::RendermanPipeline</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Part of <a class="el" href="structpvr_1_1utils_1_1_renderman_structure.html" title="Internal class containing the Render Manager tree structure representation of a scene">RendermanStructure</a>. This class is a cooked EffectPipeline, exactly mirroring the PFX pipelines. It is affected on creation time by the meshes that use it (for the Vertex Input configuration) but after that it is used for rendering directly when traversing the scene. <a href="structpvr_1_1utils_1_1_renderman_pipeline.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpvr_1_1utils_1_1_renderman_structure.html">pvr::utils::RendermanStructure</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Internal class containing the Render Manager tree structure representation of a scene <a href="structpvr_1_1utils_1_1_renderman_structure.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpvr_1_1utils_1_1_renderman_subpass.html">pvr::utils::RendermanSubpass</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Part of <a class="el" href="structpvr_1_1utils_1_1_renderman_structure.html" title="Internal class containing the Render Manager tree structure representation of a scene">RendermanStructure</a>. This struct groups the Renderpass subpass group. <a href="structpvr_1_1utils_1_1_renderman_subpass.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpvr_1_1utils_1_1_renderman_subpass_group.html">pvr::utils::RendermanSubpassGroup</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Part of <a class="el" href="structpvr_1_1utils_1_1_renderman_structure.html" title="Internal class containing the Render Manager tree structure representation of a scene">RendermanStructure</a>. This class groups the Renderman pipeline and Models of a single <a class="el" href="structpvr_1_1utils_1_1_renderman_subpass.html" title="Part of RendermanStructure. This struct groups the Renderpass subpass group.">RendermanSubpass</a>. This grouping is to be able to separate and order different parts of rendering and different objects that might potentially have the same conditions, inside the same subpass (for example, a user might want to draw different objects with a different effect although the objects have the same conditions. <a href="structpvr_1_1utils_1_1_renderman_subpass_group.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpvr_1_1utils_1_1_renderman_subpass_group_model.html">pvr::utils::RendermanSubpassGroupModel</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Part of <a class="el" href="structpvr_1_1utils_1_1_renderman_structure.html" title="Internal class containing the Render Manager tree structure representation of a scene">RendermanStructure</a>. This class stores RendermanNodes and RendermanMaterialEffects The list of nodes here references the list of materials. It references the Models in the original RendermanModelStore list.  <a href="structpvr_1_1utils_1_1_renderman_subpass_group_model.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpvr_1_1utils_1_1_renderman_subpass_material.html">pvr::utils::RendermanSubpassMaterial</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Part of <a class="el" href="structpvr_1_1utils_1_1_renderman_structure.html" title="Internal class containing the Render Manager tree structure representation of a scene">RendermanStructure</a>. This class contains the Material's instances that are used by a pipeline The reason is that a pipeline is selected BOTH by material AND by mesh, making it possible for one material in one subpass to be used by different pipelines. <a href="structpvr_1_1utils_1_1_renderman_subpass_material.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpvr_1_1utils_1_1_renderman_subpass_mesh.html">pvr::utils::RendermanSubpassMesh</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Part of <a class="el" href="structpvr_1_1utils_1_1_renderman_structure.html" title="Internal class containing the Render Manager tree structure representation of a scene">RendermanStructure</a>. This class is a Mesh's instances as used by a pipeline The "usedByPipelines" is only a helper. <a href="structpvr_1_1utils_1_1_renderman_subpass_mesh.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpvr_1_1utils_1_1_uniform_semantic.html">pvr::utils::UniformSemantic</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class contains information for an Effect Semantic that is used as a Uniform or PushConstant, and keeps the memory where this value will be intermediately kept (i.e. the "memory" variable is updated by the application or automatic semantics, and then can be uploaded to the shader. Will normally be used with the actual Semantic as a key in a map, hence it does not contain it. <a href="structpvr_1_1utils_1_1_uniform_semantic.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespacepvr"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr.html">pvr</a></td></tr>
<tr class="memdesc:namespacepvr"><td class="mdescLeft">&#160;</td><td class="mdescRight">Main PowerVR Framework namespace<br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacepvr_1_1utils"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1utils.html">pvr::utils</a></td></tr>
<tr class="memdesc:namespacepvr_1_1utils"><td class="mdescLeft">&#160;</td><td class="mdescRight">Main namespace for the PVRUtils Library <br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a6d76ff5c44e70698baef1dfd19dd90e3"><td class="memItemLeft" align="right" valign="top">typedef bool(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1utils.html#a6d76ff5c44e70698baef1dfd19dd90e3">pvr::utils::ModelSemanticSetter</a> )(TypedMem &amp;mem, const RendermanModel &amp;model)</td></tr>
<tr class="memdesc:a6d76ff5c44e70698baef1dfd19dd90e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">A pointer to a function that sets a specific Model Semantic from the model to the provided memory object <a href="#a6d76ff5c44e70698baef1dfd19dd90e3">More...</a><br/></td></tr>
<tr class="separator:a6d76ff5c44e70698baef1dfd19dd90e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52ce711be6305e9237b2513013656b90"><td class="memItemLeft" align="right" valign="top">typedef bool(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1utils.html#a52ce711be6305e9237b2513013656b90">pvr::utils::NodeSemanticSetter</a> )(TypedMem &amp;mem, const RendermanNode &amp;node)</td></tr>
<tr class="memdesc:a52ce711be6305e9237b2513013656b90"><td class="mdescLeft">&#160;</td><td class="mdescRight">A NodeSemanticSetter is a function that sets a specified Semantic to a value. It always applies to a specific semantic, and sources all required information from the node parameter, then writes the new updated value in the mem parameter <a href="#a52ce711be6305e9237b2513013656b90">More...</a><br/></td></tr>
<tr class="separator:a52ce711be6305e9237b2513013656b90"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Contains the implementations for the PowerVR RenderManager and other Rendering helpers. </p>
<p>The RenderManager class. Provides basic engine rendering functionality. See class documentation for basic use.</p>
<dl class="section author"><dt>Author</dt><dd>PowerVR by Imagination, Developer Technology Team </dd></dl>
<dl class="section user"><dt>Copyright:</dt><dd>Copyright (c) Imagination Technologies Limited.</dd></dl>
<dl class="section user"><dt>Copyright:</dt><dd>Copyright (c) Imagination Technologies Limited. </dd></dl>
</div></div><!-- contents -->
<!-- HTML footer for doxygen 1.8.4-->
<!-- start footer part (NON TREEVIEW ONLY!!) -->
<!--BEGIN GENERATE_TREEVIEW-->
<div id="FooterMainContainer">
	<div id="FooterContainer">
		<div class="footerlogo">
			<a href="http://www.imgtec.com" target="_blank"><img src="img-footer-logo-grey.png" width="100%" height="100%" border="none" /></a>
		</div>
		<div class="copyright"><p>&copy; Imagination Technologies Limited<br> All rights reserved</p></div>
	</div>
</div>
</body>
</html>
