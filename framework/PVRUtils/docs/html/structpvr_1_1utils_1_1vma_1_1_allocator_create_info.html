<!-- HTML header for doxygen 1.8.4-->
<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="generator" content="Doxygen 1.8.6"/>
<title>PVRUtils: pvr::utils::vma::AllocatorCreateInfo Struct Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="IMGdoxygen.css" rel="stylesheet" type="text/css"/>
<link rel="shortcut icon" href="http://www.imgtec.com/images/img.ico">
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
  <div class="headercontent">
    <div class="PVRlogo">
      <a href="http://www.powervrinsider.com" target="_blank"><img src="PVRlogo.png" width="40%" height="40%"  border="none" /></a>
    </div>
    <a class="SiteTitle"><span id="projectname">PVRUtils</span> Documentation</a>
   <tbody>
  </div>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="inherits.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Macros</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacepvr.html">pvr</a></li><li class="navelem"><a class="el" href="namespacepvr_1_1utils.html">utils</a></li><li class="navelem"><b>vma</b></li><li class="navelem"><a class="el" href="structpvr_1_1utils_1_1vma_1_1_allocator_create_info.html">AllocatorCreateInfo</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="structpvr_1_1utils_1_1vma_1_1_allocator_create_info-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">pvr::utils::vma::AllocatorCreateInfo Struct Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>The <a class="el" href="structpvr_1_1utils_1_1vma_1_1_allocator_create_info.html" title="The AllocatorCreateInfo struct specifies the way in which a VmaAllocator will be created.">AllocatorCreateInfo</a> struct specifies the way in which a VmaAllocator will be created. 
 <a href="structpvr_1_1utils_1_1vma_1_1_allocator_create_info.html#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:af9898a7f43cc30a384abd68501795ed4"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpvr_1_1utils_1_1vma_1_1_allocator_create_info.html#af9898a7f43cc30a384abd68501795ed4">AllocatorCreateInfo</a> ()</td></tr>
<tr class="memdesc:af9898a7f43cc30a384abd68501795ed4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default Constructor. <a href="#af9898a7f43cc30a384abd68501795ed4">More...</a><br/></td></tr>
<tr class="separator:af9898a7f43cc30a384abd68501795ed4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a177a9212e4246d0dbf533e4dd122ddf2"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpvr_1_1utils_1_1vma_1_1_allocator_create_info.html#a177a9212e4246d0dbf533e4dd122ddf2">AllocatorCreateInfo</a> (pvrvk::Device &amp;<a class="el" href="structpvr_1_1utils_1_1vma_1_1_allocator_create_info.html#a115c325d419df953795b77015c68934b">device</a>, pvrvk::DeviceSize <a class="el" href="structpvr_1_1utils_1_1vma_1_1_allocator_create_info.html#a3fbec2a3e723df4b9d1ecb30e89a33ad">preferredLargeHeapBlockSize</a>=0, AllocatorCreateFlags <a class="el" href="structpvr_1_1utils_1_1vma_1_1_allocator_create_info.html#a6b18e0ac249d83013396ad08cd8d74ab">flags</a>=AllocatorCreateFlags::e_NONE, DebugReportFlags debugReportFlags=DebugReportFlags::None, uint32_t <a class="el" href="structpvr_1_1utils_1_1vma_1_1_allocator_create_info.html#a9c572bf355de83cda778402eccb80f85">frameInUseCount</a>=0, const pvrvk::DeviceSize *<a class="el" href="structpvr_1_1utils_1_1vma_1_1_allocator_create_info.html#a5587aeecf9583b68cda9c93a95adefee">pHeapSizeLimit</a>=nullptr, const pvrvk::AllocationCallbacks *<a class="el" href="structpvr_1_1utils_1_1vma_1_1_allocator_create_info.html#a0382de4bfe72088255893471dd9376b3">pAllocationCallbacks</a>=nullptr, const <a class="el" href="structpvr_1_1utils_1_1vma_1_1_device_memory_callbacks.html">DeviceMemoryCallbacks</a> *<a class="el" href="structpvr_1_1utils_1_1vma_1_1_allocator_create_info.html#aa65f3b2a40f467ae3e9806e973f77238">pDeviceMemoryCallbacks</a>=nullptr)</td></tr>
<tr class="memdesc:a177a9212e4246d0dbf533e4dd122ddf2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor. <a href="#a177a9212e4246d0dbf533e4dd122ddf2">More...</a><br/></td></tr>
<tr class="separator:a177a9212e4246d0dbf533e4dd122ddf2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:a115c325d419df953795b77015c68934b"><td class="memItemLeft" align="right" valign="top">pvrvk::Device&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpvr_1_1utils_1_1vma_1_1_allocator_create_info.html#a115c325d419df953795b77015c68934b">device</a></td></tr>
<tr class="memdesc:a115c325d419df953795b77015c68934b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vulkan device. It must be valid throughout whole lifetime of created allocator. <a href="#a115c325d419df953795b77015c68934b">More...</a><br/></td></tr>
<tr class="separator:a115c325d419df953795b77015c68934b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b18e0ac249d83013396ad08cd8d74ab"><td class="memItemLeft" align="right" valign="top">AllocatorCreateFlags&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpvr_1_1utils_1_1vma_1_1_allocator_create_info.html#a6b18e0ac249d83013396ad08cd8d74ab">flags</a></td></tr>
<tr class="memdesc:a6b18e0ac249d83013396ad08cd8d74ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flags for created allocator. Use VmaAllocatorCreateFlags enum. <a href="#a6b18e0ac249d83013396ad08cd8d74ab">More...</a><br/></td></tr>
<tr class="separator:a6b18e0ac249d83013396ad08cd8d74ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c572bf355de83cda778402eccb80f85"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpvr_1_1utils_1_1vma_1_1_allocator_create_info.html#a9c572bf355de83cda778402eccb80f85">frameInUseCount</a></td></tr>
<tr class="memdesc:a9c572bf355de83cda778402eccb80f85"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum number of additional frames that are in use at the same time as current frame. This value is used only when you make allocations with AllocationCreateFlags::e_CAN_BECOME_LOST_BIT flag. Such allocation cannot become lost if allocation.lastUseFrameIndex &gt;= allocator.currentFrameIndex - frameInUseCount. For example, if you double-buffer your command buffers, so resources used for rendering in previous frame may still be in use by the GPU at the moment you allocate resources needed for the current frame, set this value to 1. If you want to allow any allocations other than used in the current frame to become lost, set this value to 0. <a href="#a9c572bf355de83cda778402eccb80f85">More...</a><br/></td></tr>
<tr class="separator:a9c572bf355de83cda778402eccb80f85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0382de4bfe72088255893471dd9376b3"><td class="memItemLeft" align="right" valign="top">const pvrvk::AllocationCallbacks *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpvr_1_1utils_1_1vma_1_1_allocator_create_info.html#a0382de4bfe72088255893471dd9376b3">pAllocationCallbacks</a></td></tr>
<tr class="memdesc:a0382de4bfe72088255893471dd9376b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Custom CPU memory allocation callbacks. Optional, can be null. When specified, will also be used for all CPU-side memory allocations. <a href="#a0382de4bfe72088255893471dd9376b3">More...</a><br/></td></tr>
<tr class="separator:a0382de4bfe72088255893471dd9376b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa65f3b2a40f467ae3e9806e973f77238"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structpvr_1_1utils_1_1vma_1_1_device_memory_callbacks.html">DeviceMemoryCallbacks</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpvr_1_1utils_1_1vma_1_1_allocator_create_info.html#aa65f3b2a40f467ae3e9806e973f77238">pDeviceMemoryCallbacks</a></td></tr>
<tr class="memdesc:aa65f3b2a40f467ae3e9806e973f77238"><td class="mdescLeft">&#160;</td><td class="mdescRight">Informative callbacks for vkAllocateMemory, vkFreeMemory. Optional, can be null. <a href="#aa65f3b2a40f467ae3e9806e973f77238">More...</a><br/></td></tr>
<tr class="separator:aa65f3b2a40f467ae3e9806e973f77238"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5587aeecf9583b68cda9c93a95adefee"><td class="memItemLeft" align="right" valign="top">const pvrvk::DeviceSize *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpvr_1_1utils_1_1vma_1_1_allocator_create_info.html#a5587aeecf9583b68cda9c93a95adefee">pHeapSizeLimit</a></td></tr>
<tr class="memdesc:a5587aeecf9583b68cda9c93a95adefee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Either NULL or a pointer to an array of limits on maximum number of bytes that can be allocated out of particular Vulkan memory heap. If not NULL, it must be a pointer to an array of <code>pvrvk::PhysicalDeviceMemoryProperties::memoryHeapCount</code> elements, defining limit on maximum number of bytes that can be allocated out of particular Vulkan memory heap. Any of the elements may be equal to <code>VK_WHOLE_SIZE</code>, which means no limit on that heap. This is also the default in case of <code>pHeapSizeLimit</code> = NULL. If there is a limit defined for a heap:  <a href="#a5587aeecf9583b68cda9c93a95adefee">More...</a><br/></td></tr>
<tr class="separator:a5587aeecf9583b68cda9c93a95adefee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3fbec2a3e723df4b9d1ecb30e89a33ad"><td class="memItemLeft" align="right" valign="top">pvrvk::DeviceSize&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpvr_1_1utils_1_1vma_1_1_allocator_create_info.html#a3fbec2a3e723df4b9d1ecb30e89a33ad">preferredLargeHeapBlockSize</a></td></tr>
<tr class="memdesc:a3fbec2a3e723df4b9d1ecb30e89a33ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Preferred size of a single <code>pvrvk::DeviceMemory</code> block to be allocated from large heaps. Set to 0 to use default, which is currently 256 MB. <a href="#a3fbec2a3e723df4b9d1ecb30e89a33ad">More...</a><br/></td></tr>
<tr class="separator:a3fbec2a3e723df4b9d1ecb30e89a33ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14470d47dbaef4ad9bbe26c705a7c0b1"><td class="memItemLeft" align="right" valign="top">DebugReportFlags&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpvr_1_1utils_1_1vma_1_1_allocator_create_info.html#a14470d47dbaef4ad9bbe26c705a7c0b1">reportFlags</a></td></tr>
<tr class="memdesc:a14470d47dbaef4ad9bbe26c705a7c0b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flags which will effect the way in which the debug report mechanism will function. <a href="#a14470d47dbaef4ad9bbe26c705a7c0b1">More...</a><br/></td></tr>
<tr class="separator:a14470d47dbaef4ad9bbe26c705a7c0b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>The <a class="el" href="structpvr_1_1utils_1_1vma_1_1_allocator_create_info.html" title="The AllocatorCreateInfo struct specifies the way in which a VmaAllocator will be created.">AllocatorCreateInfo</a> struct specifies the way in which a VmaAllocator will be created.</p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="af9898a7f43cc30a384abd68501795ed4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">pvr::utils::vma::AllocatorCreateInfo::AllocatorCreateInfo </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default Constructor.</p>

</div>
</div>
<a class="anchor" id="a177a9212e4246d0dbf533e4dd122ddf2"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">pvr::utils::vma::AllocatorCreateInfo::AllocatorCreateInfo </td>
          <td>(</td>
          <td class="paramtype">pvrvk::Device &amp;&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pvrvk::DeviceSize&#160;</td>
          <td class="paramname"><em>preferredLargeHeapBlockSize</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">AllocatorCreateFlags&#160;</td>
          <td class="paramname"><em>flags</em> = <code>AllocatorCreateFlags::e_NONE</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DebugReportFlags&#160;</td>
          <td class="paramname"><em>debugReportFlags</em> = <code>DebugReportFlags::None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>frameInUseCount</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const pvrvk::DeviceSize *&#160;</td>
          <td class="paramname"><em>pHeapSizeLimit</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const pvrvk::AllocationCallbacks *&#160;</td>
          <td class="paramname"><em>pAllocationCallbacks</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structpvr_1_1utils_1_1vma_1_1_device_memory_callbacks.html">DeviceMemoryCallbacks</a> *&#160;</td>
          <td class="paramname"><em>pDeviceMemoryCallbacks</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructor.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">device</td><td>The device to be used for allocating memory by this allocator</td></tr>
    <tr><td class="paramname">preferredLargeHeapBlockSize</td><td>The preferred size of any single allocation from large heaps</td></tr>
    <tr><td class="paramname">flags</td><td>Flags which will effect the way in which the allocator functions</td></tr>
    <tr><td class="paramname">debugReportFlags</td><td>A set of debug report flags which will effect the way in which the allocator providing debug logging</td></tr>
    <tr><td class="paramname">frameInUseCount</td><td>Maximum number of additional frames that are in use at the same time as current frame</td></tr>
    <tr><td class="paramname">pHeapSizeLimit</td><td>Either NULL or a pointer to an array of limits on maximum number of bytes that can be allocated out of particular Vulkan memory heap</td></tr>
    <tr><td class="paramname">pAllocationCallbacks</td><td>Custom CPU memory allocation callbacks</td></tr>
    <tr><td class="paramname">pDeviceMemoryCallbacks</td><td>Informative callbacks for vkAllocateMemory, vkFreeMemory</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a class="anchor" id="a115c325d419df953795b77015c68934b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pvrvk::Device pvr::utils::vma::AllocatorCreateInfo::device</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Vulkan device. It must be valid throughout whole lifetime of created allocator.</p>

</div>
</div>
<a class="anchor" id="a6b18e0ac249d83013396ad08cd8d74ab"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AllocatorCreateFlags pvr::utils::vma::AllocatorCreateInfo::flags</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Flags for created allocator. Use VmaAllocatorCreateFlags enum.</p>

</div>
</div>
<a class="anchor" id="a9c572bf355de83cda778402eccb80f85"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t pvr::utils::vma::AllocatorCreateInfo::frameInUseCount</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Maximum number of additional frames that are in use at the same time as current frame. This value is used only when you make allocations with AllocationCreateFlags::e_CAN_BECOME_LOST_BIT flag. Such allocation cannot become lost if allocation.lastUseFrameIndex &gt;= allocator.currentFrameIndex - frameInUseCount. For example, if you double-buffer your command buffers, so resources used for rendering in previous frame may still be in use by the GPU at the moment you allocate resources needed for the current frame, set this value to 1. If you want to allow any allocations other than used in the current frame to become lost, set this value to 0.</p>

</div>
</div>
<a class="anchor" id="a0382de4bfe72088255893471dd9376b3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const pvrvk::AllocationCallbacks* pvr::utils::vma::AllocatorCreateInfo::pAllocationCallbacks</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Custom CPU memory allocation callbacks. Optional, can be null. When specified, will also be used for all CPU-side memory allocations.</p>

</div>
</div>
<a class="anchor" id="aa65f3b2a40f467ae3e9806e973f77238"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structpvr_1_1utils_1_1vma_1_1_device_memory_callbacks.html">DeviceMemoryCallbacks</a>* pvr::utils::vma::AllocatorCreateInfo::pDeviceMemoryCallbacks</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Informative callbacks for vkAllocateMemory, vkFreeMemory. Optional, can be null.</p>

</div>
</div>
<a class="anchor" id="a5587aeecf9583b68cda9c93a95adefee"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const pvrvk::DeviceSize* pvr::utils::vma::AllocatorCreateInfo::pHeapSizeLimit</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Either NULL or a pointer to an array of limits on maximum number of bytes that can be allocated out of particular Vulkan memory heap. If not NULL, it must be a pointer to an array of <code>pvrvk::PhysicalDeviceMemoryProperties::memoryHeapCount</code> elements, defining limit on maximum number of bytes that can be allocated out of particular Vulkan memory heap. Any of the elements may be equal to <code>VK_WHOLE_SIZE</code>, which means no limit on that heap. This is also the default in case of <code>pHeapSizeLimit</code> = NULL. If there is a limit defined for a heap: </p>
<ul>
<li>If user tries to allocate more memory from that heap using this allocator, the allocation fails with <code>pvrvk::Error::e_OUT_OF_DEVICE_MEMORY</code>.</li>
<li>If the limit is smaller than heap size reported in <code>pvrvk::MemoryHeap::size</code>, the value of this limit will be reported instead when using vmaGetMemoryProperties().</li>
</ul>

</div>
</div>
<a class="anchor" id="a3fbec2a3e723df4b9d1ecb30e89a33ad"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pvrvk::DeviceSize pvr::utils::vma::AllocatorCreateInfo::preferredLargeHeapBlockSize</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Preferred size of a single <code>pvrvk::DeviceMemory</code> block to be allocated from large heaps. Set to 0 to use default, which is currently 256 MB.</p>

</div>
</div>
<a class="anchor" id="a14470d47dbaef4ad9bbe26c705a7c0b1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DebugReportFlags pvr::utils::vma::AllocatorCreateInfo::reportFlags</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Flags which will effect the way in which the debug report mechanism will function.</p>

</div>
</div>
<hr/>The documentation for this struct was generated from the following file:<ul>
<li>/usr/buildxl/buildroot/sdk/branch/SDK/framework/PVRUtils/Vulkan/<a class="el" href="_memory_allocator_8h_source.html">MemoryAllocator.h</a></li>
</ul>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.4-->
<!-- start footer part (NON TREEVIEW ONLY!!) -->
<!--BEGIN GENERATE_TREEVIEW-->
<div id="FooterMainContainer">
	<div id="FooterContainer">
		<div class="footerlogo">
			<a href="http://www.imgtec.com" target="_blank"><img src="img-footer-logo-grey.png" width="100%" height="100%" border="none" /></a>
		</div>
		<div class="copyright"><p>&copy; Imagination Technologies Limited<br> All rights reserved</p></div>
	</div>
</div>
</body>
</html>
